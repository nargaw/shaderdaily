/*! For license information please see main.b78df724.js.LICENSE.txt */
!function(){var n={345:function(n,e){"use strict";function t(n,e){var t=n.length;n.push(e);n:for(;0<t;){var o=t-1>>>1,r=n[o];if(!(0<a(r,e)))break n;n[o]=e,n[t]=r,t=o}}function o(n){return 0===n.length?null:n[0]}function r(n){if(0===n.length)return null;var e=n[0],t=n.pop();if(t!==e){n[0]=t;n:for(var o=0,r=n.length,i=r>>>1;o<i;){var v=2*(o+1)-1,c=n[v],l=v+1,s=n[l];if(0>a(c,t))l<r&&0>a(s,c)?(n[o]=s,n[l]=t,o=l):(n[o]=c,n[v]=t,o=v);else{if(!(l<r&&0>a(s,t)))break n;n[o]=s,n[l]=t,o=l}}}return e}function a(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var v=Date,c=v.now();e.unstable_now=function(){return v.now()-c}}var l=[],s=[],u=1,f=null,p=3,m=!1,d=!1,h=!1,x="function"===typeof setTimeout?setTimeout:null,y="function"===typeof clearTimeout?clearTimeout:null,g="undefined"!==typeof setImmediate?setImmediate:null;function b(n){for(var e=o(s);null!==e;){if(null===e.callback)r(s);else{if(!(e.startTime<=n))break;r(s),e.sortIndex=e.expirationTime,t(l,e)}e=o(s)}}function _(n){if(h=!1,b(n),!d)if(null!==o(l))d=!0,F(U);else{var e=o(s);null!==e&&j(_,e.startTime-n)}}function U(n,t){d=!1,h&&(h=!1,y(z),z=-1),m=!0;var a=p;try{for(b(t),f=o(l);null!==f&&(!(f.expirationTime>t)||n&&!T());){var i=f.callback;if("function"===typeof i){f.callback=null,p=f.priorityLevel;var v=i(f.expirationTime<=t);t=e.unstable_now(),"function"===typeof v?f.callback=v:f===o(l)&&r(l),b(t)}else r(l);f=o(l)}if(null!==f)var c=!0;else{var u=o(s);null!==u&&j(_,u.startTime-t),c=!1}return c}finally{f=null,p=a,m=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,S=!1,M=null,z=-1,k=5,C=-1;function T(){return!(e.unstable_now()-C<k)}function R(){if(null!==M){var n=e.unstable_now();C=n;var t=!0;try{t=M(!0,n)}finally{t?w():(S=!1,M=null)}}else S=!1}if("function"===typeof g)w=function(){g(R)};else if("undefined"!==typeof MessageChannel){var D=new MessageChannel,P=D.port2;D.port1.onmessage=R,w=function(){P.postMessage(null)}}else w=function(){x(R,0)};function F(n){M=n,S||(S=!0,w())}function j(n,t){z=x((function(){n(e.unstable_now())}),t)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){d||m||(d=!0,F(U))},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):k=0<n?Math.floor(1e3/n):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return o(l)},e.unstable_next=function(n){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var t=p;p=e;try{return n()}finally{p=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=p;p=n;try{return e()}finally{p=t}},e.unstable_scheduleCallback=function(n,r,a){var i=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,n){case 1:var v=-1;break;case 2:v=250;break;case 5:v=1073741823;break;case 4:v=1e4;break;default:v=5e3}return n={id:u++,callback:r,priorityLevel:n,startTime:a,expirationTime:v=a+v,sortIndex:-1},a>i?(n.sortIndex=a,t(s,n),null===o(l)&&n===o(s)&&(h?(y(z),z=-1):h=!0,j(_,a-i))):(n.sortIndex=v,t(l,n),d||m||(d=!0,F(U))),n},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(n){var e=p;return function(){var t=p;p=e;try{return n.apply(this,arguments)}finally{p=t}}}},545:function(n,e,t){"use strict";n.exports=t(345)},494:function(n){function e(n,e,t){var o,r,a,i,v;function c(){var l=Date.now()-i;l<e&&l>=0?o=setTimeout(c,e-l):(o=null,t||(v=n.apply(a,r),a=r=null))}null==e&&(e=100);var l=function(){a=this,r=arguments,i=Date.now();var l=t&&!o;return o||(o=setTimeout(c,e)),l&&(v=n.apply(a,r),a=r=null),v};return l.clear=function(){o&&(clearTimeout(o),o=null)},l.flush=function(){o&&(v=n.apply(a,r),a=r=null,clearTimeout(o),o=null)},l}e.debounce=e,n.exports=e},463:function(n,e,t){"use strict";var o=t(791),r=t(296);function a(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,v={};function c(n,e){l(n,e),l(n+"Capture",e)}function l(n,e){for(v[n]=e,n=0;n<e.length;n++)i.add(e[n])}var s=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),u=Object.prototype.hasOwnProperty,f=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},m={};function d(n,e,t,o,r,a,i){this.acceptsBooleans=2===e||3===e||4===e,this.attributeName=o,this.attributeNamespace=r,this.mustUseProperty=t,this.propertyName=n,this.type=e,this.sanitizeURL=a,this.removeEmptyString=i}var h={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(n){h[n]=new d(n,0,!1,n,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(n){var e=n[0];h[e]=new d(e,1,!1,n[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(n){h[n]=new d(n,2,!1,n.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(n){h[n]=new d(n,2,!1,n,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(n){h[n]=new d(n,3,!1,n.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(n){h[n]=new d(n,3,!0,n,null,!1,!1)})),["capture","download"].forEach((function(n){h[n]=new d(n,4,!1,n,null,!1,!1)})),["cols","rows","size","span"].forEach((function(n){h[n]=new d(n,6,!1,n,null,!1,!1)})),["rowSpan","start"].forEach((function(n){h[n]=new d(n,5,!1,n.toLowerCase(),null,!1,!1)}));var x=/[\-:]([a-z])/g;function y(n){return n[1].toUpperCase()}function g(n,e,t,o){var r=h.hasOwnProperty(e)?h[e]:null;(null!==r?0!==r.type:o||!(2<e.length)||"o"!==e[0]&&"O"!==e[0]||"n"!==e[1]&&"N"!==e[1])&&(function(n,e,t,o){if(null===e||"undefined"===typeof e||function(n,e,t,o){if(null!==t&&0===t.type)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return!o&&(null!==t?!t.acceptsBooleans:"data-"!==(n=n.toLowerCase().slice(0,5))&&"aria-"!==n);default:return!1}}(n,e,t,o))return!0;if(o)return!1;if(null!==t)switch(t.type){case 3:return!e;case 4:return!1===e;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}(e,t,r,o)&&(t=null),o||null===r?function(n){return!!u.call(m,n)||!u.call(p,n)&&(f.test(n)?m[n]=!0:(p[n]=!0,!1))}(e)&&(null===t?n.removeAttribute(e):n.setAttribute(e,""+t)):r.mustUseProperty?n[r.propertyName]=null===t?3!==r.type&&"":t:(e=r.attributeName,o=r.attributeNamespace,null===t?n.removeAttribute(e):(t=3===(r=r.type)||4===r&&!0===t?"":""+t,o?n.setAttributeNS(o,e,t):n.setAttribute(e,t))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(n){var e=n.replace(x,y);h[e]=new d(e,1,!1,n,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(n){var e=n.replace(x,y);h[e]=new d(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(n){var e=n.replace(x,y);h[e]=new d(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(n){h[n]=new d(n,1,!1,n.toLowerCase(),null,!1,!1)})),h.xlinkHref=new d("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(n){h[n]=new d(n,1,!1,n.toLowerCase(),null,!0,!0)}));var b=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,_=Symbol.for("react.element"),U=Symbol.for("react.portal"),w=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),M=Symbol.for("react.profiler"),z=Symbol.for("react.provider"),k=Symbol.for("react.context"),C=Symbol.for("react.forward_ref"),T=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),D=Symbol.for("react.memo"),P=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var F=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var j=Symbol.iterator;function I(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=j&&n[j]||n["@@iterator"])?n:null}var E,O=Object.assign;function L(n){if(void 0===E)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);E=e&&e[1]||""}return"\n"+E+n}var A=!1;function G(n,e){if(!n||A)return"";A=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(l){var o=l}Reflect.construct(n,[],e)}else{try{e.call()}catch(l){o=l}n.call(e.prototype)}else{try{throw Error()}catch(l){o=l}n()}}catch(l){if(l&&o&&"string"===typeof l.stack){for(var r=l.stack.split("\n"),a=o.stack.split("\n"),i=r.length-1,v=a.length-1;1<=i&&0<=v&&r[i]!==a[v];)v--;for(;1<=i&&0<=v;i--,v--)if(r[i]!==a[v]){if(1!==i||1!==v)do{if(i--,0>--v||r[i]!==a[v]){var c="\n"+r[i].replace(" at new "," at ");return n.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",n.displayName)),c}}while(1<=i&&0<=v);break}}}finally{A=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?L(n):""}function N(n){switch(n.tag){case 5:return L(n.type);case 16:return L("Lazy");case 13:return L("Suspense");case 19:return L("SuspenseList");case 0:case 2:case 15:return n=G(n.type,!1);case 11:return n=G(n.type.render,!1);case 1:return n=G(n.type,!0);default:return""}}function B(n){if(null==n)return null;if("function"===typeof n)return n.displayName||n.name||null;if("string"===typeof n)return n;switch(n){case w:return"Fragment";case U:return"Portal";case M:return"Profiler";case S:return"StrictMode";case T:return"Suspense";case R:return"SuspenseList"}if("object"===typeof n)switch(n.$$typeof){case k:return(n.displayName||"Context")+".Consumer";case z:return(n._context.displayName||"Context")+".Provider";case C:var e=n.render;return(n=n.displayName)||(n=""!==(n=e.displayName||e.name||"")?"ForwardRef("+n+")":"ForwardRef"),n;case D:return null!==(e=n.displayName||null)?e:B(n.type)||"Memo";case P:e=n._payload,n=n._init;try{return B(n(e))}catch(t){}}return null}function q(n){var e=n.type;switch(n.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return n=(n=e.render).displayName||n.name||"",e.displayName||(""!==n?"ForwardRef("+n+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return B(e);case 8:return e===S?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e}return null}function V(n){switch(typeof n){case"boolean":case"number":case"string":case"undefined":case"object":return n;default:return""}}function W(n){var e=n.type;return(n=n.nodeName)&&"input"===n.toLowerCase()&&("checkbox"===e||"radio"===e)}function H(n){n._valueTracker||(n._valueTracker=function(n){var e=W(n)?"checked":"value",t=Object.getOwnPropertyDescriptor(n.constructor.prototype,e),o=""+n[e];if(!n.hasOwnProperty(e)&&"undefined"!==typeof t&&"function"===typeof t.get&&"function"===typeof t.set){var r=t.get,a=t.set;return Object.defineProperty(n,e,{configurable:!0,get:function(){return r.call(this)},set:function(n){o=""+n,a.call(this,n)}}),Object.defineProperty(n,e,{enumerable:t.enumerable}),{getValue:function(){return o},setValue:function(n){o=""+n},stopTracking:function(){n._valueTracker=null,delete n[e]}}}}(n))}function X(n){if(!n)return!1;var e=n._valueTracker;if(!e)return!0;var t=e.getValue(),o="";return n&&(o=W(n)?n.checked?"true":"false":n.value),(n=o)!==t&&(e.setValue(n),!0)}function Y(n){if("undefined"===typeof(n=n||("undefined"!==typeof document?document:void 0)))return null;try{return n.activeElement||n.body}catch(e){return n.body}}function Z(n,e){var t=e.checked;return O({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=t?t:n._wrapperState.initialChecked})}function Q(n,e){var t=null==e.defaultValue?"":e.defaultValue,o=null!=e.checked?e.checked:e.defaultChecked;t=V(null!=e.value?e.value:t),n._wrapperState={initialChecked:o,initialValue:t,controlled:"checkbox"===e.type||"radio"===e.type?null!=e.checked:null!=e.value}}function J(n,e){null!=(e=e.checked)&&g(n,"checked",e,!1)}function K(n,e){J(n,e);var t=V(e.value),o=e.type;if(null!=t)"number"===o?(0===t&&""===n.value||n.value!=t)&&(n.value=""+t):n.value!==""+t&&(n.value=""+t);else if("submit"===o||"reset"===o)return void n.removeAttribute("value");e.hasOwnProperty("value")?nn(n,e.type,t):e.hasOwnProperty("defaultValue")&&nn(n,e.type,V(e.defaultValue)),null==e.checked&&null!=e.defaultChecked&&(n.defaultChecked=!!e.defaultChecked)}function $(n,e,t){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var o=e.type;if(!("submit"!==o&&"reset"!==o||void 0!==e.value&&null!==e.value))return;e=""+n._wrapperState.initialValue,t||e===n.value||(n.value=e),n.defaultValue=e}""!==(t=n.name)&&(n.name=""),n.defaultChecked=!!n._wrapperState.initialChecked,""!==t&&(n.name=t)}function nn(n,e,t){"number"===e&&Y(n.ownerDocument)===n||(null==t?n.defaultValue=""+n._wrapperState.initialValue:n.defaultValue!==""+t&&(n.defaultValue=""+t))}var en=Array.isArray;function tn(n,e,t,o){if(n=n.options,e){e={};for(var r=0;r<t.length;r++)e["$"+t[r]]=!0;for(t=0;t<n.length;t++)r=e.hasOwnProperty("$"+n[t].value),n[t].selected!==r&&(n[t].selected=r),r&&o&&(n[t].defaultSelected=!0)}else{for(t=""+V(t),e=null,r=0;r<n.length;r++){if(n[r].value===t)return n[r].selected=!0,void(o&&(n[r].defaultSelected=!0));null!==e||n[r].disabled||(e=n[r])}null!==e&&(e.selected=!0)}}function on(n,e){if(null!=e.dangerouslySetInnerHTML)throw Error(a(91));return O({},e,{value:void 0,defaultValue:void 0,children:""+n._wrapperState.initialValue})}function rn(n,e){var t=e.value;if(null==t){if(t=e.children,e=e.defaultValue,null!=t){if(null!=e)throw Error(a(92));if(en(t)){if(1<t.length)throw Error(a(93));t=t[0]}e=t}null==e&&(e=""),t=e}n._wrapperState={initialValue:V(t)}}function an(n,e){var t=V(e.value),o=V(e.defaultValue);null!=t&&((t=""+t)!==n.value&&(n.value=t),null==e.defaultValue&&n.defaultValue!==t&&(n.defaultValue=t)),null!=o&&(n.defaultValue=""+o)}function vn(n){var e=n.textContent;e===n._wrapperState.initialValue&&""!==e&&null!==e&&(n.value=e)}function cn(n){switch(n){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ln(n,e){return null==n||"http://www.w3.org/1999/xhtml"===n?cn(e):"http://www.w3.org/2000/svg"===n&&"foreignObject"===e?"http://www.w3.org/1999/xhtml":n}var sn,un,fn=(un=function(n,e){if("http://www.w3.org/2000/svg"!==n.namespaceURI||"innerHTML"in n)n.innerHTML=e;else{for((sn=sn||document.createElement("div")).innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=sn.firstChild;n.firstChild;)n.removeChild(n.firstChild);for(;e.firstChild;)n.appendChild(e.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(n,e,t,o){MSApp.execUnsafeLocalFunction((function(){return un(n,e)}))}:un);function pn(n,e){if(e){var t=n.firstChild;if(t&&t===n.lastChild&&3===t.nodeType)return void(t.nodeValue=e)}n.textContent=e}var mn={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},dn=["Webkit","ms","Moz","O"];function hn(n,e,t){return null==e||"boolean"===typeof e||""===e?"":t||"number"!==typeof e||0===e||mn.hasOwnProperty(n)&&mn[n]?(""+e).trim():e+"px"}function xn(n,e){for(var t in n=n.style,e)if(e.hasOwnProperty(t)){var o=0===t.indexOf("--"),r=hn(t,e[t],o);"float"===t&&(t="cssFloat"),o?n.setProperty(t,r):n[t]=r}}Object.keys(mn).forEach((function(n){dn.forEach((function(e){e=e+n.charAt(0).toUpperCase()+n.substring(1),mn[e]=mn[n]}))}));var yn=O({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function gn(n,e){if(e){if(yn[n]&&(null!=e.children||null!=e.dangerouslySetInnerHTML))throw Error(a(137,n));if(null!=e.dangerouslySetInnerHTML){if(null!=e.children)throw Error(a(60));if("object"!==typeof e.dangerouslySetInnerHTML||!("__html"in e.dangerouslySetInnerHTML))throw Error(a(61))}if(null!=e.style&&"object"!==typeof e.style)throw Error(a(62))}}function bn(n,e){if(-1===n.indexOf("-"))return"string"===typeof e.is;switch(n){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var _n=null;function Un(n){return(n=n.target||n.srcElement||window).correspondingUseElement&&(n=n.correspondingUseElement),3===n.nodeType?n.parentNode:n}var wn=null,Sn=null,Mn=null;function zn(n){if(n=br(n)){if("function"!==typeof wn)throw Error(a(280));var e=n.stateNode;e&&(e=Ur(e),wn(n.stateNode,n.type,e))}}function kn(n){Sn?Mn?Mn.push(n):Mn=[n]:Sn=n}function Cn(){if(Sn){var n=Sn,e=Mn;if(Mn=Sn=null,zn(n),e)for(n=0;n<e.length;n++)zn(e[n])}}function Tn(n,e){return n(e)}function Rn(){}var Dn=!1;function Pn(n,e,t){if(Dn)return n(e,t);Dn=!0;try{return Tn(n,e,t)}finally{Dn=!1,(null!==Sn||null!==Mn)&&(Rn(),Cn())}}function Fn(n,e){var t=n.stateNode;if(null===t)return null;var o=Ur(t);if(null===o)return null;t=o[e];n:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(o=!o.disabled)||(o=!("button"===(n=n.type)||"input"===n||"select"===n||"textarea"===n)),n=!o;break n;default:n=!1}if(n)return null;if(t&&"function"!==typeof t)throw Error(a(231,e,typeof t));return t}var jn=!1;if(s)try{var In={};Object.defineProperty(In,"passive",{get:function(){jn=!0}}),window.addEventListener("test",In,In),window.removeEventListener("test",In,In)}catch(un){jn=!1}function En(n,e,t,o,r,a,i,v,c){var l=Array.prototype.slice.call(arguments,3);try{e.apply(t,l)}catch(s){this.onError(s)}}var On=!1,Ln=null,An=!1,Gn=null,Nn={onError:function(n){On=!0,Ln=n}};function Bn(n,e,t,o,r,a,i,v,c){On=!1,Ln=null,En.apply(Nn,arguments)}function qn(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do{0!==(4098&(e=n).flags)&&(t=e.return),n=e.return}while(n)}return 3===e.tag?t:null}function Vn(n){if(13===n.tag){var e=n.memoizedState;if(null===e&&(null!==(n=n.alternate)&&(e=n.memoizedState)),null!==e)return e.dehydrated}return null}function Wn(n){if(qn(n)!==n)throw Error(a(188))}function Hn(n){return null!==(n=function(n){var e=n.alternate;if(!e){if(null===(e=qn(n)))throw Error(a(188));return e!==n?null:n}for(var t=n,o=e;;){var r=t.return;if(null===r)break;var i=r.alternate;if(null===i){if(null!==(o=r.return)){t=o;continue}break}if(r.child===i.child){for(i=r.child;i;){if(i===t)return Wn(r),n;if(i===o)return Wn(r),e;i=i.sibling}throw Error(a(188))}if(t.return!==o.return)t=r,o=i;else{for(var v=!1,c=r.child;c;){if(c===t){v=!0,t=r,o=i;break}if(c===o){v=!0,o=r,t=i;break}c=c.sibling}if(!v){for(c=i.child;c;){if(c===t){v=!0,t=i,o=r;break}if(c===o){v=!0,o=i,t=r;break}c=c.sibling}if(!v)throw Error(a(189))}}if(t.alternate!==o)throw Error(a(190))}if(3!==t.tag)throw Error(a(188));return t.stateNode.current===t?n:e}(n))?Xn(n):null}function Xn(n){if(5===n.tag||6===n.tag)return n;for(n=n.child;null!==n;){var e=Xn(n);if(null!==e)return e;n=n.sibling}return null}var Yn=r.unstable_scheduleCallback,Zn=r.unstable_cancelCallback,Qn=r.unstable_shouldYield,Jn=r.unstable_requestPaint,Kn=r.unstable_now,$n=r.unstable_getCurrentPriorityLevel,ne=r.unstable_ImmediatePriority,ee=r.unstable_UserBlockingPriority,te=r.unstable_NormalPriority,oe=r.unstable_LowPriority,re=r.unstable_IdlePriority,ae=null,ie=null;var ve=Math.clz32?Math.clz32:function(n){return 0===(n>>>=0)?32:31-(ce(n)/le|0)|0},ce=Math.log,le=Math.LN2;var se=64,ue=4194304;function fe(n){switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&n;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&n;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return n}}function pe(n,e){var t=n.pendingLanes;if(0===t)return 0;var o=0,r=n.suspendedLanes,a=n.pingedLanes,i=268435455&t;if(0!==i){var v=i&~r;0!==v?o=fe(v):0!==(a&=i)&&(o=fe(a))}else 0!==(i=t&~r)?o=fe(i):0!==a&&(o=fe(a));if(0===o)return 0;if(0!==e&&e!==o&&0===(e&r)&&((r=o&-o)>=(a=e&-e)||16===r&&0!==(4194240&a)))return e;if(0!==(4&o)&&(o|=16&t),0!==(e=n.entangledLanes))for(n=n.entanglements,e&=o;0<e;)r=1<<(t=31-ve(e)),o|=n[t],e&=~r;return o}function me(n,e){switch(n){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function de(n){return 0!==(n=-1073741825&n.pendingLanes)?n:1073741824&n?1073741824:0}function he(){var n=se;return 0===(4194240&(se<<=1))&&(se=64),n}function xe(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function ye(n,e,t){n.pendingLanes|=e,536870912!==e&&(n.suspendedLanes=0,n.pingedLanes=0),(n=n.eventTimes)[e=31-ve(e)]=t}function ge(n,e){var t=n.entangledLanes|=e;for(n=n.entanglements;t;){var o=31-ve(t),r=1<<o;r&e|n[o]&e&&(n[o]|=e),t&=~r}}var be=0;function _e(n){return 1<(n&=-n)?4<n?0!==(268435455&n)?16:536870912:4:1}var Ue,we,Se,Me,ze,ke=!1,Ce=[],Te=null,Re=null,De=null,Pe=new Map,Fe=new Map,je=[],Ie="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ee(n,e){switch(n){case"focusin":case"focusout":Te=null;break;case"dragenter":case"dragleave":Re=null;break;case"mouseover":case"mouseout":De=null;break;case"pointerover":case"pointerout":Pe.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Fe.delete(e.pointerId)}}function Oe(n,e,t,o,r,a){return null===n||n.nativeEvent!==a?(n={blockedOn:e,domEventName:t,eventSystemFlags:o,nativeEvent:a,targetContainers:[r]},null!==e&&(null!==(e=br(e))&&we(e)),n):(n.eventSystemFlags|=o,e=n.targetContainers,null!==r&&-1===e.indexOf(r)&&e.push(r),n)}function Le(n){var e=gr(n.target);if(null!==e){var t=qn(e);if(null!==t)if(13===(e=t.tag)){if(null!==(e=Vn(t)))return n.blockedOn=e,void ze(n.priority,(function(){Se(t)}))}else if(3===e&&t.stateNode.current.memoizedState.isDehydrated)return void(n.blockedOn=3===t.tag?t.stateNode.containerInfo:null)}n.blockedOn=null}function Ae(n){if(null!==n.blockedOn)return!1;for(var e=n.targetContainers;0<e.length;){var t=Qe(n.domEventName,n.eventSystemFlags,e[0],n.nativeEvent);if(null!==t)return null!==(e=br(t))&&we(e),n.blockedOn=t,!1;var o=new(t=n.nativeEvent).constructor(t.type,t);_n=o,t.target.dispatchEvent(o),_n=null,e.shift()}return!0}function Ge(n,e,t){Ae(n)&&t.delete(e)}function Ne(){ke=!1,null!==Te&&Ae(Te)&&(Te=null),null!==Re&&Ae(Re)&&(Re=null),null!==De&&Ae(De)&&(De=null),Pe.forEach(Ge),Fe.forEach(Ge)}function Be(n,e){n.blockedOn===e&&(n.blockedOn=null,ke||(ke=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Ne)))}function qe(n){function e(e){return Be(e,n)}if(0<Ce.length){Be(Ce[0],n);for(var t=1;t<Ce.length;t++){var o=Ce[t];o.blockedOn===n&&(o.blockedOn=null)}}for(null!==Te&&Be(Te,n),null!==Re&&Be(Re,n),null!==De&&Be(De,n),Pe.forEach(e),Fe.forEach(e),t=0;t<je.length;t++)(o=je[t]).blockedOn===n&&(o.blockedOn=null);for(;0<je.length&&null===(t=je[0]).blockedOn;)Le(t),null===t.blockedOn&&je.shift()}var Ve=b.ReactCurrentBatchConfig,We=!0;function He(n,e,t,o){var r=be,a=Ve.transition;Ve.transition=null;try{be=1,Ye(n,e,t,o)}finally{be=r,Ve.transition=a}}function Xe(n,e,t,o){var r=be,a=Ve.transition;Ve.transition=null;try{be=4,Ye(n,e,t,o)}finally{be=r,Ve.transition=a}}function Ye(n,e,t,o){if(We){var r=Qe(n,e,t,o);if(null===r)Wo(n,e,o,Ze,t),Ee(n,o);else if(function(n,e,t,o,r){switch(e){case"focusin":return Te=Oe(Te,n,e,t,o,r),!0;case"dragenter":return Re=Oe(Re,n,e,t,o,r),!0;case"mouseover":return De=Oe(De,n,e,t,o,r),!0;case"pointerover":var a=r.pointerId;return Pe.set(a,Oe(Pe.get(a)||null,n,e,t,o,r)),!0;case"gotpointercapture":return a=r.pointerId,Fe.set(a,Oe(Fe.get(a)||null,n,e,t,o,r)),!0}return!1}(r,n,e,t,o))o.stopPropagation();else if(Ee(n,o),4&e&&-1<Ie.indexOf(n)){for(;null!==r;){var a=br(r);if(null!==a&&Ue(a),null===(a=Qe(n,e,t,o))&&Wo(n,e,o,Ze,t),a===r)break;r=a}null!==r&&o.stopPropagation()}else Wo(n,e,o,null,t)}}var Ze=null;function Qe(n,e,t,o){if(Ze=null,null!==(n=gr(n=Un(o))))if(null===(e=qn(n)))n=null;else if(13===(t=e.tag)){if(null!==(n=Vn(e)))return n;n=null}else if(3===t){if(e.stateNode.current.memoizedState.isDehydrated)return 3===e.tag?e.stateNode.containerInfo:null;n=null}else e!==n&&(n=null);return Ze=n,null}function Je(n){switch(n){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch($n()){case ne:return 1;case ee:return 4;case te:case oe:return 16;case re:return 536870912;default:return 16}default:return 16}}var Ke=null,$e=null,nt=null;function et(){if(nt)return nt;var n,e,t=$e,o=t.length,r="value"in Ke?Ke.value:Ke.textContent,a=r.length;for(n=0;n<o&&t[n]===r[n];n++);var i=o-n;for(e=1;e<=i&&t[o-e]===r[a-e];e++);return nt=r.slice(n,1<e?1-e:void 0)}function tt(n){var e=n.keyCode;return"charCode"in n?0===(n=n.charCode)&&13===e&&(n=13):n=e,10===n&&(n=13),32<=n||13===n?n:0}function ot(){return!0}function rt(){return!1}function at(n){function e(e,t,o,r,a){for(var i in this._reactName=e,this._targetInst=o,this.type=t,this.nativeEvent=r,this.target=a,this.currentTarget=null,n)n.hasOwnProperty(i)&&(e=n[i],this[i]=e?e(r):r[i]);return this.isDefaultPrevented=(null!=r.defaultPrevented?r.defaultPrevented:!1===r.returnValue)?ot:rt,this.isPropagationStopped=rt,this}return O(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():"unknown"!==typeof n.returnValue&&(n.returnValue=!1),this.isDefaultPrevented=ot)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():"unknown"!==typeof n.cancelBubble&&(n.cancelBubble=!0),this.isPropagationStopped=ot)},persist:function(){},isPersistent:ot}),e}var it,vt,ct,lt={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(n){return n.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},st=at(lt),ut=O({},lt,{view:0,detail:0}),ft=at(ut),pt=O({},ut,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Mt,button:0,buttons:0,relatedTarget:function(n){return void 0===n.relatedTarget?n.fromElement===n.srcElement?n.toElement:n.fromElement:n.relatedTarget},movementX:function(n){return"movementX"in n?n.movementX:(n!==ct&&(ct&&"mousemove"===n.type?(it=n.screenX-ct.screenX,vt=n.screenY-ct.screenY):vt=it=0,ct=n),it)},movementY:function(n){return"movementY"in n?n.movementY:vt}}),mt=at(pt),dt=at(O({},pt,{dataTransfer:0})),ht=at(O({},ut,{relatedTarget:0})),xt=at(O({},lt,{animationName:0,elapsedTime:0,pseudoElement:0})),yt=O({},lt,{clipboardData:function(n){return"clipboardData"in n?n.clipboardData:window.clipboardData}}),gt=at(yt),bt=at(O({},lt,{data:0})),_t={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Ut={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},wt={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function St(n){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(n):!!(n=wt[n])&&!!e[n]}function Mt(){return St}var zt=O({},ut,{key:function(n){if(n.key){var e=_t[n.key]||n.key;if("Unidentified"!==e)return e}return"keypress"===n.type?13===(n=tt(n))?"Enter":String.fromCharCode(n):"keydown"===n.type||"keyup"===n.type?Ut[n.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Mt,charCode:function(n){return"keypress"===n.type?tt(n):0},keyCode:function(n){return"keydown"===n.type||"keyup"===n.type?n.keyCode:0},which:function(n){return"keypress"===n.type?tt(n):"keydown"===n.type||"keyup"===n.type?n.keyCode:0}}),kt=at(zt),Ct=at(O({},pt,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Tt=at(O({},ut,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Mt})),Rt=at(O({},lt,{propertyName:0,elapsedTime:0,pseudoElement:0})),Dt=O({},pt,{deltaX:function(n){return"deltaX"in n?n.deltaX:"wheelDeltaX"in n?-n.wheelDeltaX:0},deltaY:function(n){return"deltaY"in n?n.deltaY:"wheelDeltaY"in n?-n.wheelDeltaY:"wheelDelta"in n?-n.wheelDelta:0},deltaZ:0,deltaMode:0}),Pt=at(Dt),Ft=[9,13,27,32],jt=s&&"CompositionEvent"in window,It=null;s&&"documentMode"in document&&(It=document.documentMode);var Et=s&&"TextEvent"in window&&!It,Ot=s&&(!jt||It&&8<It&&11>=It),Lt=String.fromCharCode(32),At=!1;function Gt(n,e){switch(n){case"keyup":return-1!==Ft.indexOf(e.keyCode);case"keydown":return 229!==e.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Nt(n){return"object"===typeof(n=n.detail)&&"data"in n?n.data:null}var Bt=!1;var qt={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Vt(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return"input"===e?!!qt[n.type]:"textarea"===e}function Wt(n,e,t,o){kn(o),0<(e=Xo(e,"onChange")).length&&(t=new st("onChange","change",null,t,o),n.push({event:t,listeners:e}))}var Ht=null,Xt=null;function Yt(n){Ao(n,0)}function Zt(n){if(X(_r(n)))return n}function Qt(n,e){if("change"===n)return e}var Jt=!1;if(s){var Kt;if(s){var $t="oninput"in document;if(!$t){var no=document.createElement("div");no.setAttribute("oninput","return;"),$t="function"===typeof no.oninput}Kt=$t}else Kt=!1;Jt=Kt&&(!document.documentMode||9<document.documentMode)}function eo(){Ht&&(Ht.detachEvent("onpropertychange",to),Xt=Ht=null)}function to(n){if("value"===n.propertyName&&Zt(Xt)){var e=[];Wt(e,Xt,n,Un(n)),Pn(Yt,e)}}function oo(n,e,t){"focusin"===n?(eo(),Xt=t,(Ht=e).attachEvent("onpropertychange",to)):"focusout"===n&&eo()}function ro(n){if("selectionchange"===n||"keyup"===n||"keydown"===n)return Zt(Xt)}function ao(n,e){if("click"===n)return Zt(e)}function io(n,e){if("input"===n||"change"===n)return Zt(e)}var vo="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e};function co(n,e){if(vo(n,e))return!0;if("object"!==typeof n||null===n||"object"!==typeof e||null===e)return!1;var t=Object.keys(n),o=Object.keys(e);if(t.length!==o.length)return!1;for(o=0;o<t.length;o++){var r=t[o];if(!u.call(e,r)||!vo(n[r],e[r]))return!1}return!0}function lo(n){for(;n&&n.firstChild;)n=n.firstChild;return n}function so(n,e){var t,o=lo(n);for(n=0;o;){if(3===o.nodeType){if(t=n+o.textContent.length,n<=e&&t>=e)return{node:o,offset:e-n};n=t}n:{for(;o;){if(o.nextSibling){o=o.nextSibling;break n}o=o.parentNode}o=void 0}o=lo(o)}}function uo(n,e){return!(!n||!e)&&(n===e||(!n||3!==n.nodeType)&&(e&&3===e.nodeType?uo(n,e.parentNode):"contains"in n?n.contains(e):!!n.compareDocumentPosition&&!!(16&n.compareDocumentPosition(e))))}function fo(){for(var n=window,e=Y();e instanceof n.HTMLIFrameElement;){try{var t="string"===typeof e.contentWindow.location.href}catch(o){t=!1}if(!t)break;e=Y((n=e.contentWindow).document)}return e}function po(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e&&("input"===e&&("text"===n.type||"search"===n.type||"tel"===n.type||"url"===n.type||"password"===n.type)||"textarea"===e||"true"===n.contentEditable)}function mo(n){var e=fo(),t=n.focusedElem,o=n.selectionRange;if(e!==t&&t&&t.ownerDocument&&uo(t.ownerDocument.documentElement,t)){if(null!==o&&po(t))if(e=o.start,void 0===(n=o.end)&&(n=e),"selectionStart"in t)t.selectionStart=e,t.selectionEnd=Math.min(n,t.value.length);else if((n=(e=t.ownerDocument||document)&&e.defaultView||window).getSelection){n=n.getSelection();var r=t.textContent.length,a=Math.min(o.start,r);o=void 0===o.end?a:Math.min(o.end,r),!n.extend&&a>o&&(r=o,o=a,a=r),r=so(t,a);var i=so(t,o);r&&i&&(1!==n.rangeCount||n.anchorNode!==r.node||n.anchorOffset!==r.offset||n.focusNode!==i.node||n.focusOffset!==i.offset)&&((e=e.createRange()).setStart(r.node,r.offset),n.removeAllRanges(),a>o?(n.addRange(e),n.extend(i.node,i.offset)):(e.setEnd(i.node,i.offset),n.addRange(e)))}for(e=[],n=t;n=n.parentNode;)1===n.nodeType&&e.push({element:n,left:n.scrollLeft,top:n.scrollTop});for("function"===typeof t.focus&&t.focus(),t=0;t<e.length;t++)(n=e[t]).element.scrollLeft=n.left,n.element.scrollTop=n.top}}var ho=s&&"documentMode"in document&&11>=document.documentMode,xo=null,yo=null,go=null,bo=!1;function _o(n,e,t){var o=t.window===t?t.document:9===t.nodeType?t:t.ownerDocument;bo||null==xo||xo!==Y(o)||("selectionStart"in(o=xo)&&po(o)?o={start:o.selectionStart,end:o.selectionEnd}:o={anchorNode:(o=(o.ownerDocument&&o.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:o.anchorOffset,focusNode:o.focusNode,focusOffset:o.focusOffset},go&&co(go,o)||(go=o,0<(o=Xo(yo,"onSelect")).length&&(e=new st("onSelect","select",null,e,t),n.push({event:e,listeners:o}),e.target=xo)))}function Uo(n,e){var t={};return t[n.toLowerCase()]=e.toLowerCase(),t["Webkit"+n]="webkit"+e,t["Moz"+n]="moz"+e,t}var wo={animationend:Uo("Animation","AnimationEnd"),animationiteration:Uo("Animation","AnimationIteration"),animationstart:Uo("Animation","AnimationStart"),transitionend:Uo("Transition","TransitionEnd")},So={},Mo={};function zo(n){if(So[n])return So[n];if(!wo[n])return n;var e,t=wo[n];for(e in t)if(t.hasOwnProperty(e)&&e in Mo)return So[n]=t[e];return n}s&&(Mo=document.createElement("div").style,"AnimationEvent"in window||(delete wo.animationend.animation,delete wo.animationiteration.animation,delete wo.animationstart.animation),"TransitionEvent"in window||delete wo.transitionend.transition);var ko=zo("animationend"),Co=zo("animationiteration"),To=zo("animationstart"),Ro=zo("transitionend"),Do=new Map,Po="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Fo(n,e){Do.set(n,e),c(e,[n])}for(var jo=0;jo<Po.length;jo++){var Io=Po[jo];Fo(Io.toLowerCase(),"on"+(Io[0].toUpperCase()+Io.slice(1)))}Fo(ko,"onAnimationEnd"),Fo(Co,"onAnimationIteration"),Fo(To,"onAnimationStart"),Fo("dblclick","onDoubleClick"),Fo("focusin","onFocus"),Fo("focusout","onBlur"),Fo(Ro,"onTransitionEnd"),l("onMouseEnter",["mouseout","mouseover"]),l("onMouseLeave",["mouseout","mouseover"]),l("onPointerEnter",["pointerout","pointerover"]),l("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Eo="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Oo=new Set("cancel close invalid load scroll toggle".split(" ").concat(Eo));function Lo(n,e,t){var o=n.type||"unknown-event";n.currentTarget=t,function(n,e,t,o,r,i,v,c,l){if(Bn.apply(this,arguments),On){if(!On)throw Error(a(198));var s=Ln;On=!1,Ln=null,An||(An=!0,Gn=s)}}(o,e,void 0,n),n.currentTarget=null}function Ao(n,e){e=0!==(4&e);for(var t=0;t<n.length;t++){var o=n[t],r=o.event;o=o.listeners;n:{var a=void 0;if(e)for(var i=o.length-1;0<=i;i--){var v=o[i],c=v.instance,l=v.currentTarget;if(v=v.listener,c!==a&&r.isPropagationStopped())break n;Lo(r,v,l),a=c}else for(i=0;i<o.length;i++){if(c=(v=o[i]).instance,l=v.currentTarget,v=v.listener,c!==a&&r.isPropagationStopped())break n;Lo(r,v,l),a=c}}}if(An)throw n=Gn,An=!1,Gn=null,n}function Go(n,e){var t=e[hr];void 0===t&&(t=e[hr]=new Set);var o=n+"__bubble";t.has(o)||(Vo(e,n,2,!1),t.add(o))}function No(n,e,t){var o=0;e&&(o|=4),Vo(t,n,o,e)}var Bo="_reactListening"+Math.random().toString(36).slice(2);function qo(n){if(!n[Bo]){n[Bo]=!0,i.forEach((function(e){"selectionchange"!==e&&(Oo.has(e)||No(e,!1,n),No(e,!0,n))}));var e=9===n.nodeType?n:n.ownerDocument;null===e||e[Bo]||(e[Bo]=!0,No("selectionchange",!1,e))}}function Vo(n,e,t,o){switch(Je(e)){case 1:var r=He;break;case 4:r=Xe;break;default:r=Ye}t=r.bind(null,e,t,n),r=void 0,!jn||"touchstart"!==e&&"touchmove"!==e&&"wheel"!==e||(r=!0),o?void 0!==r?n.addEventListener(e,t,{capture:!0,passive:r}):n.addEventListener(e,t,!0):void 0!==r?n.addEventListener(e,t,{passive:r}):n.addEventListener(e,t,!1)}function Wo(n,e,t,o,r){var a=o;if(0===(1&e)&&0===(2&e)&&null!==o)n:for(;;){if(null===o)return;var i=o.tag;if(3===i||4===i){var v=o.stateNode.containerInfo;if(v===r||8===v.nodeType&&v.parentNode===r)break;if(4===i)for(i=o.return;null!==i;){var c=i.tag;if((3===c||4===c)&&((c=i.stateNode.containerInfo)===r||8===c.nodeType&&c.parentNode===r))return;i=i.return}for(;null!==v;){if(null===(i=gr(v)))return;if(5===(c=i.tag)||6===c){o=a=i;continue n}v=v.parentNode}}o=o.return}Pn((function(){var o=a,r=Un(t),i=[];n:{var v=Do.get(n);if(void 0!==v){var c=st,l=n;switch(n){case"keypress":if(0===tt(t))break n;case"keydown":case"keyup":c=kt;break;case"focusin":l="focus",c=ht;break;case"focusout":l="blur",c=ht;break;case"beforeblur":case"afterblur":c=ht;break;case"click":if(2===t.button)break n;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=mt;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=dt;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=Tt;break;case ko:case Co:case To:c=xt;break;case Ro:c=Rt;break;case"scroll":c=ft;break;case"wheel":c=Pt;break;case"copy":case"cut":case"paste":c=gt;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=Ct}var s=0!==(4&e),u=!s&&"scroll"===n,f=s?null!==v?v+"Capture":null:v;s=[];for(var p,m=o;null!==m;){var d=(p=m).stateNode;if(5===p.tag&&null!==d&&(p=d,null!==f&&(null!=(d=Fn(m,f))&&s.push(Ho(m,d,p)))),u)break;m=m.return}0<s.length&&(v=new c(v,l,null,t,r),i.push({event:v,listeners:s}))}}if(0===(7&e)){if(c="mouseout"===n||"pointerout"===n,(!(v="mouseover"===n||"pointerover"===n)||t===_n||!(l=t.relatedTarget||t.fromElement)||!gr(l)&&!l[dr])&&(c||v)&&(v=r.window===r?r:(v=r.ownerDocument)?v.defaultView||v.parentWindow:window,c?(c=o,null!==(l=(l=t.relatedTarget||t.toElement)?gr(l):null)&&(l!==(u=qn(l))||5!==l.tag&&6!==l.tag)&&(l=null)):(c=null,l=o),c!==l)){if(s=mt,d="onMouseLeave",f="onMouseEnter",m="mouse","pointerout"!==n&&"pointerover"!==n||(s=Ct,d="onPointerLeave",f="onPointerEnter",m="pointer"),u=null==c?v:_r(c),p=null==l?v:_r(l),(v=new s(d,m+"leave",c,t,r)).target=u,v.relatedTarget=p,d=null,gr(r)===o&&((s=new s(f,m+"enter",l,t,r)).target=p,s.relatedTarget=u,d=s),u=d,c&&l)n:{for(f=l,m=0,p=s=c;p;p=Yo(p))m++;for(p=0,d=f;d;d=Yo(d))p++;for(;0<m-p;)s=Yo(s),m--;for(;0<p-m;)f=Yo(f),p--;for(;m--;){if(s===f||null!==f&&s===f.alternate)break n;s=Yo(s),f=Yo(f)}s=null}else s=null;null!==c&&Zo(i,v,c,s,!1),null!==l&&null!==u&&Zo(i,u,l,s,!0)}if("select"===(c=(v=o?_r(o):window).nodeName&&v.nodeName.toLowerCase())||"input"===c&&"file"===v.type)var h=Qt;else if(Vt(v))if(Jt)h=io;else{h=ro;var x=oo}else(c=v.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===v.type||"radio"===v.type)&&(h=ao);switch(h&&(h=h(n,o))?Wt(i,h,t,r):(x&&x(n,v,o),"focusout"===n&&(x=v._wrapperState)&&x.controlled&&"number"===v.type&&nn(v,"number",v.value)),x=o?_r(o):window,n){case"focusin":(Vt(x)||"true"===x.contentEditable)&&(xo=x,yo=o,go=null);break;case"focusout":go=yo=xo=null;break;case"mousedown":bo=!0;break;case"contextmenu":case"mouseup":case"dragend":bo=!1,_o(i,t,r);break;case"selectionchange":if(ho)break;case"keydown":case"keyup":_o(i,t,r)}var y;if(jt)n:{switch(n){case"compositionstart":var g="onCompositionStart";break n;case"compositionend":g="onCompositionEnd";break n;case"compositionupdate":g="onCompositionUpdate";break n}g=void 0}else Bt?Gt(n,t)&&(g="onCompositionEnd"):"keydown"===n&&229===t.keyCode&&(g="onCompositionStart");g&&(Ot&&"ko"!==t.locale&&(Bt||"onCompositionStart"!==g?"onCompositionEnd"===g&&Bt&&(y=et()):($e="value"in(Ke=r)?Ke.value:Ke.textContent,Bt=!0)),0<(x=Xo(o,g)).length&&(g=new bt(g,n,null,t,r),i.push({event:g,listeners:x}),y?g.data=y:null!==(y=Nt(t))&&(g.data=y))),(y=Et?function(n,e){switch(n){case"compositionend":return Nt(e);case"keypress":return 32!==e.which?null:(At=!0,Lt);case"textInput":return(n=e.data)===Lt&&At?null:n;default:return null}}(n,t):function(n,e){if(Bt)return"compositionend"===n||!jt&&Gt(n,e)?(n=et(),nt=$e=Ke=null,Bt=!1,n):null;switch(n){case"paste":default:return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return Ot&&"ko"!==e.locale?null:e.data}}(n,t))&&(0<(o=Xo(o,"onBeforeInput")).length&&(r=new bt("onBeforeInput","beforeinput",null,t,r),i.push({event:r,listeners:o}),r.data=y))}Ao(i,e)}))}function Ho(n,e,t){return{instance:n,listener:e,currentTarget:t}}function Xo(n,e){for(var t=e+"Capture",o=[];null!==n;){var r=n,a=r.stateNode;5===r.tag&&null!==a&&(r=a,null!=(a=Fn(n,t))&&o.unshift(Ho(n,a,r)),null!=(a=Fn(n,e))&&o.push(Ho(n,a,r))),n=n.return}return o}function Yo(n){if(null===n)return null;do{n=n.return}while(n&&5!==n.tag);return n||null}function Zo(n,e,t,o,r){for(var a=e._reactName,i=[];null!==t&&t!==o;){var v=t,c=v.alternate,l=v.stateNode;if(null!==c&&c===o)break;5===v.tag&&null!==l&&(v=l,r?null!=(c=Fn(t,a))&&i.unshift(Ho(t,c,v)):r||null!=(c=Fn(t,a))&&i.push(Ho(t,c,v))),t=t.return}0!==i.length&&n.push({event:e,listeners:i})}var Qo=/\r\n?/g,Jo=/\u0000|\uFFFD/g;function Ko(n){return("string"===typeof n?n:""+n).replace(Qo,"\n").replace(Jo,"")}function $o(n,e,t){if(e=Ko(e),Ko(n)!==e&&t)throw Error(a(425))}function nr(){}var er=null,tr=null;function or(n,e){return"textarea"===n||"noscript"===n||"string"===typeof e.children||"number"===typeof e.children||"object"===typeof e.dangerouslySetInnerHTML&&null!==e.dangerouslySetInnerHTML&&null!=e.dangerouslySetInnerHTML.__html}var rr="function"===typeof setTimeout?setTimeout:void 0,ar="function"===typeof clearTimeout?clearTimeout:void 0,ir="function"===typeof Promise?Promise:void 0,vr="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof ir?function(n){return ir.resolve(null).then(n).catch(cr)}:rr;function cr(n){setTimeout((function(){throw n}))}function lr(n,e){var t=e,o=0;do{var r=t.nextSibling;if(n.removeChild(t),r&&8===r.nodeType)if("/$"===(t=r.data)){if(0===o)return n.removeChild(r),void qe(e);o--}else"$"!==t&&"$?"!==t&&"$!"!==t||o++;t=r}while(t);qe(e)}function sr(n){for(;null!=n;n=n.nextSibling){var e=n.nodeType;if(1===e||3===e)break;if(8===e){if("$"===(e=n.data)||"$!"===e||"$?"===e)break;if("/$"===e)return null}}return n}function ur(n){n=n.previousSibling;for(var e=0;n;){if(8===n.nodeType){var t=n.data;if("$"===t||"$!"===t||"$?"===t){if(0===e)return n;e--}else"/$"===t&&e++}n=n.previousSibling}return null}var fr=Math.random().toString(36).slice(2),pr="__reactFiber$"+fr,mr="__reactProps$"+fr,dr="__reactContainer$"+fr,hr="__reactEvents$"+fr,xr="__reactListeners$"+fr,yr="__reactHandles$"+fr;function gr(n){var e=n[pr];if(e)return e;for(var t=n.parentNode;t;){if(e=t[dr]||t[pr]){if(t=e.alternate,null!==e.child||null!==t&&null!==t.child)for(n=ur(n);null!==n;){if(t=n[pr])return t;n=ur(n)}return e}t=(n=t).parentNode}return null}function br(n){return!(n=n[pr]||n[dr])||5!==n.tag&&6!==n.tag&&13!==n.tag&&3!==n.tag?null:n}function _r(n){if(5===n.tag||6===n.tag)return n.stateNode;throw Error(a(33))}function Ur(n){return n[mr]||null}var wr=[],Sr=-1;function Mr(n){return{current:n}}function zr(n){0>Sr||(n.current=wr[Sr],wr[Sr]=null,Sr--)}function kr(n,e){Sr++,wr[Sr]=n.current,n.current=e}var Cr={},Tr=Mr(Cr),Rr=Mr(!1),Dr=Cr;function Pr(n,e){var t=n.type.contextTypes;if(!t)return Cr;var o=n.stateNode;if(o&&o.__reactInternalMemoizedUnmaskedChildContext===e)return o.__reactInternalMemoizedMaskedChildContext;var r,a={};for(r in t)a[r]=e[r];return o&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=a),a}function Fr(n){return null!==(n=n.childContextTypes)&&void 0!==n}function jr(){zr(Rr),zr(Tr)}function Ir(n,e,t){if(Tr.current!==Cr)throw Error(a(168));kr(Tr,e),kr(Rr,t)}function Er(n,e,t){var o=n.stateNode;if(e=e.childContextTypes,"function"!==typeof o.getChildContext)return t;for(var r in o=o.getChildContext())if(!(r in e))throw Error(a(108,q(n)||"Unknown",r));return O({},t,o)}function Or(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||Cr,Dr=Tr.current,kr(Tr,n),kr(Rr,Rr.current),!0}function Lr(n,e,t){var o=n.stateNode;if(!o)throw Error(a(169));t?(n=Er(n,e,Dr),o.__reactInternalMemoizedMergedChildContext=n,zr(Rr),zr(Tr),kr(Tr,n)):zr(Rr),kr(Rr,t)}var Ar=null,Gr=!1,Nr=!1;function Br(n){null===Ar?Ar=[n]:Ar.push(n)}function qr(){if(!Nr&&null!==Ar){Nr=!0;var n=0,e=be;try{var t=Ar;for(be=1;n<t.length;n++){var o=t[n];do{o=o(!0)}while(null!==o)}Ar=null,Gr=!1}catch(r){throw null!==Ar&&(Ar=Ar.slice(n+1)),Yn(ne,qr),r}finally{be=e,Nr=!1}}return null}var Vr=[],Wr=0,Hr=null,Xr=0,Yr=[],Zr=0,Qr=null,Jr=1,Kr="";function $r(n,e){Vr[Wr++]=Xr,Vr[Wr++]=Hr,Hr=n,Xr=e}function na(n,e,t){Yr[Zr++]=Jr,Yr[Zr++]=Kr,Yr[Zr++]=Qr,Qr=n;var o=Jr;n=Kr;var r=32-ve(o)-1;o&=~(1<<r),t+=1;var a=32-ve(e)+r;if(30<a){var i=r-r%5;a=(o&(1<<i)-1).toString(32),o>>=i,r-=i,Jr=1<<32-ve(e)+r|t<<r|o,Kr=a+n}else Jr=1<<a|t<<r|o,Kr=n}function ea(n){null!==n.return&&($r(n,1),na(n,1,0))}function ta(n){for(;n===Hr;)Hr=Vr[--Wr],Vr[Wr]=null,Xr=Vr[--Wr],Vr[Wr]=null;for(;n===Qr;)Qr=Yr[--Zr],Yr[Zr]=null,Kr=Yr[--Zr],Yr[Zr]=null,Jr=Yr[--Zr],Yr[Zr]=null}var oa=null,ra=null,aa=!1,ia=null;function va(n,e){var t=Dl(5,null,null,0);t.elementType="DELETED",t.stateNode=e,t.return=n,null===(e=n.deletions)?(n.deletions=[t],n.flags|=16):e.push(t)}function ca(n,e){switch(n.tag){case 5:var t=n.type;return null!==(e=1!==e.nodeType||t.toLowerCase()!==e.nodeName.toLowerCase()?null:e)&&(n.stateNode=e,oa=n,ra=sr(e.firstChild),!0);case 6:return null!==(e=""===n.pendingProps||3!==e.nodeType?null:e)&&(n.stateNode=e,oa=n,ra=null,!0);case 13:return null!==(e=8!==e.nodeType?null:e)&&(t=null!==Qr?{id:Jr,overflow:Kr}:null,n.memoizedState={dehydrated:e,treeContext:t,retryLane:1073741824},(t=Dl(18,null,null,0)).stateNode=e,t.return=n,n.child=t,oa=n,ra=null,!0);default:return!1}}function la(n){return 0!==(1&n.mode)&&0===(128&n.flags)}function sa(n){if(aa){var e=ra;if(e){var t=e;if(!ca(n,e)){if(la(n))throw Error(a(418));e=sr(t.nextSibling);var o=oa;e&&ca(n,e)?va(o,t):(n.flags=-4097&n.flags|2,aa=!1,oa=n)}}else{if(la(n))throw Error(a(418));n.flags=-4097&n.flags|2,aa=!1,oa=n}}}function ua(n){for(n=n.return;null!==n&&5!==n.tag&&3!==n.tag&&13!==n.tag;)n=n.return;oa=n}function fa(n){if(n!==oa)return!1;if(!aa)return ua(n),aa=!0,!1;var e;if((e=3!==n.tag)&&!(e=5!==n.tag)&&(e="head"!==(e=n.type)&&"body"!==e&&!or(n.type,n.memoizedProps)),e&&(e=ra)){if(la(n))throw pa(),Error(a(418));for(;e;)va(n,e),e=sr(e.nextSibling)}if(ua(n),13===n.tag){if(!(n=null!==(n=n.memoizedState)?n.dehydrated:null))throw Error(a(317));n:{for(n=n.nextSibling,e=0;n;){if(8===n.nodeType){var t=n.data;if("/$"===t){if(0===e){ra=sr(n.nextSibling);break n}e--}else"$"!==t&&"$!"!==t&&"$?"!==t||e++}n=n.nextSibling}ra=null}}else ra=oa?sr(n.stateNode.nextSibling):null;return!0}function pa(){for(var n=ra;n;)n=sr(n.nextSibling)}function ma(){ra=oa=null,aa=!1}function da(n){null===ia?ia=[n]:ia.push(n)}var ha=b.ReactCurrentBatchConfig;function xa(n,e){if(n&&n.defaultProps){for(var t in e=O({},e),n=n.defaultProps)void 0===e[t]&&(e[t]=n[t]);return e}return e}var ya=Mr(null),ga=null,ba=null,_a=null;function Ua(){_a=ba=ga=null}function wa(n){var e=ya.current;zr(ya),n._currentValue=e}function Sa(n,e,t){for(;null!==n;){var o=n.alternate;if((n.childLanes&e)!==e?(n.childLanes|=e,null!==o&&(o.childLanes|=e)):null!==o&&(o.childLanes&e)!==e&&(o.childLanes|=e),n===t)break;n=n.return}}function Ma(n,e){ga=n,_a=ba=null,null!==(n=n.dependencies)&&null!==n.firstContext&&(0!==(n.lanes&e)&&(bv=!0),n.firstContext=null)}function za(n){var e=n._currentValue;if(_a!==n)if(n={context:n,memoizedValue:e,next:null},null===ba){if(null===ga)throw Error(a(308));ba=n,ga.dependencies={lanes:0,firstContext:n}}else ba=ba.next=n;return e}var ka=null;function Ca(n){null===ka?ka=[n]:ka.push(n)}function Ta(n,e,t,o){var r=e.interleaved;return null===r?(t.next=t,Ca(e)):(t.next=r.next,r.next=t),e.interleaved=t,Ra(n,o)}function Ra(n,e){n.lanes|=e;var t=n.alternate;for(null!==t&&(t.lanes|=e),t=n,n=n.return;null!==n;)n.childLanes|=e,null!==(t=n.alternate)&&(t.childLanes|=e),t=n,n=n.return;return 3===t.tag?t.stateNode:null}var Da=!1;function Pa(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Fa(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function ja(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function Ia(n,e,t){var o=n.updateQueue;if(null===o)return null;if(o=o.shared,0!==(2&Cc)){var r=o.pending;return null===r?e.next=e:(e.next=r.next,r.next=e),o.pending=e,Ra(n,t)}return null===(r=o.interleaved)?(e.next=e,Ca(o)):(e.next=r.next,r.next=e),o.interleaved=e,Ra(n,t)}function Ea(n,e,t){if(null!==(e=e.updateQueue)&&(e=e.shared,0!==(4194240&t))){var o=e.lanes;t|=o&=n.pendingLanes,e.lanes=t,ge(n,t)}}function Oa(n,e){var t=n.updateQueue,o=n.alternate;if(null!==o&&t===(o=o.updateQueue)){var r=null,a=null;if(null!==(t=t.firstBaseUpdate)){do{var i={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===a?r=a=i:a=a.next=i,t=t.next}while(null!==t);null===a?r=a=e:a=a.next=e}else r=a=e;return t={baseState:o.baseState,firstBaseUpdate:r,lastBaseUpdate:a,shared:o.shared,effects:o.effects},void(n.updateQueue=t)}null===(n=t.lastBaseUpdate)?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function La(n,e,t,o){var r=n.updateQueue;Da=!1;var a=r.firstBaseUpdate,i=r.lastBaseUpdate,v=r.shared.pending;if(null!==v){r.shared.pending=null;var c=v,l=c.next;c.next=null,null===i?a=l:i.next=l,i=c;var s=n.alternate;null!==s&&((v=(s=s.updateQueue).lastBaseUpdate)!==i&&(null===v?s.firstBaseUpdate=l:v.next=l,s.lastBaseUpdate=c))}if(null!==a){var u=r.baseState;for(i=0,s=l=c=null,v=a;;){var f=v.lane,p=v.eventTime;if((o&f)===f){null!==s&&(s=s.next={eventTime:p,lane:0,tag:v.tag,payload:v.payload,callback:v.callback,next:null});n:{var m=n,d=v;switch(f=e,p=t,d.tag){case 1:if("function"===typeof(m=d.payload)){u=m.call(p,u,f);break n}u=m;break n;case 3:m.flags=-65537&m.flags|128;case 0:if(null===(f="function"===typeof(m=d.payload)?m.call(p,u,f):m)||void 0===f)break n;u=O({},u,f);break n;case 2:Da=!0}}null!==v.callback&&0!==v.lane&&(n.flags|=64,null===(f=r.effects)?r.effects=[v]:f.push(v))}else p={eventTime:p,lane:f,tag:v.tag,payload:v.payload,callback:v.callback,next:null},null===s?(l=s=p,c=u):s=s.next=p,i|=f;if(null===(v=v.next)){if(null===(v=r.shared.pending))break;v=(f=v).next,f.next=null,r.lastBaseUpdate=f,r.shared.pending=null}}if(null===s&&(c=u),r.baseState=c,r.firstBaseUpdate=l,r.lastBaseUpdate=s,null!==(e=r.shared.interleaved)){r=e;do{i|=r.lane,r=r.next}while(r!==e)}else null===a&&(r.shared.lanes=0);Ec|=i,n.lanes=i,n.memoizedState=u}}function Aa(n,e,t){if(n=e.effects,e.effects=null,null!==n)for(e=0;e<n.length;e++){var o=n[e],r=o.callback;if(null!==r){if(o.callback=null,o=t,"function"!==typeof r)throw Error(a(191,r));r.call(o)}}}var Ga=(new o.Component).refs;function Na(n,e,t,o){t=null===(t=t(o,e=n.memoizedState))||void 0===t?e:O({},e,t),n.memoizedState=t,0===n.lanes&&(n.updateQueue.baseState=t)}var Ba={isMounted:function(n){return!!(n=n._reactInternals)&&qn(n)===n},enqueueSetState:function(n,e,t){n=n._reactInternals;var o=nl(),r=el(n),a=ja(o,r);a.payload=e,void 0!==t&&null!==t&&(a.callback=t),null!==(e=Ia(n,a,r))&&(tl(e,n,r,o),Ea(e,n,r))},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var o=nl(),r=el(n),a=ja(o,r);a.tag=1,a.payload=e,void 0!==t&&null!==t&&(a.callback=t),null!==(e=Ia(n,a,r))&&(tl(e,n,r,o),Ea(e,n,r))},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=nl(),o=el(n),r=ja(t,o);r.tag=2,void 0!==e&&null!==e&&(r.callback=e),null!==(e=Ia(n,r,o))&&(tl(e,n,o,t),Ea(e,n,o))}};function qa(n,e,t,o,r,a,i){return"function"===typeof(n=n.stateNode).shouldComponentUpdate?n.shouldComponentUpdate(o,a,i):!e.prototype||!e.prototype.isPureReactComponent||(!co(t,o)||!co(r,a))}function Va(n,e,t){var o=!1,r=Cr,a=e.contextType;return"object"===typeof a&&null!==a?a=za(a):(r=Fr(e)?Dr:Tr.current,a=(o=null!==(o=e.contextTypes)&&void 0!==o)?Pr(n,r):Cr),e=new e(t,a),n.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=Ba,n.stateNode=e,e._reactInternals=n,o&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,n.__reactInternalMemoizedMaskedChildContext=a),e}function Wa(n,e,t,o){n=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(t,o),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(t,o),e.state!==n&&Ba.enqueueReplaceState(e,e.state,null)}function Ha(n,e,t,o){var r=n.stateNode;r.props=t,r.state=n.memoizedState,r.refs=Ga,Pa(n);var a=e.contextType;"object"===typeof a&&null!==a?r.context=za(a):(a=Fr(e)?Dr:Tr.current,r.context=Pr(n,a)),r.state=n.memoizedState,"function"===typeof(a=e.getDerivedStateFromProps)&&(Na(n,e,a,t),r.state=n.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(e=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),e!==r.state&&Ba.enqueueReplaceState(r,r.state,null),La(n,t,r,o),r.state=n.memoizedState),"function"===typeof r.componentDidMount&&(n.flags|=4194308)}function Xa(n,e,t){if(null!==(n=t.ref)&&"function"!==typeof n&&"object"!==typeof n){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(a(309));var o=t.stateNode}if(!o)throw Error(a(147,n));var r=o,i=""+n;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===i?e.ref:(e=function(n){var e=r.refs;e===Ga&&(e=r.refs={}),null===n?delete e[i]:e[i]=n},e._stringRef=i,e)}if("string"!==typeof n)throw Error(a(284));if(!t._owner)throw Error(a(290,n))}return n}function Ya(n,e){throw n=Object.prototype.toString.call(e),Error(a(31,"[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n))}function Za(n){return(0,n._init)(n._payload)}function Qa(n){function e(e,t){if(n){var o=e.deletions;null===o?(e.deletions=[t],e.flags|=16):o.push(t)}}function t(t,o){if(!n)return null;for(;null!==o;)e(t,o),o=o.sibling;return null}function o(n,e){for(n=new Map;null!==e;)null!==e.key?n.set(e.key,e):n.set(e.index,e),e=e.sibling;return n}function r(n,e){return(n=Fl(n,e)).index=0,n.sibling=null,n}function i(e,t,o){return e.index=o,n?null!==(o=e.alternate)?(o=o.index)<t?(e.flags|=2,t):o:(e.flags|=2,t):(e.flags|=1048576,t)}function v(e){return n&&null===e.alternate&&(e.flags|=2),e}function c(n,e,t,o){return null===e||6!==e.tag?((e=Ol(t,n.mode,o)).return=n,e):((e=r(e,t)).return=n,e)}function l(n,e,t,o){var a=t.type;return a===w?u(n,e,t.props.children,o,t.key):null!==e&&(e.elementType===a||"object"===typeof a&&null!==a&&a.$$typeof===P&&Za(a)===e.type)?((o=r(e,t.props)).ref=Xa(n,e,t),o.return=n,o):((o=jl(t.type,t.key,t.props,null,n.mode,o)).ref=Xa(n,e,t),o.return=n,o)}function s(n,e,t,o){return null===e||4!==e.tag||e.stateNode.containerInfo!==t.containerInfo||e.stateNode.implementation!==t.implementation?((e=Ll(t,n.mode,o)).return=n,e):((e=r(e,t.children||[])).return=n,e)}function u(n,e,t,o,a){return null===e||7!==e.tag?((e=Il(t,n.mode,o,a)).return=n,e):((e=r(e,t)).return=n,e)}function f(n,e,t){if("string"===typeof e&&""!==e||"number"===typeof e)return(e=Ol(""+e,n.mode,t)).return=n,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case _:return(t=jl(e.type,e.key,e.props,null,n.mode,t)).ref=Xa(n,null,e),t.return=n,t;case U:return(e=Ll(e,n.mode,t)).return=n,e;case P:return f(n,(0,e._init)(e._payload),t)}if(en(e)||I(e))return(e=Il(e,n.mode,t,null)).return=n,e;Ya(n,e)}return null}function p(n,e,t,o){var r=null!==e?e.key:null;if("string"===typeof t&&""!==t||"number"===typeof t)return null!==r?null:c(n,e,""+t,o);if("object"===typeof t&&null!==t){switch(t.$$typeof){case _:return t.key===r?l(n,e,t,o):null;case U:return t.key===r?s(n,e,t,o):null;case P:return p(n,e,(r=t._init)(t._payload),o)}if(en(t)||I(t))return null!==r?null:u(n,e,t,o,null);Ya(n,t)}return null}function m(n,e,t,o,r){if("string"===typeof o&&""!==o||"number"===typeof o)return c(e,n=n.get(t)||null,""+o,r);if("object"===typeof o&&null!==o){switch(o.$$typeof){case _:return l(e,n=n.get(null===o.key?t:o.key)||null,o,r);case U:return s(e,n=n.get(null===o.key?t:o.key)||null,o,r);case P:return m(n,e,t,(0,o._init)(o._payload),r)}if(en(o)||I(o))return u(e,n=n.get(t)||null,o,r,null);Ya(e,o)}return null}function d(r,a,v,c){for(var l=null,s=null,u=a,d=a=0,h=null;null!==u&&d<v.length;d++){u.index>d?(h=u,u=null):h=u.sibling;var x=p(r,u,v[d],c);if(null===x){null===u&&(u=h);break}n&&u&&null===x.alternate&&e(r,u),a=i(x,a,d),null===s?l=x:s.sibling=x,s=x,u=h}if(d===v.length)return t(r,u),aa&&$r(r,d),l;if(null===u){for(;d<v.length;d++)null!==(u=f(r,v[d],c))&&(a=i(u,a,d),null===s?l=u:s.sibling=u,s=u);return aa&&$r(r,d),l}for(u=o(r,u);d<v.length;d++)null!==(h=m(u,r,d,v[d],c))&&(n&&null!==h.alternate&&u.delete(null===h.key?d:h.key),a=i(h,a,d),null===s?l=h:s.sibling=h,s=h);return n&&u.forEach((function(n){return e(r,n)})),aa&&$r(r,d),l}function h(r,v,c,l){var s=I(c);if("function"!==typeof s)throw Error(a(150));if(null==(c=s.call(c)))throw Error(a(151));for(var u=s=null,d=v,h=v=0,x=null,y=c.next();null!==d&&!y.done;h++,y=c.next()){d.index>h?(x=d,d=null):x=d.sibling;var g=p(r,d,y.value,l);if(null===g){null===d&&(d=x);break}n&&d&&null===g.alternate&&e(r,d),v=i(g,v,h),null===u?s=g:u.sibling=g,u=g,d=x}if(y.done)return t(r,d),aa&&$r(r,h),s;if(null===d){for(;!y.done;h++,y=c.next())null!==(y=f(r,y.value,l))&&(v=i(y,v,h),null===u?s=y:u.sibling=y,u=y);return aa&&$r(r,h),s}for(d=o(r,d);!y.done;h++,y=c.next())null!==(y=m(d,r,h,y.value,l))&&(n&&null!==y.alternate&&d.delete(null===y.key?h:y.key),v=i(y,v,h),null===u?s=y:u.sibling=y,u=y);return n&&d.forEach((function(n){return e(r,n)})),aa&&$r(r,h),s}return function n(o,a,i,c){if("object"===typeof i&&null!==i&&i.type===w&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case _:n:{for(var l=i.key,s=a;null!==s;){if(s.key===l){if((l=i.type)===w){if(7===s.tag){t(o,s.sibling),(a=r(s,i.props.children)).return=o,o=a;break n}}else if(s.elementType===l||"object"===typeof l&&null!==l&&l.$$typeof===P&&Za(l)===s.type){t(o,s.sibling),(a=r(s,i.props)).ref=Xa(o,s,i),a.return=o,o=a;break n}t(o,s);break}e(o,s),s=s.sibling}i.type===w?((a=Il(i.props.children,o.mode,c,i.key)).return=o,o=a):((c=jl(i.type,i.key,i.props,null,o.mode,c)).ref=Xa(o,a,i),c.return=o,o=c)}return v(o);case U:n:{for(s=i.key;null!==a;){if(a.key===s){if(4===a.tag&&a.stateNode.containerInfo===i.containerInfo&&a.stateNode.implementation===i.implementation){t(o,a.sibling),(a=r(a,i.children||[])).return=o,o=a;break n}t(o,a);break}e(o,a),a=a.sibling}(a=Ll(i,o.mode,c)).return=o,o=a}return v(o);case P:return n(o,a,(s=i._init)(i._payload),c)}if(en(i))return d(o,a,i,c);if(I(i))return h(o,a,i,c);Ya(o,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==a&&6===a.tag?(t(o,a.sibling),(a=r(a,i)).return=o,o=a):(t(o,a),(a=Ol(i,o.mode,c)).return=o,o=a),v(o)):t(o,a)}}var Ja=Qa(!0),Ka=Qa(!1),$a={},ni=Mr($a),ei=Mr($a),ti=Mr($a);function oi(n){if(n===$a)throw Error(a(174));return n}function ri(n,e){switch(kr(ti,e),kr(ei,n),kr(ni,$a),n=e.nodeType){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:ln(null,"");break;default:e=ln(e=(n=8===n?e.parentNode:e).namespaceURI||null,n=n.tagName)}zr(ni),kr(ni,e)}function ai(){zr(ni),zr(ei),zr(ti)}function ii(n){oi(ti.current);var e=oi(ni.current),t=ln(e,n.type);e!==t&&(kr(ei,n),kr(ni,t))}function vi(n){ei.current===n&&(zr(ni),zr(ei))}var ci=Mr(0);function li(n){for(var e=n;null!==e;){if(13===e.tag){var t=e.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||"$?"===t.data||"$!"===t.data))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(128&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var si=[];function ui(){for(var n=0;n<si.length;n++)si[n]._workInProgressVersionPrimary=null;si.length=0}var fi=b.ReactCurrentDispatcher,pi=b.ReactCurrentBatchConfig,mi=0,di=null,hi=null,xi=null,yi=!1,gi=!1,bi=0,_i=0;function Ui(){throw Error(a(321))}function wi(n,e){if(null===e)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!vo(n[t],e[t]))return!1;return!0}function Si(n,e,t,o,r,i){if(mi=i,di=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,fi.current=null===n||null===n.memoizedState?vv:cv,n=t(o,r),gi){i=0;do{if(gi=!1,bi=0,25<=i)throw Error(a(301));i+=1,xi=hi=null,e.updateQueue=null,fi.current=lv,n=t(o,r)}while(gi)}if(fi.current=iv,e=null!==hi&&null!==hi.next,mi=0,xi=hi=di=null,yi=!1,e)throw Error(a(300));return n}function Mi(){var n=0!==bi;return bi=0,n}function zi(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===xi?di.memoizedState=xi=n:xi=xi.next=n,xi}function ki(){if(null===hi){var n=di.alternate;n=null!==n?n.memoizedState:null}else n=hi.next;var e=null===xi?di.memoizedState:xi.next;if(null!==e)xi=e,hi=n;else{if(null===n)throw Error(a(310));n={memoizedState:(hi=n).memoizedState,baseState:hi.baseState,baseQueue:hi.baseQueue,queue:hi.queue,next:null},null===xi?di.memoizedState=xi=n:xi=xi.next=n}return xi}function Ci(n,e){return"function"===typeof e?e(n):e}function Ti(n){var e=ki(),t=e.queue;if(null===t)throw Error(a(311));t.lastRenderedReducer=n;var o=hi,r=o.baseQueue,i=t.pending;if(null!==i){if(null!==r){var v=r.next;r.next=i.next,i.next=v}o.baseQueue=r=i,t.pending=null}if(null!==r){i=r.next,o=o.baseState;var c=v=null,l=null,s=i;do{var u=s.lane;if((mi&u)===u)null!==l&&(l=l.next={lane:0,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null}),o=s.hasEagerState?s.eagerState:n(o,s.action);else{var f={lane:u,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null};null===l?(c=l=f,v=o):l=l.next=f,di.lanes|=u,Ec|=u}s=s.next}while(null!==s&&s!==i);null===l?v=o:l.next=c,vo(o,e.memoizedState)||(bv=!0),e.memoizedState=o,e.baseState=v,e.baseQueue=l,t.lastRenderedState=o}if(null!==(n=t.interleaved)){r=n;do{i=r.lane,di.lanes|=i,Ec|=i,r=r.next}while(r!==n)}else null===r&&(t.lanes=0);return[e.memoizedState,t.dispatch]}function Ri(n){var e=ki(),t=e.queue;if(null===t)throw Error(a(311));t.lastRenderedReducer=n;var o=t.dispatch,r=t.pending,i=e.memoizedState;if(null!==r){t.pending=null;var v=r=r.next;do{i=n(i,v.action),v=v.next}while(v!==r);vo(i,e.memoizedState)||(bv=!0),e.memoizedState=i,null===e.baseQueue&&(e.baseState=i),t.lastRenderedState=i}return[i,o]}function Di(){}function Pi(n,e){var t=di,o=ki(),r=e(),i=!vo(o.memoizedState,r);if(i&&(o.memoizedState=r,bv=!0),o=o.queue,Vi(Ii.bind(null,t,o,n),[n]),o.getSnapshot!==e||i||null!==xi&&1&xi.memoizedState.tag){if(t.flags|=2048,Ai(9,ji.bind(null,t,o,r,e),void 0,null),null===Tc)throw Error(a(349));0!==(30&mi)||Fi(t,e,r)}return r}function Fi(n,e,t){n.flags|=16384,n={getSnapshot:e,value:t},null===(e=di.updateQueue)?(e={lastEffect:null,stores:null},di.updateQueue=e,e.stores=[n]):null===(t=e.stores)?e.stores=[n]:t.push(n)}function ji(n,e,t,o){e.value=t,e.getSnapshot=o,Ei(e)&&Oi(n)}function Ii(n,e,t){return t((function(){Ei(e)&&Oi(n)}))}function Ei(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!vo(n,t)}catch(o){return!0}}function Oi(n){var e=Ra(n,1);null!==e&&tl(e,n,1,-1)}function Li(n){var e=zi();return"function"===typeof n&&(n=n()),e.memoizedState=e.baseState=n,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Ci,lastRenderedState:n},e.queue=n,n=n.dispatch=tv.bind(null,di,n),[e.memoizedState,n]}function Ai(n,e,t,o){return n={tag:n,create:e,destroy:t,deps:o,next:null},null===(e=di.updateQueue)?(e={lastEffect:null,stores:null},di.updateQueue=e,e.lastEffect=n.next=n):null===(t=e.lastEffect)?e.lastEffect=n.next=n:(o=t.next,t.next=n,n.next=o,e.lastEffect=n),n}function Gi(){return ki().memoizedState}function Ni(n,e,t,o){var r=zi();di.flags|=n,r.memoizedState=Ai(1|e,t,void 0,void 0===o?null:o)}function Bi(n,e,t,o){var r=ki();o=void 0===o?null:o;var a=void 0;if(null!==hi){var i=hi.memoizedState;if(a=i.destroy,null!==o&&wi(o,i.deps))return void(r.memoizedState=Ai(e,t,a,o))}di.flags|=n,r.memoizedState=Ai(1|e,t,a,o)}function qi(n,e){return Ni(8390656,8,n,e)}function Vi(n,e){return Bi(2048,8,n,e)}function Wi(n,e){return Bi(4,2,n,e)}function Hi(n,e){return Bi(4,4,n,e)}function Xi(n,e){return"function"===typeof e?(n=n(),e(n),function(){e(null)}):null!==e&&void 0!==e?(n=n(),e.current=n,function(){e.current=null}):void 0}function Yi(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Bi(4,4,Xi.bind(null,e,n),t)}function Zi(){}function Qi(n,e){var t=ki();e=void 0===e?null:e;var o=t.memoizedState;return null!==o&&null!==e&&wi(e,o[1])?o[0]:(t.memoizedState=[n,e],n)}function Ji(n,e){var t=ki();e=void 0===e?null:e;var o=t.memoizedState;return null!==o&&null!==e&&wi(e,o[1])?o[0]:(n=n(),t.memoizedState=[n,e],n)}function Ki(n,e,t){return 0===(21&mi)?(n.baseState&&(n.baseState=!1,bv=!0),n.memoizedState=t):(vo(t,e)||(t=he(),di.lanes|=t,Ec|=t,n.baseState=!0),e)}function $i(n,e){var t=be;be=0!==t&&4>t?t:4,n(!0);var o=pi.transition;pi.transition={};try{n(!1),e()}finally{be=t,pi.transition=o}}function nv(){return ki().memoizedState}function ev(n,e,t){var o=el(n);if(t={lane:o,action:t,hasEagerState:!1,eagerState:null,next:null},ov(n))rv(e,t);else if(null!==(t=Ta(n,e,t,o))){tl(t,n,o,nl()),av(t,e,o)}}function tv(n,e,t){var o=el(n),r={lane:o,action:t,hasEagerState:!1,eagerState:null,next:null};if(ov(n))rv(e,r);else{var a=n.alternate;if(0===n.lanes&&(null===a||0===a.lanes)&&null!==(a=e.lastRenderedReducer))try{var i=e.lastRenderedState,v=a(i,t);if(r.hasEagerState=!0,r.eagerState=v,vo(v,i)){var c=e.interleaved;return null===c?(r.next=r,Ca(e)):(r.next=c.next,c.next=r),void(e.interleaved=r)}}catch(l){}null!==(t=Ta(n,e,r,o))&&(tl(t,n,o,r=nl()),av(t,e,o))}}function ov(n){var e=n.alternate;return n===di||null!==e&&e===di}function rv(n,e){gi=yi=!0;var t=n.pending;null===t?e.next=e:(e.next=t.next,t.next=e),n.pending=e}function av(n,e,t){if(0!==(4194240&t)){var o=e.lanes;t|=o&=n.pendingLanes,e.lanes=t,ge(n,t)}}var iv={readContext:za,useCallback:Ui,useContext:Ui,useEffect:Ui,useImperativeHandle:Ui,useInsertionEffect:Ui,useLayoutEffect:Ui,useMemo:Ui,useReducer:Ui,useRef:Ui,useState:Ui,useDebugValue:Ui,useDeferredValue:Ui,useTransition:Ui,useMutableSource:Ui,useSyncExternalStore:Ui,useId:Ui,unstable_isNewReconciler:!1},vv={readContext:za,useCallback:function(n,e){return zi().memoizedState=[n,void 0===e?null:e],n},useContext:za,useEffect:qi,useImperativeHandle:function(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Ni(4194308,4,Xi.bind(null,e,n),t)},useLayoutEffect:function(n,e){return Ni(4194308,4,n,e)},useInsertionEffect:function(n,e){return Ni(4,2,n,e)},useMemo:function(n,e){var t=zi();return e=void 0===e?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var o=zi();return e=void 0!==t?t(e):e,o.memoizedState=o.baseState=e,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:e},o.queue=n,n=n.dispatch=ev.bind(null,di,n),[o.memoizedState,n]},useRef:function(n){return n={current:n},zi().memoizedState=n},useState:Li,useDebugValue:Zi,useDeferredValue:function(n){return zi().memoizedState=n},useTransition:function(){var n=Li(!1),e=n[0];return n=$i.bind(null,n[1]),zi().memoizedState=n,[e,n]},useMutableSource:function(){},useSyncExternalStore:function(n,e,t){var o=di,r=zi();if(aa){if(void 0===t)throw Error(a(407));t=t()}else{if(t=e(),null===Tc)throw Error(a(349));0!==(30&mi)||Fi(o,e,t)}r.memoizedState=t;var i={value:t,getSnapshot:e};return r.queue=i,qi(Ii.bind(null,o,i,n),[n]),o.flags|=2048,Ai(9,ji.bind(null,o,i,t,e),void 0,null),t},useId:function(){var n=zi(),e=Tc.identifierPrefix;if(aa){var t=Kr;e=":"+e+"R"+(t=(Jr&~(1<<32-ve(Jr)-1)).toString(32)+t),0<(t=bi++)&&(e+="H"+t.toString(32)),e+=":"}else e=":"+e+"r"+(t=_i++).toString(32)+":";return n.memoizedState=e},unstable_isNewReconciler:!1},cv={readContext:za,useCallback:Qi,useContext:za,useEffect:Vi,useImperativeHandle:Yi,useInsertionEffect:Wi,useLayoutEffect:Hi,useMemo:Ji,useReducer:Ti,useRef:Gi,useState:function(){return Ti(Ci)},useDebugValue:Zi,useDeferredValue:function(n){return Ki(ki(),hi.memoizedState,n)},useTransition:function(){return[Ti(Ci)[0],ki().memoizedState]},useMutableSource:Di,useSyncExternalStore:Pi,useId:nv,unstable_isNewReconciler:!1},lv={readContext:za,useCallback:Qi,useContext:za,useEffect:Vi,useImperativeHandle:Yi,useInsertionEffect:Wi,useLayoutEffect:Hi,useMemo:Ji,useReducer:Ri,useRef:Gi,useState:function(){return Ri(Ci)},useDebugValue:Zi,useDeferredValue:function(n){var e=ki();return null===hi?e.memoizedState=n:Ki(e,hi.memoizedState,n)},useTransition:function(){return[Ri(Ci)[0],ki().memoizedState]},useMutableSource:Di,useSyncExternalStore:Pi,useId:nv,unstable_isNewReconciler:!1};function sv(n,e){try{var t="",o=e;do{t+=N(o),o=o.return}while(o);var r=t}catch(a){r="\nError generating stack: "+a.message+"\n"+a.stack}return{value:n,source:e,stack:r,digest:null}}function uv(n,e,t){return{value:n,source:null,stack:null!=t?t:null,digest:null!=e?e:null}}function fv(n,e){try{console.error(e.value)}catch(t){setTimeout((function(){throw t}))}}var pv="function"===typeof WeakMap?WeakMap:Map;function mv(n,e,t){(t=ja(-1,t)).tag=3,t.payload={element:null};var o=e.value;return t.callback=function(){Vc||(Vc=!0,Wc=o),fv(0,e)},t}function dv(n,e,t){(t=ja(-1,t)).tag=3;var o=n.type.getDerivedStateFromError;if("function"===typeof o){var r=e.value;t.payload=function(){return o(r)},t.callback=function(){fv(0,e)}}var a=n.stateNode;return null!==a&&"function"===typeof a.componentDidCatch&&(t.callback=function(){fv(0,e),"function"!==typeof o&&(null===Hc?Hc=new Set([this]):Hc.add(this));var n=e.stack;this.componentDidCatch(e.value,{componentStack:null!==n?n:""})}),t}function hv(n,e,t){var o=n.pingCache;if(null===o){o=n.pingCache=new pv;var r=new Set;o.set(e,r)}else void 0===(r=o.get(e))&&(r=new Set,o.set(e,r));r.has(t)||(r.add(t),n=Ml.bind(null,n,e,t),e.then(n,n))}function xv(n){do{var e;if((e=13===n.tag)&&(e=null===(e=n.memoizedState)||null!==e.dehydrated),e)return n;n=n.return}while(null!==n);return null}function yv(n,e,t,o,r){return 0===(1&n.mode)?(n===e?n.flags|=65536:(n.flags|=128,t.flags|=131072,t.flags&=-52805,1===t.tag&&(null===t.alternate?t.tag=17:((e=ja(-1,1)).tag=2,Ia(t,e,1))),t.lanes|=1),n):(n.flags|=65536,n.lanes=r,n)}var gv=b.ReactCurrentOwner,bv=!1;function _v(n,e,t,o){e.child=null===n?Ka(e,null,t,o):Ja(e,n.child,t,o)}function Uv(n,e,t,o,r){t=t.render;var a=e.ref;return Ma(e,r),o=Si(n,e,t,o,a,r),t=Mi(),null===n||bv?(aa&&t&&ea(e),e.flags|=1,_v(n,e,o,r),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,Vv(n,e,r))}function wv(n,e,t,o,r){if(null===n){var a=t.type;return"function"!==typeof a||Pl(a)||void 0!==a.defaultProps||null!==t.compare||void 0!==t.defaultProps?((n=jl(t.type,null,o,e,e.mode,r)).ref=e.ref,n.return=e,e.child=n):(e.tag=15,e.type=a,Sv(n,e,a,o,r))}if(a=n.child,0===(n.lanes&r)){var i=a.memoizedProps;if((t=null!==(t=t.compare)?t:co)(i,o)&&n.ref===e.ref)return Vv(n,e,r)}return e.flags|=1,(n=Fl(a,o)).ref=e.ref,n.return=e,e.child=n}function Sv(n,e,t,o,r){if(null!==n){var a=n.memoizedProps;if(co(a,o)&&n.ref===e.ref){if(bv=!1,e.pendingProps=o=a,0===(n.lanes&r))return e.lanes=n.lanes,Vv(n,e,r);0!==(131072&n.flags)&&(bv=!0)}}return kv(n,e,t,o,r)}function Mv(n,e,t){var o=e.pendingProps,r=o.children,a=null!==n?n.memoizedState:null;if("hidden"===o.mode)if(0===(1&e.mode))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},kr(Fc,Pc),Pc|=t;else{if(0===(1073741824&t))return n=null!==a?a.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n,cachePool:null,transitions:null},e.updateQueue=null,kr(Fc,Pc),Pc|=n,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},o=null!==a?a.baseLanes:t,kr(Fc,Pc),Pc|=o}else null!==a?(o=a.baseLanes|t,e.memoizedState=null):o=t,kr(Fc,Pc),Pc|=o;return _v(n,e,r,t),e.child}function zv(n,e){var t=e.ref;(null===n&&null!==t||null!==n&&n.ref!==t)&&(e.flags|=512,e.flags|=2097152)}function kv(n,e,t,o,r){var a=Fr(t)?Dr:Tr.current;return a=Pr(e,a),Ma(e,r),t=Si(n,e,t,o,a,r),o=Mi(),null===n||bv?(aa&&o&&ea(e),e.flags|=1,_v(n,e,t,r),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,Vv(n,e,r))}function Cv(n,e,t,o,r){if(Fr(t)){var a=!0;Or(e)}else a=!1;if(Ma(e,r),null===e.stateNode)qv(n,e),Va(e,t,o),Ha(e,t,o,r),o=!0;else if(null===n){var i=e.stateNode,v=e.memoizedProps;i.props=v;var c=i.context,l=t.contextType;"object"===typeof l&&null!==l?l=za(l):l=Pr(e,l=Fr(t)?Dr:Tr.current);var s=t.getDerivedStateFromProps,u="function"===typeof s||"function"===typeof i.getSnapshotBeforeUpdate;u||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==o||c!==l)&&Wa(e,i,o,l),Da=!1;var f=e.memoizedState;i.state=f,La(e,o,i,r),c=e.memoizedState,v!==o||f!==c||Rr.current||Da?("function"===typeof s&&(Na(e,t,s,o),c=e.memoizedState),(v=Da||qa(e,t,v,o,f,c,l))?(u||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(e.flags|=4194308)):("function"===typeof i.componentDidMount&&(e.flags|=4194308),e.memoizedProps=o,e.memoizedState=c),i.props=o,i.state=c,i.context=l,o=v):("function"===typeof i.componentDidMount&&(e.flags|=4194308),o=!1)}else{i=e.stateNode,Fa(n,e),v=e.memoizedProps,l=e.type===e.elementType?v:xa(e.type,v),i.props=l,u=e.pendingProps,f=i.context,"object"===typeof(c=t.contextType)&&null!==c?c=za(c):c=Pr(e,c=Fr(t)?Dr:Tr.current);var p=t.getDerivedStateFromProps;(s="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==u||f!==c)&&Wa(e,i,o,c),Da=!1,f=e.memoizedState,i.state=f,La(e,o,i,r);var m=e.memoizedState;v!==u||f!==m||Rr.current||Da?("function"===typeof p&&(Na(e,t,p,o),m=e.memoizedState),(l=Da||qa(e,t,l,o,f,m,c)||!1)?(s||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(o,m,c),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(o,m,c)),"function"===typeof i.componentDidUpdate&&(e.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),e.memoizedProps=o,e.memoizedState=m),i.props=o,i.state=m,i.context=c,o=l):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),o=!1)}return Tv(n,e,t,o,a,r)}function Tv(n,e,t,o,r,a){zv(n,e);var i=0!==(128&e.flags);if(!o&&!i)return r&&Lr(e,t,!1),Vv(n,e,a);o=e.stateNode,gv.current=e;var v=i&&"function"!==typeof t.getDerivedStateFromError?null:o.render();return e.flags|=1,null!==n&&i?(e.child=Ja(e,n.child,null,a),e.child=Ja(e,null,v,a)):_v(n,e,v,a),e.memoizedState=o.state,r&&Lr(e,t,!0),e.child}function Rv(n){var e=n.stateNode;e.pendingContext?Ir(0,e.pendingContext,e.pendingContext!==e.context):e.context&&Ir(0,e.context,!1),ri(n,e.containerInfo)}function Dv(n,e,t,o,r){return ma(),da(r),e.flags|=256,_v(n,e,t,o),e.child}var Pv,Fv,jv,Iv={dehydrated:null,treeContext:null,retryLane:0};function Ev(n){return{baseLanes:n,cachePool:null,transitions:null}}function Ov(n,e,t){var o,r=e.pendingProps,i=ci.current,v=!1,c=0!==(128&e.flags);if((o=c)||(o=(null===n||null!==n.memoizedState)&&0!==(2&i)),o?(v=!0,e.flags&=-129):null!==n&&null===n.memoizedState||(i|=1),kr(ci,1&i),null===n)return sa(e),null!==(n=e.memoizedState)&&null!==(n=n.dehydrated)?(0===(1&e.mode)?e.lanes=1:"$!"===n.data?e.lanes=8:e.lanes=1073741824,null):(c=r.children,n=r.fallback,v?(r=e.mode,v=e.child,c={mode:"hidden",children:c},0===(1&r)&&null!==v?(v.childLanes=0,v.pendingProps=c):v=El(c,r,0,null),n=Il(n,r,t,null),v.return=e,n.return=e,v.sibling=n,e.child=v,e.child.memoizedState=Ev(t),e.memoizedState=Iv,n):Lv(e,c));if(null!==(i=n.memoizedState)&&null!==(o=i.dehydrated))return function(n,e,t,o,r,i,v){if(t)return 256&e.flags?(e.flags&=-257,Av(n,e,v,o=uv(Error(a(422))))):null!==e.memoizedState?(e.child=n.child,e.flags|=128,null):(i=o.fallback,r=e.mode,o=El({mode:"visible",children:o.children},r,0,null),(i=Il(i,r,v,null)).flags|=2,o.return=e,i.return=e,o.sibling=i,e.child=o,0!==(1&e.mode)&&Ja(e,n.child,null,v),e.child.memoizedState=Ev(v),e.memoizedState=Iv,i);if(0===(1&e.mode))return Av(n,e,v,null);if("$!"===r.data){if(o=r.nextSibling&&r.nextSibling.dataset)var c=o.dgst;return o=c,Av(n,e,v,o=uv(i=Error(a(419)),o,void 0))}if(c=0!==(v&n.childLanes),bv||c){if(null!==(o=Tc)){switch(v&-v){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}0!==(r=0!==(r&(o.suspendedLanes|v))?0:r)&&r!==i.retryLane&&(i.retryLane=r,Ra(n,r),tl(o,n,r,-1))}return dl(),Av(n,e,v,o=uv(Error(a(421))))}return"$?"===r.data?(e.flags|=128,e.child=n.child,e=kl.bind(null,n),r._reactRetry=e,null):(n=i.treeContext,ra=sr(r.nextSibling),oa=e,aa=!0,ia=null,null!==n&&(Yr[Zr++]=Jr,Yr[Zr++]=Kr,Yr[Zr++]=Qr,Jr=n.id,Kr=n.overflow,Qr=e),(e=Lv(e,o.children)).flags|=4096,e)}(n,e,c,r,o,i,t);if(v){v=r.fallback,c=e.mode,o=(i=n.child).sibling;var l={mode:"hidden",children:r.children};return 0===(1&c)&&e.child!==i?((r=e.child).childLanes=0,r.pendingProps=l,e.deletions=null):(r=Fl(i,l)).subtreeFlags=14680064&i.subtreeFlags,null!==o?v=Fl(o,v):(v=Il(v,c,t,null)).flags|=2,v.return=e,r.return=e,r.sibling=v,e.child=r,r=v,v=e.child,c=null===(c=n.child.memoizedState)?Ev(t):{baseLanes:c.baseLanes|t,cachePool:null,transitions:c.transitions},v.memoizedState=c,v.childLanes=n.childLanes&~t,e.memoizedState=Iv,r}return n=(v=n.child).sibling,r=Fl(v,{mode:"visible",children:r.children}),0===(1&e.mode)&&(r.lanes=t),r.return=e,r.sibling=null,null!==n&&(null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)),e.child=r,e.memoizedState=null,r}function Lv(n,e){return(e=El({mode:"visible",children:e},n.mode,0,null)).return=n,n.child=e}function Av(n,e,t,o){return null!==o&&da(o),Ja(e,n.child,null,t),(n=Lv(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,n}function Gv(n,e,t){n.lanes|=e;var o=n.alternate;null!==o&&(o.lanes|=e),Sa(n.return,e,t)}function Nv(n,e,t,o,r){var a=n.memoizedState;null===a?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:o,tail:t,tailMode:r}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=o,a.tail=t,a.tailMode=r)}function Bv(n,e,t){var o=e.pendingProps,r=o.revealOrder,a=o.tail;if(_v(n,e,o.children,t),0!==(2&(o=ci.current)))o=1&o|2,e.flags|=128;else{if(null!==n&&0!==(128&n.flags))n:for(n=e.child;null!==n;){if(13===n.tag)null!==n.memoizedState&&Gv(n,t,e);else if(19===n.tag)Gv(n,t,e);else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break n;for(;null===n.sibling;){if(null===n.return||n.return===e)break n;n=n.return}n.sibling.return=n.return,n=n.sibling}o&=1}if(kr(ci,o),0===(1&e.mode))e.memoizedState=null;else switch(r){case"forwards":for(t=e.child,r=null;null!==t;)null!==(n=t.alternate)&&null===li(n)&&(r=t),t=t.sibling;null===(t=r)?(r=e.child,e.child=null):(r=t.sibling,t.sibling=null),Nv(e,!1,r,t,a);break;case"backwards":for(t=null,r=e.child,e.child=null;null!==r;){if(null!==(n=r.alternate)&&null===li(n)){e.child=r;break}n=r.sibling,r.sibling=t,t=r,r=n}Nv(e,!0,t,null,a);break;case"together":Nv(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function qv(n,e){0===(1&e.mode)&&null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2)}function Vv(n,e,t){if(null!==n&&(e.dependencies=n.dependencies),Ec|=e.lanes,0===(t&e.childLanes))return null;if(null!==n&&e.child!==n.child)throw Error(a(153));if(null!==e.child){for(t=Fl(n=e.child,n.pendingProps),e.child=t,t.return=e;null!==n.sibling;)n=n.sibling,(t=t.sibling=Fl(n,n.pendingProps)).return=e;t.sibling=null}return e.child}function Wv(n,e){if(!aa)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;null!==e;)null!==e.alternate&&(t=e),e=e.sibling;null===t?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var o=null;null!==t;)null!==t.alternate&&(o=t),t=t.sibling;null===o?e||null===n.tail?n.tail=null:n.tail.sibling=null:o.sibling=null}}function Hv(n){var e=null!==n.alternate&&n.alternate.child===n.child,t=0,o=0;if(e)for(var r=n.child;null!==r;)t|=r.lanes|r.childLanes,o|=14680064&r.subtreeFlags,o|=14680064&r.flags,r.return=n,r=r.sibling;else for(r=n.child;null!==r;)t|=r.lanes|r.childLanes,o|=r.subtreeFlags,o|=r.flags,r.return=n,r=r.sibling;return n.subtreeFlags|=o,n.childLanes=t,e}function Xv(n,e,t){var o=e.pendingProps;switch(ta(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Hv(e),null;case 1:case 17:return Fr(e.type)&&jr(),Hv(e),null;case 3:return o=e.stateNode,ai(),zr(Rr),zr(Tr),ui(),o.pendingContext&&(o.context=o.pendingContext,o.pendingContext=null),null!==n&&null!==n.child||(fa(e)?e.flags|=4:null===n||n.memoizedState.isDehydrated&&0===(256&e.flags)||(e.flags|=1024,null!==ia&&(il(ia),ia=null))),Hv(e),null;case 5:vi(e);var r=oi(ti.current);if(t=e.type,null!==n&&null!=e.stateNode)Fv(n,e,t,o),n.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!o){if(null===e.stateNode)throw Error(a(166));return Hv(e),null}if(n=oi(ni.current),fa(e)){o=e.stateNode,t=e.type;var i=e.memoizedProps;switch(o[pr]=e,o[mr]=i,n=0!==(1&e.mode),t){case"dialog":Go("cancel",o),Go("close",o);break;case"iframe":case"object":case"embed":Go("load",o);break;case"video":case"audio":for(r=0;r<Eo.length;r++)Go(Eo[r],o);break;case"source":Go("error",o);break;case"img":case"image":case"link":Go("error",o),Go("load",o);break;case"details":Go("toggle",o);break;case"input":Q(o,i),Go("invalid",o);break;case"select":o._wrapperState={wasMultiple:!!i.multiple},Go("invalid",o);break;case"textarea":rn(o,i),Go("invalid",o)}for(var c in gn(t,i),r=null,i)if(i.hasOwnProperty(c)){var l=i[c];"children"===c?"string"===typeof l?o.textContent!==l&&(!0!==i.suppressHydrationWarning&&$o(o.textContent,l,n),r=["children",l]):"number"===typeof l&&o.textContent!==""+l&&(!0!==i.suppressHydrationWarning&&$o(o.textContent,l,n),r=["children",""+l]):v.hasOwnProperty(c)&&null!=l&&"onScroll"===c&&Go("scroll",o)}switch(t){case"input":H(o),$(o,i,!0);break;case"textarea":H(o),vn(o);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(o.onclick=nr)}o=r,e.updateQueue=o,null!==o&&(e.flags|=4)}else{c=9===r.nodeType?r:r.ownerDocument,"http://www.w3.org/1999/xhtml"===n&&(n=cn(t)),"http://www.w3.org/1999/xhtml"===n?"script"===t?((n=c.createElement("div")).innerHTML="<script><\/script>",n=n.removeChild(n.firstChild)):"string"===typeof o.is?n=c.createElement(t,{is:o.is}):(n=c.createElement(t),"select"===t&&(c=n,o.multiple?c.multiple=!0:o.size&&(c.size=o.size))):n=c.createElementNS(n,t),n[pr]=e,n[mr]=o,Pv(n,e),e.stateNode=n;n:{switch(c=bn(t,o),t){case"dialog":Go("cancel",n),Go("close",n),r=o;break;case"iframe":case"object":case"embed":Go("load",n),r=o;break;case"video":case"audio":for(r=0;r<Eo.length;r++)Go(Eo[r],n);r=o;break;case"source":Go("error",n),r=o;break;case"img":case"image":case"link":Go("error",n),Go("load",n),r=o;break;case"details":Go("toggle",n),r=o;break;case"input":Q(n,o),r=Z(n,o),Go("invalid",n);break;case"option":default:r=o;break;case"select":n._wrapperState={wasMultiple:!!o.multiple},r=O({},o,{value:void 0}),Go("invalid",n);break;case"textarea":rn(n,o),r=on(n,o),Go("invalid",n)}for(i in gn(t,r),l=r)if(l.hasOwnProperty(i)){var s=l[i];"style"===i?xn(n,s):"dangerouslySetInnerHTML"===i?null!=(s=s?s.__html:void 0)&&fn(n,s):"children"===i?"string"===typeof s?("textarea"!==t||""!==s)&&pn(n,s):"number"===typeof s&&pn(n,""+s):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(v.hasOwnProperty(i)?null!=s&&"onScroll"===i&&Go("scroll",n):null!=s&&g(n,i,s,c))}switch(t){case"input":H(n),$(n,o,!1);break;case"textarea":H(n),vn(n);break;case"option":null!=o.value&&n.setAttribute("value",""+V(o.value));break;case"select":n.multiple=!!o.multiple,null!=(i=o.value)?tn(n,!!o.multiple,i,!1):null!=o.defaultValue&&tn(n,!!o.multiple,o.defaultValue,!0);break;default:"function"===typeof r.onClick&&(n.onclick=nr)}switch(t){case"button":case"input":case"select":case"textarea":o=!!o.autoFocus;break n;case"img":o=!0;break n;default:o=!1}}o&&(e.flags|=4)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return Hv(e),null;case 6:if(n&&null!=e.stateNode)jv(0,e,n.memoizedProps,o);else{if("string"!==typeof o&&null===e.stateNode)throw Error(a(166));if(t=oi(ti.current),oi(ni.current),fa(e)){if(o=e.stateNode,t=e.memoizedProps,o[pr]=e,(i=o.nodeValue!==t)&&null!==(n=oa))switch(n.tag){case 3:$o(o.nodeValue,t,0!==(1&n.mode));break;case 5:!0!==n.memoizedProps.suppressHydrationWarning&&$o(o.nodeValue,t,0!==(1&n.mode))}i&&(e.flags|=4)}else(o=(9===t.nodeType?t:t.ownerDocument).createTextNode(o))[pr]=e,e.stateNode=o}return Hv(e),null;case 13:if(zr(ci),o=e.memoizedState,null===n||null!==n.memoizedState&&null!==n.memoizedState.dehydrated){if(aa&&null!==ra&&0!==(1&e.mode)&&0===(128&e.flags))pa(),ma(),e.flags|=98560,i=!1;else if(i=fa(e),null!==o&&null!==o.dehydrated){if(null===n){if(!i)throw Error(a(318));if(!(i=null!==(i=e.memoizedState)?i.dehydrated:null))throw Error(a(317));i[pr]=e}else ma(),0===(128&e.flags)&&(e.memoizedState=null),e.flags|=4;Hv(e),i=!1}else null!==ia&&(il(ia),ia=null),i=!0;if(!i)return 65536&e.flags?e:null}return 0!==(128&e.flags)?(e.lanes=t,e):((o=null!==o)!==(null!==n&&null!==n.memoizedState)&&o&&(e.child.flags|=8192,0!==(1&e.mode)&&(null===n||0!==(1&ci.current)?0===jc&&(jc=3):dl())),null!==e.updateQueue&&(e.flags|=4),Hv(e),null);case 4:return ai(),null===n&&qo(e.stateNode.containerInfo),Hv(e),null;case 10:return wa(e.type._context),Hv(e),null;case 19:if(zr(ci),null===(i=e.memoizedState))return Hv(e),null;if(o=0!==(128&e.flags),null===(c=i.rendering))if(o)Wv(i,!1);else{if(0!==jc||null!==n&&0!==(128&n.flags))for(n=e.child;null!==n;){if(null!==(c=li(n))){for(e.flags|=128,Wv(i,!1),null!==(o=c.updateQueue)&&(e.updateQueue=o,e.flags|=4),e.subtreeFlags=0,o=t,t=e.child;null!==t;)n=o,(i=t).flags&=14680066,null===(c=i.alternate)?(i.childLanes=0,i.lanes=n,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=c.childLanes,i.lanes=c.lanes,i.child=c.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=c.memoizedProps,i.memoizedState=c.memoizedState,i.updateQueue=c.updateQueue,i.type=c.type,n=c.dependencies,i.dependencies=null===n?null:{lanes:n.lanes,firstContext:n.firstContext}),t=t.sibling;return kr(ci,1&ci.current|2),e.child}n=n.sibling}null!==i.tail&&Kn()>Bc&&(e.flags|=128,o=!0,Wv(i,!1),e.lanes=4194304)}else{if(!o)if(null!==(n=li(c))){if(e.flags|=128,o=!0,null!==(t=n.updateQueue)&&(e.updateQueue=t,e.flags|=4),Wv(i,!0),null===i.tail&&"hidden"===i.tailMode&&!c.alternate&&!aa)return Hv(e),null}else 2*Kn()-i.renderingStartTime>Bc&&1073741824!==t&&(e.flags|=128,o=!0,Wv(i,!1),e.lanes=4194304);i.isBackwards?(c.sibling=e.child,e.child=c):(null!==(t=i.last)?t.sibling=c:e.child=c,i.last=c)}return null!==i.tail?(e=i.tail,i.rendering=e,i.tail=e.sibling,i.renderingStartTime=Kn(),e.sibling=null,t=ci.current,kr(ci,o?1&t|2:1&t),e):(Hv(e),null);case 22:case 23:return ul(),o=null!==e.memoizedState,null!==n&&null!==n.memoizedState!==o&&(e.flags|=8192),o&&0!==(1&e.mode)?0!==(1073741824&Pc)&&(Hv(e),6&e.subtreeFlags&&(e.flags|=8192)):Hv(e),null;case 24:case 25:return null}throw Error(a(156,e.tag))}function Yv(n,e){switch(ta(e),e.tag){case 1:return Fr(e.type)&&jr(),65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 3:return ai(),zr(Rr),zr(Tr),ui(),0!==(65536&(n=e.flags))&&0===(128&n)?(e.flags=-65537&n|128,e):null;case 5:return vi(e),null;case 13:if(zr(ci),null!==(n=e.memoizedState)&&null!==n.dehydrated){if(null===e.alternate)throw Error(a(340));ma()}return 65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 19:return zr(ci),null;case 4:return ai(),null;case 10:return wa(e.type._context),null;case 22:case 23:return ul(),null;default:return null}}Pv=function(n,e){for(var t=e.child;null!==t;){if(5===t.tag||6===t.tag)n.appendChild(t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},Fv=function(n,e,t,o){var r=n.memoizedProps;if(r!==o){n=e.stateNode,oi(ni.current);var a,i=null;switch(t){case"input":r=Z(n,r),o=Z(n,o),i=[];break;case"select":r=O({},r,{value:void 0}),o=O({},o,{value:void 0}),i=[];break;case"textarea":r=on(n,r),o=on(n,o),i=[];break;default:"function"!==typeof r.onClick&&"function"===typeof o.onClick&&(n.onclick=nr)}for(s in gn(t,o),t=null,r)if(!o.hasOwnProperty(s)&&r.hasOwnProperty(s)&&null!=r[s])if("style"===s){var c=r[s];for(a in c)c.hasOwnProperty(a)&&(t||(t={}),t[a]="")}else"dangerouslySetInnerHTML"!==s&&"children"!==s&&"suppressContentEditableWarning"!==s&&"suppressHydrationWarning"!==s&&"autoFocus"!==s&&(v.hasOwnProperty(s)?i||(i=[]):(i=i||[]).push(s,null));for(s in o){var l=o[s];if(c=null!=r?r[s]:void 0,o.hasOwnProperty(s)&&l!==c&&(null!=l||null!=c))if("style"===s)if(c){for(a in c)!c.hasOwnProperty(a)||l&&l.hasOwnProperty(a)||(t||(t={}),t[a]="");for(a in l)l.hasOwnProperty(a)&&c[a]!==l[a]&&(t||(t={}),t[a]=l[a])}else t||(i||(i=[]),i.push(s,t)),t=l;else"dangerouslySetInnerHTML"===s?(l=l?l.__html:void 0,c=c?c.__html:void 0,null!=l&&c!==l&&(i=i||[]).push(s,l)):"children"===s?"string"!==typeof l&&"number"!==typeof l||(i=i||[]).push(s,""+l):"suppressContentEditableWarning"!==s&&"suppressHydrationWarning"!==s&&(v.hasOwnProperty(s)?(null!=l&&"onScroll"===s&&Go("scroll",n),i||c===l||(i=[])):(i=i||[]).push(s,l))}t&&(i=i||[]).push("style",t);var s=i;(e.updateQueue=s)&&(e.flags|=4)}},jv=function(n,e,t,o){t!==o&&(e.flags|=4)};var Zv=!1,Qv=!1,Jv="function"===typeof WeakSet?WeakSet:Set,Kv=null;function $v(n,e){var t=n.ref;if(null!==t)if("function"===typeof t)try{t(null)}catch(o){Sl(n,e,o)}else t.current=null}function nc(n,e,t){try{t()}catch(o){Sl(n,e,o)}}var ec=!1;function tc(n,e,t){var o=e.updateQueue;if(null!==(o=null!==o?o.lastEffect:null)){var r=o=o.next;do{if((r.tag&n)===n){var a=r.destroy;r.destroy=void 0,void 0!==a&&nc(e,t,a)}r=r.next}while(r!==o)}}function oc(n,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var t=e=e.next;do{if((t.tag&n)===n){var o=t.create;t.destroy=o()}t=t.next}while(t!==e)}}function rc(n){var e=n.ref;if(null!==e){var t=n.stateNode;n.tag,n=t,"function"===typeof e?e(n):e.current=n}}function ac(n){var e=n.alternate;null!==e&&(n.alternate=null,ac(e)),n.child=null,n.deletions=null,n.sibling=null,5===n.tag&&(null!==(e=n.stateNode)&&(delete e[pr],delete e[mr],delete e[hr],delete e[xr],delete e[yr])),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}function ic(n){return 5===n.tag||3===n.tag||4===n.tag}function vc(n){n:for(;;){for(;null===n.sibling;){if(null===n.return||ic(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.flags)continue n;if(null===n.child||4===n.tag)continue n;n.child.return=n,n=n.child}if(!(2&n.flags))return n.stateNode}}function cc(n,e,t){var o=n.tag;if(5===o||6===o)n=n.stateNode,e?8===t.nodeType?t.parentNode.insertBefore(n,e):t.insertBefore(n,e):(8===t.nodeType?(e=t.parentNode).insertBefore(n,t):(e=t).appendChild(n),null!==(t=t._reactRootContainer)&&void 0!==t||null!==e.onclick||(e.onclick=nr));else if(4!==o&&null!==(n=n.child))for(cc(n,e,t),n=n.sibling;null!==n;)cc(n,e,t),n=n.sibling}function lc(n,e,t){var o=n.tag;if(5===o||6===o)n=n.stateNode,e?t.insertBefore(n,e):t.appendChild(n);else if(4!==o&&null!==(n=n.child))for(lc(n,e,t),n=n.sibling;null!==n;)lc(n,e,t),n=n.sibling}var sc=null,uc=!1;function fc(n,e,t){for(t=t.child;null!==t;)pc(n,e,t),t=t.sibling}function pc(n,e,t){if(ie&&"function"===typeof ie.onCommitFiberUnmount)try{ie.onCommitFiberUnmount(ae,t)}catch(v){}switch(t.tag){case 5:Qv||$v(t,e);case 6:var o=sc,r=uc;sc=null,fc(n,e,t),uc=r,null!==(sc=o)&&(uc?(n=sc,t=t.stateNode,8===n.nodeType?n.parentNode.removeChild(t):n.removeChild(t)):sc.removeChild(t.stateNode));break;case 18:null!==sc&&(uc?(n=sc,t=t.stateNode,8===n.nodeType?lr(n.parentNode,t):1===n.nodeType&&lr(n,t),qe(n)):lr(sc,t.stateNode));break;case 4:o=sc,r=uc,sc=t.stateNode.containerInfo,uc=!0,fc(n,e,t),sc=o,uc=r;break;case 0:case 11:case 14:case 15:if(!Qv&&(null!==(o=t.updateQueue)&&null!==(o=o.lastEffect))){r=o=o.next;do{var a=r,i=a.destroy;a=a.tag,void 0!==i&&(0!==(2&a)||0!==(4&a))&&nc(t,e,i),r=r.next}while(r!==o)}fc(n,e,t);break;case 1:if(!Qv&&($v(t,e),"function"===typeof(o=t.stateNode).componentWillUnmount))try{o.props=t.memoizedProps,o.state=t.memoizedState,o.componentWillUnmount()}catch(v){Sl(t,e,v)}fc(n,e,t);break;case 21:fc(n,e,t);break;case 22:1&t.mode?(Qv=(o=Qv)||null!==t.memoizedState,fc(n,e,t),Qv=o):fc(n,e,t);break;default:fc(n,e,t)}}function mc(n){var e=n.updateQueue;if(null!==e){n.updateQueue=null;var t=n.stateNode;null===t&&(t=n.stateNode=new Jv),e.forEach((function(e){var o=Cl.bind(null,n,e);t.has(e)||(t.add(e),e.then(o,o))}))}}function dc(n,e){var t=e.deletions;if(null!==t)for(var o=0;o<t.length;o++){var r=t[o];try{var i=n,v=e,c=v;n:for(;null!==c;){switch(c.tag){case 5:sc=c.stateNode,uc=!1;break n;case 3:case 4:sc=c.stateNode.containerInfo,uc=!0;break n}c=c.return}if(null===sc)throw Error(a(160));pc(i,v,r),sc=null,uc=!1;var l=r.alternate;null!==l&&(l.return=null),r.return=null}catch(s){Sl(r,e,s)}}if(12854&e.subtreeFlags)for(e=e.child;null!==e;)hc(e,n),e=e.sibling}function hc(n,e){var t=n.alternate,o=n.flags;switch(n.tag){case 0:case 11:case 14:case 15:if(dc(e,n),xc(n),4&o){try{tc(3,n,n.return),oc(3,n)}catch(h){Sl(n,n.return,h)}try{tc(5,n,n.return)}catch(h){Sl(n,n.return,h)}}break;case 1:dc(e,n),xc(n),512&o&&null!==t&&$v(t,t.return);break;case 5:if(dc(e,n),xc(n),512&o&&null!==t&&$v(t,t.return),32&n.flags){var r=n.stateNode;try{pn(r,"")}catch(h){Sl(n,n.return,h)}}if(4&o&&null!=(r=n.stateNode)){var i=n.memoizedProps,v=null!==t?t.memoizedProps:i,c=n.type,l=n.updateQueue;if(n.updateQueue=null,null!==l)try{"input"===c&&"radio"===i.type&&null!=i.name&&J(r,i),bn(c,v);var s=bn(c,i);for(v=0;v<l.length;v+=2){var u=l[v],f=l[v+1];"style"===u?xn(r,f):"dangerouslySetInnerHTML"===u?fn(r,f):"children"===u?pn(r,f):g(r,u,f,s)}switch(c){case"input":K(r,i);break;case"textarea":an(r,i);break;case"select":var p=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!i.multiple;var m=i.value;null!=m?tn(r,!!i.multiple,m,!1):p!==!!i.multiple&&(null!=i.defaultValue?tn(r,!!i.multiple,i.defaultValue,!0):tn(r,!!i.multiple,i.multiple?[]:"",!1))}r[mr]=i}catch(h){Sl(n,n.return,h)}}break;case 6:if(dc(e,n),xc(n),4&o){if(null===n.stateNode)throw Error(a(162));r=n.stateNode,i=n.memoizedProps;try{r.nodeValue=i}catch(h){Sl(n,n.return,h)}}break;case 3:if(dc(e,n),xc(n),4&o&&null!==t&&t.memoizedState.isDehydrated)try{qe(e.containerInfo)}catch(h){Sl(n,n.return,h)}break;case 4:default:dc(e,n),xc(n);break;case 13:dc(e,n),xc(n),8192&(r=n.child).flags&&(i=null!==r.memoizedState,r.stateNode.isHidden=i,!i||null!==r.alternate&&null!==r.alternate.memoizedState||(Nc=Kn())),4&o&&mc(n);break;case 22:if(u=null!==t&&null!==t.memoizedState,1&n.mode?(Qv=(s=Qv)||u,dc(e,n),Qv=s):dc(e,n),xc(n),8192&o){if(s=null!==n.memoizedState,(n.stateNode.isHidden=s)&&!u&&0!==(1&n.mode))for(Kv=n,u=n.child;null!==u;){for(f=Kv=u;null!==Kv;){switch(m=(p=Kv).child,p.tag){case 0:case 11:case 14:case 15:tc(4,p,p.return);break;case 1:$v(p,p.return);var d=p.stateNode;if("function"===typeof d.componentWillUnmount){o=p,t=p.return;try{e=o,d.props=e.memoizedProps,d.state=e.memoizedState,d.componentWillUnmount()}catch(h){Sl(o,t,h)}}break;case 5:$v(p,p.return);break;case 22:if(null!==p.memoizedState){_c(f);continue}}null!==m?(m.return=p,Kv=m):_c(f)}u=u.sibling}n:for(u=null,f=n;;){if(5===f.tag){if(null===u){u=f;try{r=f.stateNode,s?"function"===typeof(i=r.style).setProperty?i.setProperty("display","none","important"):i.display="none":(c=f.stateNode,v=void 0!==(l=f.memoizedProps.style)&&null!==l&&l.hasOwnProperty("display")?l.display:null,c.style.display=hn("display",v))}catch(h){Sl(n,n.return,h)}}}else if(6===f.tag){if(null===u)try{f.stateNode.nodeValue=s?"":f.memoizedProps}catch(h){Sl(n,n.return,h)}}else if((22!==f.tag&&23!==f.tag||null===f.memoizedState||f===n)&&null!==f.child){f.child.return=f,f=f.child;continue}if(f===n)break n;for(;null===f.sibling;){if(null===f.return||f.return===n)break n;u===f&&(u=null),f=f.return}u===f&&(u=null),f.sibling.return=f.return,f=f.sibling}}break;case 19:dc(e,n),xc(n),4&o&&mc(n);case 21:}}function xc(n){var e=n.flags;if(2&e){try{n:{for(var t=n.return;null!==t;){if(ic(t)){var o=t;break n}t=t.return}throw Error(a(160))}switch(o.tag){case 5:var r=o.stateNode;32&o.flags&&(pn(r,""),o.flags&=-33),lc(n,vc(n),r);break;case 3:case 4:var i=o.stateNode.containerInfo;cc(n,vc(n),i);break;default:throw Error(a(161))}}catch(v){Sl(n,n.return,v)}n.flags&=-3}4096&e&&(n.flags&=-4097)}function yc(n,e,t){Kv=n,gc(n,e,t)}function gc(n,e,t){for(var o=0!==(1&n.mode);null!==Kv;){var r=Kv,a=r.child;if(22===r.tag&&o){var i=null!==r.memoizedState||Zv;if(!i){var v=r.alternate,c=null!==v&&null!==v.memoizedState||Qv;v=Zv;var l=Qv;if(Zv=i,(Qv=c)&&!l)for(Kv=r;null!==Kv;)c=(i=Kv).child,22===i.tag&&null!==i.memoizedState?Uc(r):null!==c?(c.return=i,Kv=c):Uc(r);for(;null!==a;)Kv=a,gc(a,e,t),a=a.sibling;Kv=r,Zv=v,Qv=l}bc(n)}else 0!==(8772&r.subtreeFlags)&&null!==a?(a.return=r,Kv=a):bc(n)}}function bc(n){for(;null!==Kv;){var e=Kv;if(0!==(8772&e.flags)){var t=e.alternate;try{if(0!==(8772&e.flags))switch(e.tag){case 0:case 11:case 15:Qv||oc(5,e);break;case 1:var o=e.stateNode;if(4&e.flags&&!Qv)if(null===t)o.componentDidMount();else{var r=e.elementType===e.type?t.memoizedProps:xa(e.type,t.memoizedProps);o.componentDidUpdate(r,t.memoizedState,o.__reactInternalSnapshotBeforeUpdate)}var i=e.updateQueue;null!==i&&Aa(e,i,o);break;case 3:var v=e.updateQueue;if(null!==v){if(t=null,null!==e.child)switch(e.child.tag){case 5:case 1:t=e.child.stateNode}Aa(e,v,t)}break;case 5:var c=e.stateNode;if(null===t&&4&e.flags){t=c;var l=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&t.focus();break;case"img":l.src&&(t.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===e.memoizedState){var s=e.alternate;if(null!==s){var u=s.memoizedState;if(null!==u){var f=u.dehydrated;null!==f&&qe(f)}}}break;default:throw Error(a(163))}Qv||512&e.flags&&rc(e)}catch(p){Sl(e,e.return,p)}}if(e===n){Kv=null;break}if(null!==(t=e.sibling)){t.return=e.return,Kv=t;break}Kv=e.return}}function _c(n){for(;null!==Kv;){var e=Kv;if(e===n){Kv=null;break}var t=e.sibling;if(null!==t){t.return=e.return,Kv=t;break}Kv=e.return}}function Uc(n){for(;null!==Kv;){var e=Kv;try{switch(e.tag){case 0:case 11:case 15:var t=e.return;try{oc(4,e)}catch(c){Sl(e,t,c)}break;case 1:var o=e.stateNode;if("function"===typeof o.componentDidMount){var r=e.return;try{o.componentDidMount()}catch(c){Sl(e,r,c)}}var a=e.return;try{rc(e)}catch(c){Sl(e,a,c)}break;case 5:var i=e.return;try{rc(e)}catch(c){Sl(e,i,c)}}}catch(c){Sl(e,e.return,c)}if(e===n){Kv=null;break}var v=e.sibling;if(null!==v){v.return=e.return,Kv=v;break}Kv=e.return}}var wc,Sc=Math.ceil,Mc=b.ReactCurrentDispatcher,zc=b.ReactCurrentOwner,kc=b.ReactCurrentBatchConfig,Cc=0,Tc=null,Rc=null,Dc=0,Pc=0,Fc=Mr(0),jc=0,Ic=null,Ec=0,Oc=0,Lc=0,Ac=null,Gc=null,Nc=0,Bc=1/0,qc=null,Vc=!1,Wc=null,Hc=null,Xc=!1,Yc=null,Zc=0,Qc=0,Jc=null,Kc=-1,$c=0;function nl(){return 0!==(6&Cc)?Kn():-1!==Kc?Kc:Kc=Kn()}function el(n){return 0===(1&n.mode)?1:0!==(2&Cc)&&0!==Dc?Dc&-Dc:null!==ha.transition?(0===$c&&($c=he()),$c):0!==(n=be)?n:n=void 0===(n=window.event)?16:Je(n.type)}function tl(n,e,t,o){if(50<Qc)throw Qc=0,Jc=null,Error(a(185));ye(n,t,o),0!==(2&Cc)&&n===Tc||(n===Tc&&(0===(2&Cc)&&(Oc|=t),4===jc&&vl(n,Dc)),ol(n,o),1===t&&0===Cc&&0===(1&e.mode)&&(Bc=Kn()+500,Gr&&qr()))}function ol(n,e){var t=n.callbackNode;!function(n,e){for(var t=n.suspendedLanes,o=n.pingedLanes,r=n.expirationTimes,a=n.pendingLanes;0<a;){var i=31-ve(a),v=1<<i,c=r[i];-1===c?0!==(v&t)&&0===(v&o)||(r[i]=me(v,e)):c<=e&&(n.expiredLanes|=v),a&=~v}}(n,e);var o=pe(n,n===Tc?Dc:0);if(0===o)null!==t&&Zn(t),n.callbackNode=null,n.callbackPriority=0;else if(e=o&-o,n.callbackPriority!==e){if(null!=t&&Zn(t),1===e)0===n.tag?function(n){Gr=!0,Br(n)}(cl.bind(null,n)):Br(cl.bind(null,n)),vr((function(){0===(6&Cc)&&qr()})),t=null;else{switch(_e(o)){case 1:t=ne;break;case 4:t=ee;break;case 16:default:t=te;break;case 536870912:t=re}t=Tl(t,rl.bind(null,n))}n.callbackPriority=e,n.callbackNode=t}}function rl(n,e){if(Kc=-1,$c=0,0!==(6&Cc))throw Error(a(327));var t=n.callbackNode;if(Ul()&&n.callbackNode!==t)return null;var o=pe(n,n===Tc?Dc:0);if(0===o)return null;if(0!==(30&o)||0!==(o&n.expiredLanes)||e)e=hl(n,o);else{e=o;var r=Cc;Cc|=2;var i=ml();for(Tc===n&&Dc===e||(qc=null,Bc=Kn()+500,fl(n,e));;)try{yl();break}catch(c){pl(n,c)}Ua(),Mc.current=i,Cc=r,null!==Rc?e=0:(Tc=null,Dc=0,e=jc)}if(0!==e){if(2===e&&(0!==(r=de(n))&&(o=r,e=al(n,r))),1===e)throw t=Ic,fl(n,0),vl(n,o),ol(n,Kn()),t;if(6===e)vl(n,o);else{if(r=n.current.alternate,0===(30&o)&&!function(n){for(var e=n;;){if(16384&e.flags){var t=e.updateQueue;if(null!==t&&null!==(t=t.stores))for(var o=0;o<t.length;o++){var r=t[o],a=r.getSnapshot;r=r.value;try{if(!vo(a(),r))return!1}catch(v){return!1}}}if(t=e.child,16384&e.subtreeFlags&&null!==t)t.return=e,e=t;else{if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(r)&&(2===(e=hl(n,o))&&(0!==(i=de(n))&&(o=i,e=al(n,i))),1===e))throw t=Ic,fl(n,0),vl(n,o),ol(n,Kn()),t;switch(n.finishedWork=r,n.finishedLanes=o,e){case 0:case 1:throw Error(a(345));case 2:case 5:_l(n,Gc,qc);break;case 3:if(vl(n,o),(130023424&o)===o&&10<(e=Nc+500-Kn())){if(0!==pe(n,0))break;if(((r=n.suspendedLanes)&o)!==o){nl(),n.pingedLanes|=n.suspendedLanes&r;break}n.timeoutHandle=rr(_l.bind(null,n,Gc,qc),e);break}_l(n,Gc,qc);break;case 4:if(vl(n,o),(4194240&o)===o)break;for(e=n.eventTimes,r=-1;0<o;){var v=31-ve(o);i=1<<v,(v=e[v])>r&&(r=v),o&=~i}if(o=r,10<(o=(120>(o=Kn()-o)?120:480>o?480:1080>o?1080:1920>o?1920:3e3>o?3e3:4320>o?4320:1960*Sc(o/1960))-o)){n.timeoutHandle=rr(_l.bind(null,n,Gc,qc),o);break}_l(n,Gc,qc);break;default:throw Error(a(329))}}}return ol(n,Kn()),n.callbackNode===t?rl.bind(null,n):null}function al(n,e){var t=Ac;return n.current.memoizedState.isDehydrated&&(fl(n,e).flags|=256),2!==(n=hl(n,e))&&(e=Gc,Gc=t,null!==e&&il(e)),n}function il(n){null===Gc?Gc=n:Gc.push.apply(Gc,n)}function vl(n,e){for(e&=~Lc,e&=~Oc,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-ve(e),o=1<<t;n[t]=-1,e&=~o}}function cl(n){if(0!==(6&Cc))throw Error(a(327));Ul();var e=pe(n,0);if(0===(1&e))return ol(n,Kn()),null;var t=hl(n,e);if(0!==n.tag&&2===t){var o=de(n);0!==o&&(e=o,t=al(n,o))}if(1===t)throw t=Ic,fl(n,0),vl(n,e),ol(n,Kn()),t;if(6===t)throw Error(a(345));return n.finishedWork=n.current.alternate,n.finishedLanes=e,_l(n,Gc,qc),ol(n,Kn()),null}function ll(n,e){var t=Cc;Cc|=1;try{return n(e)}finally{0===(Cc=t)&&(Bc=Kn()+500,Gr&&qr())}}function sl(n){null!==Yc&&0===Yc.tag&&0===(6&Cc)&&Ul();var e=Cc;Cc|=1;var t=kc.transition,o=be;try{if(kc.transition=null,be=1,n)return n()}finally{be=o,kc.transition=t,0===(6&(Cc=e))&&qr()}}function ul(){Pc=Fc.current,zr(Fc)}function fl(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(-1!==t&&(n.timeoutHandle=-1,ar(t)),null!==Rc)for(t=Rc.return;null!==t;){var o=t;switch(ta(o),o.tag){case 1:null!==(o=o.type.childContextTypes)&&void 0!==o&&jr();break;case 3:ai(),zr(Rr),zr(Tr),ui();break;case 5:vi(o);break;case 4:ai();break;case 13:case 19:zr(ci);break;case 10:wa(o.type._context);break;case 22:case 23:ul()}t=t.return}if(Tc=n,Rc=n=Fl(n.current,null),Dc=Pc=e,jc=0,Ic=null,Lc=Oc=Ec=0,Gc=Ac=null,null!==ka){for(e=0;e<ka.length;e++)if(null!==(o=(t=ka[e]).interleaved)){t.interleaved=null;var r=o.next,a=t.pending;if(null!==a){var i=a.next;a.next=r,o.next=i}t.pending=o}ka=null}return n}function pl(n,e){for(;;){var t=Rc;try{if(Ua(),fi.current=iv,yi){for(var o=di.memoizedState;null!==o;){var r=o.queue;null!==r&&(r.pending=null),o=o.next}yi=!1}if(mi=0,xi=hi=di=null,gi=!1,bi=0,zc.current=null,null===t||null===t.return){jc=1,Ic=e,Rc=null;break}n:{var i=n,v=t.return,c=t,l=e;if(e=Dc,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var s=l,u=c,f=u.tag;if(0===(1&u.mode)&&(0===f||11===f||15===f)){var p=u.alternate;p?(u.updateQueue=p.updateQueue,u.memoizedState=p.memoizedState,u.lanes=p.lanes):(u.updateQueue=null,u.memoizedState=null)}var m=xv(v);if(null!==m){m.flags&=-257,yv(m,v,c,0,e),1&m.mode&&hv(i,s,e),l=s;var d=(e=m).updateQueue;if(null===d){var h=new Set;h.add(l),e.updateQueue=h}else d.add(l);break n}if(0===(1&e)){hv(i,s,e),dl();break n}l=Error(a(426))}else if(aa&&1&c.mode){var x=xv(v);if(null!==x){0===(65536&x.flags)&&(x.flags|=256),yv(x,v,c,0,e),da(sv(l,c));break n}}i=l=sv(l,c),4!==jc&&(jc=2),null===Ac?Ac=[i]:Ac.push(i),i=v;do{switch(i.tag){case 3:i.flags|=65536,e&=-e,i.lanes|=e,Oa(i,mv(0,l,e));break n;case 1:c=l;var y=i.type,g=i.stateNode;if(0===(128&i.flags)&&("function"===typeof y.getDerivedStateFromError||null!==g&&"function"===typeof g.componentDidCatch&&(null===Hc||!Hc.has(g)))){i.flags|=65536,e&=-e,i.lanes|=e,Oa(i,dv(i,c,e));break n}}i=i.return}while(null!==i)}bl(t)}catch(b){e=b,Rc===t&&null!==t&&(Rc=t=t.return);continue}break}}function ml(){var n=Mc.current;return Mc.current=iv,null===n?iv:n}function dl(){0!==jc&&3!==jc&&2!==jc||(jc=4),null===Tc||0===(268435455&Ec)&&0===(268435455&Oc)||vl(Tc,Dc)}function hl(n,e){var t=Cc;Cc|=2;var o=ml();for(Tc===n&&Dc===e||(qc=null,fl(n,e));;)try{xl();break}catch(r){pl(n,r)}if(Ua(),Cc=t,Mc.current=o,null!==Rc)throw Error(a(261));return Tc=null,Dc=0,jc}function xl(){for(;null!==Rc;)gl(Rc)}function yl(){for(;null!==Rc&&!Qn();)gl(Rc)}function gl(n){var e=wc(n.alternate,n,Pc);n.memoizedProps=n.pendingProps,null===e?bl(n):Rc=e,zc.current=null}function bl(n){var e=n;do{var t=e.alternate;if(n=e.return,0===(32768&e.flags)){if(null!==(t=Xv(t,e,Pc)))return void(Rc=t)}else{if(null!==(t=Yv(t,e)))return t.flags&=32767,void(Rc=t);if(null===n)return jc=6,void(Rc=null);n.flags|=32768,n.subtreeFlags=0,n.deletions=null}if(null!==(e=e.sibling))return void(Rc=e);Rc=e=n}while(null!==e);0===jc&&(jc=5)}function _l(n,e,t){var o=be,r=kc.transition;try{kc.transition=null,be=1,function(n,e,t,o){do{Ul()}while(null!==Yc);if(0!==(6&Cc))throw Error(a(327));t=n.finishedWork;var r=n.finishedLanes;if(null===t)return null;if(n.finishedWork=null,n.finishedLanes=0,t===n.current)throw Error(a(177));n.callbackNode=null,n.callbackPriority=0;var i=t.lanes|t.childLanes;if(function(n,e){var t=n.pendingLanes&~e;n.pendingLanes=e,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=e,n.mutableReadLanes&=e,n.entangledLanes&=e,e=n.entanglements;var o=n.eventTimes;for(n=n.expirationTimes;0<t;){var r=31-ve(t),a=1<<r;e[r]=0,o[r]=-1,n[r]=-1,t&=~a}}(n,i),n===Tc&&(Rc=Tc=null,Dc=0),0===(2064&t.subtreeFlags)&&0===(2064&t.flags)||Xc||(Xc=!0,Tl(te,(function(){return Ul(),null}))),i=0!==(15990&t.flags),0!==(15990&t.subtreeFlags)||i){i=kc.transition,kc.transition=null;var v=be;be=1;var c=Cc;Cc|=4,zc.current=null,function(n,e){if(er=We,po(n=fo())){if("selectionStart"in n)var t={start:n.selectionStart,end:n.selectionEnd};else n:{var o=(t=(t=n.ownerDocument)&&t.defaultView||window).getSelection&&t.getSelection();if(o&&0!==o.rangeCount){t=o.anchorNode;var r=o.anchorOffset,i=o.focusNode;o=o.focusOffset;try{t.nodeType,i.nodeType}catch(_){t=null;break n}var v=0,c=-1,l=-1,s=0,u=0,f=n,p=null;e:for(;;){for(var m;f!==t||0!==r&&3!==f.nodeType||(c=v+r),f!==i||0!==o&&3!==f.nodeType||(l=v+o),3===f.nodeType&&(v+=f.nodeValue.length),null!==(m=f.firstChild);)p=f,f=m;for(;;){if(f===n)break e;if(p===t&&++s===r&&(c=v),p===i&&++u===o&&(l=v),null!==(m=f.nextSibling))break;p=(f=p).parentNode}f=m}t=-1===c||-1===l?null:{start:c,end:l}}else t=null}t=t||{start:0,end:0}}else t=null;for(tr={focusedElem:n,selectionRange:t},We=!1,Kv=e;null!==Kv;)if(n=(e=Kv).child,0!==(1028&e.subtreeFlags)&&null!==n)n.return=e,Kv=n;else for(;null!==Kv;){e=Kv;try{var d=e.alternate;if(0!==(1024&e.flags))switch(e.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==d){var h=d.memoizedProps,x=d.memoizedState,y=e.stateNode,g=y.getSnapshotBeforeUpdate(e.elementType===e.type?h:xa(e.type,h),x);y.__reactInternalSnapshotBeforeUpdate=g}break;case 3:var b=e.stateNode.containerInfo;1===b.nodeType?b.textContent="":9===b.nodeType&&b.documentElement&&b.removeChild(b.documentElement);break;default:throw Error(a(163))}}catch(_){Sl(e,e.return,_)}if(null!==(n=e.sibling)){n.return=e.return,Kv=n;break}Kv=e.return}d=ec,ec=!1}(n,t),hc(t,n),mo(tr),We=!!er,tr=er=null,n.current=t,yc(t,n,r),Jn(),Cc=c,be=v,kc.transition=i}else n.current=t;if(Xc&&(Xc=!1,Yc=n,Zc=r),0===(i=n.pendingLanes)&&(Hc=null),function(n){if(ie&&"function"===typeof ie.onCommitFiberRoot)try{ie.onCommitFiberRoot(ae,n,void 0,128===(128&n.current.flags))}catch(e){}}(t.stateNode),ol(n,Kn()),null!==e)for(o=n.onRecoverableError,t=0;t<e.length;t++)o((r=e[t]).value,{componentStack:r.stack,digest:r.digest});if(Vc)throw Vc=!1,n=Wc,Wc=null,n;0!==(1&Zc)&&0!==n.tag&&Ul(),0!==(1&(i=n.pendingLanes))?n===Jc?Qc++:(Qc=0,Jc=n):Qc=0,qr()}(n,e,t,o)}finally{kc.transition=r,be=o}return null}function Ul(){if(null!==Yc){var n=_e(Zc),e=kc.transition,t=be;try{if(kc.transition=null,be=16>n?16:n,null===Yc)var o=!1;else{if(n=Yc,Yc=null,Zc=0,0!==(6&Cc))throw Error(a(331));var r=Cc;for(Cc|=4,Kv=n.current;null!==Kv;){var i=Kv,v=i.child;if(0!==(16&Kv.flags)){var c=i.deletions;if(null!==c){for(var l=0;l<c.length;l++){var s=c[l];for(Kv=s;null!==Kv;){var u=Kv;switch(u.tag){case 0:case 11:case 15:tc(8,u,i)}var f=u.child;if(null!==f)f.return=u,Kv=f;else for(;null!==Kv;){var p=(u=Kv).sibling,m=u.return;if(ac(u),u===s){Kv=null;break}if(null!==p){p.return=m,Kv=p;break}Kv=m}}}var d=i.alternate;if(null!==d){var h=d.child;if(null!==h){d.child=null;do{var x=h.sibling;h.sibling=null,h=x}while(null!==h)}}Kv=i}}if(0!==(2064&i.subtreeFlags)&&null!==v)v.return=i,Kv=v;else n:for(;null!==Kv;){if(0!==(2048&(i=Kv).flags))switch(i.tag){case 0:case 11:case 15:tc(9,i,i.return)}var y=i.sibling;if(null!==y){y.return=i.return,Kv=y;break n}Kv=i.return}}var g=n.current;for(Kv=g;null!==Kv;){var b=(v=Kv).child;if(0!==(2064&v.subtreeFlags)&&null!==b)b.return=v,Kv=b;else n:for(v=g;null!==Kv;){if(0!==(2048&(c=Kv).flags))try{switch(c.tag){case 0:case 11:case 15:oc(9,c)}}catch(U){Sl(c,c.return,U)}if(c===v){Kv=null;break n}var _=c.sibling;if(null!==_){_.return=c.return,Kv=_;break n}Kv=c.return}}if(Cc=r,qr(),ie&&"function"===typeof ie.onPostCommitFiberRoot)try{ie.onPostCommitFiberRoot(ae,n)}catch(U){}o=!0}return o}finally{be=t,kc.transition=e}}return!1}function wl(n,e,t){n=Ia(n,e=mv(0,e=sv(t,e),1),1),e=nl(),null!==n&&(ye(n,1,e),ol(n,e))}function Sl(n,e,t){if(3===n.tag)wl(n,n,t);else for(;null!==e;){if(3===e.tag){wl(e,n,t);break}if(1===e.tag){var o=e.stateNode;if("function"===typeof e.type.getDerivedStateFromError||"function"===typeof o.componentDidCatch&&(null===Hc||!Hc.has(o))){e=Ia(e,n=dv(e,n=sv(t,n),1),1),n=nl(),null!==e&&(ye(e,1,n),ol(e,n));break}}e=e.return}}function Ml(n,e,t){var o=n.pingCache;null!==o&&o.delete(e),e=nl(),n.pingedLanes|=n.suspendedLanes&t,Tc===n&&(Dc&t)===t&&(4===jc||3===jc&&(130023424&Dc)===Dc&&500>Kn()-Nc?fl(n,0):Lc|=t),ol(n,e)}function zl(n,e){0===e&&(0===(1&n.mode)?e=1:(e=ue,0===(130023424&(ue<<=1))&&(ue=4194304)));var t=nl();null!==(n=Ra(n,e))&&(ye(n,e,t),ol(n,t))}function kl(n){var e=n.memoizedState,t=0;null!==e&&(t=e.retryLane),zl(n,t)}function Cl(n,e){var t=0;switch(n.tag){case 13:var o=n.stateNode,r=n.memoizedState;null!==r&&(t=r.retryLane);break;case 19:o=n.stateNode;break;default:throw Error(a(314))}null!==o&&o.delete(e),zl(n,t)}function Tl(n,e){return Yn(n,e)}function Rl(n,e,t,o){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=o,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Dl(n,e,t,o){return new Rl(n,e,t,o)}function Pl(n){return!(!(n=n.prototype)||!n.isReactComponent)}function Fl(n,e){var t=n.alternate;return null===t?((t=Dl(n.tag,e,n.key,n.mode)).elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=14680064&n.flags,t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function jl(n,e,t,o,r,i){var v=2;if(o=n,"function"===typeof n)Pl(n)&&(v=1);else if("string"===typeof n)v=5;else n:switch(n){case w:return Il(t.children,r,i,e);case S:v=8,r|=8;break;case M:return(n=Dl(12,t,e,2|r)).elementType=M,n.lanes=i,n;case T:return(n=Dl(13,t,e,r)).elementType=T,n.lanes=i,n;case R:return(n=Dl(19,t,e,r)).elementType=R,n.lanes=i,n;case F:return El(t,r,i,e);default:if("object"===typeof n&&null!==n)switch(n.$$typeof){case z:v=10;break n;case k:v=9;break n;case C:v=11;break n;case D:v=14;break n;case P:v=16,o=null;break n}throw Error(a(130,null==n?n:typeof n,""))}return(e=Dl(v,t,e,r)).elementType=n,e.type=o,e.lanes=i,e}function Il(n,e,t,o){return(n=Dl(7,n,o,e)).lanes=t,n}function El(n,e,t,o){return(n=Dl(22,n,o,e)).elementType=F,n.lanes=t,n.stateNode={isHidden:!1},n}function Ol(n,e,t){return(n=Dl(6,n,null,e)).lanes=t,n}function Ll(n,e,t){return(e=Dl(4,null!==n.children?n.children:[],n.key,e)).lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function Al(n,e,t,o,r){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=xe(0),this.expirationTimes=xe(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=xe(0),this.identifierPrefix=o,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function Gl(n,e,t,o,r,a,i,v,c){return n=new Al(n,e,t,v,c),1===e?(e=1,!0===a&&(e|=8)):e=0,a=Dl(3,null,null,e),n.current=a,a.stateNode=n,a.memoizedState={element:o,isDehydrated:t,cache:null,transitions:null,pendingSuspenseBoundaries:null},Pa(a),n}function Nl(n,e,t){var o=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:U,key:null==o?null:""+o,children:n,containerInfo:e,implementation:t}}function Bl(n){if(!n)return Cr;n:{if(qn(n=n._reactInternals)!==n||1!==n.tag)throw Error(a(170));var e=n;do{switch(e.tag){case 3:e=e.stateNode.context;break n;case 1:if(Fr(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break n}}e=e.return}while(null!==e);throw Error(a(171))}if(1===n.tag){var t=n.type;if(Fr(t))return Er(n,t,e)}return e}function ql(n,e,t,o,r,a,i,v,c){return(n=Gl(t,o,!0,n,0,a,0,v,c)).context=Bl(null),t=n.current,(a=ja(o=nl(),r=el(t))).callback=void 0!==e&&null!==e?e:null,Ia(t,a,r),n.current.lanes=r,ye(n,r,o),ol(n,o),n}function Vl(n,e,t,o){var r=e.current,a=nl(),i=el(r);return t=Bl(t),null===e.context?e.context=t:e.pendingContext=t,(e=ja(a,i)).payload={element:n},null!==(o=void 0===o?null:o)&&(e.callback=o),null!==(n=Ia(r,e,i))&&(tl(n,r,i,a),Ea(n,r,i)),i}function Wl(n){return(n=n.current).child?(n.child.tag,n.child.stateNode):null}function Hl(n,e){if(null!==(n=n.memoizedState)&&null!==n.dehydrated){var t=n.retryLane;n.retryLane=0!==t&&t<e?t:e}}function Xl(n,e){Hl(n,e),(n=n.alternate)&&Hl(n,e)}wc=function(n,e,t){if(null!==n)if(n.memoizedProps!==e.pendingProps||Rr.current)bv=!0;else{if(0===(n.lanes&t)&&0===(128&e.flags))return bv=!1,function(n,e,t){switch(e.tag){case 3:Rv(e),ma();break;case 5:ii(e);break;case 1:Fr(e.type)&&Or(e);break;case 4:ri(e,e.stateNode.containerInfo);break;case 10:var o=e.type._context,r=e.memoizedProps.value;kr(ya,o._currentValue),o._currentValue=r;break;case 13:if(null!==(o=e.memoizedState))return null!==o.dehydrated?(kr(ci,1&ci.current),e.flags|=128,null):0!==(t&e.child.childLanes)?Ov(n,e,t):(kr(ci,1&ci.current),null!==(n=Vv(n,e,t))?n.sibling:null);kr(ci,1&ci.current);break;case 19:if(o=0!==(t&e.childLanes),0!==(128&n.flags)){if(o)return Bv(n,e,t);e.flags|=128}if(null!==(r=e.memoizedState)&&(r.rendering=null,r.tail=null,r.lastEffect=null),kr(ci,ci.current),o)break;return null;case 22:case 23:return e.lanes=0,Mv(n,e,t)}return Vv(n,e,t)}(n,e,t);bv=0!==(131072&n.flags)}else bv=!1,aa&&0!==(1048576&e.flags)&&na(e,Xr,e.index);switch(e.lanes=0,e.tag){case 2:var o=e.type;qv(n,e),n=e.pendingProps;var r=Pr(e,Tr.current);Ma(e,t),r=Si(null,e,o,n,r,t);var i=Mi();return e.flags|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Fr(o)?(i=!0,Or(e)):i=!1,e.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,Pa(e),r.updater=Ba,e.stateNode=r,r._reactInternals=e,Ha(e,o,n,t),e=Tv(null,e,o,!0,i,t)):(e.tag=0,aa&&i&&ea(e),_v(null,e,r,t),e=e.child),e;case 16:o=e.elementType;n:{switch(qv(n,e),n=e.pendingProps,o=(r=o._init)(o._payload),e.type=o,r=e.tag=function(n){if("function"===typeof n)return Pl(n)?1:0;if(void 0!==n&&null!==n){if((n=n.$$typeof)===C)return 11;if(n===D)return 14}return 2}(o),n=xa(o,n),r){case 0:e=kv(null,e,o,n,t);break n;case 1:e=Cv(null,e,o,n,t);break n;case 11:e=Uv(null,e,o,n,t);break n;case 14:e=wv(null,e,o,xa(o.type,n),t);break n}throw Error(a(306,o,""))}return e;case 0:return o=e.type,r=e.pendingProps,kv(n,e,o,r=e.elementType===o?r:xa(o,r),t);case 1:return o=e.type,r=e.pendingProps,Cv(n,e,o,r=e.elementType===o?r:xa(o,r),t);case 3:n:{if(Rv(e),null===n)throw Error(a(387));o=e.pendingProps,r=(i=e.memoizedState).element,Fa(n,e),La(e,o,null,t);var v=e.memoizedState;if(o=v.element,i.isDehydrated){if(i={element:o,isDehydrated:!1,cache:v.cache,pendingSuspenseBoundaries:v.pendingSuspenseBoundaries,transitions:v.transitions},e.updateQueue.baseState=i,e.memoizedState=i,256&e.flags){e=Dv(n,e,o,t,r=sv(Error(a(423)),e));break n}if(o!==r){e=Dv(n,e,o,t,r=sv(Error(a(424)),e));break n}for(ra=sr(e.stateNode.containerInfo.firstChild),oa=e,aa=!0,ia=null,t=Ka(e,null,o,t),e.child=t;t;)t.flags=-3&t.flags|4096,t=t.sibling}else{if(ma(),o===r){e=Vv(n,e,t);break n}_v(n,e,o,t)}e=e.child}return e;case 5:return ii(e),null===n&&sa(e),o=e.type,r=e.pendingProps,i=null!==n?n.memoizedProps:null,v=r.children,or(o,r)?v=null:null!==i&&or(o,i)&&(e.flags|=32),zv(n,e),_v(n,e,v,t),e.child;case 6:return null===n&&sa(e),null;case 13:return Ov(n,e,t);case 4:return ri(e,e.stateNode.containerInfo),o=e.pendingProps,null===n?e.child=Ja(e,null,o,t):_v(n,e,o,t),e.child;case 11:return o=e.type,r=e.pendingProps,Uv(n,e,o,r=e.elementType===o?r:xa(o,r),t);case 7:return _v(n,e,e.pendingProps,t),e.child;case 8:case 12:return _v(n,e,e.pendingProps.children,t),e.child;case 10:n:{if(o=e.type._context,r=e.pendingProps,i=e.memoizedProps,v=r.value,kr(ya,o._currentValue),o._currentValue=v,null!==i)if(vo(i.value,v)){if(i.children===r.children&&!Rr.current){e=Vv(n,e,t);break n}}else for(null!==(i=e.child)&&(i.return=e);null!==i;){var c=i.dependencies;if(null!==c){v=i.child;for(var l=c.firstContext;null!==l;){if(l.context===o){if(1===i.tag){(l=ja(-1,t&-t)).tag=2;var s=i.updateQueue;if(null!==s){var u=(s=s.shared).pending;null===u?l.next=l:(l.next=u.next,u.next=l),s.pending=l}}i.lanes|=t,null!==(l=i.alternate)&&(l.lanes|=t),Sa(i.return,t,e),c.lanes|=t;break}l=l.next}}else if(10===i.tag)v=i.type===e.type?null:i.child;else if(18===i.tag){if(null===(v=i.return))throw Error(a(341));v.lanes|=t,null!==(c=v.alternate)&&(c.lanes|=t),Sa(v,t,e),v=i.sibling}else v=i.child;if(null!==v)v.return=i;else for(v=i;null!==v;){if(v===e){v=null;break}if(null!==(i=v.sibling)){i.return=v.return,v=i;break}v=v.return}i=v}_v(n,e,r.children,t),e=e.child}return e;case 9:return r=e.type,o=e.pendingProps.children,Ma(e,t),o=o(r=za(r)),e.flags|=1,_v(n,e,o,t),e.child;case 14:return r=xa(o=e.type,e.pendingProps),wv(n,e,o,r=xa(o.type,r),t);case 15:return Sv(n,e,e.type,e.pendingProps,t);case 17:return o=e.type,r=e.pendingProps,r=e.elementType===o?r:xa(o,r),qv(n,e),e.tag=1,Fr(o)?(n=!0,Or(e)):n=!1,Ma(e,t),Va(e,o,r),Ha(e,o,r,t),Tv(null,e,o,!0,n,t);case 19:return Bv(n,e,t);case 22:return Mv(n,e,t)}throw Error(a(156,e.tag))};var Yl="function"===typeof reportError?reportError:function(n){console.error(n)};function Zl(n){this._internalRoot=n}function Ql(n){this._internalRoot=n}function Jl(n){return!(!n||1!==n.nodeType&&9!==n.nodeType&&11!==n.nodeType)}function Kl(n){return!(!n||1!==n.nodeType&&9!==n.nodeType&&11!==n.nodeType&&(8!==n.nodeType||" react-mount-point-unstable "!==n.nodeValue))}function $l(){}function ns(n,e,t,o,r){var a=t._reactRootContainer;if(a){var i=a;if("function"===typeof r){var v=r;r=function(){var n=Wl(i);v.call(n)}}Vl(e,i,n,r)}else i=function(n,e,t,o,r){if(r){if("function"===typeof o){var a=o;o=function(){var n=Wl(i);a.call(n)}}var i=ql(e,o,n,0,null,!1,0,"",$l);return n._reactRootContainer=i,n[dr]=i.current,qo(8===n.nodeType?n.parentNode:n),sl(),i}for(;r=n.lastChild;)n.removeChild(r);if("function"===typeof o){var v=o;o=function(){var n=Wl(c);v.call(n)}}var c=Gl(n,0,!1,null,0,!1,0,"",$l);return n._reactRootContainer=c,n[dr]=c.current,qo(8===n.nodeType?n.parentNode:n),sl((function(){Vl(e,c,t,o)})),c}(t,e,n,r,o);return Wl(i)}Ql.prototype.render=Zl.prototype.render=function(n){var e=this._internalRoot;if(null===e)throw Error(a(409));Vl(n,e,null,null)},Ql.prototype.unmount=Zl.prototype.unmount=function(){var n=this._internalRoot;if(null!==n){this._internalRoot=null;var e=n.containerInfo;sl((function(){Vl(null,n,null,null)})),e[dr]=null}},Ql.prototype.unstable_scheduleHydration=function(n){if(n){var e=Me();n={blockedOn:null,target:n,priority:e};for(var t=0;t<je.length&&0!==e&&e<je[t].priority;t++);je.splice(t,0,n),0===t&&Le(n)}},Ue=function(n){switch(n.tag){case 3:var e=n.stateNode;if(e.current.memoizedState.isDehydrated){var t=fe(e.pendingLanes);0!==t&&(ge(e,1|t),ol(e,Kn()),0===(6&Cc)&&(Bc=Kn()+500,qr()))}break;case 13:sl((function(){var e=Ra(n,1);if(null!==e){var t=nl();tl(e,n,1,t)}})),Xl(n,1)}},we=function(n){if(13===n.tag){var e=Ra(n,134217728);if(null!==e)tl(e,n,134217728,nl());Xl(n,134217728)}},Se=function(n){if(13===n.tag){var e=el(n),t=Ra(n,e);if(null!==t)tl(t,n,e,nl());Xl(n,e)}},Me=function(){return be},ze=function(n,e){var t=be;try{return be=n,e()}finally{be=t}},wn=function(n,e,t){switch(e){case"input":if(K(n,t),e=t.name,"radio"===t.type&&null!=e){for(t=n;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<t.length;e++){var o=t[e];if(o!==n&&o.form===n.form){var r=Ur(o);if(!r)throw Error(a(90));X(o),K(o,r)}}}break;case"textarea":an(n,t);break;case"select":null!=(e=t.value)&&tn(n,!!t.multiple,e,!1)}},Tn=ll,Rn=sl;var es={usingClientEntryPoint:!1,Events:[br,_r,Ur,kn,Cn,ll]},ts={findFiberByHostInstance:gr,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},os={bundleType:ts.bundleType,version:ts.version,rendererPackageName:ts.rendererPackageName,rendererConfig:ts.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:b.ReactCurrentDispatcher,findHostInstanceByFiber:function(n){return null===(n=Hn(n))?null:n.stateNode},findFiberByHostInstance:ts.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var rs=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rs.isDisabled&&rs.supportsFiber)try{ae=rs.inject(os),ie=rs}catch(un){}}e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=es,e.createPortal=function(n,e){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Jl(e))throw Error(a(200));return Nl(n,e,null,t)},e.createRoot=function(n,e){if(!Jl(n))throw Error(a(299));var t=!1,o="",r=Yl;return null!==e&&void 0!==e&&(!0===e.unstable_strictMode&&(t=!0),void 0!==e.identifierPrefix&&(o=e.identifierPrefix),void 0!==e.onRecoverableError&&(r=e.onRecoverableError)),e=Gl(n,1,!1,null,0,t,0,o,r),n[dr]=e.current,qo(8===n.nodeType?n.parentNode:n),new Zl(e)},e.findDOMNode=function(n){if(null==n)return null;if(1===n.nodeType)return n;var e=n._reactInternals;if(void 0===e){if("function"===typeof n.render)throw Error(a(188));throw n=Object.keys(n).join(","),Error(a(268,n))}return n=null===(n=Hn(e))?null:n.stateNode},e.flushSync=function(n){return sl(n)},e.hydrate=function(n,e,t){if(!Kl(e))throw Error(a(200));return ns(null,n,e,!0,t)},e.hydrateRoot=function(n,e,t){if(!Jl(n))throw Error(a(405));var o=null!=t&&t.hydratedSources||null,r=!1,i="",v=Yl;if(null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(r=!0),void 0!==t.identifierPrefix&&(i=t.identifierPrefix),void 0!==t.onRecoverableError&&(v=t.onRecoverableError)),e=ql(e,null,n,1,null!=t?t:null,r,0,i,v),n[dr]=e.current,qo(n),o)for(n=0;n<o.length;n++)r=(r=(t=o[n])._getVersion)(t._source),null==e.mutableSourceEagerHydrationData?e.mutableSourceEagerHydrationData=[t,r]:e.mutableSourceEagerHydrationData.push(t,r);return new Ql(e)},e.render=function(n,e,t){if(!Kl(e))throw Error(a(200));return ns(null,n,e,!1,t)},e.unmountComponentAtNode=function(n){if(!Kl(n))throw Error(a(40));return!!n._reactRootContainer&&(sl((function(){ns(null,null,n,!1,(function(){n._reactRootContainer=null,n[dr]=null}))})),!0)},e.unstable_batchedUpdates=ll,e.unstable_renderSubtreeIntoContainer=function(n,e,t,o){if(!Kl(t))throw Error(a(200));if(null==n||void 0===n._reactInternals)throw Error(a(38));return ns(n,e,t,!1,o)},e.version="18.2.0-next-9e3b772b8-20220608"},250:function(n,e,t){"use strict";var o=t(164);e.s=o.createRoot,o.hydrateRoot},164:function(n,e,t){"use strict";!function n(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}(),n.exports=t(463)},976:function(n,e){"use strict";e.ConcurrentRoot=1,e.ContinuousEventPriority=4,e.DefaultEventPriority=16,e.DiscreteEventPriority=1},721:function(n,e,t){n.exports=function(n){var e={},o=t(791),r=t(100),a=Object.assign;function i(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var v=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,c=Symbol.for("react.element"),l=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),u=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),p=Symbol.for("react.provider"),m=Symbol.for("react.context"),d=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),x=Symbol.for("react.suspense_list"),y=Symbol.for("react.memo"),g=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var b=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var _=Symbol.iterator;function U(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=_&&n[_]||n["@@iterator"])?n:null}function w(n){if(null==n)return null;if("function"===typeof n)return n.displayName||n.name||null;if("string"===typeof n)return n;switch(n){case s:return"Fragment";case l:return"Portal";case f:return"Profiler";case u:return"StrictMode";case h:return"Suspense";case x:return"SuspenseList"}if("object"===typeof n)switch(n.$$typeof){case m:return(n.displayName||"Context")+".Consumer";case p:return(n._context.displayName||"Context")+".Provider";case d:var e=n.render;return(n=n.displayName)||(n=""!==(n=e.displayName||e.name||"")?"ForwardRef("+n+")":"ForwardRef"),n;case y:return null!==(e=n.displayName||null)?e:w(n.type)||"Memo";case g:e=n._payload,n=n._init;try{return w(n(e))}catch(t){}}return null}function S(n){var e=n.type;switch(n.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return n=(n=e.render).displayName||n.name||"",e.displayName||(""!==n?"ForwardRef("+n+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return w(e);case 8:return e===u?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e}return null}function M(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do{0!==(4098&(e=n).flags)&&(t=e.return),n=e.return}while(n)}return 3===e.tag?t:null}function z(n){if(M(n)!==n)throw Error(i(188))}function k(n){var e=n.alternate;if(!e){if(null===(e=M(n)))throw Error(i(188));return e!==n?null:n}for(var t=n,o=e;;){var r=t.return;if(null===r)break;var a=r.alternate;if(null===a){if(null!==(o=r.return)){t=o;continue}break}if(r.child===a.child){for(a=r.child;a;){if(a===t)return z(r),n;if(a===o)return z(r),e;a=a.sibling}throw Error(i(188))}if(t.return!==o.return)t=r,o=a;else{for(var v=!1,c=r.child;c;){if(c===t){v=!0,t=r,o=a;break}if(c===o){v=!0,o=r,t=a;break}c=c.sibling}if(!v){for(c=a.child;c;){if(c===t){v=!0,t=a,o=r;break}if(c===o){v=!0,o=a,t=r;break}c=c.sibling}if(!v)throw Error(i(189))}}if(t.alternate!==o)throw Error(i(190))}if(3!==t.tag)throw Error(i(188));return t.stateNode.current===t?n:e}function C(n){return null!==(n=k(n))?T(n):null}function T(n){if(5===n.tag||6===n.tag)return n;for(n=n.child;null!==n;){var e=T(n);if(null!==e)return e;n=n.sibling}return null}function R(n){if(5===n.tag||6===n.tag)return n;for(n=n.child;null!==n;){if(4!==n.tag){var e=R(n);if(null!==e)return e}n=n.sibling}return null}var D,P=Array.isArray,F=n.getPublicInstance,j=n.getRootHostContext,I=n.getChildHostContext,E=n.prepareForCommit,O=n.resetAfterCommit,L=n.createInstance,A=n.appendInitialChild,G=n.finalizeInitialChildren,N=n.prepareUpdate,B=n.shouldSetTextContent,q=n.createTextInstance,V=n.scheduleTimeout,W=n.cancelTimeout,H=n.noTimeout,X=n.isPrimaryRenderer,Y=n.supportsMutation,Z=n.supportsPersistence,Q=n.supportsHydration,J=n.getInstanceFromNode,K=n.preparePortalMount,$=n.getCurrentEventPriority,nn=n.detachDeletedInstance,en=n.supportsMicrotasks,tn=n.scheduleMicrotask,on=n.supportsTestSelectors,rn=n.findFiberRoot,an=n.getBoundingRect,vn=n.getTextContent,cn=n.isHiddenSubtree,ln=n.matchAccessibilityRole,sn=n.setFocusIfFocusable,un=n.setupIntersectionObserver,fn=n.appendChild,pn=n.appendChildToContainer,mn=n.commitTextUpdate,dn=n.commitMount,hn=n.commitUpdate,xn=n.insertBefore,yn=n.insertInContainerBefore,gn=n.removeChild,bn=n.removeChildFromContainer,_n=n.resetTextContent,Un=n.hideInstance,wn=n.hideTextInstance,Sn=n.unhideInstance,Mn=n.unhideTextInstance,zn=n.clearContainer,kn=n.cloneInstance,Cn=n.createContainerChildSet,Tn=n.appendChildToContainerChildSet,Rn=n.finalizeContainerChildren,Dn=n.replaceContainerChildren,Pn=n.cloneHiddenInstance,Fn=n.cloneHiddenTextInstance,jn=n.canHydrateInstance,In=n.canHydrateTextInstance,En=n.canHydrateSuspenseInstance,On=n.isSuspenseInstancePending,Ln=n.isSuspenseInstanceFallback,An=n.registerSuspenseInstanceRetry,Gn=n.getNextHydratableSibling,Nn=n.getFirstHydratableChild,Bn=n.getFirstHydratableChildWithinContainer,qn=n.getFirstHydratableChildWithinSuspenseInstance,Vn=n.hydrateInstance,Wn=n.hydrateTextInstance,Hn=n.hydrateSuspenseInstance,Xn=n.getNextHydratableInstanceAfterSuspenseInstance,Yn=n.commitHydratedContainer,Zn=n.commitHydratedSuspenseInstance,Qn=n.clearSuspenseBoundary,Jn=n.clearSuspenseBoundaryFromContainer,Kn=n.shouldDeleteUnhydratedTailInstances,$n=n.didNotMatchHydratedContainerTextInstance,ne=n.didNotMatchHydratedTextInstance;function ee(n){if(void 0===D)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);D=e&&e[1]||""}return"\n"+D+n}var te=!1;function oe(n,e){if(!n||te)return"";te=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(l){var o=l}Reflect.construct(n,[],e)}else{try{e.call()}catch(l){o=l}n.call(e.prototype)}else{try{throw Error()}catch(l){o=l}n()}}catch(l){if(l&&o&&"string"===typeof l.stack){for(var r=l.stack.split("\n"),a=o.stack.split("\n"),i=r.length-1,v=a.length-1;1<=i&&0<=v&&r[i]!==a[v];)v--;for(;1<=i&&0<=v;i--,v--)if(r[i]!==a[v]){if(1!==i||1!==v)do{if(i--,0>--v||r[i]!==a[v]){var c="\n"+r[i].replace(" at new "," at ");return n.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",n.displayName)),c}}while(1<=i&&0<=v);break}}}finally{te=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?ee(n):""}var re=Object.prototype.hasOwnProperty,ae=[],ie=-1;function ve(n){return{current:n}}function ce(n){0>ie||(n.current=ae[ie],ae[ie]=null,ie--)}function le(n,e){ie++,ae[ie]=n.current,n.current=e}var se={},ue=ve(se),fe=ve(!1),pe=se;function me(n,e){var t=n.type.contextTypes;if(!t)return se;var o=n.stateNode;if(o&&o.__reactInternalMemoizedUnmaskedChildContext===e)return o.__reactInternalMemoizedMaskedChildContext;var r,a={};for(r in t)a[r]=e[r];return o&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=a),a}function de(n){return null!==(n=n.childContextTypes)&&void 0!==n}function he(){ce(fe),ce(ue)}function xe(n,e,t){if(ue.current!==se)throw Error(i(168));le(ue,e),le(fe,t)}function ye(n,e,t){var o=n.stateNode;if(e=e.childContextTypes,"function"!==typeof o.getChildContext)return t;for(var r in o=o.getChildContext())if(!(r in e))throw Error(i(108,S(n)||"Unknown",r));return a({},t,o)}function ge(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||se,pe=ue.current,le(ue,n),le(fe,fe.current),!0}function be(n,e,t){var o=n.stateNode;if(!o)throw Error(i(169));t?(n=ye(n,e,pe),o.__reactInternalMemoizedMergedChildContext=n,ce(fe),ce(ue),le(ue,n)):ce(fe),le(fe,t)}var _e=Math.clz32?Math.clz32:function(n){return 0===(n>>>=0)?32:31-(Ue(n)/we|0)|0},Ue=Math.log,we=Math.LN2;var Se=64,Me=4194304;function ze(n){switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&n;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&n;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return n}}function ke(n,e){var t=n.pendingLanes;if(0===t)return 0;var o=0,r=n.suspendedLanes,a=n.pingedLanes,i=268435455&t;if(0!==i){var v=i&~r;0!==v?o=ze(v):0!==(a&=i)&&(o=ze(a))}else 0!==(i=t&~r)?o=ze(i):0!==a&&(o=ze(a));if(0===o)return 0;if(0!==e&&e!==o&&0===(e&r)&&((r=o&-o)>=(a=e&-e)||16===r&&0!==(4194240&a)))return e;if(0!==(4&o)&&(o|=16&t),0!==(e=n.entangledLanes))for(n=n.entanglements,e&=o;0<e;)r=1<<(t=31-_e(e)),o|=n[t],e&=~r;return o}function Ce(n,e){switch(n){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function Te(n){return 0!==(n=-1073741825&n.pendingLanes)?n:1073741824&n?1073741824:0}function Re(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function De(n,e,t){n.pendingLanes|=e,536870912!==e&&(n.suspendedLanes=0,n.pingedLanes=0),(n=n.eventTimes)[e=31-_e(e)]=t}function Pe(n,e){var t=n.entangledLanes|=e;for(n=n.entanglements;t;){var o=31-_e(t),r=1<<o;r&e|n[o]&e&&(n[o]|=e),t&=~r}}var Fe=0;function je(n){return 1<(n&=-n)?4<n?0!==(268435455&n)?16:536870912:4:1}var Ie=r.unstable_scheduleCallback,Ee=r.unstable_cancelCallback,Oe=r.unstable_shouldYield,Le=r.unstable_requestPaint,Ae=r.unstable_now,Ge=r.unstable_ImmediatePriority,Ne=r.unstable_UserBlockingPriority,Be=r.unstable_NormalPriority,qe=r.unstable_IdlePriority,Ve=null,We=null;var He="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},Xe=null,Ye=!1,Ze=!1;function Qe(n){null===Xe?Xe=[n]:Xe.push(n)}function Je(){if(!Ze&&null!==Xe){Ze=!0;var n=0,e=Fe;try{var t=Xe;for(Fe=1;n<t.length;n++){var o=t[n];do{o=o(!0)}while(null!==o)}Xe=null,Ye=!1}catch(r){throw null!==Xe&&(Xe=Xe.slice(n+1)),Ie(Ge,Je),r}finally{Fe=e,Ze=!1}}return null}var Ke=v.ReactCurrentBatchConfig;function $e(n,e){if(He(n,e))return!0;if("object"!==typeof n||null===n||"object"!==typeof e||null===e)return!1;var t=Object.keys(n),o=Object.keys(e);if(t.length!==o.length)return!1;for(o=0;o<t.length;o++){var r=t[o];if(!re.call(e,r)||!He(n[r],e[r]))return!1}return!0}function nt(n){switch(n.tag){case 5:return ee(n.type);case 16:return ee("Lazy");case 13:return ee("Suspense");case 19:return ee("SuspenseList");case 0:case 2:case 15:return n=oe(n.type,!1);case 11:return n=oe(n.type.render,!1);case 1:return n=oe(n.type,!0);default:return""}}function et(n,e){if(n&&n.defaultProps){for(var t in e=a({},e),n=n.defaultProps)void 0===e[t]&&(e[t]=n[t]);return e}return e}var tt=ve(null),ot=null,rt=null,at=null;function it(){at=rt=ot=null}function vt(n,e,t){X?(le(tt,e._currentValue),e._currentValue=t):(le(tt,e._currentValue2),e._currentValue2=t)}function ct(n){var e=tt.current;ce(tt),X?n._currentValue=e:n._currentValue2=e}function lt(n,e,t){for(;null!==n;){var o=n.alternate;if((n.childLanes&e)!==e?(n.childLanes|=e,null!==o&&(o.childLanes|=e)):null!==o&&(o.childLanes&e)!==e&&(o.childLanes|=e),n===t)break;n=n.return}}function st(n,e){ot=n,at=rt=null,null!==(n=n.dependencies)&&null!==n.firstContext&&(0!==(n.lanes&e)&&(Or=!0),n.firstContext=null)}function ut(n){var e=X?n._currentValue:n._currentValue2;if(at!==n)if(n={context:n,memoizedValue:e,next:null},null===rt){if(null===ot)throw Error(i(308));rt=n,ot.dependencies={lanes:0,firstContext:n}}else rt=rt.next=n;return e}var ft=null,pt=!1;function mt(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function dt(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function ht(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function xt(n,e){var t=n.updateQueue;null!==t&&(t=t.shared,null!==Za&&0!==(1&n.mode)&&0===(2&Ya)?(null===(n=t.interleaved)?(e.next=e,null===ft?ft=[t]:ft.push(t)):(e.next=n.next,n.next=e),t.interleaved=e):(null===(n=t.pending)?e.next=e:(e.next=n.next,n.next=e),t.pending=e))}function yt(n,e,t){if(null!==(e=e.updateQueue)&&(e=e.shared,0!==(4194240&t))){var o=e.lanes;t|=o&=n.pendingLanes,e.lanes=t,Pe(n,t)}}function gt(n,e){var t=n.updateQueue,o=n.alternate;if(null!==o&&t===(o=o.updateQueue)){var r=null,a=null;if(null!==(t=t.firstBaseUpdate)){do{var i={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===a?r=a=i:a=a.next=i,t=t.next}while(null!==t);null===a?r=a=e:a=a.next=e}else r=a=e;return t={baseState:o.baseState,firstBaseUpdate:r,lastBaseUpdate:a,shared:o.shared,effects:o.effects},void(n.updateQueue=t)}null===(n=t.lastBaseUpdate)?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function bt(n,e,t,o){var r=n.updateQueue;pt=!1;var i=r.firstBaseUpdate,v=r.lastBaseUpdate,c=r.shared.pending;if(null!==c){r.shared.pending=null;var l=c,s=l.next;l.next=null,null===v?i=s:v.next=s,v=l;var u=n.alternate;null!==u&&((c=(u=u.updateQueue).lastBaseUpdate)!==v&&(null===c?u.firstBaseUpdate=s:c.next=s,u.lastBaseUpdate=l))}if(null!==i){var f=r.baseState;for(v=0,u=s=l=null,c=i;;){var p=c.lane,m=c.eventTime;if((o&p)===p){null!==u&&(u=u.next={eventTime:m,lane:0,tag:c.tag,payload:c.payload,callback:c.callback,next:null});n:{var d=n,h=c;switch(p=e,m=t,h.tag){case 1:if("function"===typeof(d=h.payload)){f=d.call(m,f,p);break n}f=d;break n;case 3:d.flags=-65537&d.flags|128;case 0:if(null===(p="function"===typeof(d=h.payload)?d.call(m,f,p):d)||void 0===p)break n;f=a({},f,p);break n;case 2:pt=!0}}null!==c.callback&&0!==c.lane&&(n.flags|=64,null===(p=r.effects)?r.effects=[c]:p.push(c))}else m={eventTime:m,lane:p,tag:c.tag,payload:c.payload,callback:c.callback,next:null},null===u?(s=u=m,l=f):u=u.next=m,v|=p;if(null===(c=c.next)){if(null===(c=r.shared.pending))break;c=(p=c).next,p.next=null,r.lastBaseUpdate=p,r.shared.pending=null}}if(null===u&&(l=f),r.baseState=l,r.firstBaseUpdate=s,r.lastBaseUpdate=u,null!==(e=r.shared.interleaved)){r=e;do{v|=r.lane,r=r.next}while(r!==e)}else null===i&&(r.shared.lanes=0);ti|=v,n.lanes=v,n.memoizedState=f}}function _t(n,e,t){if(n=e.effects,e.effects=null,null!==n)for(e=0;e<n.length;e++){var o=n[e],r=o.callback;if(null!==r){if(o.callback=null,o=t,"function"!==typeof r)throw Error(i(191,r));r.call(o)}}}var Ut=(new o.Component).refs;function wt(n,e,t,o){t=null===(t=t(o,e=n.memoizedState))||void 0===t?e:a({},e,t),n.memoizedState=t,0===n.lanes&&(n.updateQueue.baseState=t)}var St={isMounted:function(n){return!!(n=n._reactInternals)&&M(n)===n},enqueueSetState:function(n,e,t){n=n._reactInternals;var o=_i(),r=Ui(n),a=ht(o,r);a.payload=e,void 0!==t&&null!==t&&(a.callback=t),xt(n,a),null!==(e=wi(n,r,o))&&yt(e,n,r)},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var o=_i(),r=Ui(n),a=ht(o,r);a.tag=1,a.payload=e,void 0!==t&&null!==t&&(a.callback=t),xt(n,a),null!==(e=wi(n,r,o))&&yt(e,n,r)},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=_i(),o=Ui(n),r=ht(t,o);r.tag=2,void 0!==e&&null!==e&&(r.callback=e),xt(n,r),null!==(e=wi(n,o,t))&&yt(e,n,o)}};function Mt(n,e,t,o,r,a,i){return"function"===typeof(n=n.stateNode).shouldComponentUpdate?n.shouldComponentUpdate(o,a,i):!e.prototype||!e.prototype.isPureReactComponent||(!$e(t,o)||!$e(r,a))}function zt(n,e,t){var o=!1,r=se,a=e.contextType;return"object"===typeof a&&null!==a?a=ut(a):(r=de(e)?pe:ue.current,a=(o=null!==(o=e.contextTypes)&&void 0!==o)?me(n,r):se),e=new e(t,a),n.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=St,n.stateNode=e,e._reactInternals=n,o&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,n.__reactInternalMemoizedMaskedChildContext=a),e}function kt(n,e,t,o){n=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(t,o),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(t,o),e.state!==n&&St.enqueueReplaceState(e,e.state,null)}function Ct(n,e,t,o){var r=n.stateNode;r.props=t,r.state=n.memoizedState,r.refs=Ut,mt(n);var a=e.contextType;"object"===typeof a&&null!==a?r.context=ut(a):(a=de(e)?pe:ue.current,r.context=me(n,a)),r.state=n.memoizedState,"function"===typeof(a=e.getDerivedStateFromProps)&&(wt(n,e,a,t),r.state=n.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(e=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),e!==r.state&&St.enqueueReplaceState(r,r.state,null),bt(n,t,r,o),r.state=n.memoizedState),"function"===typeof r.componentDidMount&&(n.flags|=4194308)}var Tt=[],Rt=0,Dt=null,Pt=0,Ft=[],jt=0,It=null,Et=1,Ot="";function Lt(n,e){Tt[Rt++]=Pt,Tt[Rt++]=Dt,Dt=n,Pt=e}function At(n,e,t){Ft[jt++]=Et,Ft[jt++]=Ot,Ft[jt++]=It,It=n;var o=Et;n=Ot;var r=32-_e(o)-1;o&=~(1<<r),t+=1;var a=32-_e(e)+r;if(30<a){var i=r-r%5;a=(o&(1<<i)-1).toString(32),o>>=i,r-=i,Et=1<<32-_e(e)+r|t<<r|o,Ot=a+n}else Et=1<<a|t<<r|o,Ot=n}function Gt(n){null!==n.return&&(Lt(n,1),At(n,1,0))}function Nt(n){for(;n===Dt;)Dt=Tt[--Rt],Tt[Rt]=null,Pt=Tt[--Rt],Tt[Rt]=null;for(;n===It;)It=Ft[--jt],Ft[jt]=null,Ot=Ft[--jt],Ft[jt]=null,Et=Ft[--jt],Ft[jt]=null}var Bt=null,qt=null,Vt=!1,Wt=!1,Ht=null;function Xt(n,e){var t=Ki(5,null,null,0);t.elementType="DELETED",t.stateNode=e,t.return=n,null===(e=n.deletions)?(n.deletions=[t],n.flags|=16):e.push(t)}function Yt(n,e){switch(n.tag){case 5:return null!==(e=jn(e,n.type,n.pendingProps))&&(n.stateNode=e,Bt=n,qt=Nn(e),!0);case 6:return null!==(e=In(e,n.pendingProps))&&(n.stateNode=e,Bt=n,qt=null,!0);case 13:if(null!==(e=En(e))){var t=null!==It?{id:Et,overflow:Ot}:null;return n.memoizedState={dehydrated:e,treeContext:t,retryLane:1073741824},(t=Ki(18,null,null,0)).stateNode=e,t.return=n,n.child=t,Bt=n,qt=null,!0}return!1;default:return!1}}function Zt(n){return 0!==(1&n.mode)&&0===(128&n.flags)}function Qt(n){if(Vt){var e=qt;if(e){var t=e;if(!Yt(n,e)){if(Zt(n))throw Error(i(418));e=Gn(t);var o=Bt;e&&Yt(n,e)?Xt(o,t):(n.flags=-4097&n.flags|2,Vt=!1,Bt=n)}}else{if(Zt(n))throw Error(i(418));n.flags=-4097&n.flags|2,Vt=!1,Bt=n}}}function Jt(n){for(n=n.return;null!==n&&5!==n.tag&&3!==n.tag&&13!==n.tag;)n=n.return;Bt=n}function Kt(n){if(!Q||n!==Bt)return!1;if(!Vt)return Jt(n),Vt=!0,!1;if(3!==n.tag&&(5!==n.tag||Kn(n.type)&&!B(n.type,n.memoizedProps))){var e=qt;if(e){if(Zt(n)){for(n=qt;n;)n=Gn(n);throw Error(i(418))}for(;e;)Xt(n,e),e=Gn(e)}}if(Jt(n),13===n.tag){if(!Q)throw Error(i(316));if(!(n=null!==(n=n.memoizedState)?n.dehydrated:null))throw Error(i(317));qt=Xn(n)}else qt=Bt?Gn(n.stateNode):null;return!0}function $t(){Q&&(qt=Bt=null,Wt=Vt=!1)}function no(n){null===Ht?Ht=[n]:Ht.push(n)}function eo(n,e,t){if(null!==(n=t.ref)&&"function"!==typeof n&&"object"!==typeof n){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(i(309));var o=t.stateNode}if(!o)throw Error(i(147,n));var r=o,a=""+n;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===a?e.ref:(e=function(n){var e=r.refs;e===Ut&&(e=r.refs={}),null===n?delete e[a]:e[a]=n},e._stringRef=a,e)}if("string"!==typeof n)throw Error(i(284));if(!t._owner)throw Error(i(290,n))}return n}function to(n,e){throw n=Object.prototype.toString.call(e),Error(i(31,"[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n))}function oo(n){return(0,n._init)(n._payload)}function ro(n){function e(e,t){if(n){var o=e.deletions;null===o?(e.deletions=[t],e.flags|=16):o.push(t)}}function t(t,o){if(!n)return null;for(;null!==o;)e(t,o),o=o.sibling;return null}function o(n,e){for(n=new Map;null!==e;)null!==e.key?n.set(e.key,e):n.set(e.index,e),e=e.sibling;return n}function r(n,e){return(n=nv(n,e)).index=0,n.sibling=null,n}function a(e,t,o){return e.index=o,n?null!==(o=e.alternate)?(o=o.index)<t?(e.flags|=2,t):o:(e.flags|=2,t):(e.flags|=1048576,t)}function v(e){return n&&null===e.alternate&&(e.flags|=2),e}function u(n,e,t,o){return null===e||6!==e.tag?((e=rv(t,n.mode,o)).return=n,e):((e=r(e,t)).return=n,e)}function f(n,e,t,o){var a=t.type;return a===s?m(n,e,t.props.children,o,t.key):null!==e&&(e.elementType===a||"object"===typeof a&&null!==a&&a.$$typeof===g&&oo(a)===e.type)?((o=r(e,t.props)).ref=eo(n,e,t),o.return=n,o):((o=ev(t.type,t.key,t.props,null,n.mode,o)).ref=eo(n,e,t),o.return=n,o)}function p(n,e,t,o){return null===e||4!==e.tag||e.stateNode.containerInfo!==t.containerInfo||e.stateNode.implementation!==t.implementation?((e=av(t,n.mode,o)).return=n,e):((e=r(e,t.children||[])).return=n,e)}function m(n,e,t,o,a){return null===e||7!==e.tag?((e=tv(t,n.mode,o,a)).return=n,e):((e=r(e,t)).return=n,e)}function d(n,e,t){if("string"===typeof e&&""!==e||"number"===typeof e)return(e=rv(""+e,n.mode,t)).return=n,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case c:return(t=ev(e.type,e.key,e.props,null,n.mode,t)).ref=eo(n,null,e),t.return=n,t;case l:return(e=av(e,n.mode,t)).return=n,e;case g:return d(n,(0,e._init)(e._payload),t)}if(P(e)||U(e))return(e=tv(e,n.mode,t,null)).return=n,e;to(n,e)}return null}function h(n,e,t,o){var r=null!==e?e.key:null;if("string"===typeof t&&""!==t||"number"===typeof t)return null!==r?null:u(n,e,""+t,o);if("object"===typeof t&&null!==t){switch(t.$$typeof){case c:return t.key===r?f(n,e,t,o):null;case l:return t.key===r?p(n,e,t,o):null;case g:return h(n,e,(r=t._init)(t._payload),o)}if(P(t)||U(t))return null!==r?null:m(n,e,t,o,null);to(n,t)}return null}function x(n,e,t,o,r){if("string"===typeof o&&""!==o||"number"===typeof o)return u(e,n=n.get(t)||null,""+o,r);if("object"===typeof o&&null!==o){switch(o.$$typeof){case c:return f(e,n=n.get(null===o.key?t:o.key)||null,o,r);case l:return p(e,n=n.get(null===o.key?t:o.key)||null,o,r);case g:return x(n,e,t,(0,o._init)(o._payload),r)}if(P(o)||U(o))return m(e,n=n.get(t)||null,o,r,null);to(e,o)}return null}function y(r,i,v,c){for(var l=null,s=null,u=i,f=i=0,p=null;null!==u&&f<v.length;f++){u.index>f?(p=u,u=null):p=u.sibling;var m=h(r,u,v[f],c);if(null===m){null===u&&(u=p);break}n&&u&&null===m.alternate&&e(r,u),i=a(m,i,f),null===s?l=m:s.sibling=m,s=m,u=p}if(f===v.length)return t(r,u),Vt&&Lt(r,f),l;if(null===u){for(;f<v.length;f++)null!==(u=d(r,v[f],c))&&(i=a(u,i,f),null===s?l=u:s.sibling=u,s=u);return Vt&&Lt(r,f),l}for(u=o(r,u);f<v.length;f++)null!==(p=x(u,r,f,v[f],c))&&(n&&null!==p.alternate&&u.delete(null===p.key?f:p.key),i=a(p,i,f),null===s?l=p:s.sibling=p,s=p);return n&&u.forEach((function(n){return e(r,n)})),Vt&&Lt(r,f),l}function b(r,v,c,l){var s=U(c);if("function"!==typeof s)throw Error(i(150));if(null==(c=s.call(c)))throw Error(i(151));for(var u=s=null,f=v,p=v=0,m=null,y=c.next();null!==f&&!y.done;p++,y=c.next()){f.index>p?(m=f,f=null):m=f.sibling;var g=h(r,f,y.value,l);if(null===g){null===f&&(f=m);break}n&&f&&null===g.alternate&&e(r,f),v=a(g,v,p),null===u?s=g:u.sibling=g,u=g,f=m}if(y.done)return t(r,f),Vt&&Lt(r,p),s;if(null===f){for(;!y.done;p++,y=c.next())null!==(y=d(r,y.value,l))&&(v=a(y,v,p),null===u?s=y:u.sibling=y,u=y);return Vt&&Lt(r,p),s}for(f=o(r,f);!y.done;p++,y=c.next())null!==(y=x(f,r,p,y.value,l))&&(n&&null!==y.alternate&&f.delete(null===y.key?p:y.key),v=a(y,v,p),null===u?s=y:u.sibling=y,u=y);return n&&f.forEach((function(n){return e(r,n)})),Vt&&Lt(r,p),s}return function n(o,a,i,u){if("object"===typeof i&&null!==i&&i.type===s&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case c:n:{for(var f=i.key,p=a;null!==p;){if(p.key===f){if((f=i.type)===s){if(7===p.tag){t(o,p.sibling),(a=r(p,i.props.children)).return=o,o=a;break n}}else if(p.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===g&&oo(f)===p.type){t(o,p.sibling),(a=r(p,i.props)).ref=eo(o,p,i),a.return=o,o=a;break n}t(o,p);break}e(o,p),p=p.sibling}i.type===s?((a=tv(i.props.children,o.mode,u,i.key)).return=o,o=a):((u=ev(i.type,i.key,i.props,null,o.mode,u)).ref=eo(o,a,i),u.return=o,o=u)}return v(o);case l:n:{for(p=i.key;null!==a;){if(a.key===p){if(4===a.tag&&a.stateNode.containerInfo===i.containerInfo&&a.stateNode.implementation===i.implementation){t(o,a.sibling),(a=r(a,i.children||[])).return=o,o=a;break n}t(o,a);break}e(o,a),a=a.sibling}(a=av(i,o.mode,u)).return=o,o=a}return v(o);case g:return n(o,a,(p=i._init)(i._payload),u)}if(P(i))return y(o,a,i,u);if(U(i))return b(o,a,i,u);to(o,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==a&&6===a.tag?(t(o,a.sibling),(a=r(a,i)).return=o,o=a):(t(o,a),(a=rv(i,o.mode,u)).return=o,o=a),v(o)):t(o,a)}}var ao=ro(!0),io=ro(!1),vo={},co=ve(vo),lo=ve(vo),so=ve(vo);function uo(n){if(n===vo)throw Error(i(174));return n}function fo(n,e){le(so,e),le(lo,n),le(co,vo),n=j(e),ce(co),le(co,n)}function po(){ce(co),ce(lo),ce(so)}function mo(n){var e=uo(so.current),t=uo(co.current);t!==(e=I(t,n.type,e))&&(le(lo,n),le(co,e))}function ho(n){lo.current===n&&(ce(co),ce(lo))}var xo=ve(0);function yo(n){for(var e=n;null!==e;){if(13===e.tag){var t=e.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||On(t)||Ln(t)))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(128&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var go=[];function bo(){for(var n=0;n<go.length;n++){var e=go[n];X?e._workInProgressVersionPrimary=null:e._workInProgressVersionSecondary=null}go.length=0}var _o=v.ReactCurrentDispatcher,Uo=v.ReactCurrentBatchConfig,wo=0,So=null,Mo=null,zo=null,ko=!1,Co=!1,To=0,Ro=0;function Do(){throw Error(i(321))}function Po(n,e){if(null===e)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!He(n[t],e[t]))return!1;return!0}function Fo(n,e,t,o,r,a){if(wo=a,So=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,_o.current=null===n||null===n.memoizedState?dr:hr,n=t(o,r),Co){a=0;do{if(Co=!1,To=0,25<=a)throw Error(i(301));a+=1,zo=Mo=null,e.updateQueue=null,_o.current=xr,n=t(o,r)}while(Co)}if(_o.current=mr,e=null!==Mo&&null!==Mo.next,wo=0,zo=Mo=So=null,ko=!1,e)throw Error(i(300));return n}function jo(){var n=0!==To;return To=0,n}function Io(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===zo?So.memoizedState=zo=n:zo=zo.next=n,zo}function Eo(){if(null===Mo){var n=So.alternate;n=null!==n?n.memoizedState:null}else n=Mo.next;var e=null===zo?So.memoizedState:zo.next;if(null!==e)zo=e,Mo=n;else{if(null===n)throw Error(i(310));n={memoizedState:(Mo=n).memoizedState,baseState:Mo.baseState,baseQueue:Mo.baseQueue,queue:Mo.queue,next:null},null===zo?So.memoizedState=zo=n:zo=zo.next=n}return zo}function Oo(n,e){return"function"===typeof e?e(n):e}function Lo(n){var e=Eo(),t=e.queue;if(null===t)throw Error(i(311));t.lastRenderedReducer=n;var o=Mo,r=o.baseQueue,a=t.pending;if(null!==a){if(null!==r){var v=r.next;r.next=a.next,a.next=v}o.baseQueue=r=a,t.pending=null}if(null!==r){a=r.next,o=o.baseState;var c=v=null,l=null,s=a;do{var u=s.lane;if((wo&u)===u)null!==l&&(l=l.next={lane:0,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null}),o=s.hasEagerState?s.eagerState:n(o,s.action);else{var f={lane:u,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null};null===l?(c=l=f,v=o):l=l.next=f,So.lanes|=u,ti|=u}s=s.next}while(null!==s&&s!==a);null===l?v=o:l.next=c,He(o,e.memoizedState)||(Or=!0),e.memoizedState=o,e.baseState=v,e.baseQueue=l,t.lastRenderedState=o}if(null!==(n=t.interleaved)){r=n;do{a=r.lane,So.lanes|=a,ti|=a,r=r.next}while(r!==n)}else null===r&&(t.lanes=0);return[e.memoizedState,t.dispatch]}function Ao(n){var e=Eo(),t=e.queue;if(null===t)throw Error(i(311));t.lastRenderedReducer=n;var o=t.dispatch,r=t.pending,a=e.memoizedState;if(null!==r){t.pending=null;var v=r=r.next;do{a=n(a,v.action),v=v.next}while(v!==r);He(a,e.memoizedState)||(Or=!0),e.memoizedState=a,null===e.baseQueue&&(e.baseState=a),t.lastRenderedState=a}return[a,o]}function Go(){}function No(n,e){var t=So,o=Eo(),r=e(),a=!He(o.memoizedState,r);if(a&&(o.memoizedState=r,Or=!0),o=o.queue,Ko(Vo.bind(null,t,o,n),[n]),o.getSnapshot!==e||a||null!==zo&&1&zo.memoizedState.tag){if(t.flags|=2048,Xo(9,qo.bind(null,t,o,r,e),void 0,null),null===Za)throw Error(i(349));0!==(30&wo)||Bo(t,e,r)}return r}function Bo(n,e,t){n.flags|=16384,n={getSnapshot:e,value:t},null===(e=So.updateQueue)?(e={lastEffect:null,stores:null},So.updateQueue=e,e.stores=[n]):null===(t=e.stores)?e.stores=[n]:t.push(n)}function qo(n,e,t,o){e.value=t,e.getSnapshot=o,Wo(e)&&wi(n,1,-1)}function Vo(n,e,t){return t((function(){Wo(e)&&wi(n,1,-1)}))}function Wo(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!He(n,t)}catch(o){return!0}}function Ho(n){var e=Io();return"function"===typeof n&&(n=n()),e.memoizedState=e.baseState=n,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Oo,lastRenderedState:n},e.queue=n,n=n.dispatch=lr.bind(null,So,n),[e.memoizedState,n]}function Xo(n,e,t,o){return n={tag:n,create:e,destroy:t,deps:o,next:null},null===(e=So.updateQueue)?(e={lastEffect:null,stores:null},So.updateQueue=e,e.lastEffect=n.next=n):null===(t=e.lastEffect)?e.lastEffect=n.next=n:(o=t.next,t.next=n,n.next=o,e.lastEffect=n),n}function Yo(){return Eo().memoizedState}function Zo(n,e,t,o){var r=Io();So.flags|=n,r.memoizedState=Xo(1|e,t,void 0,void 0===o?null:o)}function Qo(n,e,t,o){var r=Eo();o=void 0===o?null:o;var a=void 0;if(null!==Mo){var i=Mo.memoizedState;if(a=i.destroy,null!==o&&Po(o,i.deps))return void(r.memoizedState=Xo(e,t,a,o))}So.flags|=n,r.memoizedState=Xo(1|e,t,a,o)}function Jo(n,e){return Zo(8390656,8,n,e)}function Ko(n,e){return Qo(2048,8,n,e)}function $o(n,e){return Qo(4,2,n,e)}function nr(n,e){return Qo(4,4,n,e)}function er(n,e){return"function"===typeof e?(n=n(),e(n),function(){e(null)}):null!==e&&void 0!==e?(n=n(),e.current=n,function(){e.current=null}):void 0}function tr(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Qo(4,4,er.bind(null,e,n),t)}function or(){}function rr(n,e){var t=Eo();e=void 0===e?null:e;var o=t.memoizedState;return null!==o&&null!==e&&Po(e,o[1])?o[0]:(t.memoizedState=[n,e],n)}function ar(n,e){var t=Eo();e=void 0===e?null:e;var o=t.memoizedState;return null!==o&&null!==e&&Po(e,o[1])?o[0]:(n=n(),t.memoizedState=[n,e],n)}function ir(n,e){var t=Fe;Fe=0!==t&&4>t?t:4,n(!0);var o=Uo.transition;Uo.transition={};try{n(!1),e()}finally{Fe=t,Uo.transition=o}}function vr(){return Eo().memoizedState}function cr(n,e,t){var o=Ui(n);t={lane:o,action:t,hasEagerState:!1,eagerState:null,next:null},sr(n)?ur(e,t):(fr(n,e,t),null!==(n=wi(n,o,t=_i()))&&pr(n,e,o))}function lr(n,e,t){var o=Ui(n),r={lane:o,action:t,hasEagerState:!1,eagerState:null,next:null};if(sr(n))ur(e,r);else{fr(n,e,r);var a=n.alternate;if(0===n.lanes&&(null===a||0===a.lanes)&&null!==(a=e.lastRenderedReducer))try{var i=e.lastRenderedState,v=a(i,t);if(r.hasEagerState=!0,r.eagerState=v,He(v,i))return}catch(c){}null!==(n=wi(n,o,t=_i()))&&pr(n,e,o)}}function sr(n){var e=n.alternate;return n===So||null!==e&&e===So}function ur(n,e){Co=ko=!0;var t=n.pending;null===t?e.next=e:(e.next=t.next,t.next=e),n.pending=e}function fr(n,e,t){null!==Za&&0!==(1&n.mode)&&0===(2&Ya)?(null===(n=e.interleaved)?(t.next=t,null===ft?ft=[e]:ft.push(e)):(t.next=n.next,n.next=t),e.interleaved=t):(null===(n=e.pending)?t.next=t:(t.next=n.next,n.next=t),e.pending=t)}function pr(n,e,t){if(0!==(4194240&t)){var o=e.lanes;t|=o&=n.pendingLanes,e.lanes=t,Pe(n,t)}}var mr={readContext:ut,useCallback:Do,useContext:Do,useEffect:Do,useImperativeHandle:Do,useInsertionEffect:Do,useLayoutEffect:Do,useMemo:Do,useReducer:Do,useRef:Do,useState:Do,useDebugValue:Do,useDeferredValue:Do,useTransition:Do,useMutableSource:Do,useSyncExternalStore:Do,useId:Do,unstable_isNewReconciler:!1},dr={readContext:ut,useCallback:function(n,e){return Io().memoizedState=[n,void 0===e?null:e],n},useContext:ut,useEffect:Jo,useImperativeHandle:function(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Zo(4194308,4,er.bind(null,e,n),t)},useLayoutEffect:function(n,e){return Zo(4194308,4,n,e)},useInsertionEffect:function(n,e){return Zo(4,2,n,e)},useMemo:function(n,e){var t=Io();return e=void 0===e?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var o=Io();return e=void 0!==t?t(e):e,o.memoizedState=o.baseState=e,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:e},o.queue=n,n=n.dispatch=cr.bind(null,So,n),[o.memoizedState,n]},useRef:function(n){return n={current:n},Io().memoizedState=n},useState:Ho,useDebugValue:or,useDeferredValue:function(n){var e=Ho(n),t=e[0],o=e[1];return Jo((function(){var e=Uo.transition;Uo.transition={};try{o(n)}finally{Uo.transition=e}}),[n]),t},useTransition:function(){var n=Ho(!1),e=n[0];return n=ir.bind(null,n[1]),Io().memoizedState=n,[e,n]},useMutableSource:function(){},useSyncExternalStore:function(n,e,t){var o=So,r=Io();if(Vt){if(void 0===t)throw Error(i(407));t=t()}else{if(t=e(),null===Za)throw Error(i(349));0!==(30&wo)||Bo(o,e,t)}r.memoizedState=t;var a={value:t,getSnapshot:e};return r.queue=a,Jo(Vo.bind(null,o,a,n),[n]),o.flags|=2048,Xo(9,qo.bind(null,o,a,t,e),void 0,null),t},useId:function(){var n=Io(),e=Za.identifierPrefix;if(Vt){var t=Ot;e=":"+e+"R"+(t=(Et&~(1<<32-_e(Et)-1)).toString(32)+t),0<(t=To++)&&(e+="H"+t.toString(32)),e+=":"}else e=":"+e+"r"+(t=Ro++).toString(32)+":";return n.memoizedState=e},unstable_isNewReconciler:!1},hr={readContext:ut,useCallback:rr,useContext:ut,useEffect:Ko,useImperativeHandle:tr,useInsertionEffect:$o,useLayoutEffect:nr,useMemo:ar,useReducer:Lo,useRef:Yo,useState:function(){return Lo(Oo)},useDebugValue:or,useDeferredValue:function(n){var e=Lo(Oo),t=e[0],o=e[1];return Ko((function(){var e=Uo.transition;Uo.transition={};try{o(n)}finally{Uo.transition=e}}),[n]),t},useTransition:function(){return[Lo(Oo)[0],Eo().memoizedState]},useMutableSource:Go,useSyncExternalStore:No,useId:vr,unstable_isNewReconciler:!1},xr={readContext:ut,useCallback:rr,useContext:ut,useEffect:Ko,useImperativeHandle:tr,useInsertionEffect:$o,useLayoutEffect:nr,useMemo:ar,useReducer:Ao,useRef:Yo,useState:function(){return Ao(Oo)},useDebugValue:or,useDeferredValue:function(n){var e=Ao(Oo),t=e[0],o=e[1];return Ko((function(){var e=Uo.transition;Uo.transition={};try{o(n)}finally{Uo.transition=e}}),[n]),t},useTransition:function(){return[Ao(Oo)[0],Eo().memoizedState]},useMutableSource:Go,useSyncExternalStore:No,useId:vr,unstable_isNewReconciler:!1};function yr(n,e){try{var t="",o=e;do{t+=nt(o),o=o.return}while(o);var r=t}catch(a){r="\nError generating stack: "+a.message+"\n"+a.stack}return{value:n,source:e,stack:r}}function gr(n,e){try{console.error(e.value)}catch(t){setTimeout((function(){throw t}))}}var br,_r,Ur,wr,Sr="function"===typeof WeakMap?WeakMap:Map;function Mr(n,e,t){(t=ht(-1,t)).tag=3,t.payload={element:null};var o=e.value;return t.callback=function(){ui||(ui=!0,fi=o),gr(0,e)},t}function zr(n,e,t){(t=ht(-1,t)).tag=3;var o=n.type.getDerivedStateFromError;if("function"===typeof o){var r=e.value;t.payload=function(){return o(r)},t.callback=function(){gr(0,e)}}var a=n.stateNode;return null!==a&&"function"===typeof a.componentDidCatch&&(t.callback=function(){gr(0,e),"function"!==typeof o&&(null===pi?pi=new Set([this]):pi.add(this));var n=e.stack;this.componentDidCatch(e.value,{componentStack:null!==n?n:""})}),t}function kr(n,e,t){var o=n.pingCache;if(null===o){o=n.pingCache=new Sr;var r=new Set;o.set(e,r)}else void 0===(r=o.get(e))&&(r=new Set,o.set(e,r));r.has(t)||(r.add(t),n=Hi.bind(null,n,e,t),e.then(n,n))}function Cr(n){do{var e;if((e=13===n.tag)&&(e=null===(e=n.memoizedState)||null!==e.dehydrated),e)return n;n=n.return}while(null!==n);return null}function Tr(n,e,t,o,r){return 0===(1&n.mode)?(n===e?n.flags|=65536:(n.flags|=128,t.flags|=131072,t.flags&=-52805,1===t.tag&&(null===t.alternate?t.tag=17:((e=ht(-1,1)).tag=2,xt(t,e))),t.lanes|=1),n):(n.flags|=65536,n.lanes=r,n)}function Rr(n){n.flags|=4}function Dr(n,e){if(null!==n&&n.child===e.child)return!0;if(0!==(16&e.flags))return!1;for(n=e.child;null!==n;){if(0!==(12854&n.flags)||0!==(12854&n.subtreeFlags))return!1;n=n.sibling}return!0}if(Y)br=function(n,e){for(var t=e.child;null!==t;){if(5===t.tag||6===t.tag)A(n,t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},_r=function(){},Ur=function(n,e,t,o,r){if((n=n.memoizedProps)!==o){var a=e.stateNode,i=uo(co.current);t=N(a,t,n,o,r,i),(e.updateQueue=t)&&Rr(e)}},wr=function(n,e,t,o){t!==o&&Rr(e)};else if(Z){br=function(n,e,t,o){for(var r=e.child;null!==r;){if(5===r.tag){var a=r.stateNode;t&&o&&(a=Pn(a,r.type,r.memoizedProps,r)),A(n,a)}else if(6===r.tag)a=r.stateNode,t&&o&&(a=Fn(a,r.memoizedProps,r)),A(n,a);else if(4!==r.tag)if(22===r.tag&&null!==r.memoizedState)null!==(a=r.child)&&(a.return=r),br(n,r,!0,!0);else if(null!==r.child){r.child.return=r,r=r.child;continue}if(r===e)break;for(;null===r.sibling;){if(null===r.return||r.return===e)return;r=r.return}r.sibling.return=r.return,r=r.sibling}};var Pr=function n(e,t,o,r){for(var a=t.child;null!==a;){if(5===a.tag){var i=a.stateNode;o&&r&&(i=Pn(i,a.type,a.memoizedProps,a)),Tn(e,i)}else if(6===a.tag)i=a.stateNode,o&&r&&(i=Fn(i,a.memoizedProps,a)),Tn(e,i);else if(4!==a.tag)if(22===a.tag&&null!==a.memoizedState)null!==(i=a.child)&&(i.return=a),n(e,a,!0,!0);else if(null!==a.child){a.child.return=a,a=a.child;continue}if(a===t)break;for(;null===a.sibling;){if(null===a.return||a.return===t)return;a=a.return}a.sibling.return=a.return,a=a.sibling}};_r=function(n,e){var t=e.stateNode;if(!Dr(n,e)){n=t.containerInfo;var o=Cn(n);Pr(o,e,!1,!1),t.pendingChildren=o,Rr(e),Rn(n,o)}},Ur=function(n,e,t,o,r){var a=n.stateNode,i=n.memoizedProps;if((n=Dr(n,e))&&i===o)e.stateNode=a;else{var v=e.stateNode,c=uo(co.current),l=null;i!==o&&(l=N(v,t,i,o,r,c)),n&&null===l?e.stateNode=a:(a=kn(a,l,t,i,o,e,n,v),G(a,t,o,r,c)&&Rr(e),e.stateNode=a,n?Rr(e):br(a,e,!1,!1))}},wr=function(n,e,t,o){t!==o?(n=uo(so.current),t=uo(co.current),e.stateNode=q(o,n,t,e),Rr(e)):e.stateNode=n.stateNode}}else _r=function(){},Ur=function(){},wr=function(){};function Fr(n,e){if(!Vt)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;null!==e;)null!==e.alternate&&(t=e),e=e.sibling;null===t?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var o=null;null!==t;)null!==t.alternate&&(o=t),t=t.sibling;null===o?e||null===n.tail?n.tail=null:n.tail.sibling=null:o.sibling=null}}function jr(n){var e=null!==n.alternate&&n.alternate.child===n.child,t=0,o=0;if(e)for(var r=n.child;null!==r;)t|=r.lanes|r.childLanes,o|=14680064&r.subtreeFlags,o|=14680064&r.flags,r.return=n,r=r.sibling;else for(r=n.child;null!==r;)t|=r.lanes|r.childLanes,o|=r.subtreeFlags,o|=r.flags,r.return=n,r=r.sibling;return n.subtreeFlags|=o,n.childLanes=t,e}function Ir(n,e,t){var o=e.pendingProps;switch(Nt(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return jr(e),null;case 1:case 17:return de(e.type)&&he(),jr(e),null;case 3:return o=e.stateNode,po(),ce(fe),ce(ue),bo(),o.pendingContext&&(o.context=o.pendingContext,o.pendingContext=null),null!==n&&null!==n.child||(Kt(e)?Rr(e):null===n||n.memoizedState.isDehydrated&&0===(256&e.flags)||(e.flags|=1024,null!==Ht&&(Ci(Ht),Ht=null))),_r(n,e),jr(e),null;case 5:ho(e),t=uo(so.current);var r=e.type;if(null!==n&&null!=e.stateNode)Ur(n,e,r,o,t),n.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!o){if(null===e.stateNode)throw Error(i(166));return jr(e),null}if(n=uo(co.current),Kt(e)){if(!Q)throw Error(i(175));n=Vn(e.stateNode,e.type,e.memoizedProps,t,n,e,!Wt),e.updateQueue=n,null!==n&&Rr(e)}else{var a=L(r,o,t,n,e);br(a,e,!1,!1),e.stateNode=a,G(a,r,o,t,n)&&Rr(e)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return jr(e),null;case 6:if(n&&null!=e.stateNode)wr(n,e,n.memoizedProps,o);else{if("string"!==typeof o&&null===e.stateNode)throw Error(i(166));if(n=uo(so.current),t=uo(co.current),Kt(e)){if(!Q)throw Error(i(176));if(n=e.stateNode,o=e.memoizedProps,(t=Wn(n,o,e,!Wt))&&null!==(r=Bt))switch(a=0!==(1&r.mode),r.tag){case 3:$n(r.stateNode.containerInfo,n,o,a);break;case 5:ne(r.type,r.memoizedProps,r.stateNode,n,o,a)}t&&Rr(e)}else e.stateNode=q(o,n,t,e)}return jr(e),null;case 13:if(ce(xo),o=e.memoizedState,Vt&&null!==qt&&0!==(1&e.mode)&&0===(128&e.flags)){for(n=qt;n;)n=Gn(n);return $t(),e.flags|=98560,e}if(null!==o&&null!==o.dehydrated){if(o=Kt(e),null===n){if(!o)throw Error(i(318));if(!Q)throw Error(i(344));if(!(n=null!==(n=e.memoizedState)?n.dehydrated:null))throw Error(i(317));Hn(n,e)}else $t(),0===(128&e.flags)&&(e.memoizedState=null),e.flags|=4;return jr(e),null}return null!==Ht&&(Ci(Ht),Ht=null),0!==(128&e.flags)?(e.lanes=t,e):(o=null!==o,t=!1,null===n?Kt(e):t=null!==n.memoizedState,o&&!t&&(e.child.flags|=8192,0!==(1&e.mode)&&(null===n||0!==(1&xo.current)?0===ni&&(ni=3):Ei())),null!==e.updateQueue&&(e.flags|=4),jr(e),null);case 4:return po(),_r(n,e),null===n&&K(e.stateNode.containerInfo),jr(e),null;case 10:return ct(e.type._context),jr(e),null;case 19:if(ce(xo),null===(r=e.memoizedState))return jr(e),null;if(o=0!==(128&e.flags),null===(a=r.rendering))if(o)Fr(r,!1);else{if(0!==ni||null!==n&&0!==(128&n.flags))for(n=e.child;null!==n;){if(null!==(a=yo(n))){for(e.flags|=128,Fr(r,!1),null!==(n=a.updateQueue)&&(e.updateQueue=n,e.flags|=4),e.subtreeFlags=0,n=t,o=e.child;null!==o;)r=n,(t=o).flags&=14680066,null===(a=t.alternate)?(t.childLanes=0,t.lanes=r,t.child=null,t.subtreeFlags=0,t.memoizedProps=null,t.memoizedState=null,t.updateQueue=null,t.dependencies=null,t.stateNode=null):(t.childLanes=a.childLanes,t.lanes=a.lanes,t.child=a.child,t.subtreeFlags=0,t.deletions=null,t.memoizedProps=a.memoizedProps,t.memoizedState=a.memoizedState,t.updateQueue=a.updateQueue,t.type=a.type,r=a.dependencies,t.dependencies=null===r?null:{lanes:r.lanes,firstContext:r.firstContext}),o=o.sibling;return le(xo,1&xo.current|2),e.child}n=n.sibling}null!==r.tail&&Ae()>ci&&(e.flags|=128,o=!0,Fr(r,!1),e.lanes=4194304)}else{if(!o)if(null!==(n=yo(a))){if(e.flags|=128,o=!0,null!==(n=n.updateQueue)&&(e.updateQueue=n,e.flags|=4),Fr(r,!0),null===r.tail&&"hidden"===r.tailMode&&!a.alternate&&!Vt)return jr(e),null}else 2*Ae()-r.renderingStartTime>ci&&1073741824!==t&&(e.flags|=128,o=!0,Fr(r,!1),e.lanes=4194304);r.isBackwards?(a.sibling=e.child,e.child=a):(null!==(n=r.last)?n.sibling=a:e.child=a,r.last=a)}return null!==r.tail?(e=r.tail,r.rendering=e,r.tail=e.sibling,r.renderingStartTime=Ae(),e.sibling=null,n=xo.current,le(xo,o?1&n|2:1&n),e):(jr(e),null);case 22:case 23:return Pi(),o=null!==e.memoizedState,null!==n&&null!==n.memoizedState!==o&&(e.flags|=8192),o&&0!==(1&e.mode)?0!==(1073741824&Ka)&&(jr(e),Y&&6&e.subtreeFlags&&(e.flags|=8192)):jr(e),null;case 24:case 25:return null}throw Error(i(156,e.tag))}var Er=v.ReactCurrentOwner,Or=!1;function Lr(n,e,t,o){e.child=null===n?io(e,null,t,o):ao(e,n.child,t,o)}function Ar(n,e,t,o,r){t=t.render;var a=e.ref;return st(e,r),o=Fo(n,e,t,o,a,r),t=jo(),null===n||Or?(Vt&&t&&Gt(e),e.flags|=1,Lr(n,e,o,r),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,aa(n,e,r))}function Gr(n,e,t,o,r){if(null===n){var a=t.type;return"function"!==typeof a||$i(a)||void 0!==a.defaultProps||null!==t.compare||void 0!==t.defaultProps?((n=ev(t.type,null,o,e,e.mode,r)).ref=e.ref,n.return=e,e.child=n):(e.tag=15,e.type=a,Nr(n,e,a,o,r))}if(a=n.child,0===(n.lanes&r)){var i=a.memoizedProps;if((t=null!==(t=t.compare)?t:$e)(i,o)&&n.ref===e.ref)return aa(n,e,r)}return e.flags|=1,(n=nv(a,o)).ref=e.ref,n.return=e,e.child=n}function Nr(n,e,t,o,r){if(null!==n&&$e(n.memoizedProps,o)&&n.ref===e.ref){if(Or=!1,0===(n.lanes&r))return e.lanes=n.lanes,aa(n,e,r);0!==(131072&n.flags)&&(Or=!0)}return Vr(n,e,t,o,r)}function Br(n,e,t){var o=e.pendingProps,r=o.children,a=null!==n?n.memoizedState:null;if("hidden"===o.mode)if(0===(1&e.mode))e.memoizedState={baseLanes:0,cachePool:null},le($a,Ka),Ka|=t;else{if(0===(1073741824&t))return n=null!==a?a.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n,cachePool:null},e.updateQueue=null,le($a,Ka),Ka|=n,null;e.memoizedState={baseLanes:0,cachePool:null},o=null!==a?a.baseLanes:t,le($a,Ka),Ka|=o}else null!==a?(o=a.baseLanes|t,e.memoizedState=null):o=t,le($a,Ka),Ka|=o;return Lr(n,e,r,t),e.child}function qr(n,e){var t=e.ref;(null===n&&null!==t||null!==n&&n.ref!==t)&&(e.flags|=512,e.flags|=2097152)}function Vr(n,e,t,o,r){var a=de(t)?pe:ue.current;return a=me(e,a),st(e,r),t=Fo(n,e,t,o,a,r),o=jo(),null===n||Or?(Vt&&o&&Gt(e),e.flags|=1,Lr(n,e,t,r),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,aa(n,e,r))}function Wr(n,e,t,o,r){if(de(t)){var a=!0;ge(e)}else a=!1;if(st(e,r),null===e.stateNode)null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),zt(e,t,o),Ct(e,t,o,r),o=!0;else if(null===n){var i=e.stateNode,v=e.memoizedProps;i.props=v;var c=i.context,l=t.contextType;"object"===typeof l&&null!==l?l=ut(l):l=me(e,l=de(t)?pe:ue.current);var s=t.getDerivedStateFromProps,u="function"===typeof s||"function"===typeof i.getSnapshotBeforeUpdate;u||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==o||c!==l)&&kt(e,i,o,l),pt=!1;var f=e.memoizedState;i.state=f,bt(e,o,i,r),c=e.memoizedState,v!==o||f!==c||fe.current||pt?("function"===typeof s&&(wt(e,t,s,o),c=e.memoizedState),(v=pt||Mt(e,t,v,o,f,c,l))?(u||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(e.flags|=4194308)):("function"===typeof i.componentDidMount&&(e.flags|=4194308),e.memoizedProps=o,e.memoizedState=c),i.props=o,i.state=c,i.context=l,o=v):("function"===typeof i.componentDidMount&&(e.flags|=4194308),o=!1)}else{i=e.stateNode,dt(n,e),v=e.memoizedProps,l=e.type===e.elementType?v:et(e.type,v),i.props=l,u=e.pendingProps,f=i.context,"object"===typeof(c=t.contextType)&&null!==c?c=ut(c):c=me(e,c=de(t)?pe:ue.current);var p=t.getDerivedStateFromProps;(s="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==u||f!==c)&&kt(e,i,o,c),pt=!1,f=e.memoizedState,i.state=f,bt(e,o,i,r);var m=e.memoizedState;v!==u||f!==m||fe.current||pt?("function"===typeof p&&(wt(e,t,p,o),m=e.memoizedState),(l=pt||Mt(e,t,l,o,f,m,c)||!1)?(s||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(o,m,c),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(o,m,c)),"function"===typeof i.componentDidUpdate&&(e.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),e.memoizedProps=o,e.memoizedState=m),i.props=o,i.state=m,i.context=c,o=l):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),o=!1)}return Hr(n,e,t,o,a,r)}function Hr(n,e,t,o,r,a){qr(n,e);var i=0!==(128&e.flags);if(!o&&!i)return r&&be(e,t,!1),aa(n,e,a);o=e.stateNode,Er.current=e;var v=i&&"function"!==typeof t.getDerivedStateFromError?null:o.render();return e.flags|=1,null!==n&&i?(e.child=ao(e,n.child,null,a),e.child=ao(e,null,v,a)):Lr(n,e,v,a),e.memoizedState=o.state,r&&be(e,t,!0),e.child}function Xr(n){var e=n.stateNode;e.pendingContext?xe(0,e.pendingContext,e.pendingContext!==e.context):e.context&&xe(0,e.context,!1),fo(n,e.containerInfo)}function Yr(n,e,t,o,r){return $t(),no(r),e.flags|=256,Lr(n,e,t,o),e.child}var Zr={dehydrated:null,treeContext:null,retryLane:0};function Qr(n){return{baseLanes:n,cachePool:null}}function Jr(n,e,t){var o,r=e.pendingProps,a=xo.current,v=!1,c=0!==(128&e.flags);if((o=c)||(o=(null===n||null!==n.memoizedState)&&0!==(2&a)),o?(v=!0,e.flags&=-129):null!==n&&null===n.memoizedState||(a|=1),le(xo,1&a),null===n)return Qt(e),null!==(n=e.memoizedState)&&null!==(n=n.dehydrated)?(0===(1&e.mode)?e.lanes=1:Ln(n)?e.lanes=8:e.lanes=1073741824,null):(a=r.children,n=r.fallback,v?(r=e.mode,v=e.child,a={mode:"hidden",children:a},0===(1&r)&&null!==v?(v.childLanes=0,v.pendingProps=a):v=ov(a,r,0,null),n=tv(n,r,t,null),v.return=e,n.return=e,v.sibling=n,e.child=v,e.child.memoizedState=Qr(t),e.memoizedState=Zr,n):Kr(e,a));if(null!==(a=n.memoizedState)){if(null!==(o=a.dehydrated)){if(c)return 256&e.flags?(e.flags&=-257,ea(n,e,t,Error(i(422)))):null!==e.memoizedState?(e.child=n.child,e.flags|=128,null):(v=r.fallback,a=e.mode,r=ov({mode:"visible",children:r.children},a,0,null),(v=tv(v,a,t,null)).flags|=2,r.return=e,v.return=e,r.sibling=v,e.child=r,0!==(1&e.mode)&&ao(e,n.child,null,t),e.child.memoizedState=Qr(t),e.memoizedState=Zr,v);if(0===(1&e.mode))e=ea(n,e,t,null);else if(Ln(o))e=ea(n,e,t,Error(i(419)));else if(r=0!==(t&n.childLanes),Or||r){if(null!==(r=Za)){switch(t&-t){case 4:v=2;break;case 16:v=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:v=32;break;case 536870912:v=268435456;break;default:v=0}0!==(r=0!==(v&(r.suspendedLanes|t))?0:v)&&r!==a.retryLane&&(a.retryLane=r,wi(n,r,-1))}Ei(),e=ea(n,e,t,Error(i(421)))}else On(o)?(e.flags|=128,e.child=n.child,e=Yi.bind(null,n),An(o,e),e=null):(t=a.treeContext,Q&&(qt=qn(o),Bt=e,Vt=!0,Ht=null,Wt=!1,null!==t&&(Ft[jt++]=Et,Ft[jt++]=Ot,Ft[jt++]=It,Et=t.id,Ot=t.overflow,It=e)),(e=Kr(e,e.pendingProps.children)).flags|=4096);return e}return v?(r=na(n,e,r.children,r.fallback,t),v=e.child,a=n.child.memoizedState,v.memoizedState=null===a?Qr(t):{baseLanes:a.baseLanes|t,cachePool:null},v.childLanes=n.childLanes&~t,e.memoizedState=Zr,r):(t=$r(n,e,r.children,t),e.memoizedState=null,t)}return v?(r=na(n,e,r.children,r.fallback,t),v=e.child,a=n.child.memoizedState,v.memoizedState=null===a?Qr(t):{baseLanes:a.baseLanes|t,cachePool:null},v.childLanes=n.childLanes&~t,e.memoizedState=Zr,r):(t=$r(n,e,r.children,t),e.memoizedState=null,t)}function Kr(n,e){return(e=ov({mode:"visible",children:e},n.mode,0,null)).return=n,n.child=e}function $r(n,e,t,o){var r=n.child;return n=r.sibling,t=nv(r,{mode:"visible",children:t}),0===(1&e.mode)&&(t.lanes=o),t.return=e,t.sibling=null,null!==n&&(null===(o=e.deletions)?(e.deletions=[n],e.flags|=16):o.push(n)),e.child=t}function na(n,e,t,o,r){var a=e.mode,i=(n=n.child).sibling,v={mode:"hidden",children:t};return 0===(1&a)&&e.child!==n?((t=e.child).childLanes=0,t.pendingProps=v,e.deletions=null):(t=nv(n,v)).subtreeFlags=14680064&n.subtreeFlags,null!==i?o=nv(i,o):(o=tv(o,a,r,null)).flags|=2,o.return=e,t.return=e,t.sibling=o,e.child=t,o}function ea(n,e,t,o){return null!==o&&no(o),ao(e,n.child,null,t),(n=Kr(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,n}function ta(n,e,t){n.lanes|=e;var o=n.alternate;null!==o&&(o.lanes|=e),lt(n.return,e,t)}function oa(n,e,t,o,r){var a=n.memoizedState;null===a?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:o,tail:t,tailMode:r}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=o,a.tail=t,a.tailMode=r)}function ra(n,e,t){var o=e.pendingProps,r=o.revealOrder,a=o.tail;if(Lr(n,e,o.children,t),0!==(2&(o=xo.current)))o=1&o|2,e.flags|=128;else{if(null!==n&&0!==(128&n.flags))n:for(n=e.child;null!==n;){if(13===n.tag)null!==n.memoizedState&&ta(n,t,e);else if(19===n.tag)ta(n,t,e);else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break n;for(;null===n.sibling;){if(null===n.return||n.return===e)break n;n=n.return}n.sibling.return=n.return,n=n.sibling}o&=1}if(le(xo,o),0===(1&e.mode))e.memoizedState=null;else switch(r){case"forwards":for(t=e.child,r=null;null!==t;)null!==(n=t.alternate)&&null===yo(n)&&(r=t),t=t.sibling;null===(t=r)?(r=e.child,e.child=null):(r=t.sibling,t.sibling=null),oa(e,!1,r,t,a);break;case"backwards":for(t=null,r=e.child,e.child=null;null!==r;){if(null!==(n=r.alternate)&&null===yo(n)){e.child=r;break}n=r.sibling,r.sibling=t,t=r,r=n}oa(e,!0,t,null,a);break;case"together":oa(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function aa(n,e,t){if(null!==n&&(e.dependencies=n.dependencies),ti|=e.lanes,0===(t&e.childLanes))return null;if(null!==n&&e.child!==n.child)throw Error(i(153));if(null!==e.child){for(t=nv(n=e.child,n.pendingProps),e.child=t,t.return=e;null!==n.sibling;)n=n.sibling,(t=t.sibling=nv(n,n.pendingProps)).return=e;t.sibling=null}return e.child}function ia(n,e){switch(Nt(e),e.tag){case 1:return de(e.type)&&he(),65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 3:return po(),ce(fe),ce(ue),bo(),0!==(65536&(n=e.flags))&&0===(128&n)?(e.flags=-65537&n|128,e):null;case 5:return ho(e),null;case 13:if(ce(xo),null!==(n=e.memoizedState)&&null!==n.dehydrated){if(null===e.alternate)throw Error(i(340));$t()}return 65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 19:return ce(xo),null;case 4:return po(),null;case 10:return ct(e.type._context),null;case 22:case 23:return Pi(),null;default:return null}}var va=!1,ca=!1,la="function"===typeof WeakSet?WeakSet:Set,sa=null;function ua(n,e){var t=n.ref;if(null!==t)if("function"===typeof t)try{t(null)}catch(o){Wi(n,e,o)}else t.current=null}function fa(n,e,t){try{t()}catch(o){Wi(n,e,o)}}var pa=!1;function ma(n,e,t){var o=e.updateQueue;if(null!==(o=null!==o?o.lastEffect:null)){var r=o=o.next;do{if((r.tag&n)===n){var a=r.destroy;r.destroy=void 0,void 0!==a&&fa(e,t,a)}r=r.next}while(r!==o)}}function da(n,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var t=e=e.next;do{if((t.tag&n)===n){var o=t.create;t.destroy=o()}t=t.next}while(t!==e)}}function ha(n){var e=n.ref;if(null!==e){var t=n.stateNode;if(5===n.tag)n=F(t);else n=t;"function"===typeof e?e(n):e.current=n}}function xa(n,e,t){if(We&&"function"===typeof We.onCommitFiberUnmount)try{We.onCommitFiberUnmount(Ve,e)}catch(i){}switch(e.tag){case 0:case 11:case 14:case 15:if(null!==(n=e.updateQueue)&&null!==(n=n.lastEffect)){var o=n=n.next;do{var r=o,a=r.destroy;r=r.tag,void 0!==a&&(0!==(2&r)||0!==(4&r))&&fa(e,t,a),o=o.next}while(o!==n)}break;case 1:if(ua(e,t),"function"===typeof(n=e.stateNode).componentWillUnmount)try{n.props=e.memoizedProps,n.state=e.memoizedState,n.componentWillUnmount()}catch(i){Wi(e,t,i)}break;case 5:ua(e,t);break;case 4:Y?Ma(n,e,t):Z&&Z&&(e=e.stateNode.containerInfo,t=Cn(e),Dn(e,t))}}function ya(n,e,t){for(var o=e;;)if(xa(n,o,t),null===o.child||Y&&4===o.tag){if(o===e)break;for(;null===o.sibling;){if(null===o.return||o.return===e)return;o=o.return}o.sibling.return=o.return,o=o.sibling}else o.child.return=o,o=o.child}function ga(n){var e=n.alternate;null!==e&&(n.alternate=null,ga(e)),n.child=null,n.deletions=null,n.sibling=null,5===n.tag&&(null!==(e=n.stateNode)&&nn(e)),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}function ba(n){return 5===n.tag||3===n.tag||4===n.tag}function _a(n){n:for(;;){for(;null===n.sibling;){if(null===n.return||ba(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.flags)continue n;if(null===n.child||4===n.tag)continue n;n.child.return=n,n=n.child}if(!(2&n.flags))return n.stateNode}}function Ua(n){if(Y){n:{for(var e=n.return;null!==e;){if(ba(e))break n;e=e.return}throw Error(i(160))}var t=e;switch(t.tag){case 5:e=t.stateNode,32&t.flags&&(_n(e),t.flags&=-33),Sa(n,t=_a(n),e);break;case 3:case 4:e=t.stateNode.containerInfo,wa(n,t=_a(n),e);break;default:throw Error(i(161))}}}function wa(n,e,t){var o=n.tag;if(5===o||6===o)n=n.stateNode,e?yn(t,n,e):pn(t,n);else if(4!==o&&null!==(n=n.child))for(wa(n,e,t),n=n.sibling;null!==n;)wa(n,e,t),n=n.sibling}function Sa(n,e,t){var o=n.tag;if(5===o||6===o)n=n.stateNode,e?xn(t,n,e):fn(t,n);else if(4!==o&&null!==(n=n.child))for(Sa(n,e,t),n=n.sibling;null!==n;)Sa(n,e,t),n=n.sibling}function Ma(n,e,t){for(var o,r,a=e,v=!1;;){if(!v){v=a.return;n:for(;;){if(null===v)throw Error(i(160));switch(o=v.stateNode,v.tag){case 5:r=!1;break n;case 3:case 4:o=o.containerInfo,r=!0;break n}v=v.return}v=!0}if(5===a.tag||6===a.tag)ya(n,a,t),r?bn(o,a.stateNode):gn(o,a.stateNode);else if(18===a.tag)r?Jn(o,a.stateNode):Qn(o,a.stateNode);else if(4===a.tag){if(null!==a.child){o=a.stateNode.containerInfo,r=!0,a.child.return=a,a=a.child;continue}}else if(xa(n,a,t),null!==a.child){a.child.return=a,a=a.child;continue}if(a===e)break;for(;null===a.sibling;){if(null===a.return||a.return===e)return;4===(a=a.return).tag&&(v=!1)}a.sibling.return=a.return,a=a.sibling}}function za(n,e){if(Y){switch(e.tag){case 0:case 11:case 14:case 15:return ma(3,e,e.return),da(3,e),void ma(5,e,e.return);case 1:case 12:case 17:return;case 5:var t=e.stateNode;if(null!=t){var o=e.memoizedProps;n=null!==n?n.memoizedProps:o;var r=e.type,a=e.updateQueue;e.updateQueue=null,null!==a&&hn(t,a,r,n,o,e)}return;case 6:if(null===e.stateNode)throw Error(i(162));return t=e.memoizedProps,void mn(e.stateNode,null!==n?n.memoizedProps:t,t);case 3:return void(Q&&null!==n&&n.memoizedState.isDehydrated&&Yn(e.stateNode.containerInfo));case 13:case 19:return void ka(e)}throw Error(i(163))}switch(e.tag){case 0:case 11:case 14:case 15:return ma(3,e,e.return),da(3,e),void ma(5,e,e.return);case 12:case 22:case 23:return;case 13:case 19:return void ka(e);case 3:Q&&null!==n&&n.memoizedState.isDehydrated&&Yn(e.stateNode.containerInfo)}n:if(Z){switch(e.tag){case 1:case 5:case 6:break n;case 3:case 4:e=e.stateNode,Dn(e.containerInfo,e.pendingChildren);break n}throw Error(i(163))}}function ka(n){var e=n.updateQueue;if(null!==e){n.updateQueue=null;var t=n.stateNode;null===t&&(t=n.stateNode=new la),e.forEach((function(e){var o=Zi.bind(null,n,e);t.has(e)||(t.add(e),e.then(o,o))}))}}function Ca(n,e,t){sa=n,Ta(n,e,t)}function Ta(n,e,t){for(var o=0!==(1&n.mode);null!==sa;){var r=sa,a=r.child;if(22===r.tag&&o){var i=null!==r.memoizedState||va;if(!i){var v=r.alternate,c=null!==v&&null!==v.memoizedState||ca;v=va;var l=ca;if(va=i,(ca=c)&&!l)for(sa=r;null!==sa;)c=(i=sa).child,22===i.tag&&null!==i.memoizedState?Pa(r):null!==c?(c.return=i,sa=c):Pa(r);for(;null!==a;)sa=a,Ta(a,e,t),a=a.sibling;sa=r,va=v,ca=l}Ra(n)}else 0!==(8772&r.subtreeFlags)&&null!==a?(a.return=r,sa=a):Ra(n)}}function Ra(n){for(;null!==sa;){var e=sa;if(0!==(8772&e.flags)){var t=e.alternate;try{if(0!==(8772&e.flags))switch(e.tag){case 0:case 11:case 15:ca||da(5,e);break;case 1:var o=e.stateNode;if(4&e.flags&&!ca)if(null===t)o.componentDidMount();else{var r=e.elementType===e.type?t.memoizedProps:et(e.type,t.memoizedProps);o.componentDidUpdate(r,t.memoizedState,o.__reactInternalSnapshotBeforeUpdate)}var a=e.updateQueue;null!==a&&_t(e,a,o);break;case 3:var v=e.updateQueue;if(null!==v){if(t=null,null!==e.child)switch(e.child.tag){case 5:t=F(e.child.stateNode);break;case 1:t=e.child.stateNode}_t(e,v,t)}break;case 5:var c=e.stateNode;null===t&&4&e.flags&&dn(c,e.type,e.memoizedProps,e);break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:break;case 13:if(Q&&null===e.memoizedState){var l=e.alternate;if(null!==l){var s=l.memoizedState;if(null!==s){var u=s.dehydrated;null!==u&&Zn(u)}}}break;default:throw Error(i(163))}ca||512&e.flags&&ha(e)}catch(f){Wi(e,e.return,f)}}if(e===n){sa=null;break}if(null!==(t=e.sibling)){t.return=e.return,sa=t;break}sa=e.return}}function Da(n){for(;null!==sa;){var e=sa;if(e===n){sa=null;break}var t=e.sibling;if(null!==t){t.return=e.return,sa=t;break}sa=e.return}}function Pa(n){for(;null!==sa;){var e=sa;try{switch(e.tag){case 0:case 11:case 15:var t=e.return;try{da(4,e)}catch(c){Wi(e,t,c)}break;case 1:var o=e.stateNode;if("function"===typeof o.componentDidMount){var r=e.return;try{o.componentDidMount()}catch(c){Wi(e,r,c)}}var a=e.return;try{ha(e)}catch(c){Wi(e,a,c)}break;case 5:var i=e.return;try{ha(e)}catch(c){Wi(e,i,c)}}}catch(c){Wi(e,e.return,c)}if(e===n){sa=null;break}var v=e.sibling;if(null!==v){v.return=e.return,sa=v;break}sa=e.return}}var Fa=0,ja=1,Ia=2,Ea=3,Oa=4;if("function"===typeof Symbol&&Symbol.for){var La=Symbol.for;Fa=La("selector.component"),ja=La("selector.has_pseudo_class"),Ia=La("selector.role"),Ea=La("selector.test_id"),Oa=La("selector.text")}function Aa(n){var e=J(n);if(null!=e){if("string"!==typeof e.memoizedProps["data-testname"])throw Error(i(364));return e}if(null===(n=rn(n)))throw Error(i(362));return n.stateNode.current}function Ga(n,e){switch(e.$$typeof){case Fa:if(n.type===e.value)return!0;break;case ja:n:{e=e.value,n=[n,0];for(var t=0;t<n.length;){var o=n[t++],r=n[t++],a=e[r];if(5!==o.tag||!cn(o)){for(;null!=a&&Ga(o,a);)a=e[++r];if(r===e.length){e=!0;break n}for(o=o.child;null!==o;)n.push(o,r),o=o.sibling}}e=!1}return e;case Ia:if(5===n.tag&&ln(n.stateNode,e.value))return!0;break;case Oa:if((5===n.tag||6===n.tag)&&(null!==(n=vn(n))&&0<=n.indexOf(e.value)))return!0;break;case Ea:if(5===n.tag&&("string"===typeof(n=n.memoizedProps["data-testname"])&&n.toLowerCase()===e.value.toLowerCase()))return!0;break;default:throw Error(i(365))}return!1}function Na(n){switch(n.$$typeof){case Fa:return"<"+(w(n.value)||"Unknown")+">";case ja:return":has("+(Na(n)||"")+")";case Ia:return'[role="'+n.value+'"]';case Oa:return'"'+n.value+'"';case Ea:return'[data-testname="'+n.value+'"]';default:throw Error(i(365))}}function Ba(n,e){var t=[];n=[n,0];for(var o=0;o<n.length;){var r=n[o++],a=n[o++],i=e[a];if(5!==r.tag||!cn(r)){for(;null!=i&&Ga(r,i);)i=e[++a];if(a===e.length)t.push(r);else for(r=r.child;null!==r;)n.push(r,a),r=r.sibling}}return t}function qa(n,e){if(!on)throw Error(i(363));n=Ba(n=Aa(n),e),e=[],n=Array.from(n);for(var t=0;t<n.length;){var o=n[t++];if(5===o.tag)cn(o)||e.push(o.stateNode);else for(o=o.child;null!==o;)n.push(o),o=o.sibling}return e}var Va=Math.ceil,Wa=v.ReactCurrentDispatcher,Ha=v.ReactCurrentOwner,Xa=v.ReactCurrentBatchConfig,Ya=0,Za=null,Qa=null,Ja=0,Ka=0,$a=ve(0),ni=0,ei=null,ti=0,oi=0,ri=0,ai=null,ii=null,vi=0,ci=1/0;function li(){ci=Ae()+500}var si,ui=!1,fi=null,pi=null,mi=!1,di=null,hi=0,xi=0,yi=null,gi=-1,bi=0;function _i(){return 0!==(6&Ya)?Ae():-1!==gi?gi:gi=Ae()}function Ui(n){return 0===(1&n.mode)?1:0!==(2&Ya)&&0!==Ja?Ja&-Ja:null!==Ke.transition?(0===bi&&(n=Se,0===(4194240&(Se<<=1))&&(Se=64),bi=n),bi):0!==(n=Fe)?n:$()}function wi(n,e,t){if(50<xi)throw xi=0,yi=null,Error(i(185));var o=Si(n,e);return null===o?null:(De(o,e,t),0!==(2&Ya)&&o===Za||(o===Za&&(0===(2&Ya)&&(oi|=e),4===ni&&Ti(o,Ja)),Mi(o,t),1===e&&0===Ya&&0===(1&n.mode)&&(li(),Ye&&Je())),o)}function Si(n,e){n.lanes|=e;var t=n.alternate;for(null!==t&&(t.lanes|=e),t=n,n=n.return;null!==n;)n.childLanes|=e,null!==(t=n.alternate)&&(t.childLanes|=e),t=n,n=n.return;return 3===t.tag?t.stateNode:null}function Mi(n,e){var t=n.callbackNode;!function(n,e){for(var t=n.suspendedLanes,o=n.pingedLanes,r=n.expirationTimes,a=n.pendingLanes;0<a;){var i=31-_e(a),v=1<<i,c=r[i];-1===c?0!==(v&t)&&0===(v&o)||(r[i]=Ce(v,e)):c<=e&&(n.expiredLanes|=v),a&=~v}}(n,e);var o=ke(n,n===Za?Ja:0);if(0===o)null!==t&&Ee(t),n.callbackNode=null,n.callbackPriority=0;else if(e=o&-o,n.callbackPriority!==e){if(null!=t&&Ee(t),1===e)0===n.tag?function(n){Ye=!0,Qe(n)}(Ri.bind(null,n)):Qe(Ri.bind(null,n)),en?tn((function(){0===Ya&&Je()})):Ie(Ge,Je),t=null;else{switch(je(o)){case 1:t=Ge;break;case 4:t=Ne;break;case 16:default:t=Be;break;case 536870912:t=qe}t=Qi(t,zi.bind(null,n))}n.callbackPriority=e,n.callbackNode=t}}function zi(n,e){if(gi=-1,bi=0,0!==(6&Ya))throw Error(i(327));var t=n.callbackNode;if(qi()&&n.callbackNode!==t)return null;var o=ke(n,n===Za?Ja:0);if(0===o)return null;if(0!==(30&o)||0!==(o&n.expiredLanes)||e)e=Oi(n,o);else{e=o;var r=Ya;Ya|=2;var a=Ii();for(Za===n&&Ja===e||(li(),Fi(n,e));;)try{Ai();break}catch(c){ji(n,c)}it(),Wa.current=a,Ya=r,null!==Qa?e=0:(Za=null,Ja=0,e=ni)}if(0!==e){if(2===e&&(0!==(r=Te(n))&&(o=r,e=ki(n,r))),1===e)throw t=ei,Fi(n,0),Ti(n,o),Mi(n,Ae()),t;if(6===e)Ti(n,o);else{if(r=n.current.alternate,0===(30&o)&&!function(n){for(var e=n;;){if(16384&e.flags){var t=e.updateQueue;if(null!==t&&null!==(t=t.stores))for(var o=0;o<t.length;o++){var r=t[o],a=r.getSnapshot;r=r.value;try{if(!He(a(),r))return!1}catch(v){return!1}}}if(t=e.child,16384&e.subtreeFlags&&null!==t)t.return=e,e=t;else{if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(r)&&(2===(e=Oi(n,o))&&(0!==(a=Te(n))&&(o=a,e=ki(n,a))),1===e))throw t=ei,Fi(n,0),Ti(n,o),Mi(n,Ae()),t;switch(n.finishedWork=r,n.finishedLanes=o,e){case 0:case 1:throw Error(i(345));case 2:case 5:Bi(n,ii);break;case 3:if(Ti(n,o),(130023424&o)===o&&10<(e=vi+500-Ae())){if(0!==ke(n,0))break;if(((r=n.suspendedLanes)&o)!==o){_i(),n.pingedLanes|=n.suspendedLanes&r;break}n.timeoutHandle=V(Bi.bind(null,n,ii),e);break}Bi(n,ii);break;case 4:if(Ti(n,o),(4194240&o)===o)break;for(e=n.eventTimes,r=-1;0<o;){var v=31-_e(o);a=1<<v,(v=e[v])>r&&(r=v),o&=~a}if(o=r,10<(o=(120>(o=Ae()-o)?120:480>o?480:1080>o?1080:1920>o?1920:3e3>o?3e3:4320>o?4320:1960*Va(o/1960))-o)){n.timeoutHandle=V(Bi.bind(null,n,ii),o);break}Bi(n,ii);break;default:throw Error(i(329))}}}return Mi(n,Ae()),n.callbackNode===t?zi.bind(null,n):null}function ki(n,e){var t=ai;return n.current.memoizedState.isDehydrated&&(Fi(n,e).flags|=256),2!==(n=Oi(n,e))&&(e=ii,ii=t,null!==e&&Ci(e)),n}function Ci(n){null===ii?ii=n:ii.push.apply(ii,n)}function Ti(n,e){for(e&=~ri,e&=~oi,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-_e(e),o=1<<t;n[t]=-1,e&=~o}}function Ri(n){if(0!==(6&Ya))throw Error(i(327));qi();var e=ke(n,0);if(0===(1&e))return Mi(n,Ae()),null;var t=Oi(n,e);if(0!==n.tag&&2===t){var o=Te(n);0!==o&&(e=o,t=ki(n,o))}if(1===t)throw t=ei,Fi(n,0),Ti(n,e),Mi(n,Ae()),t;if(6===t)throw Error(i(345));return n.finishedWork=n.current.alternate,n.finishedLanes=e,Bi(n,ii),Mi(n,Ae()),null}function Di(n){null!==di&&0===di.tag&&0===(6&Ya)&&qi();var e=Ya;Ya|=1;var t=Xa.transition,o=Fe;try{if(Xa.transition=null,Fe=1,n)return n()}finally{Fe=o,Xa.transition=t,0===(6&(Ya=e))&&Je()}}function Pi(){Ka=$a.current,ce($a)}function Fi(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(t!==H&&(n.timeoutHandle=H,W(t)),null!==Qa)for(t=Qa.return;null!==t;){var o=t;switch(Nt(o),o.tag){case 1:null!==(o=o.type.childContextTypes)&&void 0!==o&&he();break;case 3:po(),ce(fe),ce(ue),bo();break;case 5:ho(o);break;case 4:po();break;case 13:case 19:ce(xo);break;case 10:ct(o.type._context);break;case 22:case 23:Pi()}t=t.return}if(Za=n,Qa=n=nv(n.current,null),Ja=Ka=e,ni=0,ei=null,ri=oi=ti=0,ii=ai=null,null!==ft){for(e=0;e<ft.length;e++)if(null!==(o=(t=ft[e]).interleaved)){t.interleaved=null;var r=o.next,a=t.pending;if(null!==a){var i=a.next;a.next=r,o.next=i}t.pending=o}ft=null}return n}function ji(n,e){for(;;){var t=Qa;try{if(it(),_o.current=mr,ko){for(var o=So.memoizedState;null!==o;){var r=o.queue;null!==r&&(r.pending=null),o=o.next}ko=!1}if(wo=0,zo=Mo=So=null,Co=!1,To=0,Ha.current=null,null===t||null===t.return){ni=1,ei=e,Qa=null;break}n:{var a=n,v=t.return,c=t,l=e;if(e=Ja,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var s=l,u=c,f=u.tag;if(0===(1&u.mode)&&(0===f||11===f||15===f)){var p=u.alternate;p?(u.updateQueue=p.updateQueue,u.memoizedState=p.memoizedState,u.lanes=p.lanes):(u.updateQueue=null,u.memoizedState=null)}var m=Cr(v);if(null!==m){m.flags&=-257,Tr(m,v,c,0,e),1&m.mode&&kr(a,s,e),l=s;var d=(e=m).updateQueue;if(null===d){var h=new Set;h.add(l),e.updateQueue=h}else d.add(l);break n}if(0===(1&e)){kr(a,s,e),Ei();break n}l=Error(i(426))}else if(Vt&&1&c.mode){var x=Cr(v);if(null!==x){0===(65536&x.flags)&&(x.flags|=256),Tr(x,v,c,0,e),no(l);break n}}a=l,4!==ni&&(ni=2),null===ai?ai=[a]:ai.push(a),l=yr(l,c),c=v;do{switch(c.tag){case 3:c.flags|=65536,e&=-e,c.lanes|=e,gt(c,Mr(0,l,e));break n;case 1:a=l;var y=c.type,g=c.stateNode;if(0===(128&c.flags)&&("function"===typeof y.getDerivedStateFromError||null!==g&&"function"===typeof g.componentDidCatch&&(null===pi||!pi.has(g)))){c.flags|=65536,e&=-e,c.lanes|=e,gt(c,zr(c,a,e));break n}}c=c.return}while(null!==c)}Ni(t)}catch(b){e=b,Qa===t&&null!==t&&(Qa=t=t.return);continue}break}}function Ii(){var n=Wa.current;return Wa.current=mr,null===n?mr:n}function Ei(){0!==ni&&3!==ni&&2!==ni||(ni=4),null===Za||0===(268435455&ti)&&0===(268435455&oi)||Ti(Za,Ja)}function Oi(n,e){var t=Ya;Ya|=2;var o=Ii();for(Za===n&&Ja===e||Fi(n,e);;)try{Li();break}catch(r){ji(n,r)}if(it(),Ya=t,Wa.current=o,null!==Qa)throw Error(i(261));return Za=null,Ja=0,ni}function Li(){for(;null!==Qa;)Gi(Qa)}function Ai(){for(;null!==Qa&&!Oe();)Gi(Qa)}function Gi(n){var e=si(n.alternate,n,Ka);n.memoizedProps=n.pendingProps,null===e?Ni(n):Qa=e,Ha.current=null}function Ni(n){var e=n;do{var t=e.alternate;if(n=e.return,0===(32768&e.flags)){if(null!==(t=Ir(t,e,Ka)))return void(Qa=t)}else{if(null!==(t=ia(t,e)))return t.flags&=32767,void(Qa=t);if(null===n)return ni=6,void(Qa=null);n.flags|=32768,n.subtreeFlags=0,n.deletions=null}if(null!==(e=e.sibling))return void(Qa=e);Qa=e=n}while(null!==e);0===ni&&(ni=5)}function Bi(n,e){var t=Fe,o=Xa.transition;try{Xa.transition=null,Fe=1,function(n,e,t){do{qi()}while(null!==di);if(0!==(6&Ya))throw Error(i(327));var o=n.finishedWork,r=n.finishedLanes;if(null===o)return null;if(n.finishedWork=null,n.finishedLanes=0,o===n.current)throw Error(i(177));n.callbackNode=null,n.callbackPriority=0;var a=o.lanes|o.childLanes;if(function(n,e){var t=n.pendingLanes&~e;n.pendingLanes=e,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=e,n.mutableReadLanes&=e,n.entangledLanes&=e,e=n.entanglements;var o=n.eventTimes;for(n=n.expirationTimes;0<t;){var r=31-_e(t),a=1<<r;e[r]=0,o[r]=-1,n[r]=-1,t&=~a}}(n,a),n===Za&&(Qa=Za=null,Ja=0),0===(2064&o.subtreeFlags)&&0===(2064&o.flags)||mi||(mi=!0,Qi(Be,(function(){return qi(),null}))),a=0!==(15990&o.flags),0!==(15990&o.subtreeFlags)||a){a=Xa.transition,Xa.transition=null;var v=Fe;Fe=1;var c=Ya;Ya|=4,Ha.current=null,function(n,e){for(E(n.containerInfo),sa=e;null!==sa;)if(e=(n=sa).child,0!==(1028&n.subtreeFlags)&&null!==e)e.return=n,sa=e;else for(;null!==sa;){n=sa;try{var t=n.alternate;if(0!==(1024&n.flags))switch(n.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==t){var o=t.memoizedProps,r=t.memoizedState,a=n.stateNode,v=a.getSnapshotBeforeUpdate(n.elementType===n.type?o:et(n.type,o),r);a.__reactInternalSnapshotBeforeUpdate=v}break;case 3:Y&&zn(n.stateNode.containerInfo);break;default:throw Error(i(163))}}catch(c){Wi(n,n.return,c)}if(null!==(e=n.sibling)){e.return=n.return,sa=e;break}sa=n.return}t=pa,pa=!1}(n,o),function(n,e){for(sa=e;null!==sa;){var t=(e=sa).deletions;if(null!==t)for(var o=0;o<t.length;o++){var r=t[o];try{var a=n;Y?Ma(a,r,e):ya(a,r,e);var i=r.alternate;null!==i&&(i.return=null),r.return=null}catch(_){Wi(r,e,_)}}if(t=e.child,0!==(12854&e.subtreeFlags)&&null!==t)t.return=e,sa=t;else for(;null!==sa;){e=sa;try{var v=e.flags;if(32&v&&Y&&_n(e.stateNode),512&v){var c=e.alternate;if(null!==c){var l=c.ref;null!==l&&("function"===typeof l?l(null):l.current=null)}}if(8192&v)switch(e.tag){case 13:if(null!==e.memoizedState){var s=e.alternate;null!==s&&null!==s.memoizedState||(vi=Ae())}break;case 22:var u=null!==e.memoizedState,f=e.alternate,p=null!==f&&null!==f.memoizedState;if(t=e,Y)n:if(o=t,r=u,a=null,Y)for(var m=o;;){if(5===m.tag){if(null===a){a=m;var d=m.stateNode;r?Un(d):Sn(m.stateNode,m.memoizedProps)}}else if(6===m.tag){if(null===a){var h=m.stateNode;r?wn(h):Mn(h,m.memoizedProps)}}else if((22!==m.tag&&23!==m.tag||null===m.memoizedState||m===o)&&null!==m.child){m.child.return=m,m=m.child;continue}if(m===o)break;for(;null===m.sibling;){if(null===m.return||m.return===o)break n;a===m&&(a=null),m=m.return}a===m&&(a=null),m.sibling.return=m.return,m=m.sibling}if(u&&!p&&0!==(1&t.mode)){sa=t;for(var x=t.child;null!==x;){for(t=sa=x;null!==sa;){var y=(o=sa).child;switch(o.tag){case 0:case 11:case 14:case 15:ma(4,o,o.return);break;case 1:ua(o,o.return);var g=o.stateNode;if("function"===typeof g.componentWillUnmount){var b=o.return;try{g.props=o.memoizedProps,g.state=o.memoizedState,g.componentWillUnmount()}catch(_){Wi(o,b,_)}}break;case 5:ua(o,o.return);break;case 22:if(null!==o.memoizedState){Da(t);continue}}null!==y?(y.return=o,sa=y):Da(t)}x=x.sibling}}}switch(4102&v){case 2:Ua(e),e.flags&=-3;break;case 6:Ua(e),e.flags&=-3,za(e.alternate,e);break;case 4096:e.flags&=-4097;break;case 4100:e.flags&=-4097,za(e.alternate,e);break;case 4:za(e.alternate,e)}}catch(_){Wi(e,e.return,_)}if(null!==(t=e.sibling)){t.return=e.return,sa=t;break}sa=e.return}}}(n,o),O(n.containerInfo),n.current=o,Ca(o,n,r),Le(),Ya=c,Fe=v,Xa.transition=a}else n.current=o;if(mi&&(mi=!1,di=n,hi=r),0===(a=n.pendingLanes)&&(pi=null),function(n){if(We&&"function"===typeof We.onCommitFiberRoot)try{We.onCommitFiberRoot(Ve,n,void 0,128===(128&n.current.flags))}catch(e){}}(o.stateNode),Mi(n,Ae()),null!==e)for(t=n.onRecoverableError,o=0;o<e.length;o++)t(e[o]);if(ui)throw ui=!1,n=fi,fi=null,n;0!==(1&hi)&&0!==n.tag&&qi(),0!==(1&(a=n.pendingLanes))?n===yi?xi++:(xi=0,yi=n):xi=0,Je()}(n,e,t)}finally{Xa.transition=o,Fe=t}return null}function qi(){if(null!==di){var n=je(hi),e=Xa.transition,t=Fe;try{if(Xa.transition=null,Fe=16>n?16:n,null===di)var o=!1;else{if(n=di,di=null,hi=0,0!==(6&Ya))throw Error(i(331));var r=Ya;for(Ya|=4,sa=n.current;null!==sa;){var a=sa,v=a.child;if(0!==(16&sa.flags)){var c=a.deletions;if(null!==c){for(var l=0;l<c.length;l++){var s=c[l];for(sa=s;null!==sa;){var u=sa;switch(u.tag){case 0:case 11:case 15:ma(8,u,a)}var f=u.child;if(null!==f)f.return=u,sa=f;else for(;null!==sa;){var p=(u=sa).sibling,m=u.return;if(ga(u),u===s){sa=null;break}if(null!==p){p.return=m,sa=p;break}sa=m}}}var d=a.alternate;if(null!==d){var h=d.child;if(null!==h){d.child=null;do{var x=h.sibling;h.sibling=null,h=x}while(null!==h)}}sa=a}}if(0!==(2064&a.subtreeFlags)&&null!==v)v.return=a,sa=v;else n:for(;null!==sa;){if(0!==(2048&(a=sa).flags))switch(a.tag){case 0:case 11:case 15:ma(9,a,a.return)}var y=a.sibling;if(null!==y){y.return=a.return,sa=y;break n}sa=a.return}}var g=n.current;for(sa=g;null!==sa;){var b=(v=sa).child;if(0!==(2064&v.subtreeFlags)&&null!==b)b.return=v,sa=b;else n:for(v=g;null!==sa;){if(0!==(2048&(c=sa).flags))try{switch(c.tag){case 0:case 11:case 15:da(9,c)}}catch(U){Wi(c,c.return,U)}if(c===v){sa=null;break n}var _=c.sibling;if(null!==_){_.return=c.return,sa=_;break n}sa=c.return}}if(Ya=r,Je(),We&&"function"===typeof We.onPostCommitFiberRoot)try{We.onPostCommitFiberRoot(Ve,n)}catch(U){}o=!0}return o}finally{Fe=t,Xa.transition=e}}return!1}function Vi(n,e,t){xt(n,e=Mr(0,e=yr(t,e),1)),e=_i(),null!==(n=Si(n,1))&&(De(n,1,e),Mi(n,e))}function Wi(n,e,t){if(3===n.tag)Vi(n,n,t);else for(;null!==e;){if(3===e.tag){Vi(e,n,t);break}if(1===e.tag){var o=e.stateNode;if("function"===typeof e.type.getDerivedStateFromError||"function"===typeof o.componentDidCatch&&(null===pi||!pi.has(o))){xt(e,n=zr(e,n=yr(t,n),1)),n=_i(),null!==(e=Si(e,1))&&(De(e,1,n),Mi(e,n));break}}e=e.return}}function Hi(n,e,t){var o=n.pingCache;null!==o&&o.delete(e),e=_i(),n.pingedLanes|=n.suspendedLanes&t,Za===n&&(Ja&t)===t&&(4===ni||3===ni&&(130023424&Ja)===Ja&&500>Ae()-vi?Fi(n,0):ri|=t),Mi(n,e)}function Xi(n,e){0===e&&(0===(1&n.mode)?e=1:(e=Me,0===(130023424&(Me<<=1))&&(Me=4194304)));var t=_i();null!==(n=Si(n,e))&&(De(n,e,t),Mi(n,t))}function Yi(n){var e=n.memoizedState,t=0;null!==e&&(t=e.retryLane),Xi(n,t)}function Zi(n,e){var t=0;switch(n.tag){case 13:var o=n.stateNode,r=n.memoizedState;null!==r&&(t=r.retryLane);break;case 19:o=n.stateNode;break;default:throw Error(i(314))}null!==o&&o.delete(e),Xi(n,t)}function Qi(n,e){return Ie(n,e)}function Ji(n,e,t,o){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=o,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ki(n,e,t,o){return new Ji(n,e,t,o)}function $i(n){return!(!(n=n.prototype)||!n.isReactComponent)}function nv(n,e){var t=n.alternate;return null===t?((t=Ki(n.tag,e,n.key,n.mode)).elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=14680064&n.flags,t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function ev(n,e,t,o,r,a){var v=2;if(o=n,"function"===typeof n)$i(n)&&(v=1);else if("string"===typeof n)v=5;else n:switch(n){case s:return tv(t.children,r,a,e);case u:v=8,r|=8;break;case f:return(n=Ki(12,t,e,2|r)).elementType=f,n.lanes=a,n;case h:return(n=Ki(13,t,e,r)).elementType=h,n.lanes=a,n;case x:return(n=Ki(19,t,e,r)).elementType=x,n.lanes=a,n;case b:return ov(t,r,a,e);default:if("object"===typeof n&&null!==n)switch(n.$$typeof){case p:v=10;break n;case m:v=9;break n;case d:v=11;break n;case y:v=14;break n;case g:v=16,o=null;break n}throw Error(i(130,null==n?n:typeof n,""))}return(e=Ki(v,t,e,r)).elementType=n,e.type=o,e.lanes=a,e}function tv(n,e,t,o){return(n=Ki(7,n,o,e)).lanes=t,n}function ov(n,e,t,o){return(n=Ki(22,n,o,e)).elementType=b,n.lanes=t,n.stateNode={},n}function rv(n,e,t){return(n=Ki(6,n,null,e)).lanes=t,n}function av(n,e,t){return(e=Ki(4,null!==n.children?n.children:[],n.key,e)).lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function iv(n,e,t,o,r){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=H,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Re(0),this.expirationTimes=Re(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Re(0),this.identifierPrefix=o,this.onRecoverableError=r,Q&&(this.mutableSourceEagerHydrationData=null)}function vv(n,e,t,o,r,a,i,v,c){return n=new iv(n,e,t,v,c),1===e?(e=1,!0===a&&(e|=8)):e=0,a=Ki(3,null,null,e),n.current=a,a.stateNode=n,a.memoizedState={element:o,isDehydrated:t,cache:null,transitions:null},mt(a),n}function cv(n){if(!n)return se;n:{if(M(n=n._reactInternals)!==n||1!==n.tag)throw Error(i(170));var e=n;do{switch(e.tag){case 3:e=e.stateNode.context;break n;case 1:if(de(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break n}}e=e.return}while(null!==e);throw Error(i(171))}if(1===n.tag){var t=n.type;if(de(t))return ye(n,t,e)}return e}function lv(n){var e=n._reactInternals;if(void 0===e){if("function"===typeof n.render)throw Error(i(188));throw n=Object.keys(n).join(","),Error(i(268,n))}return null===(n=C(e))?null:n.stateNode}function sv(n,e){if(null!==(n=n.memoizedState)&&null!==n.dehydrated){var t=n.retryLane;n.retryLane=0!==t&&t<e?t:e}}function uv(n,e){sv(n,e),(n=n.alternate)&&sv(n,e)}function fv(n){return null===(n=C(n))?null:n.stateNode}function pv(){return null}return si=function(n,e,t){if(null!==n)if(n.memoizedProps!==e.pendingProps||fe.current)Or=!0;else{if(0===(n.lanes&t)&&0===(128&e.flags))return Or=!1,function(n,e,t){switch(e.tag){case 3:Xr(e),$t();break;case 5:mo(e);break;case 1:de(e.type)&&ge(e);break;case 4:fo(e,e.stateNode.containerInfo);break;case 10:vt(0,e.type._context,e.memoizedProps.value);break;case 13:var o=e.memoizedState;if(null!==o)return null!==o.dehydrated?(le(xo,1&xo.current),e.flags|=128,null):0!==(t&e.child.childLanes)?Jr(n,e,t):(le(xo,1&xo.current),null!==(n=aa(n,e,t))?n.sibling:null);le(xo,1&xo.current);break;case 19:if(o=0!==(t&e.childLanes),0!==(128&n.flags)){if(o)return ra(n,e,t);e.flags|=128}var r=e.memoizedState;if(null!==r&&(r.rendering=null,r.tail=null,r.lastEffect=null),le(xo,xo.current),o)break;return null;case 22:case 23:return e.lanes=0,Br(n,e,t)}return aa(n,e,t)}(n,e,t);Or=0!==(131072&n.flags)}else Or=!1,Vt&&0!==(1048576&e.flags)&&At(e,Pt,e.index);switch(e.lanes=0,e.tag){case 2:var o=e.type;null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),n=e.pendingProps;var r=me(e,ue.current);st(e,t),r=Fo(null,e,o,n,r,t);var a=jo();return e.flags|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,de(o)?(a=!0,ge(e)):a=!1,e.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,mt(e),r.updater=St,e.stateNode=r,r._reactInternals=e,Ct(e,o,n,t),e=Hr(null,e,o,!0,a,t)):(e.tag=0,Vt&&a&&Gt(e),Lr(null,e,r,t),e=e.child),e;case 16:o=e.elementType;n:{switch(null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),n=e.pendingProps,o=(r=o._init)(o._payload),e.type=o,r=e.tag=function(n){if("function"===typeof n)return $i(n)?1:0;if(void 0!==n&&null!==n){if((n=n.$$typeof)===d)return 11;if(n===y)return 14}return 2}(o),n=et(o,n),r){case 0:e=Vr(null,e,o,n,t);break n;case 1:e=Wr(null,e,o,n,t);break n;case 11:e=Ar(null,e,o,n,t);break n;case 14:e=Gr(null,e,o,et(o.type,n),t);break n}throw Error(i(306,o,""))}return e;case 0:return o=e.type,r=e.pendingProps,Vr(n,e,o,r=e.elementType===o?r:et(o,r),t);case 1:return o=e.type,r=e.pendingProps,Wr(n,e,o,r=e.elementType===o?r:et(o,r),t);case 3:n:{if(Xr(e),null===n)throw Error(i(387));o=e.pendingProps,r=(a=e.memoizedState).element,dt(n,e),bt(e,o,null,t);var v=e.memoizedState;if(o=v.element,Q&&a.isDehydrated){if(a={element:o,isDehydrated:!1,cache:v.cache,transitions:v.transitions},e.updateQueue.baseState=a,e.memoizedState=a,256&e.flags){e=Yr(n,e,o,t,r=Error(i(423)));break n}if(o!==r){e=Yr(n,e,o,t,r=Error(i(424)));break n}for(Q&&(qt=Bn(e.stateNode.containerInfo),Bt=e,Vt=!0,Ht=null,Wt=!1),t=io(e,null,o,t),e.child=t;t;)t.flags=-3&t.flags|4096,t=t.sibling}else{if($t(),o===r){e=aa(n,e,t);break n}Lr(n,e,o,t)}e=e.child}return e;case 5:return mo(e),null===n&&Qt(e),o=e.type,r=e.pendingProps,a=null!==n?n.memoizedProps:null,v=r.children,B(o,r)?v=null:null!==a&&B(o,a)&&(e.flags|=32),qr(n,e),Lr(n,e,v,t),e.child;case 6:return null===n&&Qt(e),null;case 13:return Jr(n,e,t);case 4:return fo(e,e.stateNode.containerInfo),o=e.pendingProps,null===n?e.child=ao(e,null,o,t):Lr(n,e,o,t),e.child;case 11:return o=e.type,r=e.pendingProps,Ar(n,e,o,r=e.elementType===o?r:et(o,r),t);case 7:return Lr(n,e,e.pendingProps,t),e.child;case 8:case 12:return Lr(n,e,e.pendingProps.children,t),e.child;case 10:n:{if(o=e.type._context,r=e.pendingProps,a=e.memoizedProps,vt(0,o,v=r.value),null!==a)if(He(a.value,v)){if(a.children===r.children&&!fe.current){e=aa(n,e,t);break n}}else for(null!==(a=e.child)&&(a.return=e);null!==a;){var c=a.dependencies;if(null!==c){v=a.child;for(var l=c.firstContext;null!==l;){if(l.context===o){if(1===a.tag){(l=ht(-1,t&-t)).tag=2;var s=a.updateQueue;if(null!==s){var u=(s=s.shared).pending;null===u?l.next=l:(l.next=u.next,u.next=l),s.pending=l}}a.lanes|=t,null!==(l=a.alternate)&&(l.lanes|=t),lt(a.return,t,e),c.lanes|=t;break}l=l.next}}else if(10===a.tag)v=a.type===e.type?null:a.child;else if(18===a.tag){if(null===(v=a.return))throw Error(i(341));v.lanes|=t,null!==(c=v.alternate)&&(c.lanes|=t),lt(v,t,e),v=a.sibling}else v=a.child;if(null!==v)v.return=a;else for(v=a;null!==v;){if(v===e){v=null;break}if(null!==(a=v.sibling)){a.return=v.return,v=a;break}v=v.return}a=v}Lr(n,e,r.children,t),e=e.child}return e;case 9:return r=e.type,o=e.pendingProps.children,st(e,t),o=o(r=ut(r)),e.flags|=1,Lr(n,e,o,t),e.child;case 14:return r=et(o=e.type,e.pendingProps),Gr(n,e,o,r=et(o.type,r),t);case 15:return Nr(n,e,e.type,e.pendingProps,t);case 17:return o=e.type,r=e.pendingProps,r=e.elementType===o?r:et(o,r),null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),e.tag=1,de(o)?(n=!0,ge(e)):n=!1,st(e,t),zt(e,o,r),Ct(e,o,r,t),Hr(null,e,o,!0,n,t);case 19:return ra(n,e,t);case 22:return Br(n,e,t)}throw Error(i(156,e.tag))},e.attemptContinuousHydration=function(n){13===n.tag&&(wi(n,134217728,_i()),uv(n,134217728))},e.attemptHydrationAtCurrentPriority=function(n){if(13===n.tag){var e=_i(),t=Ui(n);wi(n,t,e),uv(n,t)}},e.attemptSynchronousHydration=function(n){switch(n.tag){case 3:var e=n.stateNode;if(e.current.memoizedState.isDehydrated){var t=ze(e.pendingLanes);0!==t&&(Pe(e,1|t),Mi(e,Ae()),0===(6&Ya)&&(li(),Je()))}break;case 13:var o=_i();Di((function(){return wi(n,1,o)})),uv(n,1)}},e.batchedUpdates=function(n,e){var t=Ya;Ya|=1;try{return n(e)}finally{0===(Ya=t)&&(li(),Ye&&Je())}},e.createComponentSelector=function(n){return{$$typeof:Fa,value:n}},e.createContainer=function(n,e,t,o,r,a,i){return vv(n,e,!1,null,0,o,0,a,i)},e.createHasPseudoClassSelector=function(n){return{$$typeof:ja,value:n}},e.createHydrationContainer=function(n,e,t,o,r,a,i,v,c){return(n=vv(t,o,!0,n,0,a,0,v,c)).context=cv(null),t=n.current,(a=ht(o=_i(),r=Ui(t))).callback=void 0!==e&&null!==e?e:null,xt(t,a),n.current.lanes=r,De(n,r,o),Mi(n,o),n},e.createPortal=function(n,e,t){var o=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:l,key:null==o?null:""+o,children:n,containerInfo:e,implementation:t}},e.createRoleSelector=function(n){return{$$typeof:Ia,value:n}},e.createTestNameSelector=function(n){return{$$typeof:Ea,value:n}},e.createTextSelector=function(n){return{$$typeof:Oa,value:n}},e.deferredUpdates=function(n){var e=Fe,t=Xa.transition;try{return Xa.transition=null,Fe=16,n()}finally{Fe=e,Xa.transition=t}},e.discreteUpdates=function(n,e,t,o,r){var a=Fe,i=Xa.transition;try{return Xa.transition=null,Fe=1,n(e,t,o,r)}finally{Fe=a,Xa.transition=i,0===Ya&&li()}},e.findAllNodes=qa,e.findBoundingRects=function(n,e){if(!on)throw Error(i(363));e=qa(n,e),n=[];for(var t=0;t<e.length;t++)n.push(an(e[t]));for(e=n.length-1;0<e;e--)for(var o=(t=n[e]).x,r=o+t.width,a=t.y,v=a+t.height,c=e-1;0<=c;c--)if(e!==c){var l=n[c],s=l.x,u=s+l.width,f=l.y,p=f+l.height;if(o>=s&&a>=f&&r<=u&&v<=p){n.splice(e,1);break}if(!(o!==s||t.width!==l.width||p<a||f>v)){f>a&&(l.height+=f-a,l.y=a),p<v&&(l.height=v-f),n.splice(e,1);break}if(!(a!==f||t.height!==l.height||u<o||s>r)){s>o&&(l.width+=s-o,l.x=o),u<r&&(l.width=r-s),n.splice(e,1);break}}return n},e.findHostInstance=lv,e.findHostInstanceWithNoPortals=function(n){return null===(n=null!==(n=k(n))?R(n):null)?null:n.stateNode},e.findHostInstanceWithWarning=function(n){return lv(n)},e.flushControlled=function(n){var e=Ya;Ya|=1;var t=Xa.transition,o=Fe;try{Xa.transition=null,Fe=1,n()}finally{Fe=o,Xa.transition=t,0===(Ya=e)&&(li(),Je())}},e.flushPassiveEffects=qi,e.flushSync=Di,e.focusWithin=function(n,e){if(!on)throw Error(i(363));for(e=Ba(n=Aa(n),e),e=Array.from(e),n=0;n<e.length;){var t=e[n++];if(!cn(t)){if(5===t.tag&&sn(t.stateNode))return!0;for(t=t.child;null!==t;)e.push(t),t=t.sibling}}return!1},e.getCurrentUpdatePriority=function(){return Fe},e.getFindAllNodesFailureDescription=function(n,e){if(!on)throw Error(i(363));var t=0,o=[];n=[Aa(n),0];for(var r=0;r<n.length;){var a=n[r++],v=n[r++],c=e[v];if((5!==a.tag||!cn(a))&&(Ga(a,c)&&(o.push(Na(c)),++v>t&&(t=v)),v<e.length))for(a=a.child;null!==a;)n.push(a,v),a=a.sibling}if(t<e.length){for(n=[];t<e.length;t++)n.push(Na(e[t]));return"findAllNodes was able to match part of the selector:\n  "+o.join(" > ")+"\n\nNo matching component was found for:\n  "+n.join(" > ")}return null},e.getPublicRootInstance=function(n){return(n=n.current).child?5===n.child.tag?F(n.child.stateNode):n.child.stateNode:null},e.injectIntoDevTools=function(n){if(n={bundleType:n.bundleType,version:n.version,rendererPackageName:n.rendererPackageName,rendererConfig:n.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:v.ReactCurrentDispatcher,findHostInstanceByFiber:fv,findFiberByHostInstance:n.findFiberByHostInstance||pv,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},"undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)n=!1;else{var e=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(e.isDisabled||!e.supportsFiber)n=!0;else{try{Ve=e.inject(n),We=e}catch(t){}n=!!e.checkDCE}}return n},e.isAlreadyRendering=function(){return!1},e.observeVisibleRects=function(n,e,t,o){if(!on)throw Error(i(363));n=qa(n,e);var r=un(n,t,o).disconnect;return{disconnect:function(){r()}}},e.registerMutableSourceForHydration=function(n,e){var t=e._getVersion;t=t(e._source),null==n.mutableSourceEagerHydrationData?n.mutableSourceEagerHydrationData=[e,t]:n.mutableSourceEagerHydrationData.push(e,t)},e.runWithPriority=function(n,e){var t=Fe;try{return Fe=n,e()}finally{Fe=t}},e.shouldError=function(){return null},e.shouldSuspend=function(){return!1},e.updateContainer=function(n,e,t,o){var r=e.current,a=_i(),i=Ui(r);return t=cv(t),null===e.context?e.context=t:e.pendingContext=t,(e=ht(a,i)).payload={element:n},null!==(o=void 0===o?null:o)&&(e.callback=o),xt(r,e),null!==(n=wi(r,i,a))&&yt(n,r,i),i},e}},585:function(n,e,t){"use strict";n.exports=t(976)},258:function(n,e,t){"use strict";n.exports=t(721)},783:function(n,e){"use strict";function t(n,e){var t=n.length;n.push(e);n:for(;0<t;){var o=t-1>>>1,r=n[o];if(!(0<a(r,e)))break n;n[o]=e,n[t]=r,t=o}}function o(n){return 0===n.length?null:n[0]}function r(n){if(0===n.length)return null;var e=n[0],t=n.pop();if(t!==e){n[0]=t;n:for(var o=0,r=n.length,i=r>>>1;o<i;){var v=2*(o+1)-1,c=n[v],l=v+1,s=n[l];if(0>a(c,t))l<r&&0>a(s,c)?(n[o]=s,n[l]=t,o=l):(n[o]=c,n[v]=t,o=v);else{if(!(l<r&&0>a(s,t)))break n;n[o]=s,n[l]=t,o=l}}}return e}function a(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var v=Date,c=v.now();e.unstable_now=function(){return v.now()-c}}var l=[],s=[],u=1,f=null,p=3,m=!1,d=!1,h=!1,x="function"===typeof setTimeout?setTimeout:null,y="function"===typeof clearTimeout?clearTimeout:null,g="undefined"!==typeof setImmediate?setImmediate:null;function b(n){for(var e=o(s);null!==e;){if(null===e.callback)r(s);else{if(!(e.startTime<=n))break;r(s),e.sortIndex=e.expirationTime,t(l,e)}e=o(s)}}function _(n){if(h=!1,b(n),!d)if(null!==o(l))d=!0,F(U);else{var e=o(s);null!==e&&j(_,e.startTime-n)}}function U(n,t){d=!1,h&&(h=!1,y(z),z=-1),m=!0;var a=p;try{for(b(t),f=o(l);null!==f&&(!(f.expirationTime>t)||n&&!T());){var i=f.callback;if("function"===typeof i){f.callback=null,p=f.priorityLevel;var v=i(f.expirationTime<=t);t=e.unstable_now(),"function"===typeof v?f.callback=v:f===o(l)&&r(l),b(t)}else r(l);f=o(l)}if(null!==f)var c=!0;else{var u=o(s);null!==u&&j(_,u.startTime-t),c=!1}return c}finally{f=null,p=a,m=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,S=!1,M=null,z=-1,k=5,C=-1;function T(){return!(e.unstable_now()-C<k)}function R(){if(null!==M){var n=e.unstable_now();C=n;var t=!0;try{t=M(!0,n)}finally{t?w():(S=!1,M=null)}}else S=!1}if("function"===typeof g)w=function(){g(R)};else if("undefined"!==typeof MessageChannel){var D=new MessageChannel,P=D.port2;D.port1.onmessage=R,w=function(){P.postMessage(null)}}else w=function(){x(R,0)};function F(n){M=n,S||(S=!0,w())}function j(n,t){z=x((function(){n(e.unstable_now())}),t)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){d||m||(d=!0,F(U))},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):k=0<n?Math.floor(1e3/n):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return o(l)},e.unstable_next=function(n){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var t=p;p=e;try{return n()}finally{p=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=p;p=n;try{return e()}finally{p=t}},e.unstable_scheduleCallback=function(n,r,a){var i=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,n){case 1:var v=-1;break;case 2:v=250;break;case 5:v=1073741823;break;case 4:v=1e4;break;default:v=5e3}return n={id:u++,callback:r,priorityLevel:n,startTime:a,expirationTime:v=a+v,sortIndex:-1},a>i?(n.sortIndex=a,t(s,n),null===o(l)&&n===o(s)&&(h?(y(z),z=-1):h=!0,j(_,a-i))):(n.sortIndex=v,t(l,n),d||m||(d=!0,F(U))),n},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(n){var e=p;return function(){var t=p;p=e;try{return n.apply(this,arguments)}finally{p=t}}}},100:function(n,e,t){"use strict";n.exports=t(783)},374:function(n,e,t){"use strict";var o=t(791),r=Symbol.for("react.element"),a=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,v=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(n,e,t){var o,a={},l=null,s=null;for(o in void 0!==t&&(l=""+t),void 0!==e.key&&(l=""+e.key),void 0!==e.ref&&(s=e.ref),e)i.call(e,o)&&!c.hasOwnProperty(o)&&(a[o]=e[o]);if(n&&n.defaultProps)for(o in e=n.defaultProps)void 0===a[o]&&(a[o]=e[o]);return{$$typeof:r,type:n,key:l,ref:s,props:a,_owner:v.current}}e.Fragment=a,e.jsx=l,e.jsxs=l},117:function(n,e){"use strict";var t=Symbol.for("react.element"),o=Symbol.for("react.portal"),r=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),v=Symbol.for("react.provider"),c=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),s=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),p=Symbol.iterator;var m={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},d=Object.assign,h={};function x(n,e,t){this.props=n,this.context=e,this.refs=h,this.updater=t||m}function y(){}function g(n,e,t){this.props=n,this.context=e,this.refs=h,this.updater=t||m}x.prototype.isReactComponent={},x.prototype.setState=function(n,e){if("object"!==typeof n&&"function"!==typeof n&&null!=n)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,n,e,"setState")},x.prototype.forceUpdate=function(n){this.updater.enqueueForceUpdate(this,n,"forceUpdate")},y.prototype=x.prototype;var b=g.prototype=new y;b.constructor=g,d(b,x.prototype),b.isPureReactComponent=!0;var _=Array.isArray,U=Object.prototype.hasOwnProperty,w={current:null},S={key:!0,ref:!0,__self:!0,__source:!0};function M(n,e,o){var r,a={},i=null,v=null;if(null!=e)for(r in void 0!==e.ref&&(v=e.ref),void 0!==e.key&&(i=""+e.key),e)U.call(e,r)&&!S.hasOwnProperty(r)&&(a[r]=e[r]);var c=arguments.length-2;if(1===c)a.children=o;else if(1<c){for(var l=Array(c),s=0;s<c;s++)l[s]=arguments[s+2];a.children=l}if(n&&n.defaultProps)for(r in c=n.defaultProps)void 0===a[r]&&(a[r]=c[r]);return{$$typeof:t,type:n,key:i,ref:v,props:a,_owner:w.current}}function z(n){return"object"===typeof n&&null!==n&&n.$$typeof===t}var k=/\/+/g;function C(n,e){return"object"===typeof n&&null!==n&&null!=n.key?function(n){var e={"=":"=0",":":"=2"};return"$"+n.replace(/[=:]/g,(function(n){return e[n]}))}(""+n.key):e.toString(36)}function T(n,e,r,a,i){var v=typeof n;"undefined"!==v&&"boolean"!==v||(n=null);var c=!1;if(null===n)c=!0;else switch(v){case"string":case"number":c=!0;break;case"object":switch(n.$$typeof){case t:case o:c=!0}}if(c)return i=i(c=n),n=""===a?"."+C(c,0):a,_(i)?(r="",null!=n&&(r=n.replace(k,"$&/")+"/"),T(i,e,r,"",(function(n){return n}))):null!=i&&(z(i)&&(i=function(n,e){return{$$typeof:t,type:n.type,key:e,ref:n.ref,props:n.props,_owner:n._owner}}(i,r+(!i.key||c&&c.key===i.key?"":(""+i.key).replace(k,"$&/")+"/")+n)),e.push(i)),1;if(c=0,a=""===a?".":a+":",_(n))for(var l=0;l<n.length;l++){var s=a+C(v=n[l],l);c+=T(v,e,r,s,i)}else if(s=function(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=p&&n[p]||n["@@iterator"])?n:null}(n),"function"===typeof s)for(n=s.call(n),l=0;!(v=n.next()).done;)c+=T(v=v.value,e,r,s=a+C(v,l++),i);else if("object"===v)throw e=String(n),Error("Objects are not valid as a React child (found: "+("[object Object]"===e?"object with keys {"+Object.keys(n).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return c}function R(n,e,t){if(null==n)return n;var o=[],r=0;return T(n,o,"","",(function(n){return e.call(t,n,r++)})),o}function D(n){if(-1===n._status){var e=n._result;(e=e()).then((function(e){0!==n._status&&-1!==n._status||(n._status=1,n._result=e)}),(function(e){0!==n._status&&-1!==n._status||(n._status=2,n._result=e)})),-1===n._status&&(n._status=0,n._result=e)}if(1===n._status)return n._result.default;throw n._result}var P={current:null},F={transition:null},j={ReactCurrentDispatcher:P,ReactCurrentBatchConfig:F,ReactCurrentOwner:w};e.Children={map:R,forEach:function(n,e,t){R(n,(function(){e.apply(this,arguments)}),t)},count:function(n){var e=0;return R(n,(function(){e++})),e},toArray:function(n){return R(n,(function(n){return n}))||[]},only:function(n){if(!z(n))throw Error("React.Children.only expected to receive a single React element child.");return n}},e.Component=x,e.Fragment=r,e.Profiler=i,e.PureComponent=g,e.StrictMode=a,e.Suspense=s,e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=j,e.cloneElement=function(n,e,o){if(null===n||void 0===n)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+n+".");var r=d({},n.props),a=n.key,i=n.ref,v=n._owner;if(null!=e){if(void 0!==e.ref&&(i=e.ref,v=w.current),void 0!==e.key&&(a=""+e.key),n.type&&n.type.defaultProps)var c=n.type.defaultProps;for(l in e)U.call(e,l)&&!S.hasOwnProperty(l)&&(r[l]=void 0===e[l]&&void 0!==c?c[l]:e[l])}var l=arguments.length-2;if(1===l)r.children=o;else if(1<l){c=Array(l);for(var s=0;s<l;s++)c[s]=arguments[s+2];r.children=c}return{$$typeof:t,type:n.type,key:a,ref:i,props:r,_owner:v}},e.createContext=function(n){return(n={$$typeof:c,_currentValue:n,_currentValue2:n,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:v,_context:n},n.Consumer=n},e.createElement=M,e.createFactory=function(n){var e=M.bind(null,n);return e.type=n,e},e.createRef=function(){return{current:null}},e.forwardRef=function(n){return{$$typeof:l,render:n}},e.isValidElement=z,e.lazy=function(n){return{$$typeof:f,_payload:{_status:-1,_result:n},_init:D}},e.memo=function(n,e){return{$$typeof:u,type:n,compare:void 0===e?null:e}},e.startTransition=function(n){var e=F.transition;F.transition={};try{n()}finally{F.transition=e}},e.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},e.useCallback=function(n,e){return P.current.useCallback(n,e)},e.useContext=function(n){return P.current.useContext(n)},e.useDebugValue=function(){},e.useDeferredValue=function(n){return P.current.useDeferredValue(n)},e.useEffect=function(n,e){return P.current.useEffect(n,e)},e.useId=function(){return P.current.useId()},e.useImperativeHandle=function(n,e,t){return P.current.useImperativeHandle(n,e,t)},e.useInsertionEffect=function(n,e){return P.current.useInsertionEffect(n,e)},e.useLayoutEffect=function(n,e){return P.current.useLayoutEffect(n,e)},e.useMemo=function(n,e){return P.current.useMemo(n,e)},e.useReducer=function(n,e,t){return P.current.useReducer(n,e,t)},e.useRef=function(n){return P.current.useRef(n)},e.useState=function(n){return P.current.useState(n)},e.useSyncExternalStore=function(n,e,t){return P.current.useSyncExternalStore(n,e,t)},e.useTransition=function(){return P.current.useTransition()},e.version="18.2.0"},791:function(n,e,t){"use strict";n.exports=t(117)},184:function(n,e,t){"use strict";n.exports=t(374)},813:function(n,e){"use strict";function t(n,e){var t=n.length;n.push(e);n:for(;0<t;){var o=t-1>>>1,r=n[o];if(!(0<a(r,e)))break n;n[o]=e,n[t]=r,t=o}}function o(n){return 0===n.length?null:n[0]}function r(n){if(0===n.length)return null;var e=n[0],t=n.pop();if(t!==e){n[0]=t;n:for(var o=0,r=n.length,i=r>>>1;o<i;){var v=2*(o+1)-1,c=n[v],l=v+1,s=n[l];if(0>a(c,t))l<r&&0>a(s,c)?(n[o]=s,n[l]=t,o=l):(n[o]=c,n[v]=t,o=v);else{if(!(l<r&&0>a(s,t)))break n;n[o]=s,n[l]=t,o=l}}}return e}function a(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var v=Date,c=v.now();e.unstable_now=function(){return v.now()-c}}var l=[],s=[],u=1,f=null,p=3,m=!1,d=!1,h=!1,x="function"===typeof setTimeout?setTimeout:null,y="function"===typeof clearTimeout?clearTimeout:null,g="undefined"!==typeof setImmediate?setImmediate:null;function b(n){for(var e=o(s);null!==e;){if(null===e.callback)r(s);else{if(!(e.startTime<=n))break;r(s),e.sortIndex=e.expirationTime,t(l,e)}e=o(s)}}function _(n){if(h=!1,b(n),!d)if(null!==o(l))d=!0,F(U);else{var e=o(s);null!==e&&j(_,e.startTime-n)}}function U(n,t){d=!1,h&&(h=!1,y(z),z=-1),m=!0;var a=p;try{for(b(t),f=o(l);null!==f&&(!(f.expirationTime>t)||n&&!T());){var i=f.callback;if("function"===typeof i){f.callback=null,p=f.priorityLevel;var v=i(f.expirationTime<=t);t=e.unstable_now(),"function"===typeof v?f.callback=v:f===o(l)&&r(l),b(t)}else r(l);f=o(l)}if(null!==f)var c=!0;else{var u=o(s);null!==u&&j(_,u.startTime-t),c=!1}return c}finally{f=null,p=a,m=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,S=!1,M=null,z=-1,k=5,C=-1;function T(){return!(e.unstable_now()-C<k)}function R(){if(null!==M){var n=e.unstable_now();C=n;var t=!0;try{t=M(!0,n)}finally{t?w():(S=!1,M=null)}}else S=!1}if("function"===typeof g)w=function(){g(R)};else if("undefined"!==typeof MessageChannel){var D=new MessageChannel,P=D.port2;D.port1.onmessage=R,w=function(){P.postMessage(null)}}else w=function(){x(R,0)};function F(n){M=n,S||(S=!0,w())}function j(n,t){z=x((function(){n(e.unstable_now())}),t)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){d||m||(d=!0,F(U))},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):k=0<n?Math.floor(1e3/n):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return o(l)},e.unstable_next=function(n){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var t=p;p=e;try{return n()}finally{p=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=p;p=n;try{return e()}finally{p=t}},e.unstable_scheduleCallback=function(n,r,a){var i=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,n){case 1:var v=-1;break;case 2:v=250;break;case 5:v=1073741823;break;case 4:v=1e4;break;default:v=5e3}return n={id:u++,callback:r,priorityLevel:n,startTime:a,expirationTime:v=a+v,sortIndex:-1},a>i?(n.sortIndex=a,t(s,n),null===o(l)&&n===o(s)&&(h?(y(z),z=-1):h=!0,j(_,a-i))):(n.sortIndex=v,t(l,n),d||m||(d=!0,F(U))),n},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(n){var e=p;return function(){var t=p;p=e;try{return n.apply(this,arguments)}finally{p=t}}}},296:function(n,e,t){"use strict";n.exports=t(813)},561:function(n,e,t){"use strict";var o=t(791);var r="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},a=o.useState,i=o.useEffect,v=o.useLayoutEffect,c=o.useDebugValue;function l(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!r(n,t)}catch(o){return!0}}var s="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?function(n,e){return e()}:function(n,e){var t=e(),o=a({inst:{value:t,getSnapshot:e}}),r=o[0].inst,s=o[1];return v((function(){r.value=t,r.getSnapshot=e,l(r)&&s({inst:r})}),[n,t,e]),i((function(){return l(r)&&s({inst:r}),n((function(){l(r)&&s({inst:r})}))}),[n]),c(t),t};e.useSyncExternalStore=void 0!==o.useSyncExternalStore?o.useSyncExternalStore:s},595:function(n,e,t){"use strict";var o=t(791),r=t(248);var a="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},i=r.useSyncExternalStore,v=o.useRef,c=o.useEffect,l=o.useMemo,s=o.useDebugValue;e.useSyncExternalStoreWithSelector=function(n,e,t,o,r){var u=v(null);if(null===u.current){var f={hasValue:!1,value:null};u.current=f}else f=u.current;u=l((function(){function n(n){if(!c){if(c=!0,i=n,n=o(n),void 0!==r&&f.hasValue){var e=f.value;if(r(e,n))return v=e}return v=n}if(e=v,a(i,n))return e;var t=o(n);return void 0!==r&&r(e,t)?e:(i=n,v=t)}var i,v,c=!1,l=void 0===t?null:t;return[function(){return n(e())},null===l?void 0:function(){return n(l())}]}),[e,t,o,r]);var p=i(n,u[0],u[1]);return c((function(){f.hasValue=!0,f.value=p}),[p]),s(p),p}},248:function(n,e,t){"use strict";n.exports=t(561)},327:function(n,e,t){"use strict";n.exports=t(595)}},e={};function t(o){var r=e[o];if(void 0!==r)return r.exports;var a=e[o]={exports:{}};return n[o](a,a.exports,t),a.exports}t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,{a:e}),e},t.d=function(n,e){for(var o in e)t.o(e,o)&&!t.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:e[o]})},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},function(){"use strict";var n,e={};function o(n,e){if(null==n)return{};var t,o,r=function(n,e){if(null==n)return{};var t,o,r={},a=Object.keys(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}function r(n){if(Array.isArray(n))return n}function a(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}function i(n,e){if(n){if("string"===typeof n)return a(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?a(n,e):void 0}}function v(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function c(n,e){return r(n)||function(n,e){var t=null==n?null:"undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var o,r,a=[],i=!0,v=!1;try{for(t=t.call(n);!(i=(o=t.next()).done)&&(a.push(o.value),!e||a.length!==e);i=!0);}catch(c){v=!0,r=c}finally{try{i||null==t.return||t.return()}finally{if(v)throw r}}return a}}(n,e)||i(n,e)||v()}function l(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){l(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function f(n,e){var t="undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=i(n))||e&&n&&"number"===typeof n.length){t&&(n=t);var o=0,r=function(){};return{s:r,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,v=!0,c=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return v=n.done,n},e:function(n){c=!0,a=n},f:function(){try{v||null==t.return||t.return()}finally{if(c)throw a}}}}function p(n,e){return p=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,e){return n.__proto__=e,n},p(n,e)}function m(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function d(n,e,t){return d=m()?Reflect.construct.bind():function(n,e,t){var o=[null];o.push.apply(o,e);var r=new(Function.bind.apply(n,o));return t&&p(r,t.prototype),r},d.apply(null,arguments)}function h(n){if("undefined"!==typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}function x(n){return function(n){if(Array.isArray(n))return a(n)}(n)||h(n)||i(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function y(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function g(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}function b(n,e,t){return e&&g(n.prototype,e),t&&g(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}function _(n,e){if("function"!==typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&p(n,e)}function U(n){return U=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},U(n)}function w(n){return w="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},w(n)}function S(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}function M(n,e){if(e&&("object"===w(e)||"function"===typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return S(n)}function z(n){var e=m();return function(){var t,o=U(n);if(e){var r=U(this).constructor;t=Reflect.construct(o,arguments,r)}else t=o.apply(this,arguments);return M(this,t)}}function k(n){var e="function"===typeof Map?new Map:void 0;return k=function(n){if(null===n||(t=n,-1===Function.toString.call(t).indexOf("[native code]")))return n;var t;if("function"!==typeof n)throw new TypeError("Super expression must either be null or a function");if("undefined"!==typeof e){if(e.has(n))return e.get(n);e.set(n,o)}function o(){return d(n,arguments,U(this).constructor)}return o.prototype=Object.create(n.prototype,{constructor:{value:o,enumerable:!1,writable:!0,configurable:!0}}),p(o,n)},k(n)}function C(n,e,t,o,r,a,i){try{var v=n[a](i),c=v.value}catch(l){return void t(l)}v.done?e(c):Promise.resolve(c).then(o,r)}function T(n){return function(){var e=this,t=arguments;return new Promise((function(o,r){var a=n.apply(e,t);function i(n){C(a,o,r,i,v,"next",n)}function v(n){C(a,o,r,i,v,"throw",n)}i(void 0)}))}}function R(n,e){for(;!Object.prototype.hasOwnProperty.call(n,e)&&null!==(n=U(n)););return n}function D(){return D="undefined"!==typeof Reflect&&Reflect.get?Reflect.get.bind():function(n,e,t){var o=R(n,e);if(o){var r=Object.getOwnPropertyDescriptor(o,e);return r.get?r.get.call(arguments.length<3?n:t):r.value}},D.apply(this,arguments)}function P(){P=function(){return n};var n={},e=Object.prototype,t=e.hasOwnProperty,o=Object.defineProperty||function(n,e,t){n[e]=t.value},r="function"==typeof Symbol?Symbol:{},a=r.iterator||"@@iterator",i=r.asyncIterator||"@@asyncIterator",v=r.toStringTag||"@@toStringTag";function c(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{c({},"")}catch(T){c=function(n,e,t){return n[e]=t}}function l(n,e,t,r){var a=e&&e.prototype instanceof f?e:f,i=Object.create(a.prototype),v=new z(r||[]);return o(i,"_invoke",{value:_(n,t,v)}),i}function s(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(T){return{type:"throw",arg:T}}}n.wrap=l;var u={};function f(){}function p(){}function m(){}var d={};c(d,a,(function(){return this}));var h=Object.getPrototypeOf,x=h&&h(h(k([])));x&&x!==e&&t.call(x,a)&&(d=x);var y=m.prototype=f.prototype=Object.create(d);function g(n){["next","throw","return"].forEach((function(e){c(n,e,(function(n){return this._invoke(e,n)}))}))}function b(n,e){function r(o,a,i,v){var c=s(n[o],n,a);if("throw"!==c.type){var l=c.arg,u=l.value;return u&&"object"==w(u)&&t.call(u,"__await")?e.resolve(u.__await).then((function(n){r("next",n,i,v)}),(function(n){r("throw",n,i,v)})):e.resolve(u).then((function(n){l.value=n,i(l)}),(function(n){return r("throw",n,i,v)}))}v(c.arg)}var a;o(this,"_invoke",{value:function(n,t){function o(){return new e((function(e,o){r(n,t,e,o)}))}return a=a?a.then(o,o):o()}})}function _(n,e,t){var o="suspendedStart";return function(r,a){if("executing"===o)throw new Error("Generator is already running");if("completed"===o){if("throw"===r)throw a;return C()}for(t.method=r,t.arg=a;;){var i=t.delegate;if(i){var v=U(i,t);if(v){if(v===u)continue;return v}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===o)throw o="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);o="executing";var c=s(n,e,t);if("normal"===c.type){if(o=t.done?"completed":"suspendedYield",c.arg===u)continue;return{value:c.arg,done:t.done}}"throw"===c.type&&(o="completed",t.method="throw",t.arg=c.arg)}}}function U(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,U(n,e),"throw"===e.method))return u;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return u}var o=s(t,n.iterator,e.arg);if("throw"===o.type)return e.method="throw",e.arg=o.arg,e.delegate=null,u;var r=o.arg;return r?r.done?(e[n.resultName]=r.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,u):r:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,u)}function S(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function M(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function z(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(S,this),this.reset(!0)}function k(n){if(n){var e=n[a];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var o=-1,r=function e(){for(;++o<n.length;)if(t.call(n,o))return e.value=n[o],e.done=!1,e;return e.value=void 0,e.done=!0,e};return r.next=r}}return{next:C}}function C(){return{value:void 0,done:!0}}return p.prototype=m,o(y,"constructor",{value:m,configurable:!0}),o(m,"constructor",{value:p,configurable:!0}),p.displayName=c(m,v,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,c(n,v,"GeneratorFunction")),n.prototype=Object.create(y),n},n.awrap=function(n){return{__await:n}},g(b.prototype),c(b.prototype,i,(function(){return this})),n.AsyncIterator=b,n.async=function(e,t,o,r,a){void 0===a&&(a=Promise);var i=new b(l(e,t,o,r),a);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},g(y),c(y,v,"Generator"),c(y,a,(function(){return this})),c(y,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=Object(n),t=[];for(var o in e)t.push(o);return t.reverse(),function n(){for(;t.length;){var o=t.pop();if(o in e)return n.value=o,n.done=!1,n}return n.done=!0,n}},n.values=k,z.prototype={constructor:z,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(M),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function o(t,o){return i.type="throw",i.arg=n,e.next=t,o&&(e.method="next",e.arg=void 0),!!o}for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r],i=a.completion;if("root"===a.tryLoc)return o("end");if(a.tryLoc<=this.prev){var v=t.call(a,"catchLoc"),c=t.call(a,"finallyLoc");if(v&&c){if(this.prev<a.catchLoc)return o(a.catchLoc,!0);if(this.prev<a.finallyLoc)return o(a.finallyLoc)}else if(v){if(this.prev<a.catchLoc)return o(a.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return o(a.finallyLoc)}}}},abrupt:function(n,e){for(var o=this.tryEntries.length-1;o>=0;--o){var r=this.tryEntries[o];if(r.tryLoc<=this.prev&&t.call(r,"finallyLoc")&&this.prev<r.finallyLoc){var a=r;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=n,i.arg=e,a?(this.method="next",this.next=a.finallyLoc,u):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),u},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),M(t),u}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var o=t.completion;if("throw"===o.type){var r=o.arg;M(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:k(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),u}},n}t.r(e),t.d(e,{ACESFilmicToneMapping:function(){return Dn},AddEquation:function(){return $},AddOperation:function(){return zn},AdditiveAnimationBlendMode:function(){return ot},AdditiveBlending:function(){return Z},AlphaFormat:function(){return le},AlwaysDepth:function(){return xn},AlwaysStencilFunc:function(){return Dt},AmbientLight:function(){return Mf},AmbientLightProbe:function(){return Nf},AnimationClip:function(){return Xu},AnimationLoader:function(){return of},AnimationMixer:function(){return yp},AnimationObjectGroup:function(){return dp},AnimationUtils:function(){return ju},ArcCurve:function(){return Ql},ArrayCamera:function(){return Mc},ArrowHelper:function(){return lm},Audio:function(){return $f},AudioAnalyser:function(){return ap},AudioContext:function(){return Lf},AudioListener:function(){return Kf},AudioLoader:function(){return Af},AxesHelper:function(){return sm},BackSide:function(){return W},BasicDepthPacking:function(){return lt},BasicShadowMap:function(){return G},Bone:function(){return pl},BooleanKeyframeTrack:function(){return Gu},Box2:function(){return Rp},Box3:function(){return Go},Box3Helper:function(){return im},BoxBufferGeometry:function(){return gm},BoxGeometry:function(){return Aa},BoxHelper:function(){return am},BufferAttribute:function(){return ea},BufferGeometry:function(){return ga},BufferGeometryLoader:function(){return Pf},ByteType:function(){return $n},Cache:function(){return Qu},Camera:function(){return Va},CameraHelper:function(){return nm},CanvasTexture:function(){return Xl},CapsuleBufferGeometry:function(){return bm},CapsuleGeometry:function(){return xs},CatmullRomCurve3:function(){return ts},CineonToneMapping:function(){return Rn},CircleBufferGeometry:function(){return _m},CircleGeometry:function(){return ys},ClampToEdgeWrapping:function(){return Gn},Clock:function(){return Hf},Color:function(){return wo},ColorKeyframeTrack:function(){return Nu},ColorManagement:function(){return mo},CompressedArrayTexture:function(){return Hl},CompressedTexture:function(){return Wl},CompressedTextureLoader:function(){return rf},ConeBufferGeometry:function(){return Um},ConeGeometry:function(){return bs},CubeCamera:function(){return Xa},CubeReflectionMapping:function(){return jn},CubeRefractionMapping:function(){return In},CubeTexture:function(){return Ya},CubeTextureLoader:function(){return vf},CubeUVReflectionMapping:function(){return Ln},CubicBezierCurve:function(){return is},CubicBezierCurve3:function(){return vs},CubicInterpolant:function(){return Eu},CullFaceBack:function(){return O},CullFaceFront:function(){return L},CullFaceFrontBack:function(){return A},CullFaceNone:function(){return E},Curve:function(){return Yl},CurvePath:function(){return ms},CustomBlending:function(){return K},CustomToneMapping:function(){return Pn},CylinderBufferGeometry:function(){return wm},CylinderGeometry:function(){return gs},Cylindrical:function(){return Cp},Data3DTexture:function(){return Fo},DataArrayTexture:function(){return Do},DataTexture:function(){return ml},DataTexture2DArray:function(){return xm},DataTexture3D:function(){return ym},DataTextureLoader:function(){return cf},DataUtils:function(){return mm},DecrementStencilOp:function(){return bt},DecrementWrapStencilOp:function(){return Ut},DefaultLoadingManager:function(){return Ku},DepthFormat:function(){return me},DepthStencilFormat:function(){return de},DepthTexture:function(){return Tc},DirectionalLight:function(){return Sf},DirectionalLightHelper:function(){return Jp},DiscreteInterpolant:function(){return Lu},DodecahedronBufferGeometry:function(){return Sm},DodecahedronGeometry:function(){return Us},DoubleSide:function(){return H},DstAlphaFactor:function(){return un},DstColorFactor:function(){return pn},DynamicCopyUsage:function(){return At},DynamicDrawUsage:function(){return Ft},DynamicReadUsage:function(){return Et},EdgesGeometry:function(){return ks},EllipseCurve:function(){return Zl},EqualDepth:function(){return bn},EqualStencilFunc:function(){return zt},EquirectangularReflectionMapping:function(){return En},EquirectangularRefractionMapping:function(){return On},Euler:function(){return wr},EventDispatcher:function(){return Vt},ExtrudeBufferGeometry:function(){return Mm},ExtrudeGeometry:function(){return ru},FileLoader:function(){return tf},Float16BufferAttribute:function(){return la},Float32BufferAttribute:function(){return sa},Float64BufferAttribute:function(){return ua},FloatType:function(){return re},Fog:function(){return Lc},FogExp2:function(){return Oc},FramebufferTexture:function(){return Vl},FrontSide:function(){return V},Frustum:function(){return ti},GLBufferAttribute:function(){return wp},GLSL1:function(){return Nt},GLSL3:function(){return Bt},GreaterDepth:function(){return Un},GreaterEqualDepth:function(){return _n},GreaterEqualStencilFunc:function(){return Rt},GreaterStencilFunc:function(){return Ct},GridHelper:function(){return Hp},Group:function(){return zc},HalfFloatType:function(){return ae},HemisphereLight:function(){return uf},HemisphereLightHelper:function(){return Wp},HemisphereLightProbe:function(){return Gf},IcosahedronBufferGeometry:function(){return zm},IcosahedronGeometry:function(){return iu},ImageBitmapLoader:function(){return Of},ImageLoader:function(){return af},ImageUtils:function(){return So},ImmediateRenderObject:function(){return dm},IncrementStencilOp:function(){return gt},IncrementWrapStencilOp:function(){return _t},InstancedBufferAttribute:function(){return yl},InstancedBufferGeometry:function(){return Df},InstancedInterleavedBuffer:function(){return Up},InstancedMesh:function(){return Sl},Int16BufferAttribute:function(){return aa},Int32BufferAttribute:function(){return va},Int8BufferAttribute:function(){return ta},IntType:function(){return te},InterleavedBuffer:function(){return Gc},InterleavedBufferAttribute:function(){return Bc},Interpolant:function(){return Iu},InterpolateDiscrete:function(){return Qe},InterpolateLinear:function(){return Je},InterpolateSmooth:function(){return Ke},InvertStencilOp:function(){return wt},KeepStencilOp:function(){return xt},KeyframeTrack:function(){return Au},LOD:function(){return il},LatheBufferGeometry:function(){return km},LatheGeometry:function(){return hs},Layers:function(){return Sr},LessDepth:function(){return yn},LessEqualDepth:function(){return gn},LessEqualStencilFunc:function(){return kt},LessStencilFunc:function(){return Mt},Light:function(){return sf},LightProbe:function(){return Cf},Line:function(){return Dl},Line3:function(){return Fp},LineBasicMaterial:function(){return Ml},LineCurve:function(){return cs},LineCurve3:function(){return ls},LineDashedMaterial:function(){return ku},LineLoop:function(){return Il},LineSegments:function(){return jl},LinearEncoding:function(){return vt},LinearFilter:function(){return Xn},LinearInterpolant:function(){return Ou},LinearMipMapLinearFilter:function(){return Jn},LinearMipMapNearestFilter:function(){return Zn},LinearMipmapLinearFilter:function(){return Qn},LinearMipmapNearestFilter:function(){return Yn},LinearSRGBColorSpace:function(){return dt},LinearToneMapping:function(){return Cn},Loader:function(){return $u},LoaderUtils:function(){return Rf},LoadingManager:function(){return Ju},LoopOnce:function(){return Xe},LoopPingPong:function(){return Ze},LoopRepeat:function(){return Ye},LuminanceAlphaFormat:function(){return pe},LuminanceFormat:function(){return fe},MOUSE:function(){return j},Material:function(){return Jr},MaterialLoader:function(){return Tf},MathUtils:function(){return ro},Matrix3:function(){return io},Matrix4:function(){return pr},MaxEquation:function(){return on},Mesh:function(){return Oa},MeshBasicMaterial:function(){return Kr},MeshDepthMaterial:function(){return gc},MeshDistanceMaterial:function(){return bc},MeshLambertMaterial:function(){return Mu},MeshMatcapMaterial:function(){return zu},MeshNormalMaterial:function(){return Su},MeshPhongMaterial:function(){return Uu},MeshPhysicalMaterial:function(){return _u},MeshStandardMaterial:function(){return bu},MeshToonMaterial:function(){return wu},MinEquation:function(){return tn},MirroredRepeatWrapping:function(){return Nn},MixOperation:function(){return Mn},MultiplyBlending:function(){return J},MultiplyOperation:function(){return Sn},NearestFilter:function(){return Bn},NearestMipMapLinearFilter:function(){return Hn},NearestMipMapNearestFilter:function(){return Vn},NearestMipmapLinearFilter:function(){return Wn},NearestMipmapNearestFilter:function(){return qn},NeverDepth:function(){return hn},NeverStencilFunc:function(){return St},NoBlending:function(){return X},NoColorSpace:function(){return pt},NoToneMapping:function(){return kn},NormalAnimationBlendMode:function(){return tt},NormalBlending:function(){return Y},NotEqualDepth:function(){return wn},NotEqualStencilFunc:function(){return Tt},NumberKeyframeTrack:function(){return Bu},Object3D:function(){return Lr},ObjectLoader:function(){return Ff},ObjectSpaceNormalMap:function(){return ft},OctahedronBufferGeometry:function(){return Cm},OctahedronGeometry:function(){return vu},OneFactor:function(){return an},OneMinusDstAlphaFactor:function(){return fn},OneMinusDstColorFactor:function(){return mn},OneMinusSrcAlphaFactor:function(){return sn},OneMinusSrcColorFactor:function(){return cn},OrthographicCamera:function(){return di},PCFShadowMap:function(){return N},PCFSoftShadowMap:function(){return B},PMREMGenerator:function(){return Si},Path:function(){return ds},PerspectiveCamera:function(){return Wa},Plane:function(){return $a},PlaneBufferGeometry:function(){return Tm},PlaneGeometry:function(){return ai},PlaneHelper:function(){return vm},PointLight:function(){return Uf},PointLightHelper:function(){return Np},Points:function(){return Nl},PointsMaterial:function(){return El},PolarGridHelper:function(){return Xp},PolyhedronBufferGeometry:function(){return Rm},PolyhedronGeometry:function(){return _s},PositionalAudio:function(){return rp},PropertyBinding:function(){return mp},PropertyMixer:function(){return ip},QuadraticBezierCurve:function(){return ss},QuadraticBezierCurve3:function(){return us},Quaternion:function(){return Eo},QuaternionKeyframeTrack:function(){return Vu},QuaternionLinearInterpolant:function(){return qu},REVISION:function(){return F},RGBADepthPacking:function(){return st},RGBAFormat:function(){return ue},RGBAIntegerFormat:function(){return be},RGBA_ASTC_10x10_Format:function(){return qe},RGBA_ASTC_10x5_Format:function(){return Ge},RGBA_ASTC_10x6_Format:function(){return Ne},RGBA_ASTC_10x8_Format:function(){return Be},RGBA_ASTC_12x10_Format:function(){return Ve},RGBA_ASTC_12x12_Format:function(){return We},RGBA_ASTC_4x4_Format:function(){return Pe},RGBA_ASTC_5x4_Format:function(){return Fe},RGBA_ASTC_5x5_Format:function(){return je},RGBA_ASTC_6x5_Format:function(){return Ie},RGBA_ASTC_6x6_Format:function(){return Ee},RGBA_ASTC_8x5_Format:function(){return Oe},RGBA_ASTC_8x6_Format:function(){return Le},RGBA_ASTC_8x8_Format:function(){return Ae},RGBA_BPTC_Format:function(){return He},RGBA_ETC2_EAC_Format:function(){return De},RGBA_PVRTC_2BPPV1_Format:function(){return Ce},RGBA_PVRTC_4BPPV1_Format:function(){return ke},RGBA_S3TC_DXT1_Format:function(){return Ue},RGBA_S3TC_DXT3_Format:function(){return we},RGBA_S3TC_DXT5_Format:function(){return Se},RGBFormat:function(){return se},RGB_ETC1_Format:function(){return Te},RGB_ETC2_Format:function(){return Re},RGB_PVRTC_2BPPV1_Format:function(){return ze},RGB_PVRTC_4BPPV1_Format:function(){return Me},RGB_S3TC_DXT1_Format:function(){return _e},RGFormat:function(){return ye},RGIntegerFormat:function(){return ge},RawShaderMaterial:function(){return gu},Ray:function(){return fr},Raycaster:function(){return Sp},RectAreaLight:function(){return zf},RedFormat:function(){return he},RedIntegerFormat:function(){return xe},ReinhardToneMapping:function(){return Tn},RepeatWrapping:function(){return An},ReplaceStencilOp:function(){return yt},ReverseSubtractEquation:function(){return en},RingBufferGeometry:function(){return Dm},RingGeometry:function(){return cu},SRGBColorSpace:function(){return mt},Scene:function(){return Ac},ShaderChunk:function(){return ii},ShaderLib:function(){return ci},ShaderMaterial:function(){return qa},ShadowMaterial:function(){return yu},Shape:function(){return Cs},ShapeBufferGeometry:function(){return Pm},ShapeGeometry:function(){return lu},ShapePath:function(){return um},ShapeUtils:function(){return eu},ShortType:function(){return ne},Skeleton:function(){return xl},SkeletonHelper:function(){return Ap},SkinnedMesh:function(){return fl},Source:function(){return Mo},Sphere:function(){return rr},SphereBufferGeometry:function(){return Fm},SphereGeometry:function(){return su},Spherical:function(){return kp},SphericalHarmonics3:function(){return kf},SplineCurve:function(){return fs},SpotLight:function(){return xf},SpotLightHelper:function(){return Ip},Sprite:function(){return tl},SpriteMaterial:function(){return qc},SrcAlphaFactor:function(){return ln},SrcAlphaSaturateFactor:function(){return dn},SrcColorFactor:function(){return vn},StaticCopyUsage:function(){return Lt},StaticDrawUsage:function(){return Pt},StaticReadUsage:function(){return It},StereoCamera:function(){return Wf},StreamCopyUsage:function(){return Gt},StreamDrawUsage:function(){return jt},StreamReadUsage:function(){return Ot},StringKeyframeTrack:function(){return Wu},SubtractEquation:function(){return nn},SubtractiveBlending:function(){return Q},TOUCH:function(){return I},TangentSpaceNormalMap:function(){return ut},TetrahedronBufferGeometry:function(){return jm},TetrahedronGeometry:function(){return uu},Texture:function(){return Co},TextureLoader:function(){return lf},TorusBufferGeometry:function(){return Im},TorusGeometry:function(){return fu},TorusKnotBufferGeometry:function(){return Em},TorusKnotGeometry:function(){return pu},Triangle:function(){return Zr},TriangleFanDrawMode:function(){return it},TriangleStripDrawMode:function(){return at},TrianglesDrawMode:function(){return rt},TubeBufferGeometry:function(){return Om},TubeGeometry:function(){return mu},UVMapping:function(){return Fn},Uint16BufferAttribute:function(){return ia},Uint32BufferAttribute:function(){return ca},Uint8BufferAttribute:function(){return oa},Uint8ClampedBufferAttribute:function(){return ra},Uniform:function(){return gp},UniformsGroup:function(){return _p},UniformsLib:function(){return vi},UniformsUtils:function(){return Ba},UnsignedByteType:function(){return Kn},UnsignedInt248Type:function(){return ce},UnsignedIntType:function(){return oe},UnsignedShort4444Type:function(){return ie},UnsignedShort5551Type:function(){return ve},UnsignedShortType:function(){return ee},VSMShadowMap:function(){return q},Vector2:function(){return ao},Vector3:function(){return Oo},Vector4:function(){return To},VectorKeyframeTrack:function(){return Hu},VideoTexture:function(){return ql},WebGL1Renderer:function(){return Ic},WebGL3DRenderTarget:function(){return jo},WebGLArrayRenderTarget:function(){return Po},WebGLCubeRenderTarget:function(){return Za},WebGLMultipleRenderTargets:function(){return Io},WebGLMultisampleRenderTarget:function(){return hm},WebGLRenderTarget:function(){return Ro},WebGLRenderer:function(){return jc},WebGLUtils:function(){return Sc},WireframeGeometry:function(){return du},WrapAroundEnding:function(){return et},ZeroCurvatureEnding:function(){return $e},ZeroFactor:function(){return rn},ZeroSlopeEnding:function(){return nt},ZeroStencilOp:function(){return ht},_SRGBAFormat:function(){return qt},sRGBEncoding:function(){return ct}});var F="146",j={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},I={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},E=0,O=1,L=2,A=3,G=0,N=1,B=2,q=3,V=0,W=1,H=2,X=0,Y=1,Z=2,Q=3,J=4,K=5,$=100,nn=101,en=102,tn=103,on=104,rn=200,an=201,vn=202,cn=203,ln=204,sn=205,un=206,fn=207,pn=208,mn=209,dn=210,hn=0,xn=1,yn=2,gn=3,bn=4,_n=5,Un=6,wn=7,Sn=0,Mn=1,zn=2,kn=0,Cn=1,Tn=2,Rn=3,Dn=4,Pn=5,Fn=300,jn=301,In=302,En=303,On=304,Ln=306,An=1e3,Gn=1001,Nn=1002,Bn=1003,qn=1004,Vn=1004,Wn=1005,Hn=1005,Xn=1006,Yn=1007,Zn=1007,Qn=1008,Jn=1008,Kn=1009,$n=1010,ne=1011,ee=1012,te=1013,oe=1014,re=1015,ae=1016,ie=1017,ve=1018,ce=1020,le=1021,se=1022,ue=1023,fe=1024,pe=1025,me=1026,de=1027,he=1028,xe=1029,ye=1030,ge=1031,be=1033,_e=33776,Ue=33777,we=33778,Se=33779,Me=35840,ze=35841,ke=35842,Ce=35843,Te=36196,Re=37492,De=37496,Pe=37808,Fe=37809,je=37810,Ie=37811,Ee=37812,Oe=37813,Le=37814,Ae=37815,Ge=37816,Ne=37817,Be=37818,qe=37819,Ve=37820,We=37821,He=36492,Xe=2200,Ye=2201,Ze=2202,Qe=2300,Je=2301,Ke=2302,$e=2400,nt=2401,et=2402,tt=2500,ot=2501,rt=0,at=1,it=2,vt=3e3,ct=3001,lt=3200,st=3201,ut=0,ft=1,pt="",mt="srgb",dt="srgb-linear",ht=0,xt=7680,yt=7681,gt=7682,bt=7683,_t=34055,Ut=34056,wt=5386,St=512,Mt=513,zt=514,kt=515,Ct=516,Tt=517,Rt=518,Dt=519,Pt=35044,Ft=35048,jt=35040,It=35045,Et=35049,Ot=35041,Lt=35046,At=35050,Gt=35042,Nt="100",Bt="300 es",qt=1035,Vt=function(){function n(){y(this,n)}return b(n,[{key:"addEventListener",value:function(n,e){void 0===this._listeners&&(this._listeners={});var t=this._listeners;void 0===t[n]&&(t[n]=[]),-1===t[n].indexOf(e)&&t[n].push(e)}},{key:"hasEventListener",value:function(n,e){if(void 0===this._listeners)return!1;var t=this._listeners;return void 0!==t[n]&&-1!==t[n].indexOf(e)}},{key:"removeEventListener",value:function(n,e){if(void 0!==this._listeners){var t=this._listeners[n];if(void 0!==t){var o=t.indexOf(e);-1!==o&&t.splice(o,1)}}}},{key:"dispatchEvent",value:function(n){if(void 0!==this._listeners){var e=this._listeners[n.type];if(void 0!==e){n.target=this;for(var t=e.slice(0),o=0,r=t.length;o<r;o++)t[o].call(this,n);n.target=null}}}}]),n}(),Wt=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],Ht=1234567,Xt=Math.PI/180,Yt=180/Math.PI;function Zt(){var n=4294967295*Math.random()|0,e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,o=4294967295*Math.random()|0;return(Wt[255&n]+Wt[n>>8&255]+Wt[n>>16&255]+Wt[n>>24&255]+"-"+Wt[255&e]+Wt[e>>8&255]+"-"+Wt[e>>16&15|64]+Wt[e>>24&255]+"-"+Wt[63&t|128]+Wt[t>>8&255]+"-"+Wt[t>>16&255]+Wt[t>>24&255]+Wt[255&o]+Wt[o>>8&255]+Wt[o>>16&255]+Wt[o>>24&255]).toLowerCase()}function Qt(n,e,t){return Math.max(e,Math.min(t,n))}function Jt(n,e){return(n%e+e)%e}function Kt(n,e,t){return(1-t)*n+t*e}function $t(n){return 0===(n&n-1)&&0!==n}function no(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function eo(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function to(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function oo(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return Math.round(65535*n);case Uint8Array:return Math.round(255*n);case Int16Array:return Math.round(32767*n);case Int8Array:return Math.round(127*n);default:throw new Error("Invalid component type.")}}var ro=Object.freeze({__proto__:null,DEG2RAD:Xt,RAD2DEG:Yt,generateUUID:Zt,clamp:Qt,euclideanModulo:Jt,mapLinear:function(n,e,t,o,r){return o+(n-e)*(r-o)/(t-e)},inverseLerp:function(n,e,t){return n!==e?(t-n)/(e-n):0},lerp:Kt,damp:function(n,e,t,o){return Kt(n,e,1-Math.exp(-t*o))},pingpong:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return e-Math.abs(Jt(n,2*e)-e)},smoothstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e))*n*(3-2*n)},smootherstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e))*n*n*(n*(6*n-15)+10)},randInt:function(n,e){return n+Math.floor(Math.random()*(e-n+1))},randFloat:function(n,e){return n+Math.random()*(e-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){void 0!==n&&(Ht=n);var e=Ht+=1831565813;return e=Math.imul(e^e>>>15,1|e),(((e^=e+Math.imul(e^e>>>7,61|e))^e>>>14)>>>0)/4294967296},degToRad:function(n){return n*Xt},radToDeg:function(n){return n*Yt},isPowerOfTwo:$t,ceilPowerOfTwo:no,floorPowerOfTwo:eo,setQuaternionFromProperEuler:function(n,e,t,o,r){var a=Math.cos,i=Math.sin,v=a(t/2),c=i(t/2),l=a((e+o)/2),s=i((e+o)/2),u=a((e-o)/2),f=i((e-o)/2),p=a((o-e)/2),m=i((o-e)/2);switch(r){case"XYX":n.set(v*s,c*u,c*f,v*l);break;case"YZY":n.set(c*f,v*s,c*u,v*l);break;case"ZXZ":n.set(c*u,c*f,v*s,v*l);break;case"XZX":n.set(v*s,c*m,c*p,v*l);break;case"YXY":n.set(c*p,v*s,c*m,v*l);break;case"ZYZ":n.set(c*m,c*p,v*s,v*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}},normalize:oo,denormalize:to}),ao=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,e),e.prototype.isVector2=!0,this.x=n,this.y=t}return b(e,[{key:"width",get:function(){return this.x},set:function(n){this.x=n}},{key:"height",get:function(){return this.y},set:function(n){this.y=n}},{key:"set",value:function(n,e){return this.x=n,this.y=e,this}},{key:"setScalar",value:function(n){return this.x=n,this.y=n,this}},{key:"setX",value:function(n){return this.x=n,this}},{key:"setY",value:function(n){return this.y=n,this}},{key:"setComponent",value:function(n,e){switch(n){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+n)}return this}},{key:"getComponent",value:function(n){switch(n){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+n)}}},{key:"clone",value:function(){return new this.constructor(this.x,this.y)}},{key:"copy",value:function(n){return this.x=n.x,this.y=n.y,this}},{key:"add",value:function(n){return this.x+=n.x,this.y+=n.y,this}},{key:"addScalar",value:function(n){return this.x+=n,this.y+=n,this}},{key:"addVectors",value:function(n,e){return this.x=n.x+e.x,this.y=n.y+e.y,this}},{key:"addScaledVector",value:function(n,e){return this.x+=n.x*e,this.y+=n.y*e,this}},{key:"sub",value:function(n){return this.x-=n.x,this.y-=n.y,this}},{key:"subScalar",value:function(n){return this.x-=n,this.y-=n,this}},{key:"subVectors",value:function(n,e){return this.x=n.x-e.x,this.y=n.y-e.y,this}},{key:"multiply",value:function(n){return this.x*=n.x,this.y*=n.y,this}},{key:"multiplyScalar",value:function(n){return this.x*=n,this.y*=n,this}},{key:"divide",value:function(n){return this.x/=n.x,this.y/=n.y,this}},{key:"divideScalar",value:function(n){return this.multiplyScalar(1/n)}},{key:"applyMatrix3",value:function(n){var e=this.x,t=this.y,o=n.elements;return this.x=o[0]*e+o[3]*t+o[6],this.y=o[1]*e+o[4]*t+o[7],this}},{key:"min",value:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this}},{key:"max",value:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this}},{key:"clamp",value:function(n,e){return this.x=Math.max(n.x,Math.min(e.x,this.x)),this.y=Math.max(n.y,Math.min(e.y,this.y)),this}},{key:"clampScalar",value:function(n,e){return this.x=Math.max(n,Math.min(e,this.x)),this.y=Math.max(n,Math.min(e,this.y)),this}},{key:"clampLength",value:function(n,e){var t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(n,Math.min(e,t)))}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},{key:"roundToZero",value:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this}},{key:"dot",value:function(n){return this.x*n.x+this.y*n.y}},{key:"cross",value:function(n){return this.x*n.y-this.y*n.x}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y)}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)}},{key:"normalize",value:function(){return this.divideScalar(this.length()||1)}},{key:"angle",value:function(){var n=Math.atan2(-this.y,-this.x)+Math.PI;return n}},{key:"distanceTo",value:function(n){return Math.sqrt(this.distanceToSquared(n))}},{key:"distanceToSquared",value:function(n){var e=this.x-n.x,t=this.y-n.y;return e*e+t*t}},{key:"manhattanDistanceTo",value:function(n){return Math.abs(this.x-n.x)+Math.abs(this.y-n.y)}},{key:"setLength",value:function(n){return this.normalize().multiplyScalar(n)}},{key:"lerp",value:function(n,e){return this.x+=(n.x-this.x)*e,this.y+=(n.y-this.y)*e,this}},{key:"lerpVectors",value:function(n,e,t){return this.x=n.x+(e.x-n.x)*t,this.y=n.y+(e.y-n.y)*t,this}},{key:"equals",value:function(n){return n.x===this.x&&n.y===this.y}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=n[e],this.y=n[e+1],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.x,n[e+1]=this.y,n}},{key:"fromBufferAttribute",value:function(n,e){return this.x=n.getX(e),this.y=n.getY(e),this}},{key:"rotateAround",value:function(n,e){var t=Math.cos(e),o=Math.sin(e),r=this.x-n.x,a=this.y-n.y;return this.x=r*t-a*o+n.x,this.y=r*o+a*t+n.y,this}},{key:"random",value:function(){return this.x=Math.random(),this.y=Math.random(),this}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.x;case 2:return n.next=4,this.y;case 4:case"end":return n.stop()}}),n,this)}))}]),e}(),io=function(){function n(){y(this,n),n.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}return b(n,[{key:"set",value:function(n,e,t,o,r,a,i,v,c){var l=this.elements;return l[0]=n,l[1]=o,l[2]=i,l[3]=e,l[4]=r,l[5]=v,l[6]=t,l[7]=a,l[8]=c,this}},{key:"identity",value:function(){return this.set(1,0,0,0,1,0,0,0,1),this}},{key:"copy",value:function(n){var e=this.elements,t=n.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],this}},{key:"extractBasis",value:function(n,e,t){return n.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),t.setFromMatrix3Column(this,2),this}},{key:"setFromMatrix4",value:function(n){var e=n.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}},{key:"multiply",value:function(n){return this.multiplyMatrices(this,n)}},{key:"premultiply",value:function(n){return this.multiplyMatrices(n,this)}},{key:"multiplyMatrices",value:function(n,e){var t=n.elements,o=e.elements,r=this.elements,a=t[0],i=t[3],v=t[6],c=t[1],l=t[4],s=t[7],u=t[2],f=t[5],p=t[8],m=o[0],d=o[3],h=o[6],x=o[1],y=o[4],g=o[7],b=o[2],_=o[5],U=o[8];return r[0]=a*m+i*x+v*b,r[3]=a*d+i*y+v*_,r[6]=a*h+i*g+v*U,r[1]=c*m+l*x+s*b,r[4]=c*d+l*y+s*_,r[7]=c*h+l*g+s*U,r[2]=u*m+f*x+p*b,r[5]=u*d+f*y+p*_,r[8]=u*h+f*g+p*U,this}},{key:"multiplyScalar",value:function(n){var e=this.elements;return e[0]*=n,e[3]*=n,e[6]*=n,e[1]*=n,e[4]*=n,e[7]*=n,e[2]*=n,e[5]*=n,e[8]*=n,this}},{key:"determinant",value:function(){var n=this.elements,e=n[0],t=n[1],o=n[2],r=n[3],a=n[4],i=n[5],v=n[6],c=n[7],l=n[8];return e*a*l-e*i*c-t*r*l+t*i*v+o*r*c-o*a*v}},{key:"invert",value:function(){var n=this.elements,e=n[0],t=n[1],o=n[2],r=n[3],a=n[4],i=n[5],v=n[6],c=n[7],l=n[8],s=l*a-i*c,u=i*v-l*r,f=c*r-a*v,p=e*s+t*u+o*f;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);var m=1/p;return n[0]=s*m,n[1]=(o*c-l*t)*m,n[2]=(i*t-o*a)*m,n[3]=u*m,n[4]=(l*e-o*v)*m,n[5]=(o*r-i*e)*m,n[6]=f*m,n[7]=(t*v-c*e)*m,n[8]=(a*e-t*r)*m,this}},{key:"transpose",value:function(){var n,e=this.elements;return n=e[1],e[1]=e[3],e[3]=n,n=e[2],e[2]=e[6],e[6]=n,n=e[5],e[5]=e[7],e[7]=n,this}},{key:"getNormalMatrix",value:function(n){return this.setFromMatrix4(n).invert().transpose()}},{key:"transposeIntoArray",value:function(n){var e=this.elements;return n[0]=e[0],n[1]=e[3],n[2]=e[6],n[3]=e[1],n[4]=e[4],n[5]=e[7],n[6]=e[2],n[7]=e[5],n[8]=e[8],this}},{key:"setUvTransform",value:function(n,e,t,o,r,a,i){var v=Math.cos(r),c=Math.sin(r);return this.set(t*v,t*c,-t*(v*a+c*i)+a+n,-o*c,o*v,-o*(-c*a+v*i)+i+e,0,0,1),this}},{key:"scale",value:function(n,e){var t=this.elements;return t[0]*=n,t[3]*=n,t[6]*=n,t[1]*=e,t[4]*=e,t[7]*=e,this}},{key:"rotate",value:function(n){var e=Math.cos(n),t=Math.sin(n),o=this.elements,r=o[0],a=o[3],i=o[6],v=o[1],c=o[4],l=o[7];return o[0]=e*r+t*v,o[3]=e*a+t*c,o[6]=e*i+t*l,o[1]=-t*r+e*v,o[4]=-t*a+e*c,o[7]=-t*i+e*l,this}},{key:"translate",value:function(n,e){var t=this.elements;return t[0]+=n*t[2],t[3]+=n*t[5],t[6]+=n*t[8],t[1]+=e*t[2],t[4]+=e*t[5],t[7]+=e*t[8],this}},{key:"equals",value:function(n){for(var e=this.elements,t=n.elements,o=0;o<9;o++)if(e[o]!==t[o])return!1;return!0}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=0;t<9;t++)this.elements[t]=n[t+e];return this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.elements;return n[e]=t[0],n[e+1]=t[1],n[e+2]=t[2],n[e+3]=t[3],n[e+4]=t[4],n[e+5]=t[5],n[e+6]=t[6],n[e+7]=t[7],n[e+8]=t[8],n}},{key:"clone",value:function(){return(new this.constructor).fromArray(this.elements)}}]),n}();function vo(n){for(var e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}var co={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function lo(n,e){return new co[n](e)}function so(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function uo(n){return n<.04045?.0773993808*n:Math.pow(.9478672986*n+.0521327014,2.4)}function fo(n){return n<.0031308?12.92*n:1.055*Math.pow(n,.41666)-.055}var po=(l(n={},mt,l({},dt,uo)),l(n,dt,l({},mt,fo)),n),mo={legacyMode:!0,get workingColorSpace(){return dt},set workingColorSpace(n){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,e,t){if(this.legacyMode||e===t||!e||!t)return n;if(po[e]&&void 0!==po[e][t]){var o=po[e][t];return n.r=o(n.r),n.g=o(n.g),n.b=o(n.b),n}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(n,e){return this.convert(n,this.workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this.workingColorSpace)}},ho={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},xo={r:0,g:0,b:0},yo={h:0,s:0,l:0},go={h:0,s:0,l:0};function bo(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+6*(e-n)*t:t<.5?e:t<2/3?n+6*(e-n)*(2/3-t):n}function _o(n,e){return e.r=n.r,e.g=n.g,e.b=n.b,e}var Uo,wo=function(n){function e(n,t,o){return y(this,e),this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===t&&void 0===o?this.set(n):this.setRGB(n,t,o)}return b(e,[{key:"set",value:function(n){return n&&n.isColor?this.copy(n):"number"===typeof n?this.setHex(n):"string"===typeof n&&this.setStyle(n),this}},{key:"setScalar",value:function(n){return this.r=n,this.g=n,this.b=n,this}},{key:"setHex",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mt;return n=Math.floor(n),this.r=(n>>16&255)/255,this.g=(n>>8&255)/255,this.b=(255&n)/255,mo.toWorkingColorSpace(this,e),this}},{key:"setRGB",value:function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:dt;return this.r=n,this.g=e,this.b=t,mo.toWorkingColorSpace(this,o),this}},{key:"setHSL",value:function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:dt;if(n=Jt(n,1),e=Qt(e,0,1),t=Qt(t,0,1),0===e)this.r=this.g=this.b=t;else{var r=t<=.5?t*(1+e):t+e-t*e,a=2*t-r;this.r=bo(a,r,n+1/3),this.g=bo(a,r,n),this.b=bo(a,r,n-1/3)}return mo.toWorkingColorSpace(this,o),this}},{key:"setStyle",value:function(n){var e,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mt;function o(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+n+" will be ignored.")}if(e=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(n)){var r,a=e[1],i=e[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,mo.toWorkingColorSpace(this,t),o(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,mo.toWorkingColorSpace(this,t),o(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)){var v=parseFloat(r[1])/360,c=parseFloat(r[2])/100,l=parseFloat(r[3])/100;return o(r[4]),this.setHSL(v,c,l,t)}}}else if(e=/^\#([A-Fa-f\d]+)$/.exec(n)){var s=e[1],u=s.length;if(3===u)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,mo.toWorkingColorSpace(this,t),this;if(6===u)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,mo.toWorkingColorSpace(this,t),this}return n&&n.length>0?this.setColorName(n,t):this}},{key:"setColorName",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mt,t=ho[n.toLowerCase()];return void 0!==t?this.setHex(t,e):console.warn("THREE.Color: Unknown color "+n),this}},{key:"clone",value:function(){return new this.constructor(this.r,this.g,this.b)}},{key:"copy",value:function(n){return this.r=n.r,this.g=n.g,this.b=n.b,this}},{key:"copySRGBToLinear",value:function(n){return this.r=uo(n.r),this.g=uo(n.g),this.b=uo(n.b),this}},{key:"copyLinearToSRGB",value:function(n){return this.r=fo(n.r),this.g=fo(n.g),this.b=fo(n.b),this}},{key:"convertSRGBToLinear",value:function(){return this.copySRGBToLinear(this),this}},{key:"convertLinearToSRGB",value:function(){return this.copyLinearToSRGB(this),this}},{key:"getHex",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mt;return mo.fromWorkingColorSpace(_o(this,xo),n),Qt(255*xo.r,0,255)<<16^Qt(255*xo.g,0,255)<<8^Qt(255*xo.b,0,255)<<0}},{key:"getHexString",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mt;return("000000"+this.getHex(n).toString(16)).slice(-6)}},{key:"getHSL",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:dt;mo.fromWorkingColorSpace(_o(this,xo),e);var t,o,r=xo.r,a=xo.g,i=xo.b,v=Math.max(r,a,i),c=Math.min(r,a,i),l=(c+v)/2;if(c===v)t=0,o=0;else{var s=v-c;switch(o=l<=.5?s/(v+c):s/(2-v-c),v){case r:t=(a-i)/s+(a<i?6:0);break;case a:t=(i-r)/s+2;break;case i:t=(r-a)/s+4}t/=6}return n.h=t,n.s=o,n.l=l,n}},{key:"getRGB",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:dt;return mo.fromWorkingColorSpace(_o(this,xo),e),n.r=xo.r,n.g=xo.g,n.b=xo.b,n}},{key:"getStyle",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mt;return mo.fromWorkingColorSpace(_o(this,xo),n),n!==mt?"color(".concat(n," ").concat(xo.r," ").concat(xo.g," ").concat(xo.b,")"):"rgb(".concat(255*xo.r|0,",").concat(255*xo.g|0,",").concat(255*xo.b|0,")")}},{key:"offsetHSL",value:function(n,e,t){return this.getHSL(yo),yo.h+=n,yo.s+=e,yo.l+=t,this.setHSL(yo.h,yo.s,yo.l),this}},{key:"add",value:function(n){return this.r+=n.r,this.g+=n.g,this.b+=n.b,this}},{key:"addColors",value:function(n,e){return this.r=n.r+e.r,this.g=n.g+e.g,this.b=n.b+e.b,this}},{key:"addScalar",value:function(n){return this.r+=n,this.g+=n,this.b+=n,this}},{key:"sub",value:function(n){return this.r=Math.max(0,this.r-n.r),this.g=Math.max(0,this.g-n.g),this.b=Math.max(0,this.b-n.b),this}},{key:"multiply",value:function(n){return this.r*=n.r,this.g*=n.g,this.b*=n.b,this}},{key:"multiplyScalar",value:function(n){return this.r*=n,this.g*=n,this.b*=n,this}},{key:"lerp",value:function(n,e){return this.r+=(n.r-this.r)*e,this.g+=(n.g-this.g)*e,this.b+=(n.b-this.b)*e,this}},{key:"lerpColors",value:function(n,e,t){return this.r=n.r+(e.r-n.r)*t,this.g=n.g+(e.g-n.g)*t,this.b=n.b+(e.b-n.b)*t,this}},{key:"lerpHSL",value:function(n,e){this.getHSL(yo),n.getHSL(go);var t=Kt(yo.h,go.h,e),o=Kt(yo.s,go.s,e),r=Kt(yo.l,go.l,e);return this.setHSL(t,o,r),this}},{key:"equals",value:function(n){return n.r===this.r&&n.g===this.g&&n.b===this.b}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=n[e],this.g=n[e+1],this.b=n[e+2],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.r,n[e+1]=this.g,n[e+2]=this.b,n}},{key:"fromBufferAttribute",value:function(n,e){return this.r=n.getX(e),this.g=n.getY(e),this.b=n.getZ(e),this}},{key:"toJSON",value:function(){return this.getHex()}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.r;case 2:return n.next=4,this.g;case 4:return n.next=6,this.b;case 6:case"end":return n.stop()}}),n,this)}))}]),e}();wo.NAMES=ho;var So=function(){function n(){y(this,n)}return b(n,null,[{key:"getDataURL",value:function(n){if(/^data:/i.test(n.src))return n.src;if("undefined"==typeof HTMLCanvasElement)return n.src;var e;if(n instanceof HTMLCanvasElement)e=n;else{void 0===Uo&&(Uo=so("canvas")),Uo.width=n.width,Uo.height=n.height;var t=Uo.getContext("2d");n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0,n.width,n.height),e=Uo}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",n),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}},{key:"sRGBToLinear",value:function(n){if("undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap){var e=so("canvas");e.width=n.width,e.height=n.height;var t=e.getContext("2d");t.drawImage(n,0,0,n.width,n.height);for(var o=t.getImageData(0,0,n.width,n.height),r=o.data,a=0;a<r.length;a++)r[a]=255*uo(r[a]/255);return t.putImageData(o,0,0),e}if(n.data){for(var i=n.data.slice(0),v=0;v<i.length;v++)i instanceof Uint8Array||i instanceof Uint8ClampedArray?i[v]=Math.floor(255*uo(i[v]/255)):i[v]=uo(i[v]);return{data:i,width:n.width,height:n.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),n}}]),n}(),Mo=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;y(this,n),this.isSource=!0,this.uuid=Zt(),this.data=e,this.version=0}return b(n,[{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n;if(!e&&void 0!==n.images[this.uuid])return n.images[this.uuid];var t={uuid:this.uuid,url:""},o=this.data;if(null!==o){var r;if(Array.isArray(o)){r=[];for(var a=0,i=o.length;a<i;a++)o[a].isDataTexture?r.push(zo(o[a].image)):r.push(zo(o[a]))}else r=zo(o);t.url=r}return e||(n.images[this.uuid]=t),t}}]),n}();function zo(n){return"undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap?So.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}var ko=0,Co=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.DEFAULT_IMAGE,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.DEFAULT_MAPPING,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Gn,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Gn,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Xn,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:Qn,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:ue,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:Kn,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:1,f=arguments.length>9&&void 0!==arguments[9]?arguments[9]:vt;return y(this,t),(n=e.call(this)).isTexture=!0,Object.defineProperty(S(n),"id",{value:ko++}),n.uuid=Zt(),n.name="",n.source=new Mo(o),n.mipmaps=[],n.mapping=r,n.wrapS=a,n.wrapT=i,n.magFilter=v,n.minFilter=c,n.anisotropy=u,n.format=l,n.internalFormat=null,n.type=s,n.offset=new ao(0,0),n.repeat=new ao(1,1),n.center=new ao(0,0),n.rotation=0,n.matrixAutoUpdate=!0,n.matrix=new io,n.generateMipmaps=!0,n.premultiplyAlpha=!1,n.flipY=!0,n.unpackAlignment=4,n.encoding=f,n.userData={},n.version=0,n.onUpdate=null,n.isRenderTargetTexture=!1,n.needsPMREMUpdate=!1,n}return b(t,[{key:"image",get:function(){return this.source.data},set:function(n){this.source.data=n}},{key:"updateMatrix",value:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.name=n.name,this.source=n.source,this.mipmaps=n.mipmaps.slice(0),this.mapping=n.mapping,this.wrapS=n.wrapS,this.wrapT=n.wrapT,this.magFilter=n.magFilter,this.minFilter=n.minFilter,this.anisotropy=n.anisotropy,this.format=n.format,this.internalFormat=n.internalFormat,this.type=n.type,this.offset.copy(n.offset),this.repeat.copy(n.repeat),this.center.copy(n.center),this.rotation=n.rotation,this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrix.copy(n.matrix),this.generateMipmaps=n.generateMipmaps,this.premultiplyAlpha=n.premultiplyAlpha,this.flipY=n.flipY,this.unpackAlignment=n.unpackAlignment,this.encoding=n.encoding,this.userData=JSON.parse(JSON.stringify(n.userData)),this.needsUpdate=!0,this}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n;if(!e&&void 0!==n.textures[this.uuid])return n.textures[this.uuid];var t={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(n).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(t.userData=this.userData),e||(n.textures[this.uuid]=t),t}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}},{key:"transformUv",value:function(n){if(this.mapping!==Fn)return n;if(n.applyMatrix3(this.matrix),n.x<0||n.x>1)switch(this.wrapS){case An:n.x=n.x-Math.floor(n.x);break;case Gn:n.x=n.x<0?0:1;break;case Nn:1===Math.abs(Math.floor(n.x)%2)?n.x=Math.ceil(n.x)-n.x:n.x=n.x-Math.floor(n.x)}if(n.y<0||n.y>1)switch(this.wrapT){case An:n.y=n.y-Math.floor(n.y);break;case Gn:n.y=n.y<0?0:1;break;case Nn:1===Math.abs(Math.floor(n.y)%2)?n.y=Math.ceil(n.y)-n.y:n.y=n.y-Math.floor(n.y)}return this.flipY&&(n.y=1-n.y),n}},{key:"needsUpdate",set:function(n){!0===n&&(this.version++,this.source.needsUpdate=!0)}}]),t}(Vt);Co.DEFAULT_IMAGE=null,Co.DEFAULT_MAPPING=Fn;var To=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;y(this,e),e.prototype.isVector4=!0,this.x=n,this.y=t,this.z=o,this.w=r}return b(e,[{key:"width",get:function(){return this.z},set:function(n){this.z=n}},{key:"height",get:function(){return this.w},set:function(n){this.w=n}},{key:"set",value:function(n,e,t,o){return this.x=n,this.y=e,this.z=t,this.w=o,this}},{key:"setScalar",value:function(n){return this.x=n,this.y=n,this.z=n,this.w=n,this}},{key:"setX",value:function(n){return this.x=n,this}},{key:"setY",value:function(n){return this.y=n,this}},{key:"setZ",value:function(n){return this.z=n,this}},{key:"setW",value:function(n){return this.w=n,this}},{key:"setComponent",value:function(n,e){switch(n){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+n)}return this}},{key:"getComponent",value:function(n){switch(n){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+n)}}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z,this.w)}},{key:"copy",value:function(n){return this.x=n.x,this.y=n.y,this.z=n.z,this.w=void 0!==n.w?n.w:1,this}},{key:"add",value:function(n){return this.x+=n.x,this.y+=n.y,this.z+=n.z,this.w+=n.w,this}},{key:"addScalar",value:function(n){return this.x+=n,this.y+=n,this.z+=n,this.w+=n,this}},{key:"addVectors",value:function(n,e){return this.x=n.x+e.x,this.y=n.y+e.y,this.z=n.z+e.z,this.w=n.w+e.w,this}},{key:"addScaledVector",value:function(n,e){return this.x+=n.x*e,this.y+=n.y*e,this.z+=n.z*e,this.w+=n.w*e,this}},{key:"sub",value:function(n){return this.x-=n.x,this.y-=n.y,this.z-=n.z,this.w-=n.w,this}},{key:"subScalar",value:function(n){return this.x-=n,this.y-=n,this.z-=n,this.w-=n,this}},{key:"subVectors",value:function(n,e){return this.x=n.x-e.x,this.y=n.y-e.y,this.z=n.z-e.z,this.w=n.w-e.w,this}},{key:"multiply",value:function(n){return this.x*=n.x,this.y*=n.y,this.z*=n.z,this.w*=n.w,this}},{key:"multiplyScalar",value:function(n){return this.x*=n,this.y*=n,this.z*=n,this.w*=n,this}},{key:"applyMatrix4",value:function(n){var e=this.x,t=this.y,o=this.z,r=this.w,a=n.elements;return this.x=a[0]*e+a[4]*t+a[8]*o+a[12]*r,this.y=a[1]*e+a[5]*t+a[9]*o+a[13]*r,this.z=a[2]*e+a[6]*t+a[10]*o+a[14]*r,this.w=a[3]*e+a[7]*t+a[11]*o+a[15]*r,this}},{key:"divideScalar",value:function(n){return this.multiplyScalar(1/n)}},{key:"setAxisAngleFromQuaternion",value:function(n){this.w=2*Math.acos(n.w);var e=Math.sqrt(1-n.w*n.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=n.x/e,this.y=n.y/e,this.z=n.z/e),this}},{key:"setAxisAngleFromRotationMatrix",value:function(n){var e,t,o,r,a=.01,i=.1,v=n.elements,c=v[0],l=v[4],s=v[8],u=v[1],f=v[5],p=v[9],m=v[2],d=v[6],h=v[10];if(Math.abs(l-u)<a&&Math.abs(s-m)<a&&Math.abs(p-d)<a){if(Math.abs(l+u)<i&&Math.abs(s+m)<i&&Math.abs(p+d)<i&&Math.abs(c+f+h-3)<i)return this.set(1,0,0,0),this;e=Math.PI;var x=(c+1)/2,y=(f+1)/2,g=(h+1)/2,b=(l+u)/4,_=(s+m)/4,U=(p+d)/4;return x>y&&x>g?x<a?(t=0,o=.707106781,r=.707106781):(o=b/(t=Math.sqrt(x)),r=_/t):y>g?y<a?(t=.707106781,o=0,r=.707106781):(t=b/(o=Math.sqrt(y)),r=U/o):g<a?(t=.707106781,o=.707106781,r=0):(t=_/(r=Math.sqrt(g)),o=U/r),this.set(t,o,r,e),this}var w=Math.sqrt((d-p)*(d-p)+(s-m)*(s-m)+(u-l)*(u-l));return Math.abs(w)<.001&&(w=1),this.x=(d-p)/w,this.y=(s-m)/w,this.z=(u-l)/w,this.w=Math.acos((c+f+h-1)/2),this}},{key:"min",value:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this.z=Math.min(this.z,n.z),this.w=Math.min(this.w,n.w),this}},{key:"max",value:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this.z=Math.max(this.z,n.z),this.w=Math.max(this.w,n.w),this}},{key:"clamp",value:function(n,e){return this.x=Math.max(n.x,Math.min(e.x,this.x)),this.y=Math.max(n.y,Math.min(e.y,this.y)),this.z=Math.max(n.z,Math.min(e.z,this.z)),this.w=Math.max(n.w,Math.min(e.w,this.w)),this}},{key:"clampScalar",value:function(n,e){return this.x=Math.max(n,Math.min(e,this.x)),this.y=Math.max(n,Math.min(e,this.y)),this.z=Math.max(n,Math.min(e,this.z)),this.w=Math.max(n,Math.min(e,this.w)),this}},{key:"clampLength",value:function(n,e){var t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(n,Math.min(e,t)))}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}},{key:"roundToZero",value:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}},{key:"dot",value:function(n){return this.x*n.x+this.y*n.y+this.z*n.z+this.w*n.w}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}},{key:"normalize",value:function(){return this.divideScalar(this.length()||1)}},{key:"setLength",value:function(n){return this.normalize().multiplyScalar(n)}},{key:"lerp",value:function(n,e){return this.x+=(n.x-this.x)*e,this.y+=(n.y-this.y)*e,this.z+=(n.z-this.z)*e,this.w+=(n.w-this.w)*e,this}},{key:"lerpVectors",value:function(n,e,t){return this.x=n.x+(e.x-n.x)*t,this.y=n.y+(e.y-n.y)*t,this.z=n.z+(e.z-n.z)*t,this.w=n.w+(e.w-n.w)*t,this}},{key:"equals",value:function(n){return n.x===this.x&&n.y===this.y&&n.z===this.z&&n.w===this.w}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=n[e],this.y=n[e+1],this.z=n[e+2],this.w=n[e+3],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.x,n[e+1]=this.y,n[e+2]=this.z,n[e+3]=this.w,n}},{key:"fromBufferAttribute",value:function(n,e){return this.x=n.getX(e),this.y=n.getY(e),this.z=n.getZ(e),this.w=n.getW(e),this}},{key:"random",value:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.x;case 2:return n.next=4,this.y;case 4:return n.next=6,this.z;case 6:return n.next=8,this.w;case 8:case"end":return n.stop()}}),n,this)}))}]),e}(),Ro=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};y(this,t),(n=e.call(this)).isWebGLRenderTarget=!0,n.width=o,n.height=r,n.depth=1,n.scissor=new To(0,0,o,r),n.scissorTest=!1,n.viewport=new To(0,0,o,r);var i={width:o,height:r,depth:1};return n.texture=new Co(i,a.mapping,a.wrapS,a.wrapT,a.magFilter,a.minFilter,a.format,a.type,a.anisotropy,a.encoding),n.texture.isRenderTargetTexture=!0,n.texture.flipY=!1,n.texture.generateMipmaps=void 0!==a.generateMipmaps&&a.generateMipmaps,n.texture.internalFormat=void 0!==a.internalFormat?a.internalFormat:null,n.texture.minFilter=void 0!==a.minFilter?a.minFilter:Xn,n.depthBuffer=void 0===a.depthBuffer||a.depthBuffer,n.stencilBuffer=void 0!==a.stencilBuffer&&a.stencilBuffer,n.depthTexture=void 0!==a.depthTexture?a.depthTexture:null,n.samples=void 0!==a.samples?a.samples:0,n}return b(t,[{key:"setSize",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;this.width===n&&this.height===e&&this.depth===t||(this.width=n,this.height=e,this.depth=t,this.texture.image.width=n,this.texture.image.height=e,this.texture.image.depth=t,this.dispose()),this.viewport.set(0,0,n,e),this.scissor.set(0,0,n,e)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){this.width=n.width,this.height=n.height,this.depth=n.depth,this.viewport.copy(n.viewport),this.texture=n.texture.clone(),this.texture.isRenderTargetTexture=!0;var e=Object.assign({},n.texture.image);return this.texture.source=new Mo(e),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,null!==n.depthTexture&&(this.depthTexture=n.depthTexture.clone()),this.samples=n.samples,this}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}}]),t}(Vt),Do=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return y(this,t),(n=e.call(this,null)).isDataArrayTexture=!0,n.image={data:o,width:r,height:a,depth:i},n.magFilter=Bn,n.minFilter=Bn,n.wrapR=Gn,n.generateMipmaps=!1,n.flipY=!1,n.unpackAlignment=1,n}return b(t)}(Co),Po=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return y(this,t),(n=e.call(this,o,r)).isWebGLArrayRenderTarget=!0,n.depth=a,n.texture=new Do(null,o,r,a),n.texture.isRenderTargetTexture=!0,n}return b(t)}(Ro),Fo=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return y(this,t),(n=e.call(this,null)).isData3DTexture=!0,n.image={data:o,width:r,height:a,depth:i},n.magFilter=Bn,n.minFilter=Bn,n.wrapR=Gn,n.generateMipmaps=!1,n.flipY=!1,n.unpackAlignment=1,n}return b(t)}(Co),jo=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return y(this,t),(n=e.call(this,o,r)).isWebGL3DRenderTarget=!0,n.depth=a,n.texture=new Fo(null,o,r,a),n.texture.isRenderTargetTexture=!0,n}return b(t)}(Ro),Io=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};y(this,t),(n=e.call(this,o,r,i)).isWebGLMultipleRenderTargets=!0;var v=n.texture;n.texture=[];for(var c=0;c<a;c++)n.texture[c]=v.clone(),n.texture[c].isRenderTargetTexture=!0;return n}return b(t,[{key:"setSize",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(this.width!==n||this.height!==e||this.depth!==t){this.width=n,this.height=e,this.depth=t;for(var o=0,r=this.texture.length;o<r;o++)this.texture[o].image.width=n,this.texture[o].image.height=e,this.texture[o].image.depth=t;this.dispose()}return this.viewport.set(0,0,n,e),this.scissor.set(0,0,n,e),this}},{key:"copy",value:function(n){this.dispose(),this.width=n.width,this.height=n.height,this.depth=n.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,null!==n.depthTexture&&(this.depthTexture=n.depthTexture.clone()),this.texture.length=0;for(var e=0,t=n.texture.length;e<t;e++)this.texture[e]=n.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}}]),t}(Ro),Eo=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;y(this,e),this.isQuaternion=!0,this._x=n,this._y=t,this._z=o,this._w=r}return b(e,[{key:"x",get:function(){return this._x},set:function(n){this._x=n,this._onChangeCallback()}},{key:"y",get:function(){return this._y},set:function(n){this._y=n,this._onChangeCallback()}},{key:"z",get:function(){return this._z},set:function(n){this._z=n,this._onChangeCallback()}},{key:"w",get:function(){return this._w},set:function(n){this._w=n,this._onChangeCallback()}},{key:"set",value:function(n,e,t,o){return this._x=n,this._y=e,this._z=t,this._w=o,this._onChangeCallback(),this}},{key:"clone",value:function(){return new this.constructor(this._x,this._y,this._z,this._w)}},{key:"copy",value:function(n){return this._x=n.x,this._y=n.y,this._z=n.z,this._w=n.w,this._onChangeCallback(),this}},{key:"setFromEuler",value:function(n,e){var t=n._x,o=n._y,r=n._z,a=n._order,i=Math.cos,v=Math.sin,c=i(t/2),l=i(o/2),s=i(r/2),u=v(t/2),f=v(o/2),p=v(r/2);switch(a){case"XYZ":this._x=u*l*s+c*f*p,this._y=c*f*s-u*l*p,this._z=c*l*p+u*f*s,this._w=c*l*s-u*f*p;break;case"YXZ":this._x=u*l*s+c*f*p,this._y=c*f*s-u*l*p,this._z=c*l*p-u*f*s,this._w=c*l*s+u*f*p;break;case"ZXY":this._x=u*l*s-c*f*p,this._y=c*f*s+u*l*p,this._z=c*l*p+u*f*s,this._w=c*l*s-u*f*p;break;case"ZYX":this._x=u*l*s-c*f*p,this._y=c*f*s+u*l*p,this._z=c*l*p-u*f*s,this._w=c*l*s+u*f*p;break;case"YZX":this._x=u*l*s+c*f*p,this._y=c*f*s+u*l*p,this._z=c*l*p-u*f*s,this._w=c*l*s-u*f*p;break;case"XZY":this._x=u*l*s-c*f*p,this._y=c*f*s-u*l*p,this._z=c*l*p+u*f*s,this._w=c*l*s+u*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return!1!==e&&this._onChangeCallback(),this}},{key:"setFromAxisAngle",value:function(n,e){var t=e/2,o=Math.sin(t);return this._x=n.x*o,this._y=n.y*o,this._z=n.z*o,this._w=Math.cos(t),this._onChangeCallback(),this}},{key:"setFromRotationMatrix",value:function(n){var e=n.elements,t=e[0],o=e[4],r=e[8],a=e[1],i=e[5],v=e[9],c=e[2],l=e[6],s=e[10],u=t+i+s;if(u>0){var f=.5/Math.sqrt(u+1);this._w=.25/f,this._x=(l-v)*f,this._y=(r-c)*f,this._z=(a-o)*f}else if(t>i&&t>s){var p=2*Math.sqrt(1+t-i-s);this._w=(l-v)/p,this._x=.25*p,this._y=(o+a)/p,this._z=(r+c)/p}else if(i>s){var m=2*Math.sqrt(1+i-t-s);this._w=(r-c)/m,this._x=(o+a)/m,this._y=.25*m,this._z=(v+l)/m}else{var d=2*Math.sqrt(1+s-t-i);this._w=(a-o)/d,this._x=(r+c)/d,this._y=(v+l)/d,this._z=.25*d}return this._onChangeCallback(),this}},{key:"setFromUnitVectors",value:function(n,e){var t=n.dot(e)+1;return t<Number.EPSILON?(t=0,Math.abs(n.x)>Math.abs(n.z)?(this._x=-n.y,this._y=n.x,this._z=0,this._w=t):(this._x=0,this._y=-n.z,this._z=n.y,this._w=t)):(this._x=n.y*e.z-n.z*e.y,this._y=n.z*e.x-n.x*e.z,this._z=n.x*e.y-n.y*e.x,this._w=t),this.normalize()}},{key:"angleTo",value:function(n){return 2*Math.acos(Math.abs(Qt(this.dot(n),-1,1)))}},{key:"rotateTowards",value:function(n,e){var t=this.angleTo(n);if(0===t)return this;var o=Math.min(1,e/t);return this.slerp(n,o),this}},{key:"identity",value:function(){return this.set(0,0,0,1)}},{key:"invert",value:function(){return this.conjugate()}},{key:"conjugate",value:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}},{key:"dot",value:function(n){return this._x*n._x+this._y*n._y+this._z*n._z+this._w*n._w}},{key:"lengthSq",value:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}},{key:"length",value:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}},{key:"normalize",value:function(){var n=this.length();return 0===n?(this._x=0,this._y=0,this._z=0,this._w=1):(n=1/n,this._x=this._x*n,this._y=this._y*n,this._z=this._z*n,this._w=this._w*n),this._onChangeCallback(),this}},{key:"multiply",value:function(n){return this.multiplyQuaternions(this,n)}},{key:"premultiply",value:function(n){return this.multiplyQuaternions(n,this)}},{key:"multiplyQuaternions",value:function(n,e){var t=n._x,o=n._y,r=n._z,a=n._w,i=e._x,v=e._y,c=e._z,l=e._w;return this._x=t*l+a*i+o*c-r*v,this._y=o*l+a*v+r*i-t*c,this._z=r*l+a*c+t*v-o*i,this._w=a*l-t*i-o*v-r*c,this._onChangeCallback(),this}},{key:"slerp",value:function(n,e){if(0===e)return this;if(1===e)return this.copy(n);var t=this._x,o=this._y,r=this._z,a=this._w,i=a*n._w+t*n._x+o*n._y+r*n._z;if(i<0?(this._w=-n._w,this._x=-n._x,this._y=-n._y,this._z=-n._z,i=-i):this.copy(n),i>=1)return this._w=a,this._x=t,this._y=o,this._z=r,this;var v=1-i*i;if(v<=Number.EPSILON){var c=1-e;return this._w=c*a+e*this._w,this._x=c*t+e*this._x,this._y=c*o+e*this._y,this._z=c*r+e*this._z,this.normalize(),this._onChangeCallback(),this}var l=Math.sqrt(v),s=Math.atan2(l,i),u=Math.sin((1-e)*s)/l,f=Math.sin(e*s)/l;return this._w=a*u+this._w*f,this._x=t*u+this._x*f,this._y=o*u+this._y*f,this._z=r*u+this._z*f,this._onChangeCallback(),this}},{key:"slerpQuaternions",value:function(n,e,t){return this.copy(n).slerp(e,t)}},{key:"random",value:function(){var n=Math.random(),e=Math.sqrt(1-n),t=Math.sqrt(n),o=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(o),t*Math.sin(r),t*Math.cos(r),e*Math.sin(o))}},{key:"equals",value:function(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._w===this._w}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._x=n[e],this._y=n[e+1],this._z=n[e+2],this._w=n[e+3],this._onChangeCallback(),this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this._x,n[e+1]=this._y,n[e+2]=this._z,n[e+3]=this._w,n}},{key:"fromBufferAttribute",value:function(n,e){return this._x=n.getX(e),this._y=n.getY(e),this._z=n.getZ(e),this._w=n.getW(e),this}},{key:"_onChange",value:function(n){return this._onChangeCallback=n,this}},{key:"_onChangeCallback",value:function(){}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this._x;case 2:return n.next=4,this._y;case 4:return n.next=6,this._z;case 6:return n.next=8,this._w;case 8:case"end":return n.stop()}}),n,this)}))}],[{key:"slerpFlat",value:function(n,e,t,o,r,a,i){var v=t[o+0],c=t[o+1],l=t[o+2],s=t[o+3],u=r[a+0],f=r[a+1],p=r[a+2],m=r[a+3];if(0===i)return n[e+0]=v,n[e+1]=c,n[e+2]=l,void(n[e+3]=s);if(1===i)return n[e+0]=u,n[e+1]=f,n[e+2]=p,void(n[e+3]=m);if(s!==m||v!==u||c!==f||l!==p){var d=1-i,h=v*u+c*f+l*p+s*m,x=h>=0?1:-1,y=1-h*h;if(y>Number.EPSILON){var g=Math.sqrt(y),b=Math.atan2(g,h*x);d=Math.sin(d*b)/g,i=Math.sin(i*b)/g}var _=i*x;if(v=v*d+u*_,c=c*d+f*_,l=l*d+p*_,s=s*d+m*_,d===1-i){var U=1/Math.sqrt(v*v+c*c+l*l+s*s);v*=U,c*=U,l*=U,s*=U}}n[e]=v,n[e+1]=c,n[e+2]=l,n[e+3]=s}},{key:"multiplyQuaternionsFlat",value:function(n,e,t,o,r,a){var i=t[o],v=t[o+1],c=t[o+2],l=t[o+3],s=r[a],u=r[a+1],f=r[a+2],p=r[a+3];return n[e]=i*p+l*s+v*f-c*u,n[e+1]=v*p+l*u+c*s-i*f,n[e+2]=c*p+l*f+i*u-v*s,n[e+3]=l*p-i*s-v*u-c*f,n}}]),e}(),Oo=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;y(this,e),e.prototype.isVector3=!0,this.x=n,this.y=t,this.z=o}return b(e,[{key:"set",value:function(n,e,t){return void 0===t&&(t=this.z),this.x=n,this.y=e,this.z=t,this}},{key:"setScalar",value:function(n){return this.x=n,this.y=n,this.z=n,this}},{key:"setX",value:function(n){return this.x=n,this}},{key:"setY",value:function(n){return this.y=n,this}},{key:"setZ",value:function(n){return this.z=n,this}},{key:"setComponent",value:function(n,e){switch(n){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+n)}return this}},{key:"getComponent",value:function(n){switch(n){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+n)}}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z)}},{key:"copy",value:function(n){return this.x=n.x,this.y=n.y,this.z=n.z,this}},{key:"add",value:function(n){return this.x+=n.x,this.y+=n.y,this.z+=n.z,this}},{key:"addScalar",value:function(n){return this.x+=n,this.y+=n,this.z+=n,this}},{key:"addVectors",value:function(n,e){return this.x=n.x+e.x,this.y=n.y+e.y,this.z=n.z+e.z,this}},{key:"addScaledVector",value:function(n,e){return this.x+=n.x*e,this.y+=n.y*e,this.z+=n.z*e,this}},{key:"sub",value:function(n){return this.x-=n.x,this.y-=n.y,this.z-=n.z,this}},{key:"subScalar",value:function(n){return this.x-=n,this.y-=n,this.z-=n,this}},{key:"subVectors",value:function(n,e){return this.x=n.x-e.x,this.y=n.y-e.y,this.z=n.z-e.z,this}},{key:"multiply",value:function(n){return this.x*=n.x,this.y*=n.y,this.z*=n.z,this}},{key:"multiplyScalar",value:function(n){return this.x*=n,this.y*=n,this.z*=n,this}},{key:"multiplyVectors",value:function(n,e){return this.x=n.x*e.x,this.y=n.y*e.y,this.z=n.z*e.z,this}},{key:"applyEuler",value:function(n){return this.applyQuaternion(Ao.setFromEuler(n))}},{key:"applyAxisAngle",value:function(n,e){return this.applyQuaternion(Ao.setFromAxisAngle(n,e))}},{key:"applyMatrix3",value:function(n){var e=this.x,t=this.y,o=this.z,r=n.elements;return this.x=r[0]*e+r[3]*t+r[6]*o,this.y=r[1]*e+r[4]*t+r[7]*o,this.z=r[2]*e+r[5]*t+r[8]*o,this}},{key:"applyNormalMatrix",value:function(n){return this.applyMatrix3(n).normalize()}},{key:"applyMatrix4",value:function(n){var e=this.x,t=this.y,o=this.z,r=n.elements,a=1/(r[3]*e+r[7]*t+r[11]*o+r[15]);return this.x=(r[0]*e+r[4]*t+r[8]*o+r[12])*a,this.y=(r[1]*e+r[5]*t+r[9]*o+r[13])*a,this.z=(r[2]*e+r[6]*t+r[10]*o+r[14])*a,this}},{key:"applyQuaternion",value:function(n){var e=this.x,t=this.y,o=this.z,r=n.x,a=n.y,i=n.z,v=n.w,c=v*e+a*o-i*t,l=v*t+i*e-r*o,s=v*o+r*t-a*e,u=-r*e-a*t-i*o;return this.x=c*v+u*-r+l*-i-s*-a,this.y=l*v+u*-a+s*-r-c*-i,this.z=s*v+u*-i+c*-a-l*-r,this}},{key:"project",value:function(n){return this.applyMatrix4(n.matrixWorldInverse).applyMatrix4(n.projectionMatrix)}},{key:"unproject",value:function(n){return this.applyMatrix4(n.projectionMatrixInverse).applyMatrix4(n.matrixWorld)}},{key:"transformDirection",value:function(n){var e=this.x,t=this.y,o=this.z,r=n.elements;return this.x=r[0]*e+r[4]*t+r[8]*o,this.y=r[1]*e+r[5]*t+r[9]*o,this.z=r[2]*e+r[6]*t+r[10]*o,this.normalize()}},{key:"divide",value:function(n){return this.x/=n.x,this.y/=n.y,this.z/=n.z,this}},{key:"divideScalar",value:function(n){return this.multiplyScalar(1/n)}},{key:"min",value:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this.z=Math.min(this.z,n.z),this}},{key:"max",value:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this.z=Math.max(this.z,n.z),this}},{key:"clamp",value:function(n,e){return this.x=Math.max(n.x,Math.min(e.x,this.x)),this.y=Math.max(n.y,Math.min(e.y,this.y)),this.z=Math.max(n.z,Math.min(e.z,this.z)),this}},{key:"clampScalar",value:function(n,e){return this.x=Math.max(n,Math.min(e,this.x)),this.y=Math.max(n,Math.min(e,this.y)),this.z=Math.max(n,Math.min(e,this.z)),this}},{key:"clampLength",value:function(n,e){var t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(n,Math.min(e,t)))}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}},{key:"roundToZero",value:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}},{key:"dot",value:function(n){return this.x*n.x+this.y*n.y+this.z*n.z}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}},{key:"normalize",value:function(){return this.divideScalar(this.length()||1)}},{key:"setLength",value:function(n){return this.normalize().multiplyScalar(n)}},{key:"lerp",value:function(n,e){return this.x+=(n.x-this.x)*e,this.y+=(n.y-this.y)*e,this.z+=(n.z-this.z)*e,this}},{key:"lerpVectors",value:function(n,e,t){return this.x=n.x+(e.x-n.x)*t,this.y=n.y+(e.y-n.y)*t,this.z=n.z+(e.z-n.z)*t,this}},{key:"cross",value:function(n){return this.crossVectors(this,n)}},{key:"crossVectors",value:function(n,e){var t=n.x,o=n.y,r=n.z,a=e.x,i=e.y,v=e.z;return this.x=o*v-r*i,this.y=r*a-t*v,this.z=t*i-o*a,this}},{key:"projectOnVector",value:function(n){var e=n.lengthSq();if(0===e)return this.set(0,0,0);var t=n.dot(this)/e;return this.copy(n).multiplyScalar(t)}},{key:"projectOnPlane",value:function(n){return Lo.copy(this).projectOnVector(n),this.sub(Lo)}},{key:"reflect",value:function(n){return this.sub(Lo.copy(n).multiplyScalar(2*this.dot(n)))}},{key:"angleTo",value:function(n){var e=Math.sqrt(this.lengthSq()*n.lengthSq());if(0===e)return Math.PI/2;var t=this.dot(n)/e;return Math.acos(Qt(t,-1,1))}},{key:"distanceTo",value:function(n){return Math.sqrt(this.distanceToSquared(n))}},{key:"distanceToSquared",value:function(n){var e=this.x-n.x,t=this.y-n.y,o=this.z-n.z;return e*e+t*t+o*o}},{key:"manhattanDistanceTo",value:function(n){return Math.abs(this.x-n.x)+Math.abs(this.y-n.y)+Math.abs(this.z-n.z)}},{key:"setFromSpherical",value:function(n){return this.setFromSphericalCoords(n.radius,n.phi,n.theta)}},{key:"setFromSphericalCoords",value:function(n,e,t){var o=Math.sin(e)*n;return this.x=o*Math.sin(t),this.y=Math.cos(e)*n,this.z=o*Math.cos(t),this}},{key:"setFromCylindrical",value:function(n){return this.setFromCylindricalCoords(n.radius,n.theta,n.y)}},{key:"setFromCylindricalCoords",value:function(n,e,t){return this.x=n*Math.sin(e),this.y=t,this.z=n*Math.cos(e),this}},{key:"setFromMatrixPosition",value:function(n){var e=n.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}},{key:"setFromMatrixScale",value:function(n){var e=this.setFromMatrixColumn(n,0).length(),t=this.setFromMatrixColumn(n,1).length(),o=this.setFromMatrixColumn(n,2).length();return this.x=e,this.y=t,this.z=o,this}},{key:"setFromMatrixColumn",value:function(n,e){return this.fromArray(n.elements,4*e)}},{key:"setFromMatrix3Column",value:function(n,e){return this.fromArray(n.elements,3*e)}},{key:"setFromEuler",value:function(n){return this.x=n._x,this.y=n._y,this.z=n._z,this}},{key:"equals",value:function(n){return n.x===this.x&&n.y===this.y&&n.z===this.z}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=n[e],this.y=n[e+1],this.z=n[e+2],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.x,n[e+1]=this.y,n[e+2]=this.z,n}},{key:"fromBufferAttribute",value:function(n,e){return this.x=n.getX(e),this.y=n.getY(e),this.z=n.getZ(e),this}},{key:"random",value:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}},{key:"randomDirection",value:function(){var n=2*(Math.random()-.5),e=Math.random()*Math.PI*2,t=Math.sqrt(1-Math.pow(n,2));return this.x=t*Math.cos(e),this.y=t*Math.sin(e),this.z=n,this}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.x;case 2:return n.next=4,this.y;case 4:return n.next=6,this.z;case 6:case"end":return n.stop()}}),n,this)}))}]),e}(),Lo=new Oo,Ao=new Eo,Go=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo(1/0,1/0,1/0),t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo(-1/0,-1/0,-1/0);y(this,n),this.isBox3=!0,this.min=e,this.max=t}return b(n,[{key:"set",value:function(n,e){return this.min.copy(n),this.max.copy(e),this}},{key:"setFromArray",value:function(n){for(var e=1/0,t=1/0,o=1/0,r=-1/0,a=-1/0,i=-1/0,v=0,c=n.length;v<c;v+=3){var l=n[v],s=n[v+1],u=n[v+2];l<e&&(e=l),s<t&&(t=s),u<o&&(o=u),l>r&&(r=l),s>a&&(a=s),u>i&&(i=u)}return this.min.set(e,t,o),this.max.set(r,a,i),this}},{key:"setFromBufferAttribute",value:function(n){for(var e=1/0,t=1/0,o=1/0,r=-1/0,a=-1/0,i=-1/0,v=0,c=n.count;v<c;v++){var l=n.getX(v),s=n.getY(v),u=n.getZ(v);l<e&&(e=l),s<t&&(t=s),u<o&&(o=u),l>r&&(r=l),s>a&&(a=s),u>i&&(i=u)}return this.min.set(e,t,o),this.max.set(r,a,i),this}},{key:"setFromPoints",value:function(n){this.makeEmpty();for(var e=0,t=n.length;e<t;e++)this.expandByPoint(n[e]);return this}},{key:"setFromCenterAndSize",value:function(n,e){var t=Bo.copy(e).multiplyScalar(.5);return this.min.copy(n).sub(t),this.max.copy(n).add(t),this}},{key:"setFromObject",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this.makeEmpty(),this.expandByObject(n,e)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.min.copy(n.min),this.max.copy(n.max),this}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}},{key:"getCenter",value:function(n){return this.isEmpty()?n.set(0,0,0):n.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(n){return this.isEmpty()?n.set(0,0,0):n.subVectors(this.max,this.min)}},{key:"expandByPoint",value:function(n){return this.min.min(n),this.max.max(n),this}},{key:"expandByVector",value:function(n){return this.min.sub(n),this.max.add(n),this}},{key:"expandByScalar",value:function(n){return this.min.addScalar(-n),this.max.addScalar(n),this}},{key:"expandByObject",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n.updateWorldMatrix(!1,!1);var t=n.geometry;if(void 0!==t)if(e&&void 0!=t.attributes&&void 0!==t.attributes.position)for(var o=t.attributes.position,r=0,a=o.count;r<a;r++)Bo.fromBufferAttribute(o,r).applyMatrix4(n.matrixWorld),this.expandByPoint(Bo);else null===t.boundingBox&&t.computeBoundingBox(),qo.copy(t.boundingBox),qo.applyMatrix4(n.matrixWorld),this.union(qo);for(var i=n.children,v=0,c=i.length;v<c;v++)this.expandByObject(i[v],e);return this}},{key:"containsPoint",value:function(n){return!(n.x<this.min.x||n.x>this.max.x||n.y<this.min.y||n.y>this.max.y||n.z<this.min.z||n.z>this.max.z)}},{key:"containsBox",value:function(n){return this.min.x<=n.min.x&&n.max.x<=this.max.x&&this.min.y<=n.min.y&&n.max.y<=this.max.y&&this.min.z<=n.min.z&&n.max.z<=this.max.z}},{key:"getParameter",value:function(n,e){return e.set((n.x-this.min.x)/(this.max.x-this.min.x),(n.y-this.min.y)/(this.max.y-this.min.y),(n.z-this.min.z)/(this.max.z-this.min.z))}},{key:"intersectsBox",value:function(n){return!(n.max.x<this.min.x||n.min.x>this.max.x||n.max.y<this.min.y||n.min.y>this.max.y||n.max.z<this.min.z||n.min.z>this.max.z)}},{key:"intersectsSphere",value:function(n){return this.clampPoint(n.center,Bo),Bo.distanceToSquared(n.center)<=n.radius*n.radius}},{key:"intersectsPlane",value:function(n){var e,t;return n.normal.x>0?(e=n.normal.x*this.min.x,t=n.normal.x*this.max.x):(e=n.normal.x*this.max.x,t=n.normal.x*this.min.x),n.normal.y>0?(e+=n.normal.y*this.min.y,t+=n.normal.y*this.max.y):(e+=n.normal.y*this.max.y,t+=n.normal.y*this.min.y),n.normal.z>0?(e+=n.normal.z*this.min.z,t+=n.normal.z*this.max.z):(e+=n.normal.z*this.max.z,t+=n.normal.z*this.min.z),e<=-n.constant&&t>=-n.constant}},{key:"intersectsTriangle",value:function(n){if(this.isEmpty())return!1;this.getCenter(Qo),Jo.subVectors(this.max,Qo),Vo.subVectors(n.a,Qo),Wo.subVectors(n.b,Qo),Ho.subVectors(n.c,Qo),Xo.subVectors(Wo,Vo),Yo.subVectors(Ho,Wo),Zo.subVectors(Vo,Ho);var e=[0,-Xo.z,Xo.y,0,-Yo.z,Yo.y,0,-Zo.z,Zo.y,Xo.z,0,-Xo.x,Yo.z,0,-Yo.x,Zo.z,0,-Zo.x,-Xo.y,Xo.x,0,-Yo.y,Yo.x,0,-Zo.y,Zo.x,0];return!!nr(e,Vo,Wo,Ho,Jo)&&(!!nr(e=[1,0,0,0,1,0,0,0,1],Vo,Wo,Ho,Jo)&&(Ko.crossVectors(Xo,Yo),nr(e=[Ko.x,Ko.y,Ko.z],Vo,Wo,Ho,Jo)))}},{key:"clampPoint",value:function(n,e){return e.copy(n).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(n){return Bo.copy(n).clamp(this.min,this.max).sub(n).length()}},{key:"getBoundingSphere",value:function(n){return this.getCenter(n.center),n.radius=.5*this.getSize(Bo).length(),n}},{key:"intersect",value:function(n){return this.min.max(n.min),this.max.min(n.max),this.isEmpty()&&this.makeEmpty(),this}},{key:"union",value:function(n){return this.min.min(n.min),this.max.max(n.max),this}},{key:"applyMatrix4",value:function(n){return this.isEmpty()||(No[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(n),No[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(n),No[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(n),No[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(n),No[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(n),No[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(n),No[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(n),No[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(n),this.setFromPoints(No)),this}},{key:"translate",value:function(n){return this.min.add(n),this.max.add(n),this}},{key:"equals",value:function(n){return n.min.equals(this.min)&&n.max.equals(this.max)}}]),n}(),No=[new Oo,new Oo,new Oo,new Oo,new Oo,new Oo,new Oo,new Oo],Bo=new Oo,qo=new Go,Vo=new Oo,Wo=new Oo,Ho=new Oo,Xo=new Oo,Yo=new Oo,Zo=new Oo,Qo=new Oo,Jo=new Oo,Ko=new Oo,$o=new Oo;function nr(n,e,t,o,r){for(var a=0,i=n.length-3;a<=i;a+=3){$o.fromArray(n,a);var v=r.x*Math.abs($o.x)+r.y*Math.abs($o.y)+r.z*Math.abs($o.z),c=e.dot($o),l=t.dot($o),s=o.dot($o);if(Math.max(-Math.max(c,l,s),Math.min(c,l,s))>v)return!1}return!0}var er=new Go,tr=new Oo,or=new Oo,rr=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;y(this,n),this.center=e,this.radius=t}return b(n,[{key:"set",value:function(n,e){return this.center.copy(n),this.radius=e,this}},{key:"setFromPoints",value:function(n,e){var t=this.center;void 0!==e?t.copy(e):er.setFromPoints(n).getCenter(t);for(var o=0,r=0,a=n.length;r<a;r++)o=Math.max(o,t.distanceToSquared(n[r]));return this.radius=Math.sqrt(o),this}},{key:"copy",value:function(n){return this.center.copy(n.center),this.radius=n.radius,this}},{key:"isEmpty",value:function(){return this.radius<0}},{key:"makeEmpty",value:function(){return this.center.set(0,0,0),this.radius=-1,this}},{key:"containsPoint",value:function(n){return n.distanceToSquared(this.center)<=this.radius*this.radius}},{key:"distanceToPoint",value:function(n){return n.distanceTo(this.center)-this.radius}},{key:"intersectsSphere",value:function(n){var e=this.radius+n.radius;return n.center.distanceToSquared(this.center)<=e*e}},{key:"intersectsBox",value:function(n){return n.intersectsSphere(this)}},{key:"intersectsPlane",value:function(n){return Math.abs(n.distanceToPoint(this.center))<=this.radius}},{key:"clampPoint",value:function(n,e){var t=this.center.distanceToSquared(n);return e.copy(n),t>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}},{key:"getBoundingBox",value:function(n){return this.isEmpty()?(n.makeEmpty(),n):(n.set(this.center,this.center),n.expandByScalar(this.radius),n)}},{key:"applyMatrix4",value:function(n){return this.center.applyMatrix4(n),this.radius=this.radius*n.getMaxScaleOnAxis(),this}},{key:"translate",value:function(n){return this.center.add(n),this}},{key:"expandByPoint",value:function(n){if(this.isEmpty())return this.center.copy(n),this.radius=0,this;tr.subVectors(n,this.center);var e=tr.lengthSq();if(e>this.radius*this.radius){var t=Math.sqrt(e),o=.5*(t-this.radius);this.center.addScaledVector(tr,o/t),this.radius+=o}return this}},{key:"union",value:function(n){return n.isEmpty()?this:this.isEmpty()?(this.copy(n),this):(!0===this.center.equals(n.center)?this.radius=Math.max(this.radius,n.radius):(or.subVectors(n.center,this.center).setLength(n.radius),this.expandByPoint(tr.copy(n.center).add(or)),this.expandByPoint(tr.copy(n.center).sub(or))),this)}},{key:"equals",value:function(n){return n.center.equals(this.center)&&n.radius===this.radius}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),ar=new Oo,ir=new Oo,vr=new Oo,cr=new Oo,lr=new Oo,sr=new Oo,ur=new Oo,fr=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo(0,0,-1);y(this,n),this.origin=e,this.direction=t}return b(n,[{key:"set",value:function(n,e){return this.origin.copy(n),this.direction.copy(e),this}},{key:"copy",value:function(n){return this.origin.copy(n.origin),this.direction.copy(n.direction),this}},{key:"at",value:function(n,e){return e.copy(this.direction).multiplyScalar(n).add(this.origin)}},{key:"lookAt",value:function(n){return this.direction.copy(n).sub(this.origin).normalize(),this}},{key:"recast",value:function(n){return this.origin.copy(this.at(n,ar)),this}},{key:"closestPointToPoint",value:function(n,e){e.subVectors(n,this.origin);var t=e.dot(this.direction);return t<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(t).add(this.origin)}},{key:"distanceToPoint",value:function(n){return Math.sqrt(this.distanceSqToPoint(n))}},{key:"distanceSqToPoint",value:function(n){var e=ar.subVectors(n,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(n):(ar.copy(this.direction).multiplyScalar(e).add(this.origin),ar.distanceToSquared(n))}},{key:"distanceSqToSegment",value:function(n,e,t,o){ir.copy(n).add(e).multiplyScalar(.5),vr.copy(e).sub(n).normalize(),cr.copy(this.origin).sub(ir);var r,a,i,v,c=.5*n.distanceTo(e),l=-this.direction.dot(vr),s=cr.dot(this.direction),u=-cr.dot(vr),f=cr.lengthSq(),p=Math.abs(1-l*l);if(p>0)if(a=l*s-u,v=c*p,(r=l*u-s)>=0)if(a>=-v)if(a<=v){var m=1/p;i=(r*=m)*(r+l*(a*=m)+2*s)+a*(l*r+a+2*u)+f}else a=c,i=-(r=Math.max(0,-(l*a+s)))*r+a*(a+2*u)+f;else a=-c,i=-(r=Math.max(0,-(l*a+s)))*r+a*(a+2*u)+f;else a<=-v?i=-(r=Math.max(0,-(-l*c+s)))*r+(a=r>0?-c:Math.min(Math.max(-c,-u),c))*(a+2*u)+f:a<=v?(r=0,i=(a=Math.min(Math.max(-c,-u),c))*(a+2*u)+f):i=-(r=Math.max(0,-(l*c+s)))*r+(a=r>0?c:Math.min(Math.max(-c,-u),c))*(a+2*u)+f;else a=l>0?-c:c,i=-(r=Math.max(0,-(l*a+s)))*r+a*(a+2*u)+f;return t&&t.copy(this.direction).multiplyScalar(r).add(this.origin),o&&o.copy(vr).multiplyScalar(a).add(ir),i}},{key:"intersectSphere",value:function(n,e){ar.subVectors(n.center,this.origin);var t=ar.dot(this.direction),o=ar.dot(ar)-t*t,r=n.radius*n.radius;if(o>r)return null;var a=Math.sqrt(r-o),i=t-a,v=t+a;return i<0&&v<0?null:i<0?this.at(v,e):this.at(i,e)}},{key:"intersectsSphere",value:function(n){return this.distanceSqToPoint(n.center)<=n.radius*n.radius}},{key:"distanceToPlane",value:function(n){var e=n.normal.dot(this.direction);if(0===e)return 0===n.distanceToPoint(this.origin)?0:null;var t=-(this.origin.dot(n.normal)+n.constant)/e;return t>=0?t:null}},{key:"intersectPlane",value:function(n,e){var t=this.distanceToPlane(n);return null===t?null:this.at(t,e)}},{key:"intersectsPlane",value:function(n){var e=n.distanceToPoint(this.origin);return 0===e||n.normal.dot(this.direction)*e<0}},{key:"intersectBox",value:function(n,e){var t,o,r,a,i,v,c=1/this.direction.x,l=1/this.direction.y,s=1/this.direction.z,u=this.origin;return c>=0?(t=(n.min.x-u.x)*c,o=(n.max.x-u.x)*c):(t=(n.max.x-u.x)*c,o=(n.min.x-u.x)*c),l>=0?(r=(n.min.y-u.y)*l,a=(n.max.y-u.y)*l):(r=(n.max.y-u.y)*l,a=(n.min.y-u.y)*l),t>a||r>o?null:((r>t||isNaN(t))&&(t=r),(a<o||isNaN(o))&&(o=a),s>=0?(i=(n.min.z-u.z)*s,v=(n.max.z-u.z)*s):(i=(n.max.z-u.z)*s,v=(n.min.z-u.z)*s),t>v||i>o?null:((i>t||t!==t)&&(t=i),(v<o||o!==o)&&(o=v),o<0?null:this.at(t>=0?t:o,e)))}},{key:"intersectsBox",value:function(n){return null!==this.intersectBox(n,ar)}},{key:"intersectTriangle",value:function(n,e,t,o,r){lr.subVectors(e,n),sr.subVectors(t,n),ur.crossVectors(lr,sr);var a,i=this.direction.dot(ur);if(i>0){if(o)return null;a=1}else{if(!(i<0))return null;a=-1,i=-i}cr.subVectors(this.origin,n);var v=a*this.direction.dot(sr.crossVectors(cr,sr));if(v<0)return null;var c=a*this.direction.dot(lr.cross(cr));if(c<0)return null;if(v+c>i)return null;var l=-a*cr.dot(ur);return l<0?null:this.at(l/i,r)}},{key:"applyMatrix4",value:function(n){return this.origin.applyMatrix4(n),this.direction.transformDirection(n),this}},{key:"equals",value:function(n){return n.origin.equals(this.origin)&&n.direction.equals(this.direction)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),pr=function(){function n(){y(this,n),n.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}return b(n,[{key:"set",value:function(n,e,t,o,r,a,i,v,c,l,s,u,f,p,m,d){var h=this.elements;return h[0]=n,h[4]=e,h[8]=t,h[12]=o,h[1]=r,h[5]=a,h[9]=i,h[13]=v,h[2]=c,h[6]=l,h[10]=s,h[14]=u,h[3]=f,h[7]=p,h[11]=m,h[15]=d,this}},{key:"identity",value:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}},{key:"clone",value:function(){return(new n).fromArray(this.elements)}},{key:"copy",value:function(n){var e=this.elements,t=n.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],this}},{key:"copyPosition",value:function(n){var e=this.elements,t=n.elements;return e[12]=t[12],e[13]=t[13],e[14]=t[14],this}},{key:"setFromMatrix3",value:function(n){var e=n.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}},{key:"extractBasis",value:function(n,e,t){return n.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),t.setFromMatrixColumn(this,2),this}},{key:"makeBasis",value:function(n,e,t){return this.set(n.x,e.x,t.x,0,n.y,e.y,t.y,0,n.z,e.z,t.z,0,0,0,0,1),this}},{key:"extractRotation",value:function(n){var e=this.elements,t=n.elements,o=1/mr.setFromMatrixColumn(n,0).length(),r=1/mr.setFromMatrixColumn(n,1).length(),a=1/mr.setFromMatrixColumn(n,2).length();return e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=0,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=0,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}},{key:"makeRotationFromEuler",value:function(n){var e=this.elements,t=n.x,o=n.y,r=n.z,a=Math.cos(t),i=Math.sin(t),v=Math.cos(o),c=Math.sin(o),l=Math.cos(r),s=Math.sin(r);if("XYZ"===n.order){var u=a*l,f=a*s,p=i*l,m=i*s;e[0]=v*l,e[4]=-v*s,e[8]=c,e[1]=f+p*c,e[5]=u-m*c,e[9]=-i*v,e[2]=m-u*c,e[6]=p+f*c,e[10]=a*v}else if("YXZ"===n.order){var d=v*l,h=v*s,x=c*l,y=c*s;e[0]=d+y*i,e[4]=x*i-h,e[8]=a*c,e[1]=a*s,e[5]=a*l,e[9]=-i,e[2]=h*i-x,e[6]=y+d*i,e[10]=a*v}else if("ZXY"===n.order){var g=v*l,b=v*s,_=c*l,U=c*s;e[0]=g-U*i,e[4]=-a*s,e[8]=_+b*i,e[1]=b+_*i,e[5]=a*l,e[9]=U-g*i,e[2]=-a*c,e[6]=i,e[10]=a*v}else if("ZYX"===n.order){var w=a*l,S=a*s,M=i*l,z=i*s;e[0]=v*l,e[4]=M*c-S,e[8]=w*c+z,e[1]=v*s,e[5]=z*c+w,e[9]=S*c-M,e[2]=-c,e[6]=i*v,e[10]=a*v}else if("YZX"===n.order){var k=a*v,C=a*c,T=i*v,R=i*c;e[0]=v*l,e[4]=R-k*s,e[8]=T*s+C,e[1]=s,e[5]=a*l,e[9]=-i*l,e[2]=-c*l,e[6]=C*s+T,e[10]=k-R*s}else if("XZY"===n.order){var D=a*v,P=a*c,F=i*v,j=i*c;e[0]=v*l,e[4]=-s,e[8]=c*l,e[1]=D*s+j,e[5]=a*l,e[9]=P*s-F,e[2]=F*s-P,e[6]=i*l,e[10]=j*s+D}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}},{key:"makeRotationFromQuaternion",value:function(n){return this.compose(hr,n,xr)}},{key:"lookAt",value:function(n,e,t){var o=this.elements;return br.subVectors(n,e),0===br.lengthSq()&&(br.z=1),br.normalize(),yr.crossVectors(t,br),0===yr.lengthSq()&&(1===Math.abs(t.z)?br.x+=1e-4:br.z+=1e-4,br.normalize(),yr.crossVectors(t,br)),yr.normalize(),gr.crossVectors(br,yr),o[0]=yr.x,o[4]=gr.x,o[8]=br.x,o[1]=yr.y,o[5]=gr.y,o[9]=br.y,o[2]=yr.z,o[6]=gr.z,o[10]=br.z,this}},{key:"multiply",value:function(n){return this.multiplyMatrices(this,n)}},{key:"premultiply",value:function(n){return this.multiplyMatrices(n,this)}},{key:"multiplyMatrices",value:function(n,e){var t=n.elements,o=e.elements,r=this.elements,a=t[0],i=t[4],v=t[8],c=t[12],l=t[1],s=t[5],u=t[9],f=t[13],p=t[2],m=t[6],d=t[10],h=t[14],x=t[3],y=t[7],g=t[11],b=t[15],_=o[0],U=o[4],w=o[8],S=o[12],M=o[1],z=o[5],k=o[9],C=o[13],T=o[2],R=o[6],D=o[10],P=o[14],F=o[3],j=o[7],I=o[11],E=o[15];return r[0]=a*_+i*M+v*T+c*F,r[4]=a*U+i*z+v*R+c*j,r[8]=a*w+i*k+v*D+c*I,r[12]=a*S+i*C+v*P+c*E,r[1]=l*_+s*M+u*T+f*F,r[5]=l*U+s*z+u*R+f*j,r[9]=l*w+s*k+u*D+f*I,r[13]=l*S+s*C+u*P+f*E,r[2]=p*_+m*M+d*T+h*F,r[6]=p*U+m*z+d*R+h*j,r[10]=p*w+m*k+d*D+h*I,r[14]=p*S+m*C+d*P+h*E,r[3]=x*_+y*M+g*T+b*F,r[7]=x*U+y*z+g*R+b*j,r[11]=x*w+y*k+g*D+b*I,r[15]=x*S+y*C+g*P+b*E,this}},{key:"multiplyScalar",value:function(n){var e=this.elements;return e[0]*=n,e[4]*=n,e[8]*=n,e[12]*=n,e[1]*=n,e[5]*=n,e[9]*=n,e[13]*=n,e[2]*=n,e[6]*=n,e[10]*=n,e[14]*=n,e[3]*=n,e[7]*=n,e[11]*=n,e[15]*=n,this}},{key:"determinant",value:function(){var n=this.elements,e=n[0],t=n[4],o=n[8],r=n[12],a=n[1],i=n[5],v=n[9],c=n[13],l=n[2],s=n[6],u=n[10],f=n[14];return n[3]*(+r*v*s-o*c*s-r*i*u+t*c*u+o*i*f-t*v*f)+n[7]*(+e*v*f-e*c*u+r*a*u-o*a*f+o*c*l-r*v*l)+n[11]*(+e*c*s-e*i*f-r*a*s+t*a*f+r*i*l-t*c*l)+n[15]*(-o*i*l-e*v*s+e*i*u+o*a*s-t*a*u+t*v*l)}},{key:"transpose",value:function(){var n,e=this.elements;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,this}},{key:"setPosition",value:function(n,e,t){var o=this.elements;return n.isVector3?(o[12]=n.x,o[13]=n.y,o[14]=n.z):(o[12]=n,o[13]=e,o[14]=t),this}},{key:"invert",value:function(){var n=this.elements,e=n[0],t=n[1],o=n[2],r=n[3],a=n[4],i=n[5],v=n[6],c=n[7],l=n[8],s=n[9],u=n[10],f=n[11],p=n[12],m=n[13],d=n[14],h=n[15],x=s*d*c-m*u*c+m*v*f-i*d*f-s*v*h+i*u*h,y=p*u*c-l*d*c-p*v*f+a*d*f+l*v*h-a*u*h,g=l*m*c-p*s*c+p*i*f-a*m*f-l*i*h+a*s*h,b=p*s*v-l*m*v-p*i*u+a*m*u+l*i*d-a*s*d,_=e*x+t*y+o*g+r*b;if(0===_)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);var U=1/_;return n[0]=x*U,n[1]=(m*u*r-s*d*r-m*o*f+t*d*f+s*o*h-t*u*h)*U,n[2]=(i*d*r-m*v*r+m*o*c-t*d*c-i*o*h+t*v*h)*U,n[3]=(s*v*r-i*u*r-s*o*c+t*u*c+i*o*f-t*v*f)*U,n[4]=y*U,n[5]=(l*d*r-p*u*r+p*o*f-e*d*f-l*o*h+e*u*h)*U,n[6]=(p*v*r-a*d*r-p*o*c+e*d*c+a*o*h-e*v*h)*U,n[7]=(a*u*r-l*v*r+l*o*c-e*u*c-a*o*f+e*v*f)*U,n[8]=g*U,n[9]=(p*s*r-l*m*r-p*t*f+e*m*f+l*t*h-e*s*h)*U,n[10]=(a*m*r-p*i*r+p*t*c-e*m*c-a*t*h+e*i*h)*U,n[11]=(l*i*r-a*s*r-l*t*c+e*s*c+a*t*f-e*i*f)*U,n[12]=b*U,n[13]=(l*m*o-p*s*o+p*t*u-e*m*u-l*t*d+e*s*d)*U,n[14]=(p*i*o-a*m*o-p*t*v+e*m*v+a*t*d-e*i*d)*U,n[15]=(a*s*o-l*i*o+l*t*v-e*s*v-a*t*u+e*i*u)*U,this}},{key:"scale",value:function(n){var e=this.elements,t=n.x,o=n.y,r=n.z;return e[0]*=t,e[4]*=o,e[8]*=r,e[1]*=t,e[5]*=o,e[9]*=r,e[2]*=t,e[6]*=o,e[10]*=r,e[3]*=t,e[7]*=o,e[11]*=r,this}},{key:"getMaxScaleOnAxis",value:function(){var n=this.elements,e=n[0]*n[0]+n[1]*n[1]+n[2]*n[2],t=n[4]*n[4]+n[5]*n[5]+n[6]*n[6],o=n[8]*n[8]+n[9]*n[9]+n[10]*n[10];return Math.sqrt(Math.max(e,t,o))}},{key:"makeTranslation",value:function(n,e,t){return this.set(1,0,0,n,0,1,0,e,0,0,1,t,0,0,0,1),this}},{key:"makeRotationX",value:function(n){var e=Math.cos(n),t=Math.sin(n);return this.set(1,0,0,0,0,e,-t,0,0,t,e,0,0,0,0,1),this}},{key:"makeRotationY",value:function(n){var e=Math.cos(n),t=Math.sin(n);return this.set(e,0,t,0,0,1,0,0,-t,0,e,0,0,0,0,1),this}},{key:"makeRotationZ",value:function(n){var e=Math.cos(n),t=Math.sin(n);return this.set(e,-t,0,0,t,e,0,0,0,0,1,0,0,0,0,1),this}},{key:"makeRotationAxis",value:function(n,e){var t=Math.cos(e),o=Math.sin(e),r=1-t,a=n.x,i=n.y,v=n.z,c=r*a,l=r*i;return this.set(c*a+t,c*i-o*v,c*v+o*i,0,c*i+o*v,l*i+t,l*v-o*a,0,c*v-o*i,l*v+o*a,r*v*v+t,0,0,0,0,1),this}},{key:"makeScale",value:function(n,e,t){return this.set(n,0,0,0,0,e,0,0,0,0,t,0,0,0,0,1),this}},{key:"makeShear",value:function(n,e,t,o,r,a){return this.set(1,t,r,0,n,1,a,0,e,o,1,0,0,0,0,1),this}},{key:"compose",value:function(n,e,t){var o=this.elements,r=e._x,a=e._y,i=e._z,v=e._w,c=r+r,l=a+a,s=i+i,u=r*c,f=r*l,p=r*s,m=a*l,d=a*s,h=i*s,x=v*c,y=v*l,g=v*s,b=t.x,_=t.y,U=t.z;return o[0]=(1-(m+h))*b,o[1]=(f+g)*b,o[2]=(p-y)*b,o[3]=0,o[4]=(f-g)*_,o[5]=(1-(u+h))*_,o[6]=(d+x)*_,o[7]=0,o[8]=(p+y)*U,o[9]=(d-x)*U,o[10]=(1-(u+m))*U,o[11]=0,o[12]=n.x,o[13]=n.y,o[14]=n.z,o[15]=1,this}},{key:"decompose",value:function(n,e,t){var o=this.elements,r=mr.set(o[0],o[1],o[2]).length(),a=mr.set(o[4],o[5],o[6]).length(),i=mr.set(o[8],o[9],o[10]).length();this.determinant()<0&&(r=-r),n.x=o[12],n.y=o[13],n.z=o[14],dr.copy(this);var v=1/r,c=1/a,l=1/i;return dr.elements[0]*=v,dr.elements[1]*=v,dr.elements[2]*=v,dr.elements[4]*=c,dr.elements[5]*=c,dr.elements[6]*=c,dr.elements[8]*=l,dr.elements[9]*=l,dr.elements[10]*=l,e.setFromRotationMatrix(dr),t.x=r,t.y=a,t.z=i,this}},{key:"makePerspective",value:function(n,e,t,o,r,a){var i=this.elements,v=2*r/(e-n),c=2*r/(t-o),l=(e+n)/(e-n),s=(t+o)/(t-o),u=-(a+r)/(a-r),f=-2*a*r/(a-r);return i[0]=v,i[4]=0,i[8]=l,i[12]=0,i[1]=0,i[5]=c,i[9]=s,i[13]=0,i[2]=0,i[6]=0,i[10]=u,i[14]=f,i[3]=0,i[7]=0,i[11]=-1,i[15]=0,this}},{key:"makeOrthographic",value:function(n,e,t,o,r,a){var i=this.elements,v=1/(e-n),c=1/(t-o),l=1/(a-r),s=(e+n)*v,u=(t+o)*c,f=(a+r)*l;return i[0]=2*v,i[4]=0,i[8]=0,i[12]=-s,i[1]=0,i[5]=2*c,i[9]=0,i[13]=-u,i[2]=0,i[6]=0,i[10]=-2*l,i[14]=-f,i[3]=0,i[7]=0,i[11]=0,i[15]=1,this}},{key:"equals",value:function(n){for(var e=this.elements,t=n.elements,o=0;o<16;o++)if(e[o]!==t[o])return!1;return!0}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=0;t<16;t++)this.elements[t]=n[t+e];return this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.elements;return n[e]=t[0],n[e+1]=t[1],n[e+2]=t[2],n[e+3]=t[3],n[e+4]=t[4],n[e+5]=t[5],n[e+6]=t[6],n[e+7]=t[7],n[e+8]=t[8],n[e+9]=t[9],n[e+10]=t[10],n[e+11]=t[11],n[e+12]=t[12],n[e+13]=t[13],n[e+14]=t[14],n[e+15]=t[15],n}}]),n}(),mr=new Oo,dr=new pr,hr=new Oo(0,0,0),xr=new Oo(1,1,1),yr=new Oo,gr=new Oo,br=new Oo,_r=new pr,Ur=new Eo,wr=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.DefaultOrder;y(this,e),this.isEuler=!0,this._x=n,this._y=t,this._z=o,this._order=r}return b(e,[{key:"x",get:function(){return this._x},set:function(n){this._x=n,this._onChangeCallback()}},{key:"y",get:function(){return this._y},set:function(n){this._y=n,this._onChangeCallback()}},{key:"z",get:function(){return this._z},set:function(n){this._z=n,this._onChangeCallback()}},{key:"order",get:function(){return this._order},set:function(n){this._order=n,this._onChangeCallback()}},{key:"set",value:function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this._order;return this._x=n,this._y=e,this._z=t,this._order=o,this._onChangeCallback(),this}},{key:"clone",value:function(){return new this.constructor(this._x,this._y,this._z,this._order)}},{key:"copy",value:function(n){return this._x=n._x,this._y=n._y,this._z=n._z,this._order=n._order,this._onChangeCallback(),this}},{key:"setFromRotationMatrix",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._order,t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],o=n.elements,r=o[0],a=o[4],i=o[8],v=o[1],c=o[5],l=o[9],s=o[2],u=o[6],f=o[10];switch(e){case"XYZ":this._y=Math.asin(Qt(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(-l,f),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(u,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Qt(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(i,f),this._z=Math.atan2(v,c)):(this._y=Math.atan2(-s,r),this._z=0);break;case"ZXY":this._x=Math.asin(Qt(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-s,f),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(v,r));break;case"ZYX":this._y=Math.asin(-Qt(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,f),this._z=Math.atan2(v,r)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(Qt(v,-1,1)),Math.abs(v)<.9999999?(this._x=Math.atan2(-l,c),this._y=Math.atan2(-s,r)):(this._x=0,this._y=Math.atan2(i,f));break;case"XZY":this._z=Math.asin(-Qt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(u,c),this._y=Math.atan2(i,r)):(this._x=Math.atan2(-l,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===t&&this._onChangeCallback(),this}},{key:"setFromQuaternion",value:function(n,e,t){return _r.makeRotationFromQuaternion(n),this.setFromRotationMatrix(_r,e,t)}},{key:"setFromVector3",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._order;return this.set(n.x,n.y,n.z,e)}},{key:"reorder",value:function(n){return Ur.setFromEuler(this),this.setFromQuaternion(Ur,n)}},{key:"equals",value:function(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._order===this._order}},{key:"fromArray",value:function(n){return this._x=n[0],this._y=n[1],this._z=n[2],void 0!==n[3]&&(this._order=n[3]),this._onChangeCallback(),this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this._x,n[e+1]=this._y,n[e+2]=this._z,n[e+3]=this._order,n}},{key:"_onChange",value:function(n){return this._onChangeCallback=n,this}},{key:"_onChangeCallback",value:function(){}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this._x;case 2:return n.next=4,this._y;case 4:return n.next=6,this._z;case 6:return n.next=8,this._order;case 8:case"end":return n.stop()}}),n,this)}))},{key:"toVector3",value:function(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}]),e}();wr.DefaultOrder="XYZ",wr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];var Sr=function(){function n(){y(this,n),this.mask=1}return b(n,[{key:"set",value:function(n){this.mask=(1<<n|0)>>>0}},{key:"enable",value:function(n){this.mask|=1<<n|0}},{key:"enableAll",value:function(){this.mask=-1}},{key:"toggle",value:function(n){this.mask^=1<<n|0}},{key:"disable",value:function(n){this.mask&=~(1<<n|0)}},{key:"disableAll",value:function(){this.mask=0}},{key:"test",value:function(n){return 0!==(this.mask&n.mask)}},{key:"isEnabled",value:function(n){return 0!==(this.mask&(1<<n|0))}}]),n}(),Mr=0,zr=new Oo,kr=new Eo,Cr=new pr,Tr=new Oo,Rr=new Oo,Dr=new Oo,Pr=new Eo,Fr=new Oo(1,0,0),jr=new Oo(0,1,0),Ir=new Oo(0,0,1),Er={type:"added"},Or={type:"removed"},Lr=function(n){_(t,n);var e=z(t);function t(){var n;y(this,t),(n=e.call(this)).isObject3D=!0,Object.defineProperty(S(n),"id",{value:Mr++}),n.uuid=Zt(),n.name="",n.type="Object3D",n.parent=null,n.children=[],n.up=t.DefaultUp.clone();var o=new Oo,r=new wr,a=new Eo,i=new Oo(1,1,1);return r._onChange((function(){a.setFromEuler(r,!1)})),a._onChange((function(){r.setFromQuaternion(a,void 0,!1)})),Object.defineProperties(S(n),{position:{configurable:!0,enumerable:!0,value:o},rotation:{configurable:!0,enumerable:!0,value:r},quaternion:{configurable:!0,enumerable:!0,value:a},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new pr},normalMatrix:{value:new io}}),n.matrix=new pr,n.matrixWorld=new pr,n.matrixAutoUpdate=t.DefaultMatrixAutoUpdate,n.matrixWorldNeedsUpdate=!1,n.matrixWorldAutoUpdate=t.DefaultMatrixWorldAutoUpdate,n.layers=new Sr,n.visible=!0,n.castShadow=!1,n.receiveShadow=!1,n.frustumCulled=!0,n.renderOrder=0,n.animations=[],n.userData={},n}return b(t,[{key:"onBeforeRender",value:function(){}},{key:"onAfterRender",value:function(){}},{key:"applyMatrix4",value:function(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)}},{key:"applyQuaternion",value:function(n){return this.quaternion.premultiply(n),this}},{key:"setRotationFromAxisAngle",value:function(n,e){this.quaternion.setFromAxisAngle(n,e)}},{key:"setRotationFromEuler",value:function(n){this.quaternion.setFromEuler(n,!0)}},{key:"setRotationFromMatrix",value:function(n){this.quaternion.setFromRotationMatrix(n)}},{key:"setRotationFromQuaternion",value:function(n){this.quaternion.copy(n)}},{key:"rotateOnAxis",value:function(n,e){return kr.setFromAxisAngle(n,e),this.quaternion.multiply(kr),this}},{key:"rotateOnWorldAxis",value:function(n,e){return kr.setFromAxisAngle(n,e),this.quaternion.premultiply(kr),this}},{key:"rotateX",value:function(n){return this.rotateOnAxis(Fr,n)}},{key:"rotateY",value:function(n){return this.rotateOnAxis(jr,n)}},{key:"rotateZ",value:function(n){return this.rotateOnAxis(Ir,n)}},{key:"translateOnAxis",value:function(n,e){return zr.copy(n).applyQuaternion(this.quaternion),this.position.add(zr.multiplyScalar(e)),this}},{key:"translateX",value:function(n){return this.translateOnAxis(Fr,n)}},{key:"translateY",value:function(n){return this.translateOnAxis(jr,n)}},{key:"translateZ",value:function(n){return this.translateOnAxis(Ir,n)}},{key:"localToWorld",value:function(n){return n.applyMatrix4(this.matrixWorld)}},{key:"worldToLocal",value:function(n){return n.applyMatrix4(Cr.copy(this.matrixWorld).invert())}},{key:"lookAt",value:function(n,e,t){n.isVector3?Tr.copy(n):Tr.set(n,e,t);var o=this.parent;this.updateWorldMatrix(!0,!1),Rr.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Cr.lookAt(Rr,Tr,this.up):Cr.lookAt(Tr,Rr,this.up),this.quaternion.setFromRotationMatrix(Cr),o&&(Cr.extractRotation(o.matrixWorld),kr.setFromRotationMatrix(Cr),this.quaternion.premultiply(kr.invert()))}},{key:"add",value:function(n){if(arguments.length>1){for(var e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return n===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",n),this):(n&&n.isObject3D?(null!==n.parent&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent(Er)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this)}},{key:"remove",value:function(n){if(arguments.length>1){for(var e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}var t=this.children.indexOf(n);return-1!==t&&(n.parent=null,this.children.splice(t,1),n.dispatchEvent(Or)),this}},{key:"removeFromParent",value:function(){var n=this.parent;return null!==n&&n.remove(this),this}},{key:"clear",value:function(){for(var n=0;n<this.children.length;n++){var e=this.children[n];e.parent=null,e.dispatchEvent(Or)}return this.children.length=0,this}},{key:"attach",value:function(n){return this.updateWorldMatrix(!0,!1),Cr.copy(this.matrixWorld).invert(),null!==n.parent&&(n.parent.updateWorldMatrix(!0,!1),Cr.multiply(n.parent.matrixWorld)),n.applyMatrix4(Cr),this.add(n),n.updateWorldMatrix(!1,!0),this}},{key:"getObjectById",value:function(n){return this.getObjectByProperty("id",n)}},{key:"getObjectByName",value:function(n){return this.getObjectByProperty("name",n)}},{key:"getObjectByProperty",value:function(n,e){if(this[n]===e)return this;for(var t=0,o=this.children.length;t<o;t++){var r=this.children[t].getObjectByProperty(n,e);if(void 0!==r)return r}}},{key:"getWorldPosition",value:function(n){return this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)}},{key:"getWorldQuaternion",value:function(n){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Rr,n,Dr),n}},{key:"getWorldScale",value:function(n){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Rr,Pr,n),n}},{key:"getWorldDirection",value:function(n){this.updateWorldMatrix(!0,!1);var e=this.matrixWorld.elements;return n.set(e[8],e[9],e[10]).normalize()}},{key:"raycast",value:function(){}},{key:"traverse",value:function(n){n(this);for(var e=this.children,t=0,o=e.length;t<o;t++)e[t].traverse(n)}},{key:"traverseVisible",value:function(n){if(!1!==this.visible){n(this);for(var e=this.children,t=0,o=e.length;t<o;t++)e[t].traverseVisible(n)}}},{key:"traverseAncestors",value:function(n){var e=this.parent;null!==e&&(n(e),e.traverseAncestors(n))}},{key:"updateMatrix",value:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}},{key:"updateMatrixWorld",value:function(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);for(var e=this.children,t=0,o=e.length;t<o;t++){var r=e[t];!0!==r.matrixWorldAutoUpdate&&!0!==n||r.updateMatrixWorld(n)}}},{key:"updateWorldMatrix",value:function(n,e){var t=this.parent;if(!0===n&&null!==t&&!0===t.matrixWorldAutoUpdate&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e)for(var o=this.children,r=0,a=o.length;r<a;r++){var i=o[r];!0===i.matrixWorldAutoUpdate&&i.updateWorldMatrix(!1,!0)}}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n,t={};e&&(n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},t.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});var o={};function r(e,t){return void 0===e[t.uuid]&&(e[t.uuid]=t.toJSON(n)),t.uuid}if(o.uuid=this.uuid,o.type=this.type,""!==this.name&&(o.name=this.name),!0===this.castShadow&&(o.castShadow=!0),!0===this.receiveShadow&&(o.receiveShadow=!0),!1===this.visible&&(o.visible=!1),!1===this.frustumCulled&&(o.frustumCulled=!1),0!==this.renderOrder&&(o.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(o.userData=this.userData),o.layers=this.layers.mask,o.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(o.matrixAutoUpdate=!1),this.isInstancedMesh&&(o.type="InstancedMesh",o.count=this.count,o.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(o.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?o.background=this.background.toJSON():this.background.isTexture&&(o.background=this.background.toJSON(n).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(o.environment=this.environment.toJSON(n).uuid);else if(this.isMesh||this.isLine||this.isPoints){o.geometry=r(n.geometries,this.geometry);var a=this.geometry.parameters;if(void 0!==a&&void 0!==a.shapes){var i=a.shapes;if(Array.isArray(i))for(var v=0,c=i.length;v<c;v++){var l=i[v];r(n.shapes,l)}else r(n.shapes,i)}}if(this.isSkinnedMesh&&(o.bindMode=this.bindMode,o.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(n.skeletons,this.skeleton),o.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){for(var s=[],u=0,f=this.material.length;u<f;u++)s.push(r(n.materials,this.material[u]));o.material=s}else o.material=r(n.materials,this.material);if(this.children.length>0){o.children=[];for(var p=0;p<this.children.length;p++)o.children.push(this.children[p].toJSON(n).object)}if(this.animations.length>0){o.animations=[];for(var m=0;m<this.animations.length;m++){var d=this.animations[m];o.animations.push(r(n.animations,d))}}if(e){var h=S(n.geometries),x=S(n.materials),y=S(n.textures),g=S(n.images),b=S(n.shapes),_=S(n.skeletons),U=S(n.animations),w=S(n.nodes);h.length>0&&(t.geometries=h),x.length>0&&(t.materials=x),y.length>0&&(t.textures=y),g.length>0&&(t.images=g),b.length>0&&(t.shapes=b),_.length>0&&(t.skeletons=_),U.length>0&&(t.animations=U),w.length>0&&(t.nodes=w)}return t.object=o,t;function S(n){var e=[];for(var t in n){var o=n[t];delete o.metadata,e.push(o)}return e}}},{key:"clone",value:function(n){return(new this.constructor).copy(this,n)}},{key:"copy",value:function(n){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=n.matrixWorldAutoUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.userData=JSON.parse(JSON.stringify(n.userData)),!0===e)for(var t=0;t<n.children.length;t++){var o=n.children[t];this.add(o.clone())}return this}}]),t}(Vt);Lr.DefaultUp=new Oo(0,1,0),Lr.DefaultMatrixAutoUpdate=!0,Lr.DefaultMatrixWorldAutoUpdate=!0;var Ar=new Oo,Gr=new Oo,Nr=new Oo,Br=new Oo,qr=new Oo,Vr=new Oo,Wr=new Oo,Hr=new Oo,Xr=new Oo,Yr=new Oo,Zr=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Oo;y(this,n),this.a=e,this.b=t,this.c=o}return b(n,[{key:"set",value:function(n,e,t){return this.a.copy(n),this.b.copy(e),this.c.copy(t),this}},{key:"setFromPointsAndIndices",value:function(n,e,t,o){return this.a.copy(n[e]),this.b.copy(n[t]),this.c.copy(n[o]),this}},{key:"setFromAttributeAndIndices",value:function(n,e,t,o){return this.a.fromBufferAttribute(n,e),this.b.fromBufferAttribute(n,t),this.c.fromBufferAttribute(n,o),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.a.copy(n.a),this.b.copy(n.b),this.c.copy(n.c),this}},{key:"getArea",value:function(){return Ar.subVectors(this.c,this.b),Gr.subVectors(this.a,this.b),.5*Ar.cross(Gr).length()}},{key:"getMidpoint",value:function(n){return n.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}},{key:"getNormal",value:function(e){return n.getNormal(this.a,this.b,this.c,e)}},{key:"getPlane",value:function(n){return n.setFromCoplanarPoints(this.a,this.b,this.c)}},{key:"getBarycoord",value:function(e,t){return n.getBarycoord(e,this.a,this.b,this.c,t)}},{key:"getUV",value:function(e,t,o,r,a){return n.getUV(e,this.a,this.b,this.c,t,o,r,a)}},{key:"containsPoint",value:function(e){return n.containsPoint(e,this.a,this.b,this.c)}},{key:"isFrontFacing",value:function(e){return n.isFrontFacing(this.a,this.b,this.c,e)}},{key:"intersectsBox",value:function(n){return n.intersectsTriangle(this)}},{key:"closestPointToPoint",value:function(n,e){var t,o,r=this.a,a=this.b,i=this.c;qr.subVectors(a,r),Vr.subVectors(i,r),Hr.subVectors(n,r);var v=qr.dot(Hr),c=Vr.dot(Hr);if(v<=0&&c<=0)return e.copy(r);Xr.subVectors(n,a);var l=qr.dot(Xr),s=Vr.dot(Xr);if(l>=0&&s<=l)return e.copy(a);var u=v*s-l*c;if(u<=0&&v>=0&&l<=0)return t=v/(v-l),e.copy(r).addScaledVector(qr,t);Yr.subVectors(n,i);var f=qr.dot(Yr),p=Vr.dot(Yr);if(p>=0&&f<=p)return e.copy(i);var m=f*c-v*p;if(m<=0&&c>=0&&p<=0)return o=c/(c-p),e.copy(r).addScaledVector(Vr,o);var d=l*p-f*s;if(d<=0&&s-l>=0&&f-p>=0)return Wr.subVectors(i,a),o=(s-l)/(s-l+(f-p)),e.copy(a).addScaledVector(Wr,o);var h=1/(d+m+u);return t=m*h,o=u*h,e.copy(r).addScaledVector(qr,t).addScaledVector(Vr,o)}},{key:"equals",value:function(n){return n.a.equals(this.a)&&n.b.equals(this.b)&&n.c.equals(this.c)}}],[{key:"getNormal",value:function(n,e,t,o){o.subVectors(t,e),Ar.subVectors(n,e),o.cross(Ar);var r=o.lengthSq();return r>0?o.multiplyScalar(1/Math.sqrt(r)):o.set(0,0,0)}},{key:"getBarycoord",value:function(n,e,t,o,r){Ar.subVectors(o,e),Gr.subVectors(t,e),Nr.subVectors(n,e);var a=Ar.dot(Ar),i=Ar.dot(Gr),v=Ar.dot(Nr),c=Gr.dot(Gr),l=Gr.dot(Nr),s=a*c-i*i;if(0===s)return r.set(-2,-1,-1);var u=1/s,f=(c*v-i*l)*u,p=(a*l-i*v)*u;return r.set(1-f-p,p,f)}},{key:"containsPoint",value:function(n,e,t,o){return this.getBarycoord(n,e,t,o,Br),Br.x>=0&&Br.y>=0&&Br.x+Br.y<=1}},{key:"getUV",value:function(n,e,t,o,r,a,i,v){return this.getBarycoord(n,e,t,o,Br),v.set(0,0),v.addScaledVector(r,Br.x),v.addScaledVector(a,Br.y),v.addScaledVector(i,Br.z),v}},{key:"isFrontFacing",value:function(n,e,t,o){return Ar.subVectors(t,e),Gr.subVectors(n,e),Ar.cross(Gr).dot(o)<0}}]),n}(),Qr=0,Jr=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isMaterial=!0,Object.defineProperty(S(n),"id",{value:Qr++}),n.uuid=Zt(),n.name="",n.type="Material",n.blending=Y,n.side=V,n.vertexColors=!1,n.opacity=1,n.transparent=!1,n.blendSrc=ln,n.blendDst=sn,n.blendEquation=$,n.blendSrcAlpha=null,n.blendDstAlpha=null,n.blendEquationAlpha=null,n.depthFunc=gn,n.depthTest=!0,n.depthWrite=!0,n.stencilWriteMask=255,n.stencilFunc=Dt,n.stencilRef=0,n.stencilFuncMask=255,n.stencilFail=xt,n.stencilZFail=xt,n.stencilZPass=xt,n.stencilWrite=!1,n.clippingPlanes=null,n.clipIntersection=!1,n.clipShadows=!1,n.shadowSide=null,n.colorWrite=!0,n.precision=null,n.polygonOffset=!1,n.polygonOffsetFactor=0,n.polygonOffsetUnits=0,n.dithering=!1,n.alphaToCoverage=!1,n.premultipliedAlpha=!1,n.visible=!0,n.toneMapped=!0,n.userData={},n.version=0,n._alphaTest=0,n}return b(t,[{key:"alphaTest",get:function(){return this._alphaTest},set:function(n){this._alphaTest>0!==n>0&&this.version++,this._alphaTest=n}},{key:"onBuild",value:function(){}},{key:"onBeforeRender",value:function(){}},{key:"onBeforeCompile",value:function(){}},{key:"customProgramCacheKey",value:function(){return this.onBeforeCompile.toString()}},{key:"setValues",value:function(n){if(void 0!==n)for(var e in n){var t=n[e];if(void 0!==t){var o=this[e];void 0!==o?o&&o.isColor?o.set(t):o&&o.isVector3&&t&&t.isVector3?o.copy(t):this[e]=t:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}else console.warn("THREE.Material: '"+e+"' parameter is undefined.")}}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n;e&&(n={textures:{},images:{}});var t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function o(n){var e=[];for(var t in n){var o=n[t];delete o.metadata,e.push(o)}return e}if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),void 0!==this.roughness&&(t.roughness=this.roughness),void 0!==this.metalness&&(t.metalness=this.metalness),void 0!==this.sheen&&(t.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(t.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(t.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(t.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(t.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(t.shininess=this.shininess),void 0!==this.clearcoat&&(t.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(t.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(t.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(t.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(t.iridescenceMap=this.iridescenceMap.toJSON(n).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(t.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(n).uuid),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(n).uuid,t.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(n).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(n).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(n).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(n).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(n).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(t.specularIntensityMap=this.specularIntensityMap.toJSON(n).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(t.specularColorMap=this.specularColorMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(n).uuid,void 0!==this.combine&&(t.combine=this.combine)),void 0!==this.envMapIntensity&&(t.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(t.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(t.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(n).uuid),void 0!==this.transmission&&(t.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(t.transmissionMap=this.transmissionMap.toJSON(n).uuid),void 0!==this.thickness&&(t.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(t.thicknessMap=this.thicknessMap.toJSON(n).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(t.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(t.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(t.size=this.size),null!==this.shadowSide&&(t.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==Y&&(t.blending=this.blending),this.side!==V&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),!0===this.transparent&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.colorWrite=this.colorWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(t.rotation=this.rotation),!0===this.polygonOffset&&(t.polygonOffset=!0),0!==this.polygonOffsetFactor&&(t.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(t.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(t.linewidth=this.linewidth),void 0!==this.dashSize&&(t.dashSize=this.dashSize),void 0!==this.gapSize&&(t.gapSize=this.gapSize),void 0!==this.scale&&(t.scale=this.scale),!0===this.dithering&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(t.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(t.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(t.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(t.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(t.flatShading=this.flatShading),!1===this.visible&&(t.visible=!1),!1===this.toneMapped&&(t.toneMapped=!1),!1===this.fog&&(t.fog=!1),"{}"!==JSON.stringify(this.userData)&&(t.userData=this.userData),e){var r=o(n.textures),a=o(n.images);r.length>0&&(t.textures=r),a.length>0&&(t.images=a)}return t}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){this.name=n.name,this.blending=n.blending,this.side=n.side,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;var e=n.clippingPlanes,t=null;if(null!==e){var o=e.length;t=new Array(o);for(var r=0;r!==o;++r)t[r]=e[r].clone()}return this.clippingPlanes=t,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.alphaToCoverage=n.alphaToCoverage,this.premultipliedAlpha=n.premultipliedAlpha,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}},{key:"needsUpdate",set:function(n){!0===n&&this.version++}}]),t}(Vt),Kr=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshBasicMaterial=!0,o.type="MeshBasicMaterial",o.color=new wo(16777215),o.map=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.specularMap=null,o.alphaMap=null,o.envMap=null,o.combine=Sn,o.reflectivity=1,o.refractionRatio=.98,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.fog=n.fog,this}}]),t}(Jr),$r=new Oo,na=new ao,ea=function(){function n(e,t,o){if(y(this,n),Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===o,this.usage=Pt,this.updateRange={offset:0,count:-1},this.version=0}return b(n,[{key:"onUploadCallback",value:function(){}},{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"setUsage",value:function(n){return this.usage=n,this}},{key:"copy",value:function(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this}},{key:"copyAt",value:function(n,e,t){n*=this.itemSize,t*=e.itemSize;for(var o=0,r=this.itemSize;o<r;o++)this.array[n+o]=e.array[t+o];return this}},{key:"copyArray",value:function(n){return this.array.set(n),this}},{key:"applyMatrix3",value:function(n){if(2===this.itemSize)for(var e=0,t=this.count;e<t;e++)na.fromBufferAttribute(this,e),na.applyMatrix3(n),this.setXY(e,na.x,na.y);else if(3===this.itemSize)for(var o=0,r=this.count;o<r;o++)$r.fromBufferAttribute(this,o),$r.applyMatrix3(n),this.setXYZ(o,$r.x,$r.y,$r.z);return this}},{key:"applyMatrix4",value:function(n){for(var e=0,t=this.count;e<t;e++)$r.fromBufferAttribute(this,e),$r.applyMatrix4(n),this.setXYZ(e,$r.x,$r.y,$r.z);return this}},{key:"applyNormalMatrix",value:function(n){for(var e=0,t=this.count;e<t;e++)$r.fromBufferAttribute(this,e),$r.applyNormalMatrix(n),this.setXYZ(e,$r.x,$r.y,$r.z);return this}},{key:"transformDirection",value:function(n){for(var e=0,t=this.count;e<t;e++)$r.fromBufferAttribute(this,e),$r.transformDirection(n),this.setXYZ(e,$r.x,$r.y,$r.z);return this}},{key:"set",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.array.set(n,e),this}},{key:"getX",value:function(n){var e=this.array[n*this.itemSize];return this.normalized&&(e=to(e,this.array)),e}},{key:"setX",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.array[n*this.itemSize]=e,this}},{key:"getY",value:function(n){var e=this.array[n*this.itemSize+1];return this.normalized&&(e=to(e,this.array)),e}},{key:"setY",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.array[n*this.itemSize+1]=e,this}},{key:"getZ",value:function(n){var e=this.array[n*this.itemSize+2];return this.normalized&&(e=to(e,this.array)),e}},{key:"setZ",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.array[n*this.itemSize+2]=e,this}},{key:"getW",value:function(n){var e=this.array[n*this.itemSize+3];return this.normalized&&(e=to(e,this.array)),e}},{key:"setW",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.array[n*this.itemSize+3]=e,this}},{key:"setXY",value:function(n,e,t){return n*=this.itemSize,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array)),this.array[n+0]=e,this.array[n+1]=t,this}},{key:"setXYZ",value:function(n,e,t,o){return n*=this.itemSize,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array),o=oo(o,this.array)),this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=o,this}},{key:"setXYZW",value:function(n,e,t,o,r){return n*=this.itemSize,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array),o=oo(o,this.array),r=oo(r,this.array)),this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=o,this.array[n+3]=r,this}},{key:"onUpload",value:function(n){return this.onUploadCallback=n,this}},{key:"clone",value:function(){return new this.constructor(this.array,this.itemSize).copy(this)}},{key:"toJSON",value:function(){var n={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(n.name=this.name),this.usage!==Pt&&(n.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(n.updateRange=this.updateRange),n}},{key:"copyColorsArray",value:function(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}},{key:"copyVector2sArray",value:function(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}},{key:"copyVector3sArray",value:function(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}},{key:"copyVector4sArray",value:function(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}]),n}(),ta=function(n){_(t,n);var e=z(t);function t(n,o,r){return y(this,t),e.call(this,new Int8Array(n),o,r)}return b(t)}(ea),oa=function(n){_(t,n);var e=z(t);function t(n,o,r){return y(this,t),e.call(this,new Uint8Array(n),o,r)}return b(t)}(ea),ra=function(n){_(t,n);var e=z(t);function t(n,o,r){return y(this,t),e.call(this,new Uint8ClampedArray(n),o,r)}return b(t)}(ea),aa=function(n){_(t,n);var e=z(t);function t(n,o,r){return y(this,t),e.call(this,new Int16Array(n),o,r)}return b(t)}(ea),ia=function(n){_(t,n);var e=z(t);function t(n,o,r){return y(this,t),e.call(this,new Uint16Array(n),o,r)}return b(t)}(ea),va=function(n){_(t,n);var e=z(t);function t(n,o,r){return y(this,t),e.call(this,new Int32Array(n),o,r)}return b(t)}(ea),ca=function(n){_(t,n);var e=z(t);function t(n,o,r){return y(this,t),e.call(this,new Uint32Array(n),o,r)}return b(t)}(ea),la=function(n){_(t,n);var e=z(t);function t(n,o,r){var a;return y(this,t),(a=e.call(this,new Uint16Array(n),o,r)).isFloat16BufferAttribute=!0,a}return b(t)}(ea),sa=function(n){_(t,n);var e=z(t);function t(n,o,r){return y(this,t),e.call(this,new Float32Array(n),o,r)}return b(t)}(ea),ua=function(n){_(t,n);var e=z(t);function t(n,o,r){return y(this,t),e.call(this,new Float64Array(n),o,r)}return b(t)}(ea),fa=0,pa=new pr,ma=new Lr,da=new Oo,ha=new Go,xa=new Go,ya=new Oo,ga=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isBufferGeometry=!0,Object.defineProperty(S(n),"id",{value:fa++}),n.uuid=Zt(),n.name="",n.type="BufferGeometry",n.index=null,n.attributes={},n.morphAttributes={},n.morphTargetsRelative=!1,n.groups=[],n.boundingBox=null,n.boundingSphere=null,n.drawRange={start:0,count:1/0},n.userData={},n}return b(t,[{key:"getIndex",value:function(){return this.index}},{key:"setIndex",value:function(n){return Array.isArray(n)?this.index=new(vo(n)?ca:ia)(n,1):this.index=n,this}},{key:"getAttribute",value:function(n){return this.attributes[n]}},{key:"setAttribute",value:function(n,e){return this.attributes[n]=e,this}},{key:"deleteAttribute",value:function(n){return delete this.attributes[n],this}},{key:"hasAttribute",value:function(n){return void 0!==this.attributes[n]}},{key:"addGroup",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.groups.push({start:n,count:e,materialIndex:t})}},{key:"clearGroups",value:function(){this.groups=[]}},{key:"setDrawRange",value:function(n,e){this.drawRange.start=n,this.drawRange.count=e}},{key:"applyMatrix4",value:function(n){var e=this.attributes.position;void 0!==e&&(e.applyMatrix4(n),e.needsUpdate=!0);var t=this.attributes.normal;if(void 0!==t){var o=(new io).getNormalMatrix(n);t.applyNormalMatrix(o),t.needsUpdate=!0}var r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(n),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}},{key:"applyQuaternion",value:function(n){return pa.makeRotationFromQuaternion(n),this.applyMatrix4(pa),this}},{key:"rotateX",value:function(n){return pa.makeRotationX(n),this.applyMatrix4(pa),this}},{key:"rotateY",value:function(n){return pa.makeRotationY(n),this.applyMatrix4(pa),this}},{key:"rotateZ",value:function(n){return pa.makeRotationZ(n),this.applyMatrix4(pa),this}},{key:"translate",value:function(n,e,t){return pa.makeTranslation(n,e,t),this.applyMatrix4(pa),this}},{key:"scale",value:function(n,e,t){return pa.makeScale(n,e,t),this.applyMatrix4(pa),this}},{key:"lookAt",value:function(n){return ma.lookAt(n),ma.updateMatrix(),this.applyMatrix4(ma.matrix),this}},{key:"center",value:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(da).negate(),this.translate(da.x,da.y,da.z),this}},{key:"setFromPoints",value:function(n){for(var e=[],t=0,o=n.length;t<o;t++){var r=n[t];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new sa(e,3)),this}},{key:"computeBoundingBox",value:function(){null===this.boundingBox&&(this.boundingBox=new Go);var n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new Oo(-1/0,-1/0,-1/0),new Oo(1/0,1/0,1/0));if(void 0!==n){if(this.boundingBox.setFromBufferAttribute(n),e)for(var t=0,o=e.length;t<o;t++){var r=e[t];ha.setFromBufferAttribute(r),this.morphTargetsRelative?(ya.addVectors(this.boundingBox.min,ha.min),this.boundingBox.expandByPoint(ya),ya.addVectors(this.boundingBox.max,ha.max),this.boundingBox.expandByPoint(ya)):(this.boundingBox.expandByPoint(ha.min),this.boundingBox.expandByPoint(ha.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}},{key:"computeBoundingSphere",value:function(){null===this.boundingSphere&&(this.boundingSphere=new rr);var n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new Oo,1/0);if(n){var t=this.boundingSphere.center;if(ha.setFromBufferAttribute(n),e)for(var o=0,r=e.length;o<r;o++){var a=e[o];xa.setFromBufferAttribute(a),this.morphTargetsRelative?(ya.addVectors(ha.min,xa.min),ha.expandByPoint(ya),ya.addVectors(ha.max,xa.max),ha.expandByPoint(ya)):(ha.expandByPoint(xa.min),ha.expandByPoint(xa.max))}ha.getCenter(t);for(var i=0,v=0,c=n.count;v<c;v++)ya.fromBufferAttribute(n,v),i=Math.max(i,t.distanceToSquared(ya));if(e)for(var l=0,s=e.length;l<s;l++)for(var u=e[l],f=this.morphTargetsRelative,p=0,m=u.count;p<m;p++)ya.fromBufferAttribute(u,p),f&&(da.fromBufferAttribute(n,p),ya.add(da)),i=Math.max(i,t.distanceToSquared(ya));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}},{key:"computeTangents",value:function(){var n=this.index,e=this.attributes;if(null!==n&&void 0!==e.position&&void 0!==e.normal&&void 0!==e.uv){var t=n.array,o=e.position.array,r=e.normal.array,a=e.uv.array,i=o.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new ea(new Float32Array(4*i),4));for(var v=this.getAttribute("tangent").array,c=[],l=[],s=0;s<i;s++)c[s]=new Oo,l[s]=new Oo;var u=new Oo,f=new Oo,p=new Oo,m=new ao,d=new ao,h=new ao,x=new Oo,y=new Oo,g=this.groups;0===g.length&&(g=[{start:0,count:t.length}]);for(var b=0,_=g.length;b<_;++b)for(var U=g[b],w=U.start,S=w,M=w+U.count;S<M;S+=3)E(t[S+0],t[S+1],t[S+2]);for(var z=new Oo,k=new Oo,C=new Oo,T=new Oo,R=0,D=g.length;R<D;++R)for(var P=g[R],F=P.start,j=F,I=F+P.count;j<I;j+=3)O(t[j+0]),O(t[j+1]),O(t[j+2])}else console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");function E(n,e,t){u.fromArray(o,3*n),f.fromArray(o,3*e),p.fromArray(o,3*t),m.fromArray(a,2*n),d.fromArray(a,2*e),h.fromArray(a,2*t),f.sub(u),p.sub(u),d.sub(m),h.sub(m);var r=1/(d.x*h.y-h.x*d.y);isFinite(r)&&(x.copy(f).multiplyScalar(h.y).addScaledVector(p,-d.y).multiplyScalar(r),y.copy(p).multiplyScalar(d.x).addScaledVector(f,-h.x).multiplyScalar(r),c[n].add(x),c[e].add(x),c[t].add(x),l[n].add(y),l[e].add(y),l[t].add(y))}function O(n){C.fromArray(r,3*n),T.copy(C);var e=c[n];z.copy(e),z.sub(C.multiplyScalar(C.dot(e))).normalize(),k.crossVectors(T,e);var t=k.dot(l[n])<0?-1:1;v[4*n]=z.x,v[4*n+1]=z.y,v[4*n+2]=z.z,v[4*n+3]=t}}},{key:"computeVertexNormals",value:function(){var n=this.index,e=this.getAttribute("position");if(void 0!==e){var t=this.getAttribute("normal");if(void 0===t)t=new ea(new Float32Array(3*e.count),3),this.setAttribute("normal",t);else for(var o=0,r=t.count;o<r;o++)t.setXYZ(o,0,0,0);var a=new Oo,i=new Oo,v=new Oo,c=new Oo,l=new Oo,s=new Oo,u=new Oo,f=new Oo;if(n)for(var p=0,m=n.count;p<m;p+=3){var d=n.getX(p+0),h=n.getX(p+1),x=n.getX(p+2);a.fromBufferAttribute(e,d),i.fromBufferAttribute(e,h),v.fromBufferAttribute(e,x),u.subVectors(v,i),f.subVectors(a,i),u.cross(f),c.fromBufferAttribute(t,d),l.fromBufferAttribute(t,h),s.fromBufferAttribute(t,x),c.add(u),l.add(u),s.add(u),t.setXYZ(d,c.x,c.y,c.z),t.setXYZ(h,l.x,l.y,l.z),t.setXYZ(x,s.x,s.y,s.z)}else for(var y=0,g=e.count;y<g;y+=3)a.fromBufferAttribute(e,y+0),i.fromBufferAttribute(e,y+1),v.fromBufferAttribute(e,y+2),u.subVectors(v,i),f.subVectors(a,i),u.cross(f),t.setXYZ(y+0,u.x,u.y,u.z),t.setXYZ(y+1,u.x,u.y,u.z),t.setXYZ(y+2,u.x,u.y,u.z);this.normalizeNormals(),t.needsUpdate=!0}}},{key:"merge",value:function(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}},{key:"normalizeNormals",value:function(){for(var n=this.attributes.normal,e=0,t=n.count;e<t;e++)ya.fromBufferAttribute(n,e),ya.normalize(),n.setXYZ(e,ya.x,ya.y,ya.z)}},{key:"toNonIndexed",value:function(){function n(n,e){for(var t=n.array,o=n.itemSize,r=n.normalized,a=new t.constructor(e.length*o),i=0,v=0,c=0,l=e.length;c<l;c++){i=n.isInterleavedBufferAttribute?e[c]*n.data.stride+n.offset:e[c]*o;for(var s=0;s<o;s++)a[v++]=t[i++]}return new ea(a,o,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;var e=new t,o=this.index.array,r=this.attributes;for(var a in r){var i=n(r[a],o);e.setAttribute(a,i)}var v=this.morphAttributes;for(var c in v){for(var l=[],s=v[c],u=0,f=s.length;u<f;u++){var p=n(s[u],o);l.push(p)}e.morphAttributes[c]=l}e.morphTargetsRelative=this.morphTargetsRelative;for(var m=this.groups,d=0,h=m.length;d<h;d++){var x=m[d];e.addGroup(x.start,x.count,x.materialIndex)}return e}},{key:"toJSON",value:function(){var n={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),void 0!==this.parameters){var e=this.parameters;for(var t in e)void 0!==e[t]&&(n[t]=e[t]);return n}n.data={attributes:{}};var o=this.index;null!==o&&(n.data.index={type:o.array.constructor.name,array:Array.prototype.slice.call(o.array)});var r=this.attributes;for(var a in r){var i=r[a];n.data.attributes[a]=i.toJSON(n.data)}var v={},c=!1;for(var l in this.morphAttributes){for(var s=this.morphAttributes[l],u=[],f=0,p=s.length;f<p;f++){var m=s[f];u.push(m.toJSON(n.data))}u.length>0&&(v[l]=u,c=!0)}c&&(n.data.morphAttributes=v,n.data.morphTargetsRelative=this.morphTargetsRelative);var d=this.groups;d.length>0&&(n.data.groups=JSON.parse(JSON.stringify(d)));var h=this.boundingSphere;return null!==h&&(n.data.boundingSphere={center:h.center.toArray(),radius:h.radius}),n}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;var e={};this.name=n.name;var t=n.index;null!==t&&this.setIndex(t.clone(e));var o=n.attributes;for(var r in o){var a=o[r];this.setAttribute(r,a.clone(e))}var i=n.morphAttributes;for(var v in i){for(var c=[],l=i[v],s=0,u=l.length;s<u;s++)c.push(l[s].clone(e));this.morphAttributes[v]=c}this.morphTargetsRelative=n.morphTargetsRelative;for(var f=n.groups,p=0,m=f.length;p<m;p++){var d=f[p];this.addGroup(d.start,d.count,d.materialIndex)}var h=n.boundingBox;null!==h&&(this.boundingBox=h.clone());var x=n.boundingSphere;return null!==x&&(this.boundingSphere=x.clone()),this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,this.userData=n.userData,void 0!==n.parameters&&(this.parameters=Object.assign({},n.parameters)),this}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}}]),t}(Vt),ba=new pr,_a=new fr,Ua=new rr,wa=new Oo,Sa=new Oo,Ma=new Oo,za=new Oo,ka=new Oo,Ca=new Oo,Ta=new Oo,Ra=new Oo,Da=new Oo,Pa=new ao,Fa=new ao,ja=new ao,Ia=new Oo,Ea=new Oo,Oa=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ga,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Kr;return y(this,t),(n=e.call(this)).isMesh=!0,n.type="Mesh",n.geometry=o,n.material=r,n.updateMorphTargets(),n}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),void 0!==n.morphTargetInfluences&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),void 0!==n.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=n.material,this.geometry=n.geometry,this}},{key:"updateMorphTargets",value:function(){var n=this.geometry.morphAttributes,e=Object.keys(n);if(e.length>0){var t=n[e[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var o=0,r=t.length;o<r;o++){var a=t[o].name||String(o);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=o}}}}},{key:"raycast",value:function(n,e){var t=this.geometry,o=this.material,r=this.matrixWorld;if(void 0!==o&&(null===t.boundingSphere&&t.computeBoundingSphere(),Ua.copy(t.boundingSphere),Ua.applyMatrix4(r),!1!==n.ray.intersectsSphere(Ua)&&(ba.copy(r).invert(),_a.copy(n.ray).applyMatrix4(ba),null===t.boundingBox||!1!==_a.intersectsBox(t.boundingBox)))){var a,i=t.index,v=t.attributes.position,c=t.morphAttributes.position,l=t.morphTargetsRelative,s=t.attributes.uv,u=t.attributes.uv2,f=t.groups,p=t.drawRange;if(null!==i)if(Array.isArray(o))for(var m=0,d=f.length;m<d;m++)for(var h=f[m],x=o[h.materialIndex],y=Math.max(h.start,p.start),g=Math.min(i.count,Math.min(h.start+h.count,p.start+p.count));y<g;y+=3){var b=i.getX(y),_=i.getX(y+1),U=i.getX(y+2);(a=La(this,x,n,_a,v,c,l,s,u,b,_,U))&&(a.faceIndex=Math.floor(y/3),a.face.materialIndex=h.materialIndex,e.push(a))}else for(var w=Math.max(0,p.start),S=Math.min(i.count,p.start+p.count);w<S;w+=3){var M=i.getX(w),z=i.getX(w+1),k=i.getX(w+2);(a=La(this,o,n,_a,v,c,l,s,u,M,z,k))&&(a.faceIndex=Math.floor(w/3),e.push(a))}else if(void 0!==v)if(Array.isArray(o))for(var C=0,T=f.length;C<T;C++)for(var R=f[C],D=o[R.materialIndex],P=Math.max(R.start,p.start),F=Math.min(v.count,Math.min(R.start+R.count,p.start+p.count));P<F;P+=3){(a=La(this,D,n,_a,v,c,l,s,u,P,P+1,P+2))&&(a.faceIndex=Math.floor(P/3),a.face.materialIndex=R.materialIndex,e.push(a))}else for(var j=Math.max(0,p.start),I=Math.min(v.count,p.start+p.count);j<I;j+=3){(a=La(this,o,n,_a,v,c,l,s,u,j,j+1,j+2))&&(a.faceIndex=Math.floor(j/3),e.push(a))}}}}]),t}(Lr);function La(n,e,t,o,r,a,i,v,c,l,s,u){wa.fromBufferAttribute(r,l),Sa.fromBufferAttribute(r,s),Ma.fromBufferAttribute(r,u);var f=n.morphTargetInfluences;if(a&&f){Ta.set(0,0,0),Ra.set(0,0,0),Da.set(0,0,0);for(var p=0,m=a.length;p<m;p++){var d=f[p],h=a[p];0!==d&&(za.fromBufferAttribute(h,l),ka.fromBufferAttribute(h,s),Ca.fromBufferAttribute(h,u),i?(Ta.addScaledVector(za,d),Ra.addScaledVector(ka,d),Da.addScaledVector(Ca,d)):(Ta.addScaledVector(za.sub(wa),d),Ra.addScaledVector(ka.sub(Sa),d),Da.addScaledVector(Ca.sub(Ma),d)))}wa.add(Ta),Sa.add(Ra),Ma.add(Da)}n.isSkinnedMesh&&(n.boneTransform(l,wa),n.boneTransform(s,Sa),n.boneTransform(u,Ma));var x=function(n,e,t,o,r,a,i,v){if(null===(e.side===W?o.intersectTriangle(i,a,r,!0,v):o.intersectTriangle(r,a,i,e.side!==H,v)))return null;Ea.copy(v),Ea.applyMatrix4(n.matrixWorld);var c=t.ray.origin.distanceTo(Ea);return c<t.near||c>t.far?null:{distance:c,point:Ea.clone(),object:n}}(n,e,t,o,wa,Sa,Ma,Ia);if(x){v&&(Pa.fromBufferAttribute(v,l),Fa.fromBufferAttribute(v,s),ja.fromBufferAttribute(v,u),x.uv=Zr.getUV(Ia,wa,Sa,Ma,Pa,Fa,ja,new ao)),c&&(Pa.fromBufferAttribute(c,l),Fa.fromBufferAttribute(c,s),ja.fromBufferAttribute(c,u),x.uv2=Zr.getUV(Ia,wa,Sa,Ma,Pa,Fa,ja,new ao));var y={a:l,b:s,c:u,normal:new Oo,materialIndex:0};Zr.getNormal(wa,Sa,Ma,y.normal),x.face=y}return x}var Aa=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;y(this,t),(n=e.call(this)).type="BoxGeometry",n.parameters={width:o,height:r,depth:a,widthSegments:i,heightSegments:v,depthSegments:c};var l=S(n);i=Math.floor(i),v=Math.floor(v),c=Math.floor(c);var s=[],u=[],f=[],p=[],m=0,d=0;function h(n,e,t,o,r,a,i,v,c,h,x){for(var y=a/c,g=i/h,b=a/2,_=i/2,U=v/2,w=c+1,S=h+1,M=0,z=0,k=new Oo,C=0;C<S;C++)for(var T=C*g-_,R=0;R<w;R++){var D=R*y-b;k[n]=D*o,k[e]=T*r,k[t]=U,u.push(k.x,k.y,k.z),k[n]=0,k[e]=0,k[t]=v>0?1:-1,f.push(k.x,k.y,k.z),p.push(R/c),p.push(1-C/h),M+=1}for(var P=0;P<h;P++)for(var F=0;F<c;F++){var j=m+F+w*P,I=m+F+w*(P+1),E=m+(F+1)+w*(P+1),O=m+(F+1)+w*P;s.push(j,I,O),s.push(I,E,O),z+=6}l.addGroup(d,z,x),d+=z,m+=M}return h("z","y","x",-1,-1,a,r,o,c,v,0),h("z","y","x",1,-1,a,r,-o,c,v,1),h("x","z","y",1,1,o,a,r,i,c,2),h("x","z","y",1,-1,o,a,-r,i,c,3),h("x","y","z",1,-1,o,r,a,i,v,4),h("x","y","z",-1,-1,o,r,-a,i,v,5),n.setIndex(s),n.setAttribute("position",new sa(u,3)),n.setAttribute("normal",new sa(f,3)),n.setAttribute("uv",new sa(p,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.width,n.height,n.depth,n.widthSegments,n.heightSegments,n.depthSegments)}}]),t}(ga);function Ga(n){var e={};for(var t in n)for(var o in e[t]={},n[t]){var r=n[t][o];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[t][o]=r.clone():Array.isArray(r)?e[t][o]=r.slice():e[t][o]=r}return e}function Na(n){for(var e={},t=0;t<n.length;t++){var o=Ga(n[t]);for(var r in o)e[r]=o[r]}return e}var Ba={clone:Ga,merge:Na},qa=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isShaderMaterial=!0,o.type="ShaderMaterial",o.defines={},o.uniforms={},o.uniformsGroups=[],o.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",o.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",o.linewidth=1,o.wireframe=!1,o.wireframeLinewidth=1,o.fog=!1,o.lights=!1,o.clipping=!1,o.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},o.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},o.index0AttributeName=void 0,o.uniformsNeedUpdate=!1,o.glslVersion=null,void 0!==n&&o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=Ga(n.uniforms),this.uniformsGroups=function(n){for(var e=[],t=0;t<n.length;t++)e.push(n[t].clone());return e}(n.uniformsGroups),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.fog=n.fog,this.lights=n.lights,this.clipping=n.clipping,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this}},{key:"toJSON",value:function(n){var e=D(U(t.prototype),"toJSON",this).call(this,n);for(var o in e.glslVersion=this.glslVersion,e.uniforms={},this.uniforms){var r=this.uniforms[o].value;r&&r.isTexture?e.uniforms[o]={type:"t",value:r.toJSON(n).uuid}:r&&r.isColor?e.uniforms[o]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[o]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[o]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[o]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[o]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[o]={type:"m4",value:r.toArray()}:e.uniforms[o]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;var a={};for(var i in this.extensions)!0===this.extensions[i]&&(a[i]=!0);return Object.keys(a).length>0&&(e.extensions=a),e}}]),t}(Jr),Va=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isCamera=!0,n.type="Camera",n.matrixWorldInverse=new pr,n.projectionMatrix=new pr,n.projectionMatrixInverse=new pr,n}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this}},{key:"getWorldDirection",value:function(n){this.updateWorldMatrix(!0,!1);var e=this.matrixWorld.elements;return n.set(-e[8],-e[9],-e[10]).normalize()}},{key:"updateMatrixWorld",value:function(n){D(U(t.prototype),"updateMatrixWorld",this).call(this,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()}},{key:"updateWorldMatrix",value:function(n,e){D(U(t.prototype),"updateWorldMatrix",this).call(this,n,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),t}(Lr),Wa=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:50,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2e3;return y(this,t),(n=e.call(this)).isPerspectiveCamera=!0,n.type="PerspectiveCamera",n.fov=o,n.zoom=1,n.near=a,n.far=i,n.focus=10,n.aspect=r,n.view=null,n.filmGauge=35,n.filmOffset=0,n.updateProjectionMatrix(),n}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=null===n.view?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this}},{key:"setFocalLength",value:function(n){var e=.5*this.getFilmHeight()/n;this.fov=2*Yt*Math.atan(e),this.updateProjectionMatrix()}},{key:"getFocalLength",value:function(){var n=Math.tan(.5*Xt*this.fov);return.5*this.getFilmHeight()/n}},{key:"getEffectiveFOV",value:function(){return 2*Yt*Math.atan(Math.tan(.5*Xt*this.fov)/this.zoom)}},{key:"getFilmWidth",value:function(){return this.filmGauge*Math.min(this.aspect,1)}},{key:"getFilmHeight",value:function(){return this.filmGauge/Math.max(this.aspect,1)}},{key:"setViewOffset",value:function(n,e,t,o,r,a){this.aspect=n/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=o,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}},{key:"clearViewOffset",value:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}},{key:"updateProjectionMatrix",value:function(){var n=this.near,e=n*Math.tan(.5*Xt*this.fov)/this.zoom,t=2*e,o=this.aspect*t,r=-.5*o,a=this.view;if(null!==this.view&&this.view.enabled){var i=a.fullWidth,v=a.fullHeight;r+=a.offsetX*o/i,e-=a.offsetY*t/v,o*=a.width/i,t*=a.height/v}var c=this.filmOffset;0!==c&&(r+=n*c/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+o,e,e-t,n,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}},{key:"toJSON",value:function(n){var e=D(U(t.prototype),"toJSON",this).call(this,n);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}]),t}(Va),Ha=90,Xa=function(n){_(t,n);var e=z(t);function t(n,o,r){var a;y(this,t),(a=e.call(this)).type="CubeCamera",a.renderTarget=r;var i=new Wa(Ha,1,n,o);i.layers=a.layers,i.up.set(0,-1,0),i.lookAt(new Oo(1,0,0)),a.add(i);var v=new Wa(Ha,1,n,o);v.layers=a.layers,v.up.set(0,-1,0),v.lookAt(new Oo(-1,0,0)),a.add(v);var c=new Wa(Ha,1,n,o);c.layers=a.layers,c.up.set(0,0,1),c.lookAt(new Oo(0,1,0)),a.add(c);var l=new Wa(Ha,1,n,o);l.layers=a.layers,l.up.set(0,0,-1),l.lookAt(new Oo(0,-1,0)),a.add(l);var s=new Wa(Ha,1,n,o);s.layers=a.layers,s.up.set(0,-1,0),s.lookAt(new Oo(0,0,1)),a.add(s);var u=new Wa(Ha,1,n,o);return u.layers=a.layers,u.up.set(0,-1,0),u.lookAt(new Oo(0,0,-1)),a.add(u),a}return b(t,[{key:"update",value:function(n,e){null===this.parent&&this.updateMatrixWorld();var t=this.renderTarget,o=c(this.children,6),r=o[0],a=o[1],i=o[2],v=o[3],l=o[4],s=o[5],u=n.getRenderTarget(),f=n.toneMapping,p=n.xr.enabled;n.toneMapping=kn,n.xr.enabled=!1;var m=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,n.setRenderTarget(t,0),n.render(e,r),n.setRenderTarget(t,1),n.render(e,a),n.setRenderTarget(t,2),n.render(e,i),n.setRenderTarget(t,3),n.render(e,v),n.setRenderTarget(t,4),n.render(e,l),t.texture.generateMipmaps=m,n.setRenderTarget(t,5),n.render(e,s),n.setRenderTarget(u),n.toneMapping=f,n.xr.enabled=p,t.texture.needsPMREMUpdate=!0}}]),t}(Lr),Ya=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v,c,l,s,u){var f;return y(this,t),n=void 0!==n?n:[],o=void 0!==o?o:jn,(f=e.call(this,n,o,r,a,i,v,c,l,s,u)).isCubeTexture=!0,f.flipY=!1,f}return b(t,[{key:"images",get:function(){return this.image},set:function(n){this.image=n}}]),t}(Co),Za=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};y(this,t),(n=e.call(this,o,o,r)).isWebGLCubeRenderTarget=!0;var a={width:o,height:o,depth:1},i=[a,a,a,a,a,a];return n.texture=new Ya(i,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),n.texture.isRenderTargetTexture=!0,n.texture.generateMipmaps=void 0!==r.generateMipmaps&&r.generateMipmaps,n.texture.minFilter=void 0!==r.minFilter?r.minFilter:Xn,n}return b(t,[{key:"fromEquirectangularTexture",value:function(n,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;var t={tEquirect:{value:null}},o="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",r="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",a=new Aa(5,5,5),i=new qa({name:"CubemapFromEquirect",uniforms:Ga(t),vertexShader:o,fragmentShader:r,side:W,blending:X});i.uniforms.tEquirect.value=e;var v=new Oa(a,i),c=e.minFilter;return e.minFilter===Qn&&(e.minFilter=Xn),new Xa(1,10,this).update(n,v),e.minFilter=c,v.geometry.dispose(),v.material.dispose(),this}},{key:"clear",value:function(n,e,t,o){for(var r=n.getRenderTarget(),a=0;a<6;a++)n.setRenderTarget(this,a),n.clear(e,t,o);n.setRenderTarget(r)}}]),t}(Ro),Qa=new Oo,Ja=new Oo,Ka=new io,$a=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo(1,0,0),t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,n),this.isPlane=!0,this.normal=e,this.constant=t}return b(n,[{key:"set",value:function(n,e){return this.normal.copy(n),this.constant=e,this}},{key:"setComponents",value:function(n,e,t,o){return this.normal.set(n,e,t),this.constant=o,this}},{key:"setFromNormalAndCoplanarPoint",value:function(n,e){return this.normal.copy(n),this.constant=-e.dot(this.normal),this}},{key:"setFromCoplanarPoints",value:function(n,e,t){var o=Qa.subVectors(t,e).cross(Ja.subVectors(n,e)).normalize();return this.setFromNormalAndCoplanarPoint(o,n),this}},{key:"copy",value:function(n){return this.normal.copy(n.normal),this.constant=n.constant,this}},{key:"normalize",value:function(){var n=1/this.normal.length();return this.normal.multiplyScalar(n),this.constant*=n,this}},{key:"negate",value:function(){return this.constant*=-1,this.normal.negate(),this}},{key:"distanceToPoint",value:function(n){return this.normal.dot(n)+this.constant}},{key:"distanceToSphere",value:function(n){return this.distanceToPoint(n.center)-n.radius}},{key:"projectPoint",value:function(n,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(n)).add(n)}},{key:"intersectLine",value:function(n,e){var t=n.delta(Qa),o=this.normal.dot(t);if(0===o)return 0===this.distanceToPoint(n.start)?e.copy(n.start):null;var r=-(n.start.dot(this.normal)+this.constant)/o;return r<0||r>1?null:e.copy(t).multiplyScalar(r).add(n.start)}},{key:"intersectsLine",value:function(n){var e=this.distanceToPoint(n.start),t=this.distanceToPoint(n.end);return e<0&&t>0||t<0&&e>0}},{key:"intersectsBox",value:function(n){return n.intersectsPlane(this)}},{key:"intersectsSphere",value:function(n){return n.intersectsPlane(this)}},{key:"coplanarPoint",value:function(n){return n.copy(this.normal).multiplyScalar(-this.constant)}},{key:"applyMatrix4",value:function(n,e){var t=e||Ka.getNormalMatrix(n),o=this.coplanarPoint(Qa).applyMatrix4(n),r=this.normal.applyMatrix3(t).normalize();return this.constant=-o.dot(r),this}},{key:"translate",value:function(n){return this.constant-=n.dot(this.normal),this}},{key:"equals",value:function(n){return n.normal.equals(this.normal)&&n.constant===this.constant}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),ni=new rr,ei=new Oo,ti=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new $a,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new $a,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new $a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new $a,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new $a,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:new $a;y(this,n),this.planes=[e,t,o,r,a,i]}return b(n,[{key:"set",value:function(n,e,t,o,r,a){var i=this.planes;return i[0].copy(n),i[1].copy(e),i[2].copy(t),i[3].copy(o),i[4].copy(r),i[5].copy(a),this}},{key:"copy",value:function(n){for(var e=this.planes,t=0;t<6;t++)e[t].copy(n.planes[t]);return this}},{key:"setFromProjectionMatrix",value:function(n){var e=this.planes,t=n.elements,o=t[0],r=t[1],a=t[2],i=t[3],v=t[4],c=t[5],l=t[6],s=t[7],u=t[8],f=t[9],p=t[10],m=t[11],d=t[12],h=t[13],x=t[14],y=t[15];return e[0].setComponents(i-o,s-v,m-u,y-d).normalize(),e[1].setComponents(i+o,s+v,m+u,y+d).normalize(),e[2].setComponents(i+r,s+c,m+f,y+h).normalize(),e[3].setComponents(i-r,s-c,m-f,y-h).normalize(),e[4].setComponents(i-a,s-l,m-p,y-x).normalize(),e[5].setComponents(i+a,s+l,m+p,y+x).normalize(),this}},{key:"intersectsObject",value:function(n){var e=n.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),ni.copy(e.boundingSphere).applyMatrix4(n.matrixWorld),this.intersectsSphere(ni)}},{key:"intersectsSprite",value:function(n){return ni.center.set(0,0,0),ni.radius=.7071067811865476,ni.applyMatrix4(n.matrixWorld),this.intersectsSphere(ni)}},{key:"intersectsSphere",value:function(n){for(var e=this.planes,t=n.center,o=-n.radius,r=0;r<6;r++){if(e[r].distanceToPoint(t)<o)return!1}return!0}},{key:"intersectsBox",value:function(n){for(var e=this.planes,t=0;t<6;t++){var o=e[t];if(ei.x=o.normal.x>0?n.max.x:n.min.x,ei.y=o.normal.y>0?n.max.y:n.min.y,ei.z=o.normal.z>0?n.max.z:n.min.z,o.distanceToPoint(ei)<0)return!1}return!0}},{key:"containsPoint",value:function(n){for(var e=this.planes,t=0;t<6;t++)if(e[t].distanceToPoint(n)<0)return!1;return!0}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}();function oi(){var n=null,e=!1,t=null,o=null;function r(e,a){t(e,a),o=n.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==t&&(o=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(o),e=!1},setAnimationLoop:function(n){t=n},setContext:function(e){n=e}}}function ri(n,e){var t=e.isWebGL2,o=new WeakMap;return{get:function(n){return n.isInterleavedBufferAttribute&&(n=n.data),o.get(n)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);var t=o.get(e);t&&(n.deleteBuffer(t.buffer),o.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){var a=o.get(e);(!a||a.version<e.version)&&o.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version})}else{e.isInterleavedBufferAttribute&&(e=e.data);var i=o.get(e);void 0===i?o.set(e,function(e,o){var r,a=e.array,i=e.usage,v=n.createBuffer();if(n.bindBuffer(o,v),n.bufferData(o,a,i),e.onUploadCallback(),a instanceof Float32Array)r=5126;else if(a instanceof Uint16Array)if(e.isFloat16BufferAttribute){if(!t)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");r=5131}else r=5123;else if(a instanceof Int16Array)r=5122;else if(a instanceof Uint32Array)r=5125;else if(a instanceof Int32Array)r=5124;else if(a instanceof Int8Array)r=5120;else if(a instanceof Uint8Array)r=5121;else{if(!(a instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+a);r=5121}return{buffer:v,type:r,bytesPerElement:a.BYTES_PER_ELEMENT,version:e.version}}(e,r)):i.version<e.version&&(!function(e,o,r){var a=o.array,i=o.updateRange;n.bindBuffer(r,e),-1===i.count?n.bufferSubData(r,0,a):(t?n.bufferSubData(r,i.offset*a.BYTES_PER_ELEMENT,a,i.offset,i.count):n.bufferSubData(r,i.offset*a.BYTES_PER_ELEMENT,a.subarray(i.offset,i.offset+i.count)),i.count=-1)}(i.buffer,e,r),i.version=e.version)}}}}var ai=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;y(this,t),(n=e.call(this)).type="PlaneGeometry",n.parameters={width:o,height:r,widthSegments:a,heightSegments:i};for(var v=o/2,c=r/2,l=Math.floor(a),s=Math.floor(i),u=l+1,f=s+1,p=o/l,m=r/s,d=[],h=[],x=[],g=[],b=0;b<f;b++)for(var _=b*m-c,U=0;U<u;U++){var w=U*p-v;h.push(w,-_,0),x.push(0,0,1),g.push(U/l),g.push(1-b/s)}for(var S=0;S<s;S++)for(var M=0;M<l;M++){var z=M+u*S,k=M+u*(S+1),C=M+1+u*(S+1),T=M+1+u*S;d.push(z,k,T),d.push(k,C,T)}return n.setIndex(d),n.setAttribute("position",new sa(h,3)),n.setAttribute("normal",new sa(x,3)),n.setAttribute("uv",new sa(g,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.width,n.height,n.widthSegments,n.heightSegments)}}]),t}(ga),ii={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},vi={common:{diffuse:{value:new wo(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new io},uv2Transform:{value:new io},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new ao(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new wo(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new wo(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new io}},sprite:{diffuse:{value:new wo(16777215)},opacity:{value:1},center:{value:new ao(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new io}}},ci={basic:{uniforms:Na([vi.common,vi.specularmap,vi.envmap,vi.aomap,vi.lightmap,vi.fog]),vertexShader:ii.meshbasic_vert,fragmentShader:ii.meshbasic_frag},lambert:{uniforms:Na([vi.common,vi.specularmap,vi.envmap,vi.aomap,vi.lightmap,vi.emissivemap,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.fog,vi.lights,{emissive:{value:new wo(0)}}]),vertexShader:ii.meshlambert_vert,fragmentShader:ii.meshlambert_frag},phong:{uniforms:Na([vi.common,vi.specularmap,vi.envmap,vi.aomap,vi.lightmap,vi.emissivemap,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.fog,vi.lights,{emissive:{value:new wo(0)},specular:{value:new wo(1118481)},shininess:{value:30}}]),vertexShader:ii.meshphong_vert,fragmentShader:ii.meshphong_frag},standard:{uniforms:Na([vi.common,vi.envmap,vi.aomap,vi.lightmap,vi.emissivemap,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.roughnessmap,vi.metalnessmap,vi.fog,vi.lights,{emissive:{value:new wo(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ii.meshphysical_vert,fragmentShader:ii.meshphysical_frag},toon:{uniforms:Na([vi.common,vi.aomap,vi.lightmap,vi.emissivemap,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.gradientmap,vi.fog,vi.lights,{emissive:{value:new wo(0)}}]),vertexShader:ii.meshtoon_vert,fragmentShader:ii.meshtoon_frag},matcap:{uniforms:Na([vi.common,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.fog,{matcap:{value:null}}]),vertexShader:ii.meshmatcap_vert,fragmentShader:ii.meshmatcap_frag},points:{uniforms:Na([vi.points,vi.fog]),vertexShader:ii.points_vert,fragmentShader:ii.points_frag},dashed:{uniforms:Na([vi.common,vi.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ii.linedashed_vert,fragmentShader:ii.linedashed_frag},depth:{uniforms:Na([vi.common,vi.displacementmap]),vertexShader:ii.depth_vert,fragmentShader:ii.depth_frag},normal:{uniforms:Na([vi.common,vi.bumpmap,vi.normalmap,vi.displacementmap,{opacity:{value:1}}]),vertexShader:ii.meshnormal_vert,fragmentShader:ii.meshnormal_frag},sprite:{uniforms:Na([vi.sprite,vi.fog]),vertexShader:ii.sprite_vert,fragmentShader:ii.sprite_frag},background:{uniforms:{uvTransform:{value:new io},t2D:{value:null}},vertexShader:ii.background_vert,fragmentShader:ii.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0}},vertexShader:ii.backgroundCube_vert,fragmentShader:ii.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ii.cube_vert,fragmentShader:ii.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ii.equirect_vert,fragmentShader:ii.equirect_frag},distanceRGBA:{uniforms:Na([vi.common,vi.displacementmap,{referencePosition:{value:new Oo},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ii.distanceRGBA_vert,fragmentShader:ii.distanceRGBA_frag},shadow:{uniforms:Na([vi.lights,vi.fog,{color:{value:new wo(0)},opacity:{value:1}}]),vertexShader:ii.shadow_vert,fragmentShader:ii.shadow_frag}};function li(n,e,t,o,r,a,i){var v,c,l=new wo(0),s=!0===a?0:1,u=null,f=0,p=null;function m(n,e){o.buffers.color.setClear(n.r,n.g,n.b,e,i)}return{getClearColor:function(){return l},setClearColor:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;l.set(n),m(l,s=e)},getClearAlpha:function(){return s},setClearAlpha:function(n){m(l,s=n)},render:function(o,a){var i=!1,d=!0===a.isScene?a.background:null;d&&d.isTexture&&(d=(a.backgroundBlurriness>0?t:e).get(d));var h=n.xr,x=h.getSession&&h.getSession();x&&"additive"===x.environmentBlendMode&&(d=null),null===d?m(l,s):d&&d.isColor&&(m(d,1),i=!0),(n.autoClear||i)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),d&&(d.isCubeTexture||d.mapping===Ln)?(void 0===c&&((c=new Oa(new Aa(1,1,1),new qa({name:"BackgroundCubeMaterial",uniforms:Ga(ci.backgroundCube.uniforms),vertexShader:ci.backgroundCube.vertexShader,fragmentShader:ci.backgroundCube.fragmentShader,side:W,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(n,e,t){this.matrixWorld.copyPosition(t.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(c)),c.material.uniforms.envMap.value=d,c.material.uniforms.flipEnvMap.value=d.isCubeTexture&&!1===d.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=a.backgroundBlurriness,u===d&&f===d.version&&p===n.toneMapping||(c.material.needsUpdate=!0,u=d,f=d.version,p=n.toneMapping),c.layers.enableAll(),o.unshift(c,c.geometry,c.material,0,0,null)):d&&d.isTexture&&(void 0===v&&((v=new Oa(new ai(2,2),new qa({name:"BackgroundMaterial",uniforms:Ga(ci.background.uniforms),vertexShader:ci.background.vertexShader,fragmentShader:ci.background.fragmentShader,side:V,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),Object.defineProperty(v.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(v)),v.material.uniforms.t2D.value=d,!0===d.matrixAutoUpdate&&d.updateMatrix(),v.material.uniforms.uvTransform.value.copy(d.matrix),u===d&&f===d.version&&p===n.toneMapping||(v.material.needsUpdate=!0,u=d,f=d.version,p=n.toneMapping),v.layers.enableAll(),o.unshift(v,v.geometry,v.material,0,0,null))}}}function si(n,e,t,o){var r=n.getParameter(34921),a=o.isWebGL2?null:e.get("OES_vertex_array_object"),i=o.isWebGL2||null!==a,v={},c=p(null),l=c,s=!1;function u(e){return o.isWebGL2?n.bindVertexArray(e):a.bindVertexArrayOES(e)}function f(e){return o.isWebGL2?n.deleteVertexArray(e):a.deleteVertexArrayOES(e)}function p(n){for(var e=[],t=[],o=[],a=0;a<r;a++)e[a]=0,t[a]=0,o[a]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:t,attributeDivisors:o,object:n,attributes:{},index:null}}function m(){for(var n=l.newAttributes,e=0,t=n.length;e<t;e++)n[e]=0}function d(n){h(n,0)}function h(t,r){var a=l.newAttributes,i=l.enabledAttributes,v=l.attributeDivisors;(a[t]=1,0===i[t]&&(n.enableVertexAttribArray(t),i[t]=1),v[t]!==r)&&((o.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[o.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](t,r),v[t]=r)}function x(){for(var e=l.newAttributes,t=l.enabledAttributes,o=0,r=t.length;o<r;o++)t[o]!==e[o]&&(n.disableVertexAttribArray(o),t[o]=0)}function y(e,t,r,a,i,v){!0!==o.isWebGL2||5124!==r&&5125!==r?n.vertexAttribPointer(e,t,r,a,i,v):n.vertexAttribIPointer(e,t,r,i,v)}function g(){b(),s=!0,l!==c&&u((l=c).object)}function b(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:function(r,c,f,g,b){var _=!1;if(i){var U=function(e,t,r){var i=!0===r.wireframe,c=v[e.id];void 0===c&&(c={},v[e.id]=c);var l=c[t.id];void 0===l&&(l={},c[t.id]=l);var s=l[i];void 0===s&&(s=p(o.isWebGL2?n.createVertexArray():a.createVertexArrayOES()),l[i]=s);return s}(g,f,c);l!==U&&u((l=U).object),_=function(n,e,t,o){var r=l.attributes,a=e.attributes,i=0,v=t.getAttributes();for(var c in v){if(v[c].location>=0){var s=r[c],u=a[c];if(void 0===u&&("instanceMatrix"===c&&n.instanceMatrix&&(u=n.instanceMatrix),"instanceColor"===c&&n.instanceColor&&(u=n.instanceColor)),void 0===s)return!0;if(s.attribute!==u)return!0;if(u&&s.data!==u.data)return!0;i++}}return l.attributesNum!==i||l.index!==o}(r,g,f,b),_&&function(n,e,t,o){var r={},a=e.attributes,i=0,v=t.getAttributes();for(var c in v){if(v[c].location>=0){var s=a[c];void 0===s&&("instanceMatrix"===c&&n.instanceMatrix&&(s=n.instanceMatrix),"instanceColor"===c&&n.instanceColor&&(s=n.instanceColor));var u={};u.attribute=s,s&&s.data&&(u.data=s.data),r[c]=u,i++}}l.attributes=r,l.attributesNum=i,l.index=o}(r,g,f,b)}else{var w=!0===c.wireframe;l.geometry===g.id&&l.program===f.id&&l.wireframe===w||(l.geometry=g.id,l.program=f.id,l.wireframe=w,_=!0)}null!==b&&t.update(b,34963),(_||s)&&(s=!1,function(r,a,i,v){if(!1===o.isWebGL2&&(r.isInstancedMesh||v.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;m();var c=v.attributes,l=i.getAttributes(),s=a.defaultAttributeValues;for(var u in l){var f=l[u];if(f.location>=0){var p=c[u];if(void 0===p&&("instanceMatrix"===u&&r.instanceMatrix&&(p=r.instanceMatrix),"instanceColor"===u&&r.instanceColor&&(p=r.instanceColor)),void 0!==p){var g=p.normalized,b=p.itemSize,_=t.get(p);if(void 0===_)continue;var U=_.buffer,w=_.type,S=_.bytesPerElement;if(p.isInterleavedBufferAttribute){var M=p.data,z=M.stride,k=p.offset;if(M.isInstancedInterleavedBuffer){for(var C=0;C<f.locationSize;C++)h(f.location+C,M.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===v._maxInstanceCount&&(v._maxInstanceCount=M.meshPerAttribute*M.count)}else for(var T=0;T<f.locationSize;T++)d(f.location+T);n.bindBuffer(34962,U);for(var R=0;R<f.locationSize;R++)y(f.location+R,b/f.locationSize,w,g,z*S,(k+b/f.locationSize*R)*S)}else{if(p.isInstancedBufferAttribute){for(var D=0;D<f.locationSize;D++)h(f.location+D,p.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===v._maxInstanceCount&&(v._maxInstanceCount=p.meshPerAttribute*p.count)}else for(var P=0;P<f.locationSize;P++)d(f.location+P);n.bindBuffer(34962,U);for(var F=0;F<f.locationSize;F++)y(f.location+F,b/f.locationSize,w,g,b*S,b/f.locationSize*F*S)}}else if(void 0!==s){var j=s[u];if(void 0!==j)switch(j.length){case 2:n.vertexAttrib2fv(f.location,j);break;case 3:n.vertexAttrib3fv(f.location,j);break;case 4:n.vertexAttrib4fv(f.location,j);break;default:n.vertexAttrib1fv(f.location,j)}}}}x()}(r,c,f,g),null!==b&&n.bindBuffer(34963,t.get(b).buffer))},reset:g,resetDefaultState:b,dispose:function(){for(var n in g(),v){var e=v[n];for(var t in e){var o=e[t];for(var r in o)f(o[r].object),delete o[r];delete e[t]}delete v[n]}},releaseStatesOfGeometry:function(n){if(void 0!==v[n.id]){var e=v[n.id];for(var t in e){var o=e[t];for(var r in o)f(o[r].object),delete o[r];delete e[t]}delete v[n.id]}},releaseStatesOfProgram:function(n){for(var e in v){var t=v[e];if(void 0!==t[n.id]){var o=t[n.id];for(var r in o)f(o[r].object),delete o[r];delete t[n.id]}}},initAttributes:m,enableAttribute:d,disableUnusedAttributes:x}}function ui(n,e,t,o){var r,a=o.isWebGL2;this.setMode=function(n){r=n},this.render=function(e,o){n.drawArrays(r,e,o),t.update(o,r,1)},this.renderInstances=function(o,i,v){if(0!==v){var c,l;if(a)c=n,l="drawArraysInstanced";else if(l="drawArraysInstancedANGLE",null===(c=e.get("ANGLE_instanced_arrays")))return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[l](r,o,i,v),t.update(i,r,v)}}}function fi(n,e,t){var o;function r(e){if("highp"===e){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}var a="undefined"!==typeof WebGL2RenderingContext&&n instanceof WebGL2RenderingContext||"undefined"!==typeof WebGL2ComputeRenderingContext&&n instanceof WebGL2ComputeRenderingContext,i=void 0!==t.precision?t.precision:"highp",v=r(i);v!==i&&(console.warn("THREE.WebGLRenderer:",i,"not supported, using",v,"instead."),i=v);var c=a||e.has("WEBGL_draw_buffers"),l=!0===t.logarithmicDepthBuffer,s=n.getParameter(34930),u=n.getParameter(35660),f=n.getParameter(3379),p=n.getParameter(34076),m=n.getParameter(34921),d=n.getParameter(36347),h=n.getParameter(36348),x=n.getParameter(36349),y=u>0,g=a||e.has("OES_texture_float");return{isWebGL2:a,drawBuffers:c,getMaxAnisotropy:function(){if(void 0!==o)return o;if(!0===e.has("EXT_texture_filter_anisotropic")){var t=e.get("EXT_texture_filter_anisotropic");o=n.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else o=0;return o},getMaxPrecision:r,precision:i,logarithmicDepthBuffer:l,maxTextures:s,maxVertexTextures:u,maxTextureSize:f,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:d,maxVaryings:h,maxFragmentUniforms:x,vertexTextures:y,floatFragmentTextures:g,floatVertexTextures:y&&g,maxSamples:a?n.getParameter(36183):0}}function pi(n){var e=this,t=null,o=0,r=!1,a=!1,i=new $a,v=new io,c={value:null,needsUpdate:!1};function l(){c.value!==t&&(c.value=t,c.needsUpdate=o>0),e.numPlanes=o,e.numIntersection=0}function s(n,t,o,r){var a=null!==n?n.length:0,l=null;if(0!==a){if(l=c.value,!0!==r||null===l){var s=o+4*a,u=t.matrixWorldInverse;v.getNormalMatrix(u),(null===l||l.length<s)&&(l=new Float32Array(s));for(var f=0,p=o;f!==a;++f,p+=4)i.copy(n[f]).applyMatrix4(u,v),i.normal.toArray(l,p),l[p+3]=i.constant}c.value=l,c.needsUpdate=!0}return e.numPlanes=a,e.numIntersection=0,l}this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(n,e,a){var i=0!==n.length||e||0!==o||r;return r=e,t=s(n,a,0),o=n.length,i},this.beginShadows=function(){a=!0,s(null)},this.endShadows=function(){a=!1,l()},this.setState=function(e,i,v){var u=e.clippingPlanes,f=e.clipIntersection,p=e.clipShadows,m=n.get(e);if(!r||null===u||0===u.length||a&&!p)a?s(null):l();else{var d=a?0:o,h=4*d,x=m.clippingState||null;c.value=x,x=s(u,i,h,v);for(var y=0;y!==h;++y)x[y]=t[y];m.clippingState=x,this.numIntersection=f?this.numPlanes:0,this.numPlanes+=d}}}function mi(n){var e=new WeakMap;function t(n,e){return e===En?n.mapping=jn:e===On&&(n.mapping=In),n}function o(n){var t=n.target;t.removeEventListener("dispose",o);var r=e.get(t);void 0!==r&&(e.delete(t),r.dispose())}return{get:function(r){if(r&&r.isTexture&&!1===r.isRenderTargetTexture){var a=r.mapping;if(a===En||a===On){if(e.has(r))return t(e.get(r).texture,r.mapping);var i=r.image;if(i&&i.height>0){var v=new Za(i.height/2);return v.fromEquirectangularTexture(n,r),e.set(r,v),r.addEventListener("dispose",o),t(v.texture,r.mapping)}return null}}return r},dispose:function(){e=new WeakMap}}}ci.physical={uniforms:Na([ci.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new ao(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new wo(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new ao},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new wo(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new wo(1,1,1)},specularColorMap:{value:null}}]),vertexShader:ii.meshphysical_vert,fragmentShader:ii.meshphysical_frag};var di=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.1,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2e3;return y(this,t),(n=e.call(this)).isOrthographicCamera=!0,n.type="OrthographicCamera",n.zoom=1,n.view=null,n.left=o,n.right=r,n.top=a,n.bottom=i,n.near=v,n.far=c,n.updateProjectionMatrix(),n}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.left=n.left,this.right=n.right,this.top=n.top,this.bottom=n.bottom,this.near=n.near,this.far=n.far,this.zoom=n.zoom,this.view=null===n.view?null:Object.assign({},n.view),this}},{key:"setViewOffset",value:function(n,e,t,o,r,a){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=o,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}},{key:"clearViewOffset",value:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}},{key:"updateProjectionMatrix",value:function(){var n=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,o=(this.top+this.bottom)/2,r=t-n,a=t+n,i=o+e,v=o-e;if(null!==this.view&&this.view.enabled){var c=(this.right-this.left)/this.view.fullWidth/this.zoom,l=(this.top-this.bottom)/this.view.fullHeight/this.zoom;a=(r+=c*this.view.offsetX)+c*this.view.width,v=(i-=l*this.view.offsetY)-l*this.view.height}this.projectionMatrix.makeOrthographic(r,a,i,v,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}},{key:"toJSON",value:function(n){var e=D(U(t.prototype),"toJSON",this).call(this,n);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}]),t}(Va),hi=[.125,.215,.35,.446,.526,.582],xi=20,yi=new di,gi=new wo,bi=null,_i=(1+Math.sqrt(5))/2,Ui=1/_i,wi=[new Oo(1,1,1),new Oo(-1,1,1),new Oo(1,1,-1),new Oo(-1,1,-1),new Oo(0,_i,Ui),new Oo(0,_i,-Ui),new Oo(Ui,0,_i),new Oo(-Ui,0,_i),new Oo(_i,Ui,0),new Oo(-_i,Ui,0)],Si=function(){function n(e){y(this,n),this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}return b(n,[{key:"fromScene",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100;bi=this._renderer.getRenderTarget(),this._setSize(256);var r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(n,t,o,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}},{key:"fromEquirectangular",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this._fromTexture(n,e)}},{key:"fromCubemap",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this._fromTexture(n,e)}},{key:"compileCubemapShader",value:function(){null===this._cubemapMaterial&&(this._cubemapMaterial=Ci(),this._compileMaterial(this._cubemapMaterial))}},{key:"compileEquirectangularShader",value:function(){null===this._equirectMaterial&&(this._equirectMaterial=ki(),this._compileMaterial(this._equirectMaterial))}},{key:"dispose",value:function(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}},{key:"_setSize",value:function(n){this._lodMax=Math.floor(Math.log2(n)),this._cubeSize=Math.pow(2,this._lodMax)}},{key:"_dispose",value:function(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(var n=0;n<this._lodPlanes.length;n++)this._lodPlanes[n].dispose()}},{key:"_cleanup",value:function(n){this._renderer.setRenderTarget(bi),n.scissorTest=!1,zi(n,0,0,n.width,n.height)}},{key:"_fromTexture",value:function(n,e){n.mapping===jn||n.mapping===In?this._setSize(0===n.image.length?16:n.image[0].width||n.image[0].image.width):this._setSize(n.image.width/4),bi=this._renderer.getRenderTarget();var t=e||this._allocateTargets();return this._textureToCubeUV(n,t),this._applyPMREM(t),this._cleanup(t),t}},{key:"_allocateTargets",value:function(){var n=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,t={magFilter:Xn,minFilter:Xn,generateMipmaps:!1,type:ae,format:ue,encoding:vt,depthBuffer:!1},o=Mi(n,e,t);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==n){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Mi(n,e,t);var r=this._lodMax,a=function(n){for(var e=[],t=[],o=[],r=n,a=n-4+1+hi.length,i=0;i<a;i++){var v=Math.pow(2,r);t.push(v);var c=1/v;i>n-4?c=hi[i-n+4-1]:0===i&&(c=0),o.push(c);for(var l=1/(v-2),s=-l,u=1+l,f=[s,s,u,s,u,u,s,s,u,u,s,u],p=6,m=6,d=3,h=2,x=1,y=new Float32Array(d*m*p),g=new Float32Array(h*m*p),b=new Float32Array(x*m*p),_=0;_<p;_++){var U=_%3*2/3-1,w=_>2?0:-1,S=[U,w,0,U+2/3,w,0,U+2/3,w+1,0,U,w,0,U+2/3,w+1,0,U,w+1,0];y.set(S,d*m*_),g.set(f,h*m*_);var M=[_,_,_,_,_,_];b.set(M,x*m*_)}var z=new ga;z.setAttribute("position",new ea(y,d)),z.setAttribute("uv",new ea(g,h)),z.setAttribute("faceIndex",new ea(b,x)),e.push(z),r>4&&r--}return{lodPlanes:e,sizeLods:t,sigmas:o}}(r);this._sizeLods=a.sizeLods,this._lodPlanes=a.lodPlanes,this._sigmas=a.sigmas,this._blurMaterial=function(n,e,t){var o=new Float32Array(xi),r=new Oo(0,1,0);return new qa({name:"SphericalGaussianBlur",defines:{n:xi,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:"".concat(n,".0")},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:o},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:X,depthTest:!1,depthWrite:!1})}(r,n,e)}return o}},{key:"_compileMaterial",value:function(n){var e=new Oa(this._lodPlanes[0],n);this._renderer.compile(e,yi)}},{key:"_sceneToCubeUV",value:function(n,e,t,o){var r=new Wa(90,1,e,t),a=[1,-1,1,1,1,1],i=[1,1,1,-1,-1,-1],v=this._renderer,c=v.autoClear,l=v.toneMapping;v.getClearColor(gi),v.toneMapping=kn,v.autoClear=!1;var s=new Kr({name:"PMREM.Background",side:W,depthWrite:!1,depthTest:!1}),u=new Oa(new Aa,s),f=!1,p=n.background;p?p.isColor&&(s.color.copy(p),n.background=null,f=!0):(s.color.copy(gi),f=!0);for(var m=0;m<6;m++){var d=m%3;0===d?(r.up.set(0,a[m],0),r.lookAt(i[m],0,0)):1===d?(r.up.set(0,0,a[m]),r.lookAt(0,i[m],0)):(r.up.set(0,a[m],0),r.lookAt(0,0,i[m]));var h=this._cubeSize;zi(o,d*h,m>2?h:0,h,h),v.setRenderTarget(o),f&&v.render(u,r),v.render(n,r)}u.geometry.dispose(),u.material.dispose(),v.toneMapping=l,v.autoClear=c,n.background=p}},{key:"_textureToCubeUV",value:function(n,e){var t=this._renderer,o=n.mapping===jn||n.mapping===In;o?(null===this._cubemapMaterial&&(this._cubemapMaterial=Ci()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===n.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=ki());var r=o?this._cubemapMaterial:this._equirectMaterial,a=new Oa(this._lodPlanes[0],r);r.uniforms.envMap.value=n;var i=this._cubeSize;zi(e,0,0,3*i,2*i),t.setRenderTarget(e),t.render(a,yi)}},{key:"_applyPMREM",value:function(n){var e=this._renderer,t=e.autoClear;e.autoClear=!1;for(var o=1;o<this._lodPlanes.length;o++){var r=Math.sqrt(this._sigmas[o]*this._sigmas[o]-this._sigmas[o-1]*this._sigmas[o-1]),a=wi[(o-1)%wi.length];this._blur(n,o-1,o,r,a)}e.autoClear=t}},{key:"_blur",value:function(n,e,t,o,r){var a=this._pingPongRenderTarget;this._halfBlur(n,a,e,t,o,"latitudinal",r),this._halfBlur(a,n,t,t,o,"longitudinal",r)}},{key:"_halfBlur",value:function(n,e,t,o,r,a,i){var v=this._renderer,c=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");var l=new Oa(this._lodPlanes[o],c),s=c.uniforms,u=this._sizeLods[t]-1,f=isFinite(r)?Math.PI/(2*u):2*Math.PI/39,p=r/f,m=isFinite(r)?1+Math.floor(3*p):xi;m>xi&&console.warn("sigmaRadians, ".concat(r,", is too large and will clip, as it requested ").concat(m," samples when the maximum is set to ").concat(xi));for(var d=[],h=0,x=0;x<xi;++x){var y=x/p,g=Math.exp(-y*y/2);d.push(g),0===x?h+=g:x<m&&(h+=2*g)}for(var b=0;b<d.length;b++)d[b]=d[b]/h;s.envMap.value=n.texture,s.samples.value=m,s.weights.value=d,s.latitudinal.value="latitudinal"===a,i&&(s.poleAxis.value=i);var _=this._lodMax;s.dTheta.value=f,s.mipInt.value=_-t;var U=this._sizeLods[o];zi(e,3*U*(o>_-4?o-_+4:0),4*(this._cubeSize-U),3*U,2*U),v.setRenderTarget(e),v.render(l,yi)}}]),n}();function Mi(n,e,t){var o=new Ro(n,e,t);return o.texture.mapping=Ln,o.texture.name="PMREM.cubeUv",o.scissorTest=!0,o}function zi(n,e,t,o,r){n.viewport.set(e,t,o,r),n.scissor.set(e,t,o,r)}function ki(){return new qa({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:X,depthTest:!1,depthWrite:!1})}function Ci(){return new qa({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:X,depthTest:!1,depthWrite:!1})}function Ti(n){var e=new WeakMap,t=null;function o(n){var t=n.target;t.removeEventListener("dispose",o);var r=e.get(t);void 0!==r&&(e.delete(t),r.dispose())}return{get:function(r){if(r&&r.isTexture){var a=r.mapping,i=a===En||a===On,v=a===jn||a===In;if(i||v){if(r.isRenderTargetTexture&&!0===r.needsPMREMUpdate){r.needsPMREMUpdate=!1;var c=e.get(r);return null===t&&(t=new Si(n)),c=i?t.fromEquirectangular(r,c):t.fromCubemap(r,c),e.set(r,c),c.texture}if(e.has(r))return e.get(r).texture;var l=r.image;if(i&&l&&l.height>0||v&&l&&function(n){for(var e=0,t=6,o=0;o<t;o++)void 0!==n[o]&&e++;return e===t}(l)){null===t&&(t=new Si(n));var s=i?t.fromEquirectangular(r):t.fromCubemap(r);return e.set(r,s),r.addEventListener("dispose",o),s.texture}return null}}return r},dispose:function(){e=new WeakMap,null!==t&&(t.dispose(),t=null)}}}function Ri(n){var e={};function t(t){if(void 0!==e[t])return e[t];var o;switch(t){case"WEBGL_depth_texture":o=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":o=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":o=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":o=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:o=n.getExtension(t)}return e[t]=o,o}return{has:function(n){return null!==t(n)},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){var e=t(n);return null===e&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),e}}}function Di(n,e,t,o){var r={},a=new WeakMap;function i(n){var v=n.target;for(var c in null!==v.index&&e.remove(v.index),v.attributes)e.remove(v.attributes[c]);v.removeEventListener("dispose",i),delete r[v.id];var l=a.get(v);l&&(e.remove(l),a.delete(v)),o.releaseStatesOfGeometry(v),!0===v.isInstancedBufferGeometry&&delete v._maxInstanceCount,t.memory.geometries--}function v(n){var t=[],o=n.index,r=n.attributes.position,i=0;if(null!==o){var v=o.array;i=o.version;for(var c=0,l=v.length;c<l;c+=3){var s=v[c+0],u=v[c+1],f=v[c+2];t.push(s,u,u,f,f,s)}}else{var p=r.array;i=r.version;for(var m=0,d=p.length/3-1;m<d;m+=3){var h=m+0,x=m+1,y=m+2;t.push(h,x,x,y,y,h)}}var g=new(vo(t)?ca:ia)(t,1);g.version=i;var b=a.get(n);b&&e.remove(b),a.set(n,g)}return{get:function(n,e){return!0===r[e.id]||(e.addEventListener("dispose",i),r[e.id]=!0,t.memory.geometries++),e},update:function(n){var t=n.attributes;for(var o in t)e.update(t[o],34962);var r=n.morphAttributes;for(var a in r)for(var i=r[a],v=0,c=i.length;v<c;v++)e.update(i[v],34962)},getWireframeAttribute:function(n){var e=a.get(n);if(e){var t=n.index;null!==t&&e.version<t.version&&v(n)}else v(n);return a.get(n)}}}function Pi(n,e,t,o){var r,a,i,v=o.isWebGL2;this.setMode=function(n){r=n},this.setIndex=function(n){a=n.type,i=n.bytesPerElement},this.render=function(e,o){n.drawElements(r,o,a,e*i),t.update(o,r,1)},this.renderInstances=function(o,c,l){if(0!==l){var s,u;if(v)s=n,u="drawElementsInstanced";else if(u="drawElementsInstancedANGLE",null===(s=e.get("ANGLE_instanced_arrays")))return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");s[u](r,c,a,o*i,l),t.update(c,r,l)}}}function Fi(n){var e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(n,t,o){switch(e.calls++,t){case 4:e.triangles+=o*(n/3);break;case 1:e.lines+=o*(n/2);break;case 3:e.lines+=o*(n-1);break;case 2:e.lines+=o*n;break;case 0:e.points+=o*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",t)}}}}function ji(n,e){return n[0]-e[0]}function Ii(n,e){return Math.abs(e[1])-Math.abs(n[1])}function Ei(n,e,t){for(var o={},r=new Float32Array(8),a=new WeakMap,i=new To,v=[],c=0;c<8;c++)v[c]=[c,0];return{update:function(c,l,s,u){var f=c.morphTargetInfluences;if(!0===e.isWebGL2){var p=l.morphAttributes.position||l.morphAttributes.normal||l.morphAttributes.color,m=void 0!==p?p.length:0,d=a.get(l);if(void 0===d||d.count!==m){void 0!==d&&d.texture.dispose();var h=void 0!==l.morphAttributes.position,x=void 0!==l.morphAttributes.normal,y=void 0!==l.morphAttributes.color,g=l.morphAttributes.position||[],b=l.morphAttributes.normal||[],_=l.morphAttributes.color||[],U=0;!0===h&&(U=1),!0===x&&(U=2),!0===y&&(U=3);var w=l.attributes.position.count*U,S=1;w>e.maxTextureSize&&(S=Math.ceil(w/e.maxTextureSize),w=e.maxTextureSize);var M=new Float32Array(w*S*4*m),z=new Do(M,w,S,m);z.type=re,z.needsUpdate=!0;for(var k=4*U,C=0;C<m;C++)for(var T=g[C],R=b[C],D=_[C],P=w*S*4*C,F=0;F<T.count;F++){var j=F*k;!0===h&&(i.fromBufferAttribute(T,F),M[P+j+0]=i.x,M[P+j+1]=i.y,M[P+j+2]=i.z,M[P+j+3]=0),!0===x&&(i.fromBufferAttribute(R,F),M[P+j+4]=i.x,M[P+j+5]=i.y,M[P+j+6]=i.z,M[P+j+7]=0),!0===y&&(i.fromBufferAttribute(D,F),M[P+j+8]=i.x,M[P+j+9]=i.y,M[P+j+10]=i.z,M[P+j+11]=4===D.itemSize?i.w:1)}d={count:m,texture:z,size:new ao(w,S)},a.set(l,d),l.addEventListener("dispose",(function n(){z.dispose(),a.delete(l),l.removeEventListener("dispose",n)}))}for(var I=0,E=0;E<f.length;E++)I+=f[E];var O=l.morphTargetsRelative?1:1-I;u.getUniforms().setValue(n,"morphTargetBaseInfluence",O),u.getUniforms().setValue(n,"morphTargetInfluences",f),u.getUniforms().setValue(n,"morphTargetsTexture",d.texture,t),u.getUniforms().setValue(n,"morphTargetsTextureSize",d.size)}else{var L=void 0===f?0:f.length,A=o[l.id];if(void 0===A||A.length!==L){A=[];for(var G=0;G<L;G++)A[G]=[G,0];o[l.id]=A}for(var N=0;N<L;N++){var B=A[N];B[0]=N,B[1]=f[N]}A.sort(Ii);for(var q=0;q<8;q++)q<L&&A[q][1]?(v[q][0]=A[q][0],v[q][1]=A[q][1]):(v[q][0]=Number.MAX_SAFE_INTEGER,v[q][1]=0);v.sort(ji);for(var V=l.morphAttributes.position,W=l.morphAttributes.normal,H=0,X=0;X<8;X++){var Y=v[X],Z=Y[0],Q=Y[1];Z!==Number.MAX_SAFE_INTEGER&&Q?(V&&l.getAttribute("morphTarget"+X)!==V[Z]&&l.setAttribute("morphTarget"+X,V[Z]),W&&l.getAttribute("morphNormal"+X)!==W[Z]&&l.setAttribute("morphNormal"+X,W[Z]),r[X]=Q,H+=Q):(V&&!0===l.hasAttribute("morphTarget"+X)&&l.deleteAttribute("morphTarget"+X),W&&!0===l.hasAttribute("morphNormal"+X)&&l.deleteAttribute("morphNormal"+X),r[X]=0)}var J=l.morphTargetsRelative?1:1-H;u.getUniforms().setValue(n,"morphTargetBaseInfluence",J),u.getUniforms().setValue(n,"morphTargetInfluences",r)}}}}function Oi(n,e,t,o){var r=new WeakMap;function a(n){var e=n.target;e.removeEventListener("dispose",a),t.remove(e.instanceMatrix),null!==e.instanceColor&&t.remove(e.instanceColor)}return{update:function(n){var i=o.render.frame,v=n.geometry,c=e.get(n,v);return r.get(c)!==i&&(e.update(c),r.set(c,i)),n.isInstancedMesh&&(!1===n.hasEventListener("dispose",a)&&n.addEventListener("dispose",a),t.update(n.instanceMatrix,34962),null!==n.instanceColor&&t.update(n.instanceColor,34962)),c},dispose:function(){r=new WeakMap}}}var Li=new Co,Ai=new Do,Gi=new Fo,Ni=new Ya,Bi=[],qi=[],Vi=new Float32Array(16),Wi=new Float32Array(9),Hi=new Float32Array(4);function Xi(n,e,t){var o=n[0];if(o<=0||o>0)return n;var r=e*t,a=Bi[r];if(void 0===a&&(a=new Float32Array(r),Bi[r]=a),0!==e){o.toArray(a,0);for(var i=1,v=0;i!==e;++i)v+=t,n[i].toArray(a,v)}return a}function Yi(n,e){if(n.length!==e.length)return!1;for(var t=0,o=n.length;t<o;t++)if(n[t]!==e[t])return!1;return!0}function Zi(n,e){for(var t=0,o=e.length;t<o;t++)n[t]=e[t]}function Qi(n,e){var t=qi[e];void 0===t&&(t=new Int32Array(e),qi[e]=t);for(var o=0;o!==e;++o)t[o]=n.allocateTextureUnit();return t}function Ji(n,e){var t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function Ki(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y||(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yi(t,e))return;n.uniform2fv(this.addr,e),Zi(t,e)}}function $i(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(void 0!==e.r)t[0]===e.r&&t[1]===e.g&&t[2]===e.b||(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Yi(t,e))return;n.uniform3fv(this.addr,e),Zi(t,e)}}function nv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yi(t,e))return;n.uniform4fv(this.addr,e),Zi(t,e)}}function ev(n,e){var t=this.cache,o=e.elements;if(void 0===o){if(Yi(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Zi(t,e)}else{if(Yi(t,o))return;Hi.set(o),n.uniformMatrix2fv(this.addr,!1,Hi),Zi(t,o)}}function tv(n,e){var t=this.cache,o=e.elements;if(void 0===o){if(Yi(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Zi(t,e)}else{if(Yi(t,o))return;Wi.set(o),n.uniformMatrix3fv(this.addr,!1,Wi),Zi(t,o)}}function ov(n,e){var t=this.cache,o=e.elements;if(void 0===o){if(Yi(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Zi(t,e)}else{if(Yi(t,o))return;Vi.set(o),n.uniformMatrix4fv(this.addr,!1,Vi),Zi(t,o)}}function rv(n,e){var t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function av(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y||(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yi(t,e))return;n.uniform2iv(this.addr,e),Zi(t,e)}}function iv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Yi(t,e))return;n.uniform3iv(this.addr,e),Zi(t,e)}}function vv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yi(t,e))return;n.uniform4iv(this.addr,e),Zi(t,e)}}function cv(n,e){var t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function lv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y||(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yi(t,e))return;n.uniform2uiv(this.addr,e),Zi(t,e)}}function sv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Yi(t,e))return;n.uniform3uiv(this.addr,e),Zi(t,e)}}function uv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yi(t,e))return;n.uniform4uiv(this.addr,e),Zi(t,e)}}function fv(n,e,t){var o=this.cache,r=t.allocateTextureUnit();o[0]!==r&&(n.uniform1i(this.addr,r),o[0]=r),t.setTexture2D(e||Li,r)}function pv(n,e,t){var o=this.cache,r=t.allocateTextureUnit();o[0]!==r&&(n.uniform1i(this.addr,r),o[0]=r),t.setTexture3D(e||Gi,r)}function mv(n,e,t){var o=this.cache,r=t.allocateTextureUnit();o[0]!==r&&(n.uniform1i(this.addr,r),o[0]=r),t.setTextureCube(e||Ni,r)}function dv(n,e,t){var o=this.cache,r=t.allocateTextureUnit();o[0]!==r&&(n.uniform1i(this.addr,r),o[0]=r),t.setTexture2DArray(e||Ai,r)}function hv(n,e){n.uniform1fv(this.addr,e)}function xv(n,e){var t=Xi(e,this.size,2);n.uniform2fv(this.addr,t)}function yv(n,e){var t=Xi(e,this.size,3);n.uniform3fv(this.addr,t)}function gv(n,e){var t=Xi(e,this.size,4);n.uniform4fv(this.addr,t)}function bv(n,e){var t=Xi(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function _v(n,e){var t=Xi(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function Uv(n,e){var t=Xi(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function wv(n,e){n.uniform1iv(this.addr,e)}function Sv(n,e){n.uniform2iv(this.addr,e)}function Mv(n,e){n.uniform3iv(this.addr,e)}function zv(n,e){n.uniform4iv(this.addr,e)}function kv(n,e){n.uniform1uiv(this.addr,e)}function Cv(n,e){n.uniform2uiv(this.addr,e)}function Tv(n,e){n.uniform3uiv(this.addr,e)}function Rv(n,e){n.uniform4uiv(this.addr,e)}function Dv(n,e,t){var o=this.cache,r=e.length,a=Qi(t,r);Yi(o,a)||(n.uniform1iv(this.addr,a),Zi(o,a));for(var i=0;i!==r;++i)t.setTexture2D(e[i]||Li,a[i])}function Pv(n,e,t){var o=this.cache,r=e.length,a=Qi(t,r);Yi(o,a)||(n.uniform1iv(this.addr,a),Zi(o,a));for(var i=0;i!==r;++i)t.setTexture3D(e[i]||Gi,a[i])}function Fv(n,e,t){var o=this.cache,r=e.length,a=Qi(t,r);Yi(o,a)||(n.uniform1iv(this.addr,a),Zi(o,a));for(var i=0;i!==r;++i)t.setTextureCube(e[i]||Ni,a[i])}function jv(n,e,t){var o=this.cache,r=e.length,a=Qi(t,r);Yi(o,a)||(n.uniform1iv(this.addr,a),Zi(o,a));for(var i=0;i!==r;++i)t.setTexture2DArray(e[i]||Ai,a[i])}var Iv=b((function n(e,t,o){y(this,n),this.id=e,this.addr=o,this.cache=[],this.setValue=function(n){switch(n){case 5126:return Ji;case 35664:return Ki;case 35665:return $i;case 35666:return nv;case 35674:return ev;case 35675:return tv;case 35676:return ov;case 5124:case 35670:return rv;case 35667:case 35671:return av;case 35668:case 35672:return iv;case 35669:case 35673:return vv;case 5125:return cv;case 36294:return lv;case 36295:return sv;case 36296:return uv;case 35678:case 36198:case 36298:case 36306:case 35682:return fv;case 35679:case 36299:case 36307:return pv;case 35680:case 36300:case 36308:case 36293:return mv;case 36289:case 36303:case 36311:case 36292:return dv}}(t.type)})),Ev=b((function n(e,t,o){y(this,n),this.id=e,this.addr=o,this.cache=[],this.size=t.size,this.setValue=function(n){switch(n){case 5126:return hv;case 35664:return xv;case 35665:return yv;case 35666:return gv;case 35674:return bv;case 35675:return _v;case 35676:return Uv;case 5124:case 35670:return wv;case 35667:case 35671:return Sv;case 35668:case 35672:return Mv;case 35669:case 35673:return zv;case 5125:return kv;case 36294:return Cv;case 36295:return Tv;case 36296:return Rv;case 35678:case 36198:case 36298:case 36306:case 35682:return Dv;case 35679:case 36299:case 36307:return Pv;case 35680:case 36300:case 36308:case 36293:return Fv;case 36289:case 36303:case 36311:case 36292:return jv}}(t.type)})),Ov=function(){function n(e){y(this,n),this.id=e,this.seq=[],this.map={}}return b(n,[{key:"setValue",value:function(n,e,t){for(var o=this.seq,r=0,a=o.length;r!==a;++r){var i=o[r];i.setValue(n,e[i.id],t)}}}]),n}(),Lv=/(\w+)(\])?(\[|\.)?/g;function Av(n,e){n.seq.push(e),n.map[e.id]=e}function Gv(n,e,t){var o=n.name,r=o.length;for(Lv.lastIndex=0;;){var a=Lv.exec(o),i=Lv.lastIndex,v=a[1],c="]"===a[2],l=a[3];if(c&&(v|=0),void 0===l||"["===l&&i+2===r){Av(t,void 0===l?new Iv(v,n,e):new Ev(v,n,e));break}var s=t.map[v];void 0===s&&Av(t,s=new Ov(v)),t=s}}var Nv=function(){function n(e,t){y(this,n),this.seq=[],this.map={};for(var o=e.getProgramParameter(t,35718),r=0;r<o;++r){var a=e.getActiveUniform(t,r);Gv(a,e.getUniformLocation(t,a.name),this)}}return b(n,[{key:"setValue",value:function(n,e,t,o){var r=this.map[e];void 0!==r&&r.setValue(n,t,o)}},{key:"setOptional",value:function(n,e,t){var o=e[t];void 0!==o&&this.setValue(n,t,o)}}],[{key:"upload",value:function(n,e,t,o){for(var r=0,a=e.length;r!==a;++r){var i=e[r],v=t[i.id];!1!==v.needsUpdate&&i.setValue(n,v.value,o)}}},{key:"seqWithValue",value:function(n,e){for(var t=[],o=0,r=n.length;o!==r;++o){var a=n[o];a.id in e&&t.push(a)}return t}}]),n}();function Bv(n,e,t){var o=n.createShader(e);return n.shaderSource(o,t),n.compileShader(o),o}var qv=0;function Vv(n,e,t){var o=n.getShaderParameter(e,35713),r=n.getShaderInfoLog(e).trim();if(o&&""===r)return"";var a=/ERROR: 0:(\d+)/.exec(r);if(a){var i=parseInt(a[1]);return t.toUpperCase()+"\n\n"+r+"\n\n"+function(n,e){for(var t=n.split("\n"),o=[],r=Math.max(e-6,0),a=Math.min(e+6,t.length),i=r;i<a;i++){var v=i+1;o.push("".concat(v===e?">":" "," ").concat(v,": ").concat(t[i]))}return o.join("\n")}(n.getShaderSource(e),i)}return r}function Wv(n,e){var t=function(n){switch(n){case vt:return["Linear","( value )"];case ct:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function Hv(n,e){var t;switch(e){case Cn:t="Linear";break;case Tn:t="Reinhard";break;case Rn:t="OptimizedCineon";break;case Dn:t="ACESFilmic";break;case Pn:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Xv(n){return""!==n}function Yv(n,e){var t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Zv(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}var Qv=/^[ \t]*#include +<([\w\d./]+)>/gm;function Jv(n){return n.replace(Qv,Kv)}function Kv(n,e){var t=ii[e];if(void 0===t)throw new Error("Can not resolve #include <"+e+">");return Jv(t)}var $v=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function nc(n){return n.replace($v,ec)}function ec(n,e,t,o){for(var r="",a=parseInt(e);a<parseInt(t);a++)r+=o.replace(/\[\s*i\s*\]/g,"[ "+a+" ]").replace(/UNROLLED_LOOP_INDEX/g,a);return r}function tc(n){var e="precision "+n.precision+" float;\nprecision "+n.precision+" int;";return"highp"===n.precision?e+="\n#define HIGH_PRECISION":"mediump"===n.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===n.precision&&(e+="\n#define LOW_PRECISION"),e}function oc(n,e,t,o){var r,a,i=n.getContext(),v=t.defines,c=t.vertexShader,l=t.fragmentShader,s=function(n){var e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===N?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===B?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===q&&(e="SHADOWMAP_TYPE_VSM"),e}(t),u=function(n){var e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case jn:case In:e="ENVMAP_TYPE_CUBE";break;case Ln:e="ENVMAP_TYPE_CUBE_UV"}return e}(t),f=function(n){var e="ENVMAP_MODE_REFLECTION";n.envMap&&n.envMapMode===In&&(e="ENVMAP_MODE_REFRACTION");return e}(t),p=function(n){var e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Sn:e="ENVMAP_BLENDING_MULTIPLY";break;case Mn:e="ENVMAP_BLENDING_MIX";break;case zn:e="ENVMAP_BLENDING_ADD"}return e}(t),m=function(n){var e=n.envMapCubeUVHeight;if(null===e)return null;var t=Math.log2(e)-2,o=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:o,maxMip:t}}(t),d=t.isWebGL2?"":function(n){return[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||"physical"===n.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Xv).join("\n")}(t),h=function(n){var e=[];for(var t in n){var o=n[t];!1!==o&&e.push("#define "+t+" "+o)}return e.join("\n")}(v),x=i.createProgram(),y=t.glslVersion?"#version "+t.glslVersion+"\n":"";t.isRawShaderMaterial?((r=[h].filter(Xv).join("\n")).length>0&&(r+="\n"),(a=[d,h].filter(Xv).join("\n")).length>0&&(a+="\n")):(r=[tc(t),"#define SHADER_NAME "+t.shaderName,h,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+f:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&!1===t.flatShading?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+s:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Xv).join("\n"),a=[d,tc(t),"#define SHADER_NAME "+t.shaderName,h,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.envMap?"#define "+f:"",t.envMap?"#define "+p:"",m?"#define CUBEUV_TEXEL_WIDTH "+m.texelWidth:"",m?"#define CUBEUV_TEXEL_HEIGHT "+m.texelHeight:"",m?"#define CUBEUV_MAX_MIP "+m.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+s:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==kn?"#define TONE_MAPPING":"",t.toneMapping!==kn?ii.tonemapping_pars_fragment:"",t.toneMapping!==kn?Hv("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",ii.encodings_pars_fragment,Wv("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"","\n"].filter(Xv).join("\n")),c=Zv(c=Yv(c=Jv(c),t),t),l=Zv(l=Yv(l=Jv(l),t),t),c=nc(c),l=nc(l),t.isWebGL2&&!0!==t.isRawShaderMaterial&&(y="#version 300 es\n",r=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+r,a=["#define varying in",t.glslVersion===Bt?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===Bt?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+a);var g,b,_=y+a+l,U=Bv(i,35633,y+r+c),w=Bv(i,35632,_);if(i.attachShader(x,U),i.attachShader(x,w),void 0!==t.index0AttributeName?i.bindAttribLocation(x,0,t.index0AttributeName):!0===t.morphTargets&&i.bindAttribLocation(x,0,"position"),i.linkProgram(x),n.debug.checkShaderErrors){var S=i.getProgramInfoLog(x).trim(),M=i.getShaderInfoLog(U).trim(),z=i.getShaderInfoLog(w).trim(),k=!0,C=!0;if(!1===i.getProgramParameter(x,35714)){k=!1;var T=Vv(i,U,"vertex"),R=Vv(i,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(x,35715)+"\n\nProgram Info Log: "+S+"\n"+T+"\n"+R)}else""!==S?console.warn("THREE.WebGLProgram: Program Info Log:",S):""!==M&&""!==z||(C=!1);C&&(this.diagnostics={runnable:k,programLog:S,vertexShader:{log:M,prefix:r},fragmentShader:{log:z,prefix:a}})}return i.deleteShader(U),i.deleteShader(w),this.getUniforms=function(){return void 0===g&&(g=new Nv(i,x)),g},this.getAttributes=function(){return void 0===b&&(b=function(n,e){for(var t={},o=n.getProgramParameter(e,35721),r=0;r<o;r++){var a=n.getActiveAttrib(e,r),i=a.name,v=1;35674===a.type&&(v=2),35675===a.type&&(v=3),35676===a.type&&(v=4),t[i]={type:a.type,location:n.getAttribLocation(e,i),locationSize:v}}return t}(i,x)),b},this.destroy=function(){o.releaseStatesOfProgram(this),i.deleteProgram(x),this.program=void 0},this.name=t.shaderName,this.id=qv++,this.cacheKey=e,this.usedTimes=1,this.program=x,this.vertexShader=U,this.fragmentShader=w,this}var rc=0,ac=function(){function n(){y(this,n),this.shaderCache=new Map,this.materialCache=new Map}return b(n,[{key:"update",value:function(n){var e=n.vertexShader,t=n.fragmentShader,o=this._getShaderStage(e),r=this._getShaderStage(t),a=this._getShaderCacheForMaterial(n);return!1===a.has(o)&&(a.add(o),o.usedTimes++),!1===a.has(r)&&(a.add(r),r.usedTimes++),this}},{key:"remove",value:function(n){var e,t=f(this.materialCache.get(n));try{for(t.s();!(e=t.n()).done;){var o=e.value;o.usedTimes--,0===o.usedTimes&&this.shaderCache.delete(o.code)}}catch(r){t.e(r)}finally{t.f()}return this.materialCache.delete(n),this}},{key:"getVertexShaderID",value:function(n){return this._getShaderStage(n.vertexShader).id}},{key:"getFragmentShaderID",value:function(n){return this._getShaderStage(n.fragmentShader).id}},{key:"dispose",value:function(){this.shaderCache.clear(),this.materialCache.clear()}},{key:"_getShaderCacheForMaterial",value:function(n){var e=this.materialCache,t=e.get(n);return void 0===t&&(t=new Set,e.set(n,t)),t}},{key:"_getShaderStage",value:function(n){var e=this.shaderCache,t=e.get(n);return void 0===t&&(t=new ic(n),e.set(n,t)),t}}]),n}(),ic=b((function n(e){y(this,n),this.id=rc++,this.code=e,this.usedTimes=0}));function vc(n,e,t,o,r,a,i){var v=new Sr,c=new ac,l=[],s=r.isWebGL2,u=r.logarithmicDepthBuffer,f=r.vertexTextures,p=r.precision,m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(a,v,l,d,h){var x=d.fog,y=h.geometry,g=a.isMeshStandardMaterial?d.environment:null,b=(a.isMeshStandardMaterial?t:e).get(a.envMap||g),_=b&&b.mapping===Ln?b.image.height:null,U=m[a.type];null!==a.precision&&(p=r.getMaxPrecision(a.precision))!==a.precision&&console.warn("THREE.WebGLProgram.getParameters:",a.precision,"not supported, using",p,"instead.");var w,S,M,z,k=y.morphAttributes.position||y.morphAttributes.normal||y.morphAttributes.color,C=void 0!==k?k.length:0,T=0;if(void 0!==y.morphAttributes.position&&(T=1),void 0!==y.morphAttributes.normal&&(T=2),void 0!==y.morphAttributes.color&&(T=3),U){var R=ci[U];w=R.vertexShader,S=R.fragmentShader}else w=a.vertexShader,S=a.fragmentShader,c.update(a),M=c.getVertexShaderID(a),z=c.getFragmentShaderID(a);var D=n.getRenderTarget(),P=a.alphaTest>0,F=a.clearcoat>0,j=a.iridescence>0;return{isWebGL2:s,shaderID:U,shaderName:a.type,vertexShader:w,fragmentShader:S,defines:a.defines,customVertexShaderID:M,customFragmentShaderID:z,isRawShaderMaterial:!0===a.isRawShaderMaterial,glslVersion:a.glslVersion,precision:p,instancing:!0===h.isInstancedMesh,instancingColor:!0===h.isInstancedMesh&&null!==h.instanceColor,supportsVertexTextures:f,outputEncoding:null===D?n.outputEncoding:!0===D.isXRRenderTarget?D.texture.encoding:vt,map:!!a.map,matcap:!!a.matcap,envMap:!!b,envMapMode:b&&b.mapping,envMapCubeUVHeight:_,lightMap:!!a.lightMap,aoMap:!!a.aoMap,emissiveMap:!!a.emissiveMap,bumpMap:!!a.bumpMap,normalMap:!!a.normalMap,objectSpaceNormalMap:a.normalMapType===ft,tangentSpaceNormalMap:a.normalMapType===ut,decodeVideoTexture:!!a.map&&!0===a.map.isVideoTexture&&a.map.encoding===ct,clearcoat:F,clearcoatMap:F&&!!a.clearcoatMap,clearcoatRoughnessMap:F&&!!a.clearcoatRoughnessMap,clearcoatNormalMap:F&&!!a.clearcoatNormalMap,iridescence:j,iridescenceMap:j&&!!a.iridescenceMap,iridescenceThicknessMap:j&&!!a.iridescenceThicknessMap,displacementMap:!!a.displacementMap,roughnessMap:!!a.roughnessMap,metalnessMap:!!a.metalnessMap,specularMap:!!a.specularMap,specularIntensityMap:!!a.specularIntensityMap,specularColorMap:!!a.specularColorMap,opaque:!1===a.transparent&&a.blending===Y,alphaMap:!!a.alphaMap,alphaTest:P,gradientMap:!!a.gradientMap,sheen:a.sheen>0,sheenColorMap:!!a.sheenColorMap,sheenRoughnessMap:!!a.sheenRoughnessMap,transmission:a.transmission>0,transmissionMap:!!a.transmissionMap,thicknessMap:!!a.thicknessMap,combine:a.combine,vertexTangents:!!a.normalMap&&!!y.attributes.tangent,vertexColors:a.vertexColors,vertexAlphas:!0===a.vertexColors&&!!y.attributes.color&&4===y.attributes.color.itemSize,vertexUvs:!!a.map||!!a.bumpMap||!!a.normalMap||!!a.specularMap||!!a.alphaMap||!!a.emissiveMap||!!a.roughnessMap||!!a.metalnessMap||!!a.clearcoatMap||!!a.clearcoatRoughnessMap||!!a.clearcoatNormalMap||!!a.iridescenceMap||!!a.iridescenceThicknessMap||!!a.displacementMap||!!a.transmissionMap||!!a.thicknessMap||!!a.specularIntensityMap||!!a.specularColorMap||!!a.sheenColorMap||!!a.sheenRoughnessMap,uvsVertexOnly:!(a.map||a.bumpMap||a.normalMap||a.specularMap||a.alphaMap||a.emissiveMap||a.roughnessMap||a.metalnessMap||a.clearcoatNormalMap||a.iridescenceMap||a.iridescenceThicknessMap||a.transmission>0||a.transmissionMap||a.thicknessMap||a.specularIntensityMap||a.specularColorMap||a.sheen>0||a.sheenColorMap||a.sheenRoughnessMap)&&!!a.displacementMap,fog:!!x,useFog:!0===a.fog,fogExp2:x&&x.isFogExp2,flatShading:!!a.flatShading,sizeAttenuation:a.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===h.isSkinnedMesh,morphTargets:void 0!==y.morphAttributes.position,morphNormals:void 0!==y.morphAttributes.normal,morphColors:void 0!==y.morphAttributes.color,morphTargetsCount:C,morphTextureStride:T,numDirLights:v.directional.length,numPointLights:v.point.length,numSpotLights:v.spot.length,numSpotLightMaps:v.spotLightMap.length,numRectAreaLights:v.rectArea.length,numHemiLights:v.hemi.length,numDirLightShadows:v.directionalShadowMap.length,numPointLightShadows:v.pointShadowMap.length,numSpotLightShadows:v.spotShadowMap.length,numSpotLightShadowsWithMaps:v.numSpotLightShadowsWithMaps,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,dithering:a.dithering,shadowMapEnabled:n.shadowMap.enabled&&l.length>0,shadowMapType:n.shadowMap.type,toneMapping:a.toneMapped?n.toneMapping:kn,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:a.premultipliedAlpha,doubleSided:a.side===H,flipSided:a.side===W,useDepthPacking:!!a.depthPacking,depthPacking:a.depthPacking||0,index0AttributeName:a.index0AttributeName,extensionDerivatives:a.extensions&&a.extensions.derivatives,extensionFragDepth:a.extensions&&a.extensions.fragDepth,extensionDrawBuffers:a.extensions&&a.extensions.drawBuffers,extensionShaderTextureLOD:a.extensions&&a.extensions.shaderTextureLOD,rendererExtensionFragDepth:s||o.has("EXT_frag_depth"),rendererExtensionDrawBuffers:s||o.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:s||o.has("EXT_shader_texture_lod"),customProgramCacheKey:a.customProgramCacheKey()}},getProgramCacheKey:function(e){var t=[];if(e.shaderID?t.push(e.shaderID):(t.push(e.customVertexShaderID),t.push(e.customFragmentShaderID)),void 0!==e.defines)for(var o in e.defines)t.push(o),t.push(e.defines[o]);return!1===e.isRawShaderMaterial&&(!function(n,e){n.push(e.precision),n.push(e.outputEncoding),n.push(e.envMapMode),n.push(e.envMapCubeUVHeight),n.push(e.combine),n.push(e.vertexUvs),n.push(e.fogExp2),n.push(e.sizeAttenuation),n.push(e.morphTargetsCount),n.push(e.morphAttributeCount),n.push(e.numDirLights),n.push(e.numPointLights),n.push(e.numSpotLights),n.push(e.numSpotLightMaps),n.push(e.numHemiLights),n.push(e.numRectAreaLights),n.push(e.numDirLightShadows),n.push(e.numPointLightShadows),n.push(e.numSpotLightShadows),n.push(e.numSpotLightShadowsWithMaps),n.push(e.shadowMapType),n.push(e.toneMapping),n.push(e.numClippingPlanes),n.push(e.numClipIntersection),n.push(e.depthPacking)}(t,e),function(n,e){v.disableAll(),e.isWebGL2&&v.enable(0);e.supportsVertexTextures&&v.enable(1);e.instancing&&v.enable(2);e.instancingColor&&v.enable(3);e.map&&v.enable(4);e.matcap&&v.enable(5);e.envMap&&v.enable(6);e.lightMap&&v.enable(7);e.aoMap&&v.enable(8);e.emissiveMap&&v.enable(9);e.bumpMap&&v.enable(10);e.normalMap&&v.enable(11);e.objectSpaceNormalMap&&v.enable(12);e.tangentSpaceNormalMap&&v.enable(13);e.clearcoat&&v.enable(14);e.clearcoatMap&&v.enable(15);e.clearcoatRoughnessMap&&v.enable(16);e.clearcoatNormalMap&&v.enable(17);e.iridescence&&v.enable(18);e.iridescenceMap&&v.enable(19);e.iridescenceThicknessMap&&v.enable(20);e.displacementMap&&v.enable(21);e.specularMap&&v.enable(22);e.roughnessMap&&v.enable(23);e.metalnessMap&&v.enable(24);e.gradientMap&&v.enable(25);e.alphaMap&&v.enable(26);e.alphaTest&&v.enable(27);e.vertexColors&&v.enable(28);e.vertexAlphas&&v.enable(29);e.vertexUvs&&v.enable(30);e.vertexTangents&&v.enable(31);e.uvsVertexOnly&&v.enable(32);n.push(v.mask),v.disableAll(),e.fog&&v.enable(0);e.useFog&&v.enable(1);e.flatShading&&v.enable(2);e.logarithmicDepthBuffer&&v.enable(3);e.skinning&&v.enable(4);e.morphTargets&&v.enable(5);e.morphNormals&&v.enable(6);e.morphColors&&v.enable(7);e.premultipliedAlpha&&v.enable(8);e.shadowMapEnabled&&v.enable(9);e.physicallyCorrectLights&&v.enable(10);e.doubleSided&&v.enable(11);e.flipSided&&v.enable(12);e.useDepthPacking&&v.enable(13);e.dithering&&v.enable(14);e.specularIntensityMap&&v.enable(15);e.specularColorMap&&v.enable(16);e.transmission&&v.enable(17);e.transmissionMap&&v.enable(18);e.thicknessMap&&v.enable(19);e.sheen&&v.enable(20);e.sheenColorMap&&v.enable(21);e.sheenRoughnessMap&&v.enable(22);e.decodeVideoTexture&&v.enable(23);e.opaque&&v.enable(24);n.push(v.mask)}(t,e),t.push(n.outputEncoding)),t.push(e.customProgramCacheKey),t.join()},getUniforms:function(n){var e,t=m[n.type];if(t){var o=ci[t];e=Ba.clone(o.uniforms)}else e=n.uniforms;return e},acquireProgram:function(e,t){for(var o,r=0,i=l.length;r<i;r++){var v=l[r];if(v.cacheKey===t){++(o=v).usedTimes;break}}return void 0===o&&(o=new oc(n,t,e,a),l.push(o)),o},releaseProgram:function(n){if(0===--n.usedTimes){var e=l.indexOf(n);l[e]=l[l.length-1],l.pop(),n.destroy()}},releaseShaderCache:function(n){c.remove(n)},programs:l,dispose:function(){c.dispose()}}}function cc(){var n=new WeakMap;return{get:function(e){var t=n.get(e);return void 0===t&&(t={},n.set(e,t)),t},remove:function(e){n.delete(e)},update:function(e,t,o){n.get(e)[t]=o},dispose:function(){n=new WeakMap}}}function lc(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function sc(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function uc(){var n=[],e=0,t=[],o=[],r=[];function a(t,o,r,a,i,v){var c=n[e];return void 0===c?(c={id:t.id,object:t,geometry:o,material:r,groupOrder:a,renderOrder:t.renderOrder,z:i,group:v},n[e]=c):(c.id=t.id,c.object=t,c.geometry=o,c.material=r,c.groupOrder=a,c.renderOrder=t.renderOrder,c.z=i,c.group=v),e++,c}return{opaque:t,transmissive:o,transparent:r,init:function(){e=0,t.length=0,o.length=0,r.length=0},push:function(n,e,i,v,c,l){var s=a(n,e,i,v,c,l);i.transmission>0?o.push(s):!0===i.transparent?r.push(s):t.push(s)},unshift:function(n,e,i,v,c,l){var s=a(n,e,i,v,c,l);i.transmission>0?o.unshift(s):!0===i.transparent?r.unshift(s):t.unshift(s)},finish:function(){for(var t=e,o=n.length;t<o;t++){var r=n[t];if(null===r.id)break;r.id=null,r.object=null,r.geometry=null,r.material=null,r.group=null}},sort:function(n,e){t.length>1&&t.sort(n||lc),o.length>1&&o.sort(e||sc),r.length>1&&r.sort(e||sc)}}}function fc(){var n=new WeakMap;return{get:function(e,t){var o,r=n.get(e);return void 0===r?(o=new uc,n.set(e,[o])):t>=r.length?(o=new uc,r.push(o)):o=r[t],o},dispose:function(){n=new WeakMap}}}function pc(){var n={};return{get:function(e){if(void 0!==n[e.id])return n[e.id];var t;switch(e.type){case"DirectionalLight":t={direction:new Oo,color:new wo};break;case"SpotLight":t={position:new Oo,direction:new Oo,color:new wo,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Oo,color:new wo,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Oo,skyColor:new wo,groundColor:new wo};break;case"RectAreaLight":t={color:new wo,position:new Oo,halfWidth:new Oo,halfHeight:new Oo}}return n[e.id]=t,t}}}var mc=0;function dc(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function hc(n,e){for(var t=new pc,o=function(){var n={};return{get:function(e){if(void 0!==n[e.id])return n[e.id];var t;switch(e.type){case"DirectionalLight":case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ao};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ao,shadowCameraNear:1,shadowCameraFar:1e3}}return n[e.id]=t,t}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0},a=0;a<9;a++)r.probe.push(new Oo);var i=new Oo,v=new pr,c=new pr;return{setup:function(a,i){for(var v=0,c=0,l=0,s=0;s<9;s++)r.probe[s].set(0,0,0);var u=0,f=0,p=0,m=0,d=0,h=0,x=0,y=0,g=0,b=0;a.sort(dc);for(var _=!0!==i?Math.PI:1,U=0,w=a.length;U<w;U++){var S=a[U],M=S.color,z=S.intensity,k=S.distance,C=S.shadow&&S.shadow.map?S.shadow.map.texture:null;if(S.isAmbientLight)v+=M.r*z*_,c+=M.g*z*_,l+=M.b*z*_;else if(S.isLightProbe)for(var T=0;T<9;T++)r.probe[T].addScaledVector(S.sh.coefficients[T],z);else if(S.isDirectionalLight){var R=t.get(S);if(R.color.copy(S.color).multiplyScalar(S.intensity*_),S.castShadow){var D=S.shadow,P=o.get(S);P.shadowBias=D.bias,P.shadowNormalBias=D.normalBias,P.shadowRadius=D.radius,P.shadowMapSize=D.mapSize,r.directionalShadow[u]=P,r.directionalShadowMap[u]=C,r.directionalShadowMatrix[u]=S.shadow.matrix,h++}r.directional[u]=R,u++}else if(S.isSpotLight){var F=t.get(S);F.position.setFromMatrixPosition(S.matrixWorld),F.color.copy(M).multiplyScalar(z*_),F.distance=k,F.coneCos=Math.cos(S.angle),F.penumbraCos=Math.cos(S.angle*(1-S.penumbra)),F.decay=S.decay,r.spot[p]=F;var j=S.shadow;if(S.map&&(r.spotLightMap[g]=S.map,g++,j.updateMatrices(S),S.castShadow&&b++),r.spotLightMatrix[p]=j.matrix,S.castShadow){var I=o.get(S);I.shadowBias=j.bias,I.shadowNormalBias=j.normalBias,I.shadowRadius=j.radius,I.shadowMapSize=j.mapSize,r.spotShadow[p]=I,r.spotShadowMap[p]=C,y++}p++}else if(S.isRectAreaLight){var E=t.get(S);E.color.copy(M).multiplyScalar(z),E.halfWidth.set(.5*S.width,0,0),E.halfHeight.set(0,.5*S.height,0),r.rectArea[m]=E,m++}else if(S.isPointLight){var O=t.get(S);if(O.color.copy(S.color).multiplyScalar(S.intensity*_),O.distance=S.distance,O.decay=S.decay,S.castShadow){var L=S.shadow,A=o.get(S);A.shadowBias=L.bias,A.shadowNormalBias=L.normalBias,A.shadowRadius=L.radius,A.shadowMapSize=L.mapSize,A.shadowCameraNear=L.camera.near,A.shadowCameraFar=L.camera.far,r.pointShadow[f]=A,r.pointShadowMap[f]=C,r.pointShadowMatrix[f]=S.shadow.matrix,x++}r.point[f]=O,f++}else if(S.isHemisphereLight){var G=t.get(S);G.skyColor.copy(S.color).multiplyScalar(z*_),G.groundColor.copy(S.groundColor).multiplyScalar(z*_),r.hemi[d]=G,d++}}m>0&&(e.isWebGL2||!0===n.has("OES_texture_float_linear")?(r.rectAreaLTC1=vi.LTC_FLOAT_1,r.rectAreaLTC2=vi.LTC_FLOAT_2):!0===n.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=vi.LTC_HALF_1,r.rectAreaLTC2=vi.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=v,r.ambient[1]=c,r.ambient[2]=l;var N=r.hash;N.directionalLength===u&&N.pointLength===f&&N.spotLength===p&&N.rectAreaLength===m&&N.hemiLength===d&&N.numDirectionalShadows===h&&N.numPointShadows===x&&N.numSpotShadows===y&&N.numSpotMaps===g||(r.directional.length=u,r.spot.length=p,r.rectArea.length=m,r.point.length=f,r.hemi.length=d,r.directionalShadow.length=h,r.directionalShadowMap.length=h,r.pointShadow.length=x,r.pointShadowMap.length=x,r.spotShadow.length=y,r.spotShadowMap.length=y,r.directionalShadowMatrix.length=h,r.pointShadowMatrix.length=x,r.spotLightMatrix.length=y+g-b,r.spotLightMap.length=g,r.numSpotLightShadowsWithMaps=b,N.directionalLength=u,N.pointLength=f,N.spotLength=p,N.rectAreaLength=m,N.hemiLength=d,N.numDirectionalShadows=h,N.numPointShadows=x,N.numSpotShadows=y,N.numSpotMaps=g,r.version=mc++)},setupView:function(n,e){for(var t=0,o=0,a=0,l=0,s=0,u=e.matrixWorldInverse,f=0,p=n.length;f<p;f++){var m=n[f];if(m.isDirectionalLight){var d=r.directional[t];d.direction.setFromMatrixPosition(m.matrixWorld),i.setFromMatrixPosition(m.target.matrixWorld),d.direction.sub(i),d.direction.transformDirection(u),t++}else if(m.isSpotLight){var h=r.spot[a];h.position.setFromMatrixPosition(m.matrixWorld),h.position.applyMatrix4(u),h.direction.setFromMatrixPosition(m.matrixWorld),i.setFromMatrixPosition(m.target.matrixWorld),h.direction.sub(i),h.direction.transformDirection(u),a++}else if(m.isRectAreaLight){var x=r.rectArea[l];x.position.setFromMatrixPosition(m.matrixWorld),x.position.applyMatrix4(u),c.identity(),v.copy(m.matrixWorld),v.premultiply(u),c.extractRotation(v),x.halfWidth.set(.5*m.width,0,0),x.halfHeight.set(0,.5*m.height,0),x.halfWidth.applyMatrix4(c),x.halfHeight.applyMatrix4(c),l++}else if(m.isPointLight){var y=r.point[o];y.position.setFromMatrixPosition(m.matrixWorld),y.position.applyMatrix4(u),o++}else if(m.isHemisphereLight){var g=r.hemi[s];g.direction.setFromMatrixPosition(m.matrixWorld),g.direction.transformDirection(u),s++}}},state:r}}function xc(n,e){var t=new hc(n,e),o=[],r=[];return{init:function(){o.length=0,r.length=0},state:{lightsArray:o,shadowsArray:r,lights:t},setupLights:function(n){t.setup(o,n)},setupLightsView:function(n){t.setupView(o,n)},pushLight:function(n){o.push(n)},pushShadow:function(n){r.push(n)}}}function yc(n,e){var t=new WeakMap;return{get:function(o){var r,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=t.get(o);return void 0===i?(r=new xc(n,e),t.set(o,[r])):a>=i.length?(r=new xc(n,e),i.push(r)):r=i[a],r},dispose:function(){t=new WeakMap}}}var gc=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshDepthMaterial=!0,o.type="MeshDepthMaterial",o.depthPacking=lt,o.map=null,o.alphaMap=null,o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.wireframe=!1,o.wireframeLinewidth=1,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.depthPacking=n.depthPacking,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this}}]),t}(Jr),bc=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshDistanceMaterial=!0,o.type="MeshDistanceMaterial",o.referencePosition=new Oo,o.nearDistance=1,o.farDistance=1e3,o.map=null,o.alphaMap=null,o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.referencePosition.copy(n.referencePosition),this.nearDistance=n.nearDistance,this.farDistance=n.farDistance,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this}}]),t}(Jr);function _c(n,e,t){var o=new ti,r=new ao,a=new ao,i=new To,v=new gc({depthPacking:st}),c=new bc,l={},s=t.maxTextureSize,u={0:W,1:V,2:H},f=new qa({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new ao},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=f.clone();p.defines.HORIZONTAL_PASS=1;var m=new ga;m.setAttribute("position",new ea(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));var d=new Oa(m,f),h=this;function x(t,o){var a=e.update(d);f.defines.VSM_SAMPLES!==t.blurSamples&&(f.defines.VSM_SAMPLES=t.blurSamples,p.defines.VSM_SAMPLES=t.blurSamples,f.needsUpdate=!0,p.needsUpdate=!0),null===t.mapPass&&(t.mapPass=new Ro(r.x,r.y)),f.uniforms.shadow_pass.value=t.map.texture,f.uniforms.resolution.value=t.mapSize,f.uniforms.radius.value=t.radius,n.setRenderTarget(t.mapPass),n.clear(),n.renderBufferDirect(o,null,a,f,d,null),p.uniforms.shadow_pass.value=t.mapPass.texture,p.uniforms.resolution.value=t.mapSize,p.uniforms.radius.value=t.radius,n.setRenderTarget(t.map),n.clear(),n.renderBufferDirect(o,null,a,p,d,null)}function y(e,t,o,r,a,i){var s=null,f=!0===o.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(s=void 0!==f?f:!0===o.isPointLight?c:v,n.localClippingEnabled&&!0===t.clipShadows&&Array.isArray(t.clippingPlanes)&&0!==t.clippingPlanes.length||t.displacementMap&&0!==t.displacementScale||t.alphaMap&&t.alphaTest>0){var p=s.uuid,m=t.uuid,d=l[p];void 0===d&&(d={},l[p]=d);var h=d[m];void 0===h&&(h=s.clone(),d[m]=h),s=h}return s.visible=t.visible,s.wireframe=t.wireframe,s.side=i===q?null!==t.shadowSide?t.shadowSide:t.side:null!==t.shadowSide?t.shadowSide:u[t.side],s.alphaMap=t.alphaMap,s.alphaTest=t.alphaTest,s.clipShadows=t.clipShadows,s.clippingPlanes=t.clippingPlanes,s.clipIntersection=t.clipIntersection,s.displacementMap=t.displacementMap,s.displacementScale=t.displacementScale,s.displacementBias=t.displacementBias,s.wireframeLinewidth=t.wireframeLinewidth,s.linewidth=t.linewidth,!0===o.isPointLight&&!0===s.isMeshDistanceMaterial&&(s.referencePosition.setFromMatrixPosition(o.matrixWorld),s.nearDistance=r,s.farDistance=a),s}function g(t,r,a,i,v){if(!1!==t.visible){if(t.layers.test(r.layers)&&(t.isMesh||t.isLine||t.isPoints)&&(t.castShadow||t.receiveShadow&&v===q)&&(!t.frustumCulled||o.intersectsObject(t))){t.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,t.matrixWorld);var c=e.update(t),l=t.material;if(Array.isArray(l))for(var s=c.groups,u=0,f=s.length;u<f;u++){var p=s[u],m=l[p.materialIndex];if(m&&m.visible){var d=y(t,m,i,a.near,a.far,v);n.renderBufferDirect(a,null,c,d,t,p)}}else if(l.visible){var h=y(t,l,i,a.near,a.far,v);n.renderBufferDirect(a,null,c,h,t,null)}}for(var x=t.children,b=0,_=x.length;b<_;b++)g(x[b],r,a,i,v)}}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=N,this.render=function(e,t,v){if(!1!==h.enabled&&(!1!==h.autoUpdate||!1!==h.needsUpdate)&&0!==e.length){var c=n.getRenderTarget(),l=n.getActiveCubeFace(),u=n.getActiveMipmapLevel(),f=n.state;f.setBlending(X),f.buffers.color.setClear(1,1,1,1),f.buffers.depth.setTest(!0),f.setScissorTest(!1);for(var p=0,m=e.length;p<m;p++){var d=e[p],y=d.shadow;if(void 0!==y){if(!1!==y.autoUpdate||!1!==y.needsUpdate){r.copy(y.mapSize);var b=y.getFrameExtents();if(r.multiply(b),a.copy(y.mapSize),(r.x>s||r.y>s)&&(r.x>s&&(a.x=Math.floor(s/b.x),r.x=a.x*b.x,y.mapSize.x=a.x),r.y>s&&(a.y=Math.floor(s/b.y),r.y=a.y*b.y,y.mapSize.y=a.y)),null===y.map){var _=this.type!==q?{minFilter:Bn,magFilter:Bn}:{};y.map=new Ro(r.x,r.y,_),y.map.texture.name=d.name+".shadowMap",y.camera.updateProjectionMatrix()}n.setRenderTarget(y.map),n.clear();for(var U=y.getViewportCount(),w=0;w<U;w++){var S=y.getViewport(w);i.set(a.x*S.x,a.y*S.y,a.x*S.z,a.y*S.w),f.viewport(i),y.updateMatrices(d,w),o=y.getFrustum(),g(t,v,y.camera,d,this.type)}!0!==y.isPointLightShadow&&this.type===q&&x(y,v),y.needsUpdate=!1}}else console.warn("THREE.WebGLShadowMap:",d,"has no shadow.")}h.needsUpdate=!1,n.setRenderTarget(c,l,u)}}}function Uc(n,e,t){var o,r,a=t.isWebGL2;var i=new function(){var e=!1,t=new To,o=null,r=new To(0,0,0,0);return{setMask:function(t){o===t||e||(n.colorMask(t,t,t,t),o=t)},setLocked:function(n){e=n},setClear:function(e,o,a,i,v){!0===v&&(e*=i,o*=i,a*=i),t.set(e,o,a,i),!1===r.equals(t)&&(n.clearColor(e,o,a,i),r.copy(t))},reset:function(){e=!1,o=null,r.set(-1,0,0,0)}}},v=new function(){var e=!1,t=null,o=null,r=null;return{setTest:function(n){n?Mn(2929):zn(2929)},setMask:function(o){t===o||e||(n.depthMask(o),t=o)},setFunc:function(e){if(o!==e){switch(e){case hn:n.depthFunc(512);break;case xn:n.depthFunc(519);break;case yn:n.depthFunc(513);break;case gn:n.depthFunc(515);break;case bn:n.depthFunc(514);break;case _n:n.depthFunc(518);break;case Un:n.depthFunc(516);break;case wn:n.depthFunc(517);break;default:n.depthFunc(515)}o=e}},setLocked:function(n){e=n},setClear:function(e){r!==e&&(n.clearDepth(e),r=e)},reset:function(){e=!1,t=null,o=null,r=null}}},c=new function(){var e=!1,t=null,o=null,r=null,a=null,i=null,v=null,c=null,l=null;return{setTest:function(n){e||(n?Mn(2960):zn(2960))},setMask:function(o){t===o||e||(n.stencilMask(o),t=o)},setFunc:function(e,t,i){o===e&&r===t&&a===i||(n.stencilFunc(e,t,i),o=e,r=t,a=i)},setOp:function(e,t,o){i===e&&v===t&&c===o||(n.stencilOp(e,t,o),i=e,v=t,c=o)},setLocked:function(n){e=n},setClear:function(e){l!==e&&(n.clearStencil(e),l=e)},reset:function(){e=!1,t=null,o=null,r=null,a=null,i=null,v=null,c=null,l=null}}},s=new WeakMap,u=new WeakMap,f={},p={},m=new WeakMap,d=[],h=null,x=!1,y=null,g=null,b=null,_=null,U=null,w=null,S=null,M=!1,z=null,k=null,C=null,T=null,R=null,D=n.getParameter(35661),P=!1,F=0,j=n.getParameter(7938);-1!==j.indexOf("WebGL")?(F=parseFloat(/^WebGL (\d)/.exec(j)[1]),P=F>=1):-1!==j.indexOf("OpenGL ES")&&(F=parseFloat(/^OpenGL ES (\d)/.exec(j)[1]),P=F>=2);var I=null,A={},G=n.getParameter(3088),N=n.getParameter(2978),B=(new To).fromArray(G),q=(new To).fromArray(N);function V(e,t,o){var r=new Uint8Array(4),a=n.createTexture();n.bindTexture(e,a),n.texParameteri(e,10241,9728),n.texParameteri(e,10240,9728);for(var i=0;i<o;i++)n.texImage2D(t+i,0,6408,1,1,0,6408,5121,r);return a}var Sn={};function Mn(e){!0!==f[e]&&(n.enable(e),f[e]=!0)}function zn(e){!1!==f[e]&&(n.disable(e),f[e]=!1)}Sn[3553]=V(3553,3553,1),Sn[34067]=V(34067,34069,6),i.setClear(0,0,0,1),v.setClear(1),c.setClear(0),Mn(2929),v.setFunc(gn),Dn(!1),Pn(O),Mn(2884),Rn(X);var kn=(l(o={},$,32774),l(o,nn,32778),l(o,en,32779),o);if(a)kn[tn]=32775,kn[on]=32776;else{var Cn=e.get("EXT_blend_minmax");null!==Cn&&(kn[tn]=Cn.MIN_EXT,kn[on]=Cn.MAX_EXT)}var Tn=(l(r={},rn,0),l(r,an,1),l(r,vn,768),l(r,ln,770),l(r,dn,776),l(r,pn,774),l(r,un,772),l(r,cn,769),l(r,sn,771),l(r,mn,775),l(r,fn,773),r);function Rn(e,t,o,r,a,i,v,c){if(e!==X){if(!1===x&&(Mn(3042),x=!0),e===K)a=a||t,i=i||o,v=v||r,t===g&&a===U||(n.blendEquationSeparate(kn[t],kn[a]),g=t,U=a),o===b&&r===_&&i===w&&v===S||(n.blendFuncSeparate(Tn[o],Tn[r],Tn[i],Tn[v]),b=o,_=r,w=i,S=v),y=e,M=null;else if(e!==y||c!==M){if(g===$&&U===$||(n.blendEquation(32774),g=$,U=$),c)switch(e){case Y:n.blendFuncSeparate(1,771,1,771);break;case Z:n.blendFunc(1,1);break;case Q:n.blendFuncSeparate(0,769,0,1);break;case J:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case Y:n.blendFuncSeparate(770,771,1,771);break;case Z:n.blendFunc(770,1);break;case Q:n.blendFuncSeparate(0,769,0,1);break;case J:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}b=null,_=null,w=null,S=null,y=e,M=c}}else!0===x&&(zn(3042),x=!1)}function Dn(e){z!==e&&(e?n.frontFace(2304):n.frontFace(2305),z=e)}function Pn(e){e!==E?(Mn(2884),e!==k&&(e===O?n.cullFace(1029):e===L?n.cullFace(1028):n.cullFace(1032))):zn(2884),k=e}function Fn(e,t,o){e?(Mn(32823),T===t&&R===o||(n.polygonOffset(t,o),T=t,R=o)):zn(32823)}return{buffers:{color:i,depth:v,stencil:c},enable:Mn,disable:zn,bindFramebuffer:function(e,t){return p[e]!==t&&(n.bindFramebuffer(e,t),p[e]=t,a&&(36009===e&&(p[36160]=t),36160===e&&(p[36009]=t)),!0)},drawBuffers:function(o,r){var a=d,i=!1;if(o)if(void 0===(a=m.get(r))&&(a=[],m.set(r,a)),o.isWebGLMultipleRenderTargets){var v=o.texture;if(a.length!==v.length||36064!==a[0]){for(var c=0,l=v.length;c<l;c++)a[c]=36064+c;a.length=v.length,i=!0}}else 36064!==a[0]&&(a[0]=36064,i=!0);else 1029!==a[0]&&(a[0]=1029,i=!0);i&&(t.isWebGL2?n.drawBuffers(a):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))},useProgram:function(e){return h!==e&&(n.useProgram(e),h=e,!0)},setBlending:Rn,setMaterial:function(n,e){n.side===H?zn(2884):Mn(2884);var t=n.side===W;e&&(t=!t),Dn(t),n.blending===Y&&!1===n.transparent?Rn(X):Rn(n.blending,n.blendEquation,n.blendSrc,n.blendDst,n.blendEquationAlpha,n.blendSrcAlpha,n.blendDstAlpha,n.premultipliedAlpha),v.setFunc(n.depthFunc),v.setTest(n.depthTest),v.setMask(n.depthWrite),i.setMask(n.colorWrite);var o=n.stencilWrite;c.setTest(o),o&&(c.setMask(n.stencilWriteMask),c.setFunc(n.stencilFunc,n.stencilRef,n.stencilFuncMask),c.setOp(n.stencilFail,n.stencilZFail,n.stencilZPass)),Fn(n.polygonOffset,n.polygonOffsetFactor,n.polygonOffsetUnits),!0===n.alphaToCoverage?Mn(32926):zn(32926)},setFlipSided:Dn,setCullFace:Pn,setLineWidth:function(e){e!==C&&(P&&n.lineWidth(e),C=e)},setPolygonOffset:Fn,setScissorTest:function(n){n?Mn(3089):zn(3089)},activeTexture:function(e){void 0===e&&(e=33984+D-1),I!==e&&(n.activeTexture(e),I=e)},bindTexture:function(e,t,o){void 0===o&&(o=null===I?33984+D-1:I);var r=A[o];void 0===r&&(r={type:void 0,texture:void 0},A[o]=r),r.type===e&&r.texture===t||(I!==o&&(n.activeTexture(o),I=o),n.bindTexture(e,t||Sn[e]),r.type=e,r.texture=t)},unbindTexture:function(){var e=A[I];void 0!==e&&void 0!==e.type&&(n.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{n.compressedTexImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexImage3D:function(){try{n.compressedTexImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{n.texImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{n.texImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},updateUBOMapping:function(e,t){var o=u.get(t);void 0===o&&(o=new WeakMap,u.set(t,o));var r=o.get(e);void 0===r&&(r=n.getUniformBlockIndex(t,e.name),o.set(e,r))},uniformBlockBinding:function(e,t){var o=u.get(t).get(e);s.get(e)!==o&&(n.uniformBlockBinding(t,o,e.__bindingPointIndex),s.set(e,o))},texStorage2D:function(){try{n.texStorage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage3D:function(){try{n.texStorage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage2D:function(){try{n.texSubImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage3D:function(){try{n.texSubImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage2D:function(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage3D:function(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(e){!1===B.equals(e)&&(n.scissor(e.x,e.y,e.z,e.w),B.copy(e))},viewport:function(e){!1===q.equals(e)&&(n.viewport(e.x,e.y,e.z,e.w),q.copy(e))},reset:function(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.disable(32926),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.bindFramebuffer(36160,null),!0===a&&(n.bindFramebuffer(36009,null),n.bindFramebuffer(36008,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),f={},I=null,A={},p={},m=new WeakMap,d=[],h=null,x=!1,y=null,g=null,b=null,_=null,U=null,w=null,S=null,M=!1,z=null,k=null,C=null,T=null,R=null,B.set(0,0,n.canvas.width,n.canvas.height),q.set(0,0,n.canvas.width,n.canvas.height),i.reset(),v.reset(),c.reset()}}}function wc(n,e,t,o,r,a,i){var v,c,s,u=r.isWebGL2,f=r.maxTextures,p=r.maxCubemapSize,m=r.maxTextureSize,d=r.maxSamples,h=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,x=/OculusBrowser/g.test("undefined"===typeof navigator?"":navigator.userAgent),y=new WeakMap,g=new WeakMap,b=!1;try{b="undefined"!==typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(W){}function _(n,e){return b?new OffscreenCanvas(n,e):so("canvas")}function U(n,e,t,o){var r=1;if((n.width>o||n.height>o)&&(r=o/Math.max(n.width,n.height)),r<1||!0===e){if("undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap){var a=e?eo:Math.floor,i=a(r*n.width),v=a(r*n.height);void 0===s&&(s=_(i,v));var c=t?_(i,v):s;return c.width=i,c.height=v,c.getContext("2d").drawImage(n,0,0,i,v),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+n.width+"x"+n.height+") to ("+i+"x"+v+")."),c}return"data"in n&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+n.width+"x"+n.height+")."),n}return n}function w(n){return $t(n.width)&&$t(n.height)}function S(n,e){return n.generateMipmaps&&e&&n.minFilter!==Bn&&n.minFilter!==Xn}function M(e){n.generateMipmap(e)}function z(t,o,r,a){var i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!1===u)return o;if(null!==t){if(void 0!==n[t])return n[t];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+t+"'")}var v=o;return 6403===o&&(5126===r&&(v=33326),5131===r&&(v=33325),5121===r&&(v=33321)),33319===o&&(5126===r&&(v=33328),5131===r&&(v=33327),5121===r&&(v=33323)),6408===o&&(5126===r&&(v=34836),5131===r&&(v=34842),5121===r&&(v=a===ct&&!1===i?35907:32856),32819===r&&(v=32854),32820===r&&(v=32855)),33325!==v&&33326!==v&&33327!==v&&33328!==v&&34842!==v&&34836!==v||e.get("EXT_color_buffer_float"),v}function k(n,e,t){return!0===S(n,t)||n.isFramebufferTexture&&n.minFilter!==Bn&&n.minFilter!==Xn?Math.log2(Math.max(e.width,e.height))+1:void 0!==n.mipmaps&&n.mipmaps.length>0?n.mipmaps.length:n.isCompressedTexture&&Array.isArray(n.image)?e.mipmaps.length:1}function C(n){return n===Bn||n===qn||n===Wn?9728:9729}function T(n){var e=n.target;e.removeEventListener("dispose",T),function(n){var e=o.get(n);if(void 0===e.__webglInit)return;var t=n.source,r=g.get(t);if(r){var a=r[e.__cacheKey];a.usedTimes--,0===a.usedTimes&&D(n),0===Object.keys(r).length&&g.delete(t)}o.remove(n)}(e),e.isVideoTexture&&y.delete(e)}function R(e){var t=e.target;t.removeEventListener("dispose",R),function(e){var t=e.texture,r=o.get(e),a=o.get(t);void 0!==a.__webglTexture&&(n.deleteTexture(a.__webglTexture),i.memory.textures--);e.depthTexture&&e.depthTexture.dispose();if(e.isWebGLCubeRenderTarget)for(var v=0;v<6;v++)n.deleteFramebuffer(r.__webglFramebuffer[v]),r.__webglDepthbuffer&&n.deleteRenderbuffer(r.__webglDepthbuffer[v]);else{if(n.deleteFramebuffer(r.__webglFramebuffer),r.__webglDepthbuffer&&n.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&n.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer)for(var c=0;c<r.__webglColorRenderbuffer.length;c++)r.__webglColorRenderbuffer[c]&&n.deleteRenderbuffer(r.__webglColorRenderbuffer[c]);r.__webglDepthRenderbuffer&&n.deleteRenderbuffer(r.__webglDepthRenderbuffer)}if(e.isWebGLMultipleRenderTargets)for(var l=0,s=t.length;l<s;l++){var u=o.get(t[l]);u.__webglTexture&&(n.deleteTexture(u.__webglTexture),i.memory.textures--),o.remove(t[l])}o.remove(t),o.remove(e)}(t)}function D(e){var t=o.get(e);n.deleteTexture(t.__webglTexture);var r=e.source;delete g.get(r)[t.__cacheKey],i.memory.textures--}var P=0;function F(n,e){var r=o.get(n);if(n.isVideoTexture&&function(n){var e=i.render.frame;y.get(n)!==e&&(y.set(n,e),n.update())}(n),!1===n.isRenderTargetTexture&&n.version>0&&r.__version!==n.version){var a=n.image;if(null===a)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==a.complete)return void L(r,n,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}t.bindTexture(3553,r.__webglTexture,33984+e)}var j=(l(v={},An,10497),l(v,Gn,33071),l(v,Nn,33648),v),I=(l(c={},Bn,9728),l(c,qn,9984),l(c,Wn,9986),l(c,Xn,9729),l(c,Yn,9985),l(c,Qn,9987),c);function E(t,a,i){if(i?(n.texParameteri(t,10242,j[a.wrapS]),n.texParameteri(t,10243,j[a.wrapT]),32879!==t&&35866!==t||n.texParameteri(t,32882,j[a.wrapR]),n.texParameteri(t,10240,I[a.magFilter]),n.texParameteri(t,10241,I[a.minFilter])):(n.texParameteri(t,10242,33071),n.texParameteri(t,10243,33071),32879!==t&&35866!==t||n.texParameteri(t,32882,33071),a.wrapS===Gn&&a.wrapT===Gn||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(t,10240,C(a.magFilter)),n.texParameteri(t,10241,C(a.minFilter)),a.minFilter!==Bn&&a.minFilter!==Xn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){var v=e.get("EXT_texture_filter_anisotropic");if(a.type===re&&!1===e.has("OES_texture_float_linear"))return;if(!1===u&&a.type===ae&&!1===e.has("OES_texture_half_float_linear"))return;(a.anisotropy>1||o.get(a).__currentAnisotropy)&&(n.texParameterf(t,v.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(a.anisotropy,r.getMaxAnisotropy())),o.get(a).__currentAnisotropy=a.anisotropy)}}function O(e,t){var o=!1;void 0===e.__webglInit&&(e.__webglInit=!0,t.addEventListener("dispose",T));var r=t.source,a=g.get(r);void 0===a&&(a={},g.set(r,a));var v=function(n){var e=[];return e.push(n.wrapS),e.push(n.wrapT),e.push(n.wrapR||0),e.push(n.magFilter),e.push(n.minFilter),e.push(n.anisotropy),e.push(n.internalFormat),e.push(n.format),e.push(n.type),e.push(n.generateMipmaps),e.push(n.premultiplyAlpha),e.push(n.flipY),e.push(n.unpackAlignment),e.push(n.encoding),e.join()}(t);if(v!==e.__cacheKey){void 0===a[v]&&(a[v]={texture:n.createTexture(),usedTimes:0},i.memory.textures++,o=!0),a[v].usedTimes++;var c=a[e.__cacheKey];void 0!==c&&(a[e.__cacheKey].usedTimes--,0===c.usedTimes&&D(t)),e.__cacheKey=v,e.__webglTexture=a[v].texture}return o}function L(e,r,i){var v=3553;(r.isDataArrayTexture||r.isCompressedArrayTexture)&&(v=35866),r.isData3DTexture&&(v=32879);var c=O(e,r),l=r.source;t.bindTexture(v,e.__webglTexture,33984+i);var s=o.get(l);if(l.version!==s.__version||!0===c){t.activeTexture(33984+i),n.pixelStorei(37440,r.flipY),n.pixelStorei(37441,r.premultiplyAlpha),n.pixelStorei(3317,r.unpackAlignment),n.pixelStorei(37443,0);var f,p=function(n){return!u&&(n.wrapS!==Gn||n.wrapT!==Gn||n.minFilter!==Bn&&n.minFilter!==Xn)}(r)&&!1===w(r.image),d=U(r.image,p,!1,m),h=w(d=V(r,d))||u,x=a.convert(r.format,r.encoding),y=a.convert(r.type),g=z(r.internalFormat,x,y,r.encoding,r.isVideoTexture);E(v,r,h);var b=r.mipmaps,_=u&&!0!==r.isVideoTexture,C=void 0===s.__version||!0===c,T=k(r,d,h);if(r.isDepthTexture)g=6402,u?g=r.type===re?36012:r.type===oe?33190:r.type===ce?35056:33189:r.type===re&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===me&&6402===g&&r.type!==ee&&r.type!==oe&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=oe,y=a.convert(r.type)),r.format===de&&6402===g&&(g=34041,r.type!==ce&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=ce,y=a.convert(r.type))),C&&(_?t.texStorage2D(3553,1,g,d.width,d.height):t.texImage2D(3553,0,g,d.width,d.height,0,x,y,null));else if(r.isDataTexture)if(b.length>0&&h){_&&C&&t.texStorage2D(3553,T,g,b[0].width,b[0].height);for(var R=0,D=b.length;R<D;R++)f=b[R],_?t.texSubImage2D(3553,R,0,0,f.width,f.height,x,y,f.data):t.texImage2D(3553,R,g,f.width,f.height,0,x,y,f.data);r.generateMipmaps=!1}else _?(C&&t.texStorage2D(3553,T,g,d.width,d.height),t.texSubImage2D(3553,0,0,0,d.width,d.height,x,y,d.data)):t.texImage2D(3553,0,g,d.width,d.height,0,x,y,d.data);else if(r.isCompressedTexture)if(r.isCompressedArrayTexture){_&&C&&t.texStorage3D(35866,T,g,b[0].width,b[0].height,d.depth);for(var P=0,F=b.length;P<F;P++)f=b[P],r.format!==ue?null!==x?_?t.compressedTexSubImage3D(35866,P,0,0,0,f.width,f.height,d.depth,x,f.data,0,0):t.compressedTexImage3D(35866,P,g,f.width,f.height,d.depth,0,f.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_?t.texSubImage3D(35866,P,0,0,0,f.width,f.height,d.depth,x,y,f.data):t.texImage3D(35866,P,g,f.width,f.height,d.depth,0,x,y,f.data)}else{_&&C&&t.texStorage2D(3553,T,g,b[0].width,b[0].height);for(var j=0,I=b.length;j<I;j++)f=b[j],r.format!==ue?null!==x?_?t.compressedTexSubImage2D(3553,j,0,0,f.width,f.height,x,f.data):t.compressedTexImage2D(3553,j,g,f.width,f.height,0,f.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_?t.texSubImage2D(3553,j,0,0,f.width,f.height,x,y,f.data):t.texImage2D(3553,j,g,f.width,f.height,0,x,y,f.data)}else if(r.isDataArrayTexture)_?(C&&t.texStorage3D(35866,T,g,d.width,d.height,d.depth),t.texSubImage3D(35866,0,0,0,0,d.width,d.height,d.depth,x,y,d.data)):t.texImage3D(35866,0,g,d.width,d.height,d.depth,0,x,y,d.data);else if(r.isData3DTexture)_?(C&&t.texStorage3D(32879,T,g,d.width,d.height,d.depth),t.texSubImage3D(32879,0,0,0,0,d.width,d.height,d.depth,x,y,d.data)):t.texImage3D(32879,0,g,d.width,d.height,d.depth,0,x,y,d.data);else if(r.isFramebufferTexture){if(C)if(_)t.texStorage2D(3553,T,g,d.width,d.height);else for(var L=d.width,A=d.height,G=0;G<T;G++)t.texImage2D(3553,G,g,L,A,0,x,y,null),L>>=1,A>>=1}else if(b.length>0&&h){_&&C&&t.texStorage2D(3553,T,g,b[0].width,b[0].height);for(var N=0,B=b.length;N<B;N++)f=b[N],_?t.texSubImage2D(3553,N,0,0,x,y,f):t.texImage2D(3553,N,g,x,y,f);r.generateMipmaps=!1}else _?(C&&t.texStorage2D(3553,T,g,d.width,d.height),t.texSubImage2D(3553,0,0,0,x,y,d)):t.texImage2D(3553,0,g,x,y,d);S(r,h)&&M(v),s.__version=l.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}function A(e,r,i,v,c){var l=a.convert(i.format,i.encoding),s=a.convert(i.type),u=z(i.internalFormat,l,s,i.encoding);o.get(r).__hasExternalTextures||(32879===c||35866===c?t.texImage3D(c,0,u,r.width,r.height,r.depth,0,l,s,null):t.texImage2D(c,0,u,r.width,r.height,0,l,s,null)),t.bindFramebuffer(36160,e),q(r)?h.framebufferTexture2DMultisampleEXT(36160,v,c,o.get(i).__webglTexture,0,B(r)):(3553===c||c>=34069&&c<=34074)&&n.framebufferTexture2D(36160,v,c,o.get(i).__webglTexture,0),t.bindFramebuffer(36160,null)}function G(e,t,o){if(n.bindRenderbuffer(36161,e),t.depthBuffer&&!t.stencilBuffer){var r=33189;if(o||q(t)){var i=t.depthTexture;i&&i.isDepthTexture&&(i.type===re?r=36012:i.type===oe&&(r=33190));var v=B(t);q(t)?h.renderbufferStorageMultisampleEXT(36161,v,r,t.width,t.height):n.renderbufferStorageMultisample(36161,v,r,t.width,t.height)}else n.renderbufferStorage(36161,r,t.width,t.height);n.framebufferRenderbuffer(36160,36096,36161,e)}else if(t.depthBuffer&&t.stencilBuffer){var c=B(t);o&&!1===q(t)?n.renderbufferStorageMultisample(36161,c,35056,t.width,t.height):q(t)?h.renderbufferStorageMultisampleEXT(36161,c,35056,t.width,t.height):n.renderbufferStorage(36161,34041,t.width,t.height),n.framebufferRenderbuffer(36160,33306,36161,e)}else for(var l=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture],s=0;s<l.length;s++){var u=l[s],f=a.convert(u.format,u.encoding),p=a.convert(u.type),m=z(u.internalFormat,f,p,u.encoding),d=B(t);o&&!1===q(t)?n.renderbufferStorageMultisample(36161,d,m,t.width,t.height):q(t)?h.renderbufferStorageMultisampleEXT(36161,d,m,t.width,t.height):n.renderbufferStorage(36161,m,t.width,t.height)}n.bindRenderbuffer(36161,null)}function N(e){var r=o.get(e),a=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!r.__autoAllocateDepthBuffer){if(a)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,e),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");o.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),F(r.depthTexture,0);var a=o.get(r.depthTexture).__webglTexture,i=B(r);if(r.depthTexture.format===me)q(r)?h.framebufferTexture2DMultisampleEXT(36160,36096,3553,a,0,i):n.framebufferTexture2D(36160,36096,3553,a,0);else{if(r.depthTexture.format!==de)throw new Error("Unknown depthTexture format");q(r)?h.framebufferTexture2DMultisampleEXT(36160,33306,3553,a,0,i):n.framebufferTexture2D(36160,33306,3553,a,0)}}(r.__webglFramebuffer,e)}else if(a){r.__webglDepthbuffer=[];for(var i=0;i<6;i++)t.bindFramebuffer(36160,r.__webglFramebuffer[i]),r.__webglDepthbuffer[i]=n.createRenderbuffer(),G(r.__webglDepthbuffer[i],e,!1)}else t.bindFramebuffer(36160,r.__webglFramebuffer),r.__webglDepthbuffer=n.createRenderbuffer(),G(r.__webglDepthbuffer,e,!1);t.bindFramebuffer(36160,null)}function B(n){return Math.min(d,n.samples)}function q(n){var t=o.get(n);return u&&n.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==t.__useRenderToTexture}function V(n,t){var o=n.encoding,r=n.format,a=n.type;return!0===n.isCompressedTexture||!0===n.isVideoTexture||n.format===qt||o!==vt&&(o===ct?!1===u?!0===e.has("EXT_sRGB")&&r===ue?(n.format=qt,n.minFilter=Xn,n.generateMipmaps=!1):t=So.sRGBToLinear(t):r===ue&&a===Kn||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",o)),t}this.allocateTextureUnit=function(){var n=P;return n>=f&&console.warn("THREE.WebGLTextures: Trying to use "+n+" texture units while this GPU supports only "+f),P+=1,n},this.resetTextureUnits=function(){P=0},this.setTexture2D=F,this.setTexture2DArray=function(n,e){var r=o.get(n);n.version>0&&r.__version!==n.version?L(r,n,e):t.bindTexture(35866,r.__webglTexture,33984+e)},this.setTexture3D=function(n,e){var r=o.get(n);n.version>0&&r.__version!==n.version?L(r,n,e):t.bindTexture(32879,r.__webglTexture,33984+e)},this.setTextureCube=function(e,r){var i=o.get(e);e.version>0&&i.__version!==e.version?function(e,r,i){if(6!==r.image.length)return;var v=O(e,r),c=r.source;t.bindTexture(34067,e.__webglTexture,33984+i);var l=o.get(c);if(c.version!==l.__version||!0===v){t.activeTexture(33984+i),n.pixelStorei(37440,r.flipY),n.pixelStorei(37441,r.premultiplyAlpha),n.pixelStorei(3317,r.unpackAlignment),n.pixelStorei(37443,0);for(var s=r.isCompressedTexture||r.image[0].isCompressedTexture,f=r.image[0]&&r.image[0].isDataTexture,m=[],d=0;d<6;d++)m[d]=s||f?f?r.image[d].image:r.image[d]:U(r.image[d],!1,!0,p),m[d]=V(r,m[d]);var h,x=m[0],y=w(x)||u,g=a.convert(r.format,r.encoding),b=a.convert(r.type),_=z(r.internalFormat,g,b,r.encoding),C=u&&!0!==r.isVideoTexture,T=void 0===l.__version||!0===v,R=k(r,x,y);if(E(34067,r,y),s){C&&T&&t.texStorage2D(34067,R,_,x.width,x.height);for(var D=0;D<6;D++){h=m[D].mipmaps;for(var P=0;P<h.length;P++){var F=h[P];r.format!==ue?null!==g?C?t.compressedTexSubImage2D(34069+D,P,0,0,F.width,F.height,g,F.data):t.compressedTexImage2D(34069+D,P,_,F.width,F.height,0,F.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):C?t.texSubImage2D(34069+D,P,0,0,F.width,F.height,g,b,F.data):t.texImage2D(34069+D,P,_,F.width,F.height,0,g,b,F.data)}}}else{h=r.mipmaps,C&&T&&(h.length>0&&R++,t.texStorage2D(34067,R,_,m[0].width,m[0].height));for(var j=0;j<6;j++)if(f){C?t.texSubImage2D(34069+j,0,0,0,m[j].width,m[j].height,g,b,m[j].data):t.texImage2D(34069+j,0,_,m[j].width,m[j].height,0,g,b,m[j].data);for(var I=0;I<h.length;I++){var L=h[I].image[j].image;C?t.texSubImage2D(34069+j,I+1,0,0,L.width,L.height,g,b,L.data):t.texImage2D(34069+j,I+1,_,L.width,L.height,0,g,b,L.data)}}else{C?t.texSubImage2D(34069+j,0,0,0,g,b,m[j]):t.texImage2D(34069+j,0,_,g,b,m[j]);for(var A=0;A<h.length;A++){var G=h[A];C?t.texSubImage2D(34069+j,A+1,0,0,g,b,G.image[j]):t.texImage2D(34069+j,A+1,_,g,b,G.image[j])}}}S(r,y)&&M(34067),l.__version=c.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}(i,e,r):t.bindTexture(34067,i.__webglTexture,33984+r)},this.rebindTextures=function(n,e,t){var r=o.get(n);void 0!==e&&A(r.__webglFramebuffer,n,n.texture,36064,3553),void 0!==t&&N(n)},this.setupRenderTarget=function(e){var v=e.texture,c=o.get(e),l=o.get(v);e.addEventListener("dispose",R),!0!==e.isWebGLMultipleRenderTargets&&(void 0===l.__webglTexture&&(l.__webglTexture=n.createTexture()),l.__version=v.version,i.memory.textures++);var s=!0===e.isWebGLCubeRenderTarget,f=!0===e.isWebGLMultipleRenderTargets,p=w(e)||u;if(s){c.__webglFramebuffer=[];for(var m=0;m<6;m++)c.__webglFramebuffer[m]=n.createFramebuffer()}else{if(c.__webglFramebuffer=n.createFramebuffer(),f)if(r.drawBuffers)for(var d=e.texture,h=0,x=d.length;h<x;h++){var y=o.get(d[h]);void 0===y.__webglTexture&&(y.__webglTexture=n.createTexture(),i.memory.textures++)}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(u&&e.samples>0&&!1===q(e)){var g=f?v:[v];c.__webglMultisampledFramebuffer=n.createFramebuffer(),c.__webglColorRenderbuffer=[],t.bindFramebuffer(36160,c.__webglMultisampledFramebuffer);for(var b=0;b<g.length;b++){var _=g[b];c.__webglColorRenderbuffer[b]=n.createRenderbuffer(),n.bindRenderbuffer(36161,c.__webglColorRenderbuffer[b]);var U=a.convert(_.format,_.encoding),k=a.convert(_.type),C=z(_.internalFormat,U,k,_.encoding,!0===e.isXRRenderTarget),T=B(e);n.renderbufferStorageMultisample(36161,T,C,e.width,e.height),n.framebufferRenderbuffer(36160,36064+b,36161,c.__webglColorRenderbuffer[b])}n.bindRenderbuffer(36161,null),e.depthBuffer&&(c.__webglDepthRenderbuffer=n.createRenderbuffer(),G(c.__webglDepthRenderbuffer,e,!0)),t.bindFramebuffer(36160,null)}}if(s){t.bindTexture(34067,l.__webglTexture),E(34067,v,p);for(var D=0;D<6;D++)A(c.__webglFramebuffer[D],e,v,36064,34069+D);S(v,p)&&M(34067),t.unbindTexture()}else if(f){for(var P=e.texture,F=0,j=P.length;F<j;F++){var I=P[F],O=o.get(I);t.bindTexture(3553,O.__webglTexture),E(3553,I,p),A(c.__webglFramebuffer,e,I,36064+F,3553),S(I,p)&&M(3553)}t.unbindTexture()}else{var L=3553;(e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(u?L=e.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(L,l.__webglTexture),E(L,v,p),A(c.__webglFramebuffer,e,v,36064,L),S(v,p)&&M(L),t.unbindTexture()}e.depthBuffer&&N(e)},this.updateRenderTargetMipmap=function(n){for(var e=w(n)||u,r=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture],a=0,i=r.length;a<i;a++){var v=r[a];if(S(v,e)){var c=n.isWebGLCubeRenderTarget?34067:3553,l=o.get(v).__webglTexture;t.bindTexture(c,l),M(c),t.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(u&&e.samples>0&&!1===q(e)){var r=e.isWebGLMultipleRenderTargets?e.texture:[e.texture],a=e.width,i=e.height,v=16384,c=[],l=e.stencilBuffer?33306:36096,s=o.get(e),f=!0===e.isWebGLMultipleRenderTargets;if(f)for(var p=0;p<r.length;p++)t.bindFramebuffer(36160,s.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+p,36161,null),t.bindFramebuffer(36160,s.__webglFramebuffer),n.framebufferTexture2D(36009,36064+p,3553,null,0);t.bindFramebuffer(36008,s.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,s.__webglFramebuffer);for(var m=0;m<r.length;m++){c.push(36064+m),e.depthBuffer&&c.push(l);var d=void 0!==s.__ignoreDepthValues&&s.__ignoreDepthValues;if(!1===d&&(e.depthBuffer&&(v|=256),e.stencilBuffer&&(v|=1024)),f&&n.framebufferRenderbuffer(36008,36064,36161,s.__webglColorRenderbuffer[m]),!0===d&&(n.invalidateFramebuffer(36008,[l]),n.invalidateFramebuffer(36009,[l])),f){var h=o.get(r[m]).__webglTexture;n.framebufferTexture2D(36009,36064,3553,h,0)}n.blitFramebuffer(0,0,a,i,0,0,a,i,v,9728),x&&n.invalidateFramebuffer(36008,c)}if(t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,null),f)for(var y=0;y<r.length;y++){t.bindFramebuffer(36160,s.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+y,36161,s.__webglColorRenderbuffer[y]);var g=o.get(r[y]).__webglTexture;t.bindFramebuffer(36160,s.__webglFramebuffer),n.framebufferTexture2D(36009,36064+y,3553,g,0)}t.bindFramebuffer(36009,s.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=N,this.setupFrameBufferTexture=A,this.useMultisampledRTT=q}function Sc(n,e,t){var o=t.isWebGL2;return{convert:function(t){var r,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t===Kn)return 5121;if(t===ie)return 32819;if(t===ve)return 32820;if(t===$n)return 5120;if(t===ne)return 5122;if(t===ee)return 5123;if(t===te)return 5124;if(t===oe)return 5125;if(t===re)return 5126;if(t===ae)return o?5131:null!==(r=e.get("OES_texture_half_float"))?r.HALF_FLOAT_OES:null;if(t===le)return 6406;if(t===ue)return 6408;if(t===fe)return 6409;if(t===pe)return 6410;if(t===me)return 6402;if(t===de)return 34041;if(t===he)return 6403;if(t===se)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(t===qt)return null!==(r=e.get("EXT_sRGB"))?r.SRGB_ALPHA_EXT:null;if(t===xe)return 36244;if(t===ye)return 33319;if(t===ge)return 33320;if(t===be)return 36249;if(t===_e||t===Ue||t===we||t===Se)if(a===ct){if(null===(r=e.get("WEBGL_compressed_texture_s3tc_srgb")))return null;if(t===_e)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(t===Ue)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(t===we)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(t===Se)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(null===(r=e.get("WEBGL_compressed_texture_s3tc")))return null;if(t===_e)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===Ue)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===we)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===Se)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(t===Me||t===ze||t===ke||t===Ce){if(null===(r=e.get("WEBGL_compressed_texture_pvrtc")))return null;if(t===Me)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===ze)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===ke)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===Ce)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(t===Te)return null!==(r=e.get("WEBGL_compressed_texture_etc1"))?r.COMPRESSED_RGB_ETC1_WEBGL:null;if(t===Re||t===De){if(null===(r=e.get("WEBGL_compressed_texture_etc")))return null;if(t===Re)return a===ct?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(t===De)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}if(t===Pe||t===Fe||t===je||t===Ie||t===Ee||t===Oe||t===Le||t===Ae||t===Ge||t===Ne||t===Be||t===qe||t===Ve||t===We){if(null===(r=e.get("WEBGL_compressed_texture_astc")))return null;if(t===Pe)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(t===Fe)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(t===je)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(t===Ie)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(t===Ee)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(t===Oe)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(t===Le)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(t===Ae)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(t===Ge)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(t===Ne)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(t===Be)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(t===qe)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(t===Ve)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(t===We)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}if(t===He){if(null===(r=e.get("EXT_texture_compression_bptc")))return null;if(t===He)return a===ct?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT}return t===ce?o?34042:null!==(r=e.get("WEBGL_depth_texture"))?r.UNSIGNED_INT_24_8_WEBGL:null:void 0!==n[t]?n[t]:null}}}var Mc=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return y(this,t),(n=e.call(this)).isArrayCamera=!0,n.cameras=o,n}return b(t)}(Wa),zc=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isGroup=!0,n.type="Group",n}return b(t)}(Lr),kc={type:"move"},Cc=function(){function n(){y(this,n),this._targetRay=null,this._grip=null,this._hand=null}return b(n,[{key:"getHandSpace",value:function(){return null===this._hand&&(this._hand=new zc,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}},{key:"getTargetRaySpace",value:function(){return null===this._targetRay&&(this._targetRay=new zc,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Oo,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Oo),this._targetRay}},{key:"getGripSpace",value:function(){return null===this._grip&&(this._grip=new zc,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Oo,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Oo),this._grip}},{key:"dispatchEvent",value:function(n){return null!==this._targetRay&&this._targetRay.dispatchEvent(n),null!==this._grip&&this._grip.dispatchEvent(n),null!==this._hand&&this._hand.dispatchEvent(n),this}},{key:"disconnect",value:function(n){return this.dispatchEvent({type:"disconnected",data:n}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}},{key:"update",value:function(n,e,t){var o=null,r=null,a=null,i=this._targetRay,v=this._grip,c=this._hand;if(n&&"visible-blurred"!==e.session.visibilityState){if(c&&n.hand){a=!0;var l,s=f(n.hand.values());try{for(s.s();!(l=s.n()).done;){var u=l.value,p=e.getJointPose(u,t);if(void 0===c.joints[u.jointName]){var m=new zc;m.matrixAutoUpdate=!1,m.visible=!1,c.joints[u.jointName]=m,c.add(m)}var d=c.joints[u.jointName];null!==p&&(d.matrix.fromArray(p.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale),d.jointRadius=p.radius),d.visible=null!==p}}catch(g){s.e(g)}finally{s.f()}var h=c.joints["index-finger-tip"],x=c.joints["thumb-tip"],y=h.position.distanceTo(x.position);c.inputState.pinching&&y>.025?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!c.inputState.pinching&&y<=.015&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else null!==v&&n.gripSpace&&null!==(r=e.getPose(n.gripSpace,t))&&(v.matrix.fromArray(r.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),r.linearVelocity?(v.hasLinearVelocity=!0,v.linearVelocity.copy(r.linearVelocity)):v.hasLinearVelocity=!1,r.angularVelocity?(v.hasAngularVelocity=!0,v.angularVelocity.copy(r.angularVelocity)):v.hasAngularVelocity=!1);null!==i&&(null===(o=e.getPose(n.targetRaySpace,t))&&null!==r&&(o=r),null!==o&&(i.matrix.fromArray(o.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),o.linearVelocity?(i.hasLinearVelocity=!0,i.linearVelocity.copy(o.linearVelocity)):i.hasLinearVelocity=!1,o.angularVelocity?(i.hasAngularVelocity=!0,i.angularVelocity.copy(o.angularVelocity)):i.hasAngularVelocity=!1,this.dispatchEvent(kc)))}return null!==i&&(i.visible=null!==o),null!==v&&(v.visible=null!==r),null!==c&&(c.visible=null!==a),this}}]),n}(),Tc=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v,c,l,s,u){var f;if(y(this,t),(u=void 0!==u?u:me)!==me&&u!==de)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");return void 0===r&&u===me&&(r=oe),void 0===r&&u===de&&(r=ce),(f=e.call(this,null,a,i,v,c,l,u,r,s)).isDepthTexture=!0,f.image={width:n,height:o},f.magFilter=void 0!==c?c:Bn,f.minFilter=void 0!==l?l:Bn,f.flipY=!1,f.generateMipmaps=!1,f}return b(t)}(Co),Rc=function(n){_(t,n);var e=z(t);function t(n,o){var r;y(this,t);var a=S(r=e.call(this)),i=null,v=1,c=null,l="local-floor",s=null,u=null,f=null,p=null,m=null,d=null,h=o.getContextAttributes(),x=null,g=null,b=[],_=[],U=new Wa;U.layers.enable(1),U.viewport=new To;var w=new Wa;w.layers.enable(2),w.viewport=new To;var M=[U,w],z=new Mc;z.layers.enable(1),z.layers.enable(2);var k=null,C=null;function R(n){var e=_.indexOf(n.inputSource);if(-1!==e){var t=b[e];void 0!==t&&t.dispatchEvent({type:n.type,data:n.inputSource})}}function D(){i.removeEventListener("select",R),i.removeEventListener("selectstart",R),i.removeEventListener("selectend",R),i.removeEventListener("squeeze",R),i.removeEventListener("squeezestart",R),i.removeEventListener("squeezeend",R),i.removeEventListener("end",D),i.removeEventListener("inputsourceschange",F);for(var e=0;e<b.length;e++){var t=_[e];null!==t&&(_[e]=null,b[e].disconnect(t))}k=null,C=null,n.setRenderTarget(x),m=null,p=null,f=null,i=null,g=null,L.stop(),a.isPresenting=!1,a.dispatchEvent({type:"sessionend"})}function F(n){for(var e=0;e<n.removed.length;e++){var t=n.removed[e],o=_.indexOf(t);o>=0&&(_[o]=null,b[o].dispatchEvent({type:"disconnected",data:t}))}for(var r=0;r<n.added.length;r++){var a=n.added[r],i=_.indexOf(a);if(-1===i){for(var v=0;v<b.length;v++){if(v>=_.length){_.push(a),i=v;break}if(null===_[v]){_[v]=a,i=v;break}}if(-1===i)break}var c=b[i];c&&c.dispatchEvent({type:"connected",data:a})}}r.cameraAutoUpdate=!0,r.enabled=!1,r.isPresenting=!1,r.getController=function(n){var e=b[n];return void 0===e&&(e=new Cc,b[n]=e),e.getTargetRaySpace()},r.getControllerGrip=function(n){var e=b[n];return void 0===e&&(e=new Cc,b[n]=e),e.getGripSpace()},r.getHand=function(n){var e=b[n];return void 0===e&&(e=new Cc,b[n]=e),e.getHandSpace()},r.setFramebufferScaleFactor=function(n){v=n,!0===a.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},r.setReferenceSpaceType=function(n){l=n,!0===a.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},r.getReferenceSpace=function(){return s||c},r.setReferenceSpace=function(n){s=n},r.getBaseLayer=function(){return null!==p?p:m},r.getBinding=function(){return f},r.getFrame=function(){return d},r.getSession=function(){return i},r.setSession=function(){var e=T(P().mark((function e(t){var r,u,d,y,b;return P().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(null===(i=t)){e.next=25;break}if(x=n.getRenderTarget(),i.addEventListener("select",R),i.addEventListener("selectstart",R),i.addEventListener("selectend",R),i.addEventListener("squeeze",R),i.addEventListener("squeezestart",R),i.addEventListener("squeezeend",R),i.addEventListener("end",D),i.addEventListener("inputsourceschange",F),!0===h.xrCompatible){e.next=14;break}return e.next=14,o.makeXRCompatible();case 14:return void 0===i.renderState.layers||!1===n.capabilities.isWebGL2?(r={antialias:void 0!==i.renderState.layers||h.antialias,alpha:h.alpha,depth:h.depth,stencil:h.stencil,framebufferScaleFactor:v},m=new XRWebGLLayer(i,o,r),i.updateRenderState({baseLayer:m}),g=new Ro(m.framebufferWidth,m.framebufferHeight,{format:ue,type:Kn,encoding:n.outputEncoding,stencilBuffer:h.stencil})):(u=null,d=null,y=null,h.depth&&(y=h.stencil?35056:33190,u=h.stencil?de:me,d=h.stencil?ce:oe),b={colorFormat:32856,depthFormat:y,scaleFactor:v},f=new XRWebGLBinding(i,o),p=f.createProjectionLayer(b),i.updateRenderState({layers:[p]}),g=new Ro(p.textureWidth,p.textureHeight,{format:ue,type:Kn,depthTexture:new Tc(p.textureWidth,p.textureHeight,d,void 0,void 0,void 0,void 0,void 0,void 0,u),stencilBuffer:h.stencil,encoding:n.outputEncoding,samples:h.antialias?4:0}),n.properties.get(g).__ignoreDepthValues=p.ignoreDepthValues),g.isXRRenderTarget=!0,this.setFoveation(1),s=null,e.next=20,i.requestReferenceSpace(l);case 20:c=e.sent,L.setContext(i),L.start(),a.isPresenting=!0,a.dispatchEvent({type:"sessionstart"});case 25:case"end":return e.stop()}}),e,this)})));return function(n){return e.apply(this,arguments)}}();var j=new Oo,I=new Oo;function E(n,e){null===e?n.matrixWorld.copy(n.matrix):n.matrixWorld.multiplyMatrices(e.matrixWorld,n.matrix),n.matrixWorldInverse.copy(n.matrixWorld).invert()}r.updateCamera=function(n){if(null!==i){z.near=w.near=U.near=n.near,z.far=w.far=U.far=n.far,k===z.near&&C===z.far||(i.updateRenderState({depthNear:z.near,depthFar:z.far}),k=z.near,C=z.far);var e=n.parent,t=z.cameras;E(z,e);for(var o=0;o<t.length;o++)E(t[o],e);z.matrixWorld.decompose(z.position,z.quaternion,z.scale),n.matrix.copy(z.matrix),n.matrix.decompose(n.position,n.quaternion,n.scale);for(var r=n.children,a=0,v=r.length;a<v;a++)r[a].updateMatrixWorld(!0);2===t.length?function(n,e,t){j.setFromMatrixPosition(e.matrixWorld),I.setFromMatrixPosition(t.matrixWorld);var o=j.distanceTo(I),r=e.projectionMatrix.elements,a=t.projectionMatrix.elements,i=r[14]/(r[10]-1),v=r[14]/(r[10]+1),c=(r[9]+1)/r[5],l=(r[9]-1)/r[5],s=(r[8]-1)/r[0],u=(a[8]+1)/a[0],f=i*s,p=i*u,m=o/(-s+u),d=m*-s;e.matrixWorld.decompose(n.position,n.quaternion,n.scale),n.translateX(d),n.translateZ(m),n.matrixWorld.compose(n.position,n.quaternion,n.scale),n.matrixWorldInverse.copy(n.matrixWorld).invert();var h=i+m,x=v+m,y=f-d,g=p+(o-d),b=c*v/x*h,_=l*v/x*h;n.projectionMatrix.makePerspective(y,g,b,_,h,x)}(z,U,w):z.projectionMatrix.copy(U.projectionMatrix)}},r.getCamera=function(){return z},r.getFoveation=function(){return null!==p?p.fixedFoveation:null!==m?m.fixedFoveation:void 0},r.setFoveation=function(n){null!==p&&(p.fixedFoveation=n),null!==m&&void 0!==m.fixedFoveation&&(m.fixedFoveation=n)};var O=null;var L=new oi;return L.setAnimationLoop((function(e,t){if(u=t.getViewerPose(s||c),d=t,null!==u){var o=u.views;null!==m&&(n.setRenderTargetFramebuffer(g,m.framebuffer),n.setRenderTarget(g));var r=!1;o.length!==z.cameras.length&&(z.cameras.length=0,r=!0);for(var a=0;a<o.length;a++){var i=o[a],v=null;if(null!==m)v=m.getViewport(i);else{var l=f.getViewSubImage(p,i);v=l.viewport,0===a&&(n.setRenderTargetTextures(g,l.colorTexture,p.ignoreDepthValues?void 0:l.depthStencilTexture),n.setRenderTarget(g))}var h=M[a];void 0===h&&((h=new Wa).layers.enable(a),h.viewport=new To,M[a]=h),h.matrix.fromArray(i.transform.matrix),h.projectionMatrix.fromArray(i.projectionMatrix),h.viewport.set(v.x,v.y,v.width,v.height),0===a&&z.matrix.copy(h.matrix),!0===r&&z.cameras.push(h)}}for(var x=0;x<b.length;x++){var y=_[x],U=b[x];null!==y&&void 0!==U&&U.update(y,t,s||c)}O&&O(e,t),d=null})),r.setAnimationLoop=function(n){O=n},r.dispose=function(){},r}return b(t)}(Vt);function Dc(n,e){function t(t,o){t.opacity.value=o.opacity,o.color&&t.diffuse.value.copy(o.color),o.emissive&&t.emissive.value.copy(o.emissive).multiplyScalar(o.emissiveIntensity),o.map&&(t.map.value=o.map),o.alphaMap&&(t.alphaMap.value=o.alphaMap),o.bumpMap&&(t.bumpMap.value=o.bumpMap,t.bumpScale.value=o.bumpScale,o.side===W&&(t.bumpScale.value*=-1)),o.displacementMap&&(t.displacementMap.value=o.displacementMap,t.displacementScale.value=o.displacementScale,t.displacementBias.value=o.displacementBias),o.emissiveMap&&(t.emissiveMap.value=o.emissiveMap),o.normalMap&&(t.normalMap.value=o.normalMap,t.normalScale.value.copy(o.normalScale),o.side===W&&t.normalScale.value.negate()),o.specularMap&&(t.specularMap.value=o.specularMap),o.alphaTest>0&&(t.alphaTest.value=o.alphaTest);var r,a,i=e.get(o).envMap;if(i&&(t.envMap.value=i,t.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,t.reflectivity.value=o.reflectivity,t.ior.value=o.ior,t.refractionRatio.value=o.refractionRatio),o.lightMap){t.lightMap.value=o.lightMap;var v=!0!==n.physicallyCorrectLights?Math.PI:1;t.lightMapIntensity.value=o.lightMapIntensity*v}o.aoMap&&(t.aoMap.value=o.aoMap,t.aoMapIntensity.value=o.aoMapIntensity),o.map?r=o.map:o.specularMap?r=o.specularMap:o.displacementMap?r=o.displacementMap:o.normalMap?r=o.normalMap:o.bumpMap?r=o.bumpMap:o.roughnessMap?r=o.roughnessMap:o.metalnessMap?r=o.metalnessMap:o.alphaMap?r=o.alphaMap:o.emissiveMap?r=o.emissiveMap:o.clearcoatMap?r=o.clearcoatMap:o.clearcoatNormalMap?r=o.clearcoatNormalMap:o.clearcoatRoughnessMap?r=o.clearcoatRoughnessMap:o.iridescenceMap?r=o.iridescenceMap:o.iridescenceThicknessMap?r=o.iridescenceThicknessMap:o.specularIntensityMap?r=o.specularIntensityMap:o.specularColorMap?r=o.specularColorMap:o.transmissionMap?r=o.transmissionMap:o.thicknessMap?r=o.thicknessMap:o.sheenColorMap?r=o.sheenColorMap:o.sheenRoughnessMap&&(r=o.sheenRoughnessMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uvTransform.value.copy(r.matrix)),o.aoMap?a=o.aoMap:o.lightMap&&(a=o.lightMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),t.uv2Transform.value.copy(a.matrix))}return{refreshFogUniforms:function(n,e){n.fogColor.value.copy(e.color),e.isFog?(n.fogNear.value=e.near,n.fogFar.value=e.far):e.isFogExp2&&(n.fogDensity.value=e.density)},refreshMaterialUniforms:function(n,o,r,a,i){o.isMeshBasicMaterial||o.isMeshLambertMaterial?t(n,o):o.isMeshToonMaterial?(t(n,o),function(n,e){e.gradientMap&&(n.gradientMap.value=e.gradientMap)}(n,o)):o.isMeshPhongMaterial?(t(n,o),function(n,e){n.specular.value.copy(e.specular),n.shininess.value=Math.max(e.shininess,1e-4)}(n,o)):o.isMeshStandardMaterial?(t(n,o),function(n,t){n.roughness.value=t.roughness,n.metalness.value=t.metalness,t.roughnessMap&&(n.roughnessMap.value=t.roughnessMap);t.metalnessMap&&(n.metalnessMap.value=t.metalnessMap);e.get(t).envMap&&(n.envMapIntensity.value=t.envMapIntensity)}(n,o),o.isMeshPhysicalMaterial&&function(n,e,t){n.ior.value=e.ior,e.sheen>0&&(n.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),n.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(n.sheenColorMap.value=e.sheenColorMap),e.sheenRoughnessMap&&(n.sheenRoughnessMap.value=e.sheenRoughnessMap));e.clearcoat>0&&(n.clearcoat.value=e.clearcoat,n.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(n.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(n.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),n.clearcoatNormalMap.value=e.clearcoatNormalMap,e.side===W&&n.clearcoatNormalScale.value.negate()));e.iridescence>0&&(n.iridescence.value=e.iridescence,n.iridescenceIOR.value=e.iridescenceIOR,n.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],n.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(n.iridescenceMap.value=e.iridescenceMap),e.iridescenceThicknessMap&&(n.iridescenceThicknessMap.value=e.iridescenceThicknessMap));e.transmission>0&&(n.transmission.value=e.transmission,n.transmissionSamplerMap.value=t.texture,n.transmissionSamplerSize.value.set(t.width,t.height),e.transmissionMap&&(n.transmissionMap.value=e.transmissionMap),n.thickness.value=e.thickness,e.thicknessMap&&(n.thicknessMap.value=e.thicknessMap),n.attenuationDistance.value=e.attenuationDistance,n.attenuationColor.value.copy(e.attenuationColor));n.specularIntensity.value=e.specularIntensity,n.specularColor.value.copy(e.specularColor),e.specularIntensityMap&&(n.specularIntensityMap.value=e.specularIntensityMap);e.specularColorMap&&(n.specularColorMap.value=e.specularColorMap)}(n,o,i)):o.isMeshMatcapMaterial?(t(n,o),function(n,e){e.matcap&&(n.matcap.value=e.matcap)}(n,o)):o.isMeshDepthMaterial?t(n,o):o.isMeshDistanceMaterial?(t(n,o),function(n,e){n.referencePosition.value.copy(e.referencePosition),n.nearDistance.value=e.nearDistance,n.farDistance.value=e.farDistance}(n,o)):o.isMeshNormalMaterial?t(n,o):o.isLineBasicMaterial?(function(n,e){n.diffuse.value.copy(e.color),n.opacity.value=e.opacity}(n,o),o.isLineDashedMaterial&&function(n,e){n.dashSize.value=e.dashSize,n.totalSize.value=e.dashSize+e.gapSize,n.scale.value=e.scale}(n,o)):o.isPointsMaterial?function(n,e,t,o){n.diffuse.value.copy(e.color),n.opacity.value=e.opacity,n.size.value=e.size*t,n.scale.value=.5*o,e.map&&(n.map.value=e.map);e.alphaMap&&(n.alphaMap.value=e.alphaMap);e.alphaTest>0&&(n.alphaTest.value=e.alphaTest);var r;e.map?r=e.map:e.alphaMap&&(r=e.alphaMap);void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),n.uvTransform.value.copy(r.matrix))}(n,o,r,a):o.isSpriteMaterial?function(n,e){n.diffuse.value.copy(e.color),n.opacity.value=e.opacity,n.rotation.value=e.rotation,e.map&&(n.map.value=e.map);e.alphaMap&&(n.alphaMap.value=e.alphaMap);e.alphaTest>0&&(n.alphaTest.value=e.alphaTest);var t;e.map?t=e.map:e.alphaMap&&(t=e.alphaMap);void 0!==t&&(!0===t.matrixAutoUpdate&&t.updateMatrix(),n.uvTransform.value.copy(t.matrix))}(n,o):o.isShadowMaterial?(n.color.value.copy(o.color),n.opacity.value=o.opacity):o.isShaderMaterial&&(o.uniformsNeedUpdate=!1)}}}function Pc(n,e,t,o){var r={},a={},i=[],v=t.isWebGL2?n.getParameter(35375):0;function c(n,e,t){var o=n.value;if(void 0===t[e])return t[e]="number"===typeof o?o:o.clone(),!0;if("number"===typeof o){if(t[e]!==o)return t[e]=o,!0}else{var r=t[e];if(!1===r.equals(o))return r.copy(o),!0}return!1}function l(n){var e=n.value,t={boundary:0,storage:0};return"number"===typeof e?(t.boundary=4,t.storage=4):e.isVector2?(t.boundary=8,t.storage=8):e.isVector3||e.isColor?(t.boundary=16,t.storage=12):e.isVector4?(t.boundary=16,t.storage=16):e.isMatrix3?(t.boundary=48,t.storage=48):e.isMatrix4?(t.boundary=64,t.storage=64):e.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",e),t}function s(e){var t=e.target;t.removeEventListener("dispose",s);var o=i.indexOf(t.__bindingPointIndex);i.splice(o,1),n.deleteBuffer(r[t.id]),delete r[t.id],delete a[t.id]}return{bind:function(n,e){var t=e.program;o.uniformBlockBinding(n,t)},update:function(t,u){var f=r[t.id];void 0===f&&(!function(n){for(var e=n.uniforms,t=0,o=16,r=0,a=0,i=e.length;a<i;a++){var v=e[a],c=l(v);if(v.__data=new Float32Array(c.storage/Float32Array.BYTES_PER_ELEMENT),v.__offset=t,a>0)0!==(r=t%o)&&o-r-c.boundary<0&&(t+=o-r,v.__offset=t);t+=c.storage}(r=t%o)>0&&(t+=o-r);n.__size=t,n.__cache={}}(t),f=function(e){var t=function(){for(var n=0;n<v;n++)if(-1===i.indexOf(n))return i.push(n),n;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.__bindingPointIndex=t;var o=n.createBuffer(),r=e.__size,a=e.usage;return n.bindBuffer(35345,o),n.bufferData(35345,r,a),n.bindBuffer(35345,null),n.bindBufferBase(35345,t,o),o}(t),r[t.id]=f,t.addEventListener("dispose",s));var p=u.program;o.updateUBOMapping(t,p);var m=e.render.frame;a[t.id]!==m&&(!function(e){var t=r[e.id],o=e.uniforms,a=e.__cache;n.bindBuffer(35345,t);for(var i=0,v=o.length;i<v;i++){var l=o[i];if(!0===c(l,i,a)){var s=l.value,u=l.__offset;"number"===typeof s?(l.__data[0]=s,n.bufferSubData(35345,u,l.__data)):(l.value.isMatrix3?(l.__data[0]=l.value.elements[0],l.__data[1]=l.value.elements[1],l.__data[2]=l.value.elements[2],l.__data[3]=l.value.elements[0],l.__data[4]=l.value.elements[3],l.__data[5]=l.value.elements[4],l.__data[6]=l.value.elements[5],l.__data[7]=l.value.elements[0],l.__data[8]=l.value.elements[6],l.__data[9]=l.value.elements[7],l.__data[10]=l.value.elements[8],l.__data[11]=l.value.elements[0]):s.toArray(l.__data),n.bufferSubData(35345,u,l.__data))}}n.bindBuffer(35345,null)}(t),a[t.id]=m)},dispose:function(){for(var e in r)n.deleteBuffer(r[e]);i=[],r={},a={}}}}function Fc(){var n=so("canvas");return n.style.display="block",n}function jc(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.isWebGLRenderer=!0;var e,t=void 0!==n.canvas?n.canvas:Fc(),o=void 0!==n.context?n.context:null,r=void 0===n.depth||n.depth,a=void 0===n.stencil||n.stencil,i=void 0!==n.antialias&&n.antialias,v=void 0===n.premultipliedAlpha||n.premultipliedAlpha,c=void 0!==n.preserveDrawingBuffer&&n.preserveDrawingBuffer,l=void 0!==n.powerPreference?n.powerPreference:"default",s=void 0!==n.failIfMajorPerformanceCaveat&&n.failIfMajorPerformanceCaveat;e=null!==o?o.getContextAttributes().alpha:void 0!==n.alpha&&n.alpha;var u=null,f=null,p=[],m=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=vt,this.physicallyCorrectLights=!1,this.toneMapping=kn,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});var d=this,h=!1,x=0,y=0,g=null,b=-1,_=null,U=new To,w=new To,S=null,M=t.width,z=t.height,k=1,C=null,T=null,R=new To(0,0,M,z),D=new To(0,0,M,z),P=!1,j=new ti,I=!1,E=!1,O=null,L=new pr,A=new ao,G=new Oo,N={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function B(){return null===g?k:1}var q,X,Y,Z,Q,J,K,$,nn,en,tn,on,rn,an,vn,cn,ln,sn,un,fn,pn,mn,dn,hn,xn=o;function yn(n,e){for(var o=0;o<n.length;o++){var r=n[o],a=t.getContext(r,e);if(null!==a)return a}return null}try{var gn={alpha:!0,depth:r,stencil:a,antialias:i,premultipliedAlpha:v,preserveDrawingBuffer:c,powerPreference:l,failIfMajorPerformanceCaveat:s};if("setAttribute"in t&&t.setAttribute("data-engine","three.js r".concat(F)),t.addEventListener("webglcontextlost",wn,!1),t.addEventListener("webglcontextrestored",Sn,!1),t.addEventListener("webglcontextcreationerror",Mn,!1),null===xn){var bn=["webgl2","webgl","experimental-webgl"];if(!0===d.isWebGL1Renderer&&bn.shift(),null===(xn=yn(bn,gn)))throw yn(bn)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===xn.getShaderPrecisionFormat&&(xn.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Wn){throw console.error("THREE.WebGLRenderer: "+Wn.message),Wn}function _n(){q=new Ri(xn),X=new fi(xn,q,n),q.init(X),mn=new Sc(xn,q,X),Y=new Uc(xn,q,X),Z=new Fi,Q=new cc,J=new wc(xn,q,Y,Q,X,mn,Z),K=new mi(d),$=new Ti(d),nn=new ri(xn,X),dn=new si(xn,q,nn,X),en=new Di(xn,nn,Z,dn),tn=new Oi(xn,en,nn,Z),un=new Ei(xn,X,J),cn=new pi(Q),on=new vc(d,K,$,q,X,dn,cn),rn=new Dc(d,Q),an=new fc,vn=new yc(q,X),sn=new li(d,K,$,Y,tn,e,v),ln=new _c(d,tn,X),hn=new Pc(xn,Z,X,Y),fn=new ui(xn,q,Z,X),pn=new Pi(xn,q,Z,X),Z.programs=on.programs,d.capabilities=X,d.extensions=q,d.properties=Q,d.renderLists=an,d.shadowMap=ln,d.state=Y,d.info=Z}_n();var Un=new Rc(d,xn);function wn(n){n.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),h=!0}function Sn(){console.log("THREE.WebGLRenderer: Context Restored."),h=!1;var n=Z.autoReset,e=ln.enabled,t=ln.autoUpdate,o=ln.needsUpdate,r=ln.type;_n(),Z.autoReset=n,ln.enabled=e,ln.autoUpdate=t,ln.needsUpdate=o,ln.type=r}function Mn(n){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",n.statusMessage)}function zn(n){var e=n.target;e.removeEventListener("dispose",zn),Cn(e)}function Cn(n){Tn(n),Q.remove(n)}function Tn(n){var e=Q.get(n).programs;void 0!==e&&(e.forEach((function(n){on.releaseProgram(n)})),n.isShaderMaterial&&on.releaseShaderCache(n))}this.xr=Un,this.getContext=function(){return xn},this.getContextAttributes=function(){return xn.getContextAttributes()},this.forceContextLoss=function(){var n=q.get("WEBGL_lose_context");n&&n.loseContext()},this.forceContextRestore=function(){var n=q.get("WEBGL_lose_context");n&&n.restoreContext()},this.getPixelRatio=function(){return k},this.setPixelRatio=function(n){void 0!==n&&(k=n,this.setSize(M,z,!1))},this.getSize=function(n){return n.set(M,z)},this.setSize=function(n,e,o){Un.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(M=n,z=e,t.width=Math.floor(n*k),t.height=Math.floor(e*k),!1!==o&&(t.style.width=n+"px",t.style.height=e+"px"),this.setViewport(0,0,n,e))},this.getDrawingBufferSize=function(n){return n.set(M*k,z*k).floor()},this.setDrawingBufferSize=function(n,e,o){M=n,z=e,k=o,t.width=Math.floor(n*o),t.height=Math.floor(e*o),this.setViewport(0,0,n,e)},this.getCurrentViewport=function(n){return n.copy(U)},this.getViewport=function(n){return n.copy(R)},this.setViewport=function(n,e,t,o){n.isVector4?R.set(n.x,n.y,n.z,n.w):R.set(n,e,t,o),Y.viewport(U.copy(R).multiplyScalar(k).floor())},this.getScissor=function(n){return n.copy(D)},this.setScissor=function(n,e,t,o){n.isVector4?D.set(n.x,n.y,n.z,n.w):D.set(n,e,t,o),Y.scissor(w.copy(D).multiplyScalar(k).floor())},this.getScissorTest=function(){return P},this.setScissorTest=function(n){Y.setScissorTest(P=n)},this.setOpaqueSort=function(n){C=n},this.setTransparentSort=function(n){T=n},this.getClearColor=function(n){return n.copy(sn.getClearColor())},this.setClearColor=function(){sn.setClearColor.apply(sn,arguments)},this.getClearAlpha=function(){return sn.getClearAlpha()},this.setClearAlpha=function(){sn.setClearAlpha.apply(sn,arguments)},this.clear=function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],o=0;n&&(o|=16384),e&&(o|=256),t&&(o|=1024),xn.clear(o)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",wn,!1),t.removeEventListener("webglcontextrestored",Sn,!1),t.removeEventListener("webglcontextcreationerror",Mn,!1),an.dispose(),vn.dispose(),Q.dispose(),K.dispose(),$.dispose(),tn.dispose(),dn.dispose(),hn.dispose(),on.dispose(),Un.dispose(),Un.removeEventListener("sessionstart",Pn),Un.removeEventListener("sessionend",Fn),O&&(O.dispose(),O=null),jn.stop()},this.renderBufferDirect=function(n,e,t,o,r,a){null===e&&(e=N);var i=r.isMesh&&r.matrixWorld.determinant()<0,v=Bn(n,e,t,o,r);Y.setMaterial(o,i);var c=t.index,l=t.attributes.position;if(null===c){if(void 0===l||0===l.count)return}else if(0===c.count)return;var s,u=1;!0===o.wireframe&&(c=en.getWireframeAttribute(t),u=2),dn.setup(r,o,v,t,c);var f=fn;null!==c&&(s=nn.get(c),(f=pn).setIndex(s));var p=null!==c?c.count:l.count,m=t.drawRange.start*u,d=t.drawRange.count*u,h=null!==a?a.start*u:0,x=null!==a?a.count*u:1/0,y=Math.max(m,h),g=Math.min(p,m+d,h+x)-1,b=Math.max(0,g-y+1);if(0!==b){if(r.isMesh)!0===o.wireframe?(Y.setLineWidth(o.wireframeLinewidth*B()),f.setMode(1)):f.setMode(4);else if(r.isLine){var _=o.linewidth;void 0===_&&(_=1),Y.setLineWidth(_*B()),r.isLineSegments?f.setMode(1):r.isLineLoop?f.setMode(2):f.setMode(3)}else r.isPoints?f.setMode(0):r.isSprite&&f.setMode(4);if(r.isInstancedMesh)f.renderInstances(y,b,r.count);else if(t.isInstancedBufferGeometry){var U=Math.min(t.instanceCount,t._maxInstanceCount);f.renderInstances(y,b,U)}else f.render(y,b)}},this.compile=function(n,e){function t(n,e,t){!0===n.transparent&&n.side===H?(n.side=W,n.needsUpdate=!0,Gn(n,e,t),n.side=V,n.needsUpdate=!0,Gn(n,e,t),n.side=H):Gn(n,e,t)}(f=vn.get(n)).init(),m.push(f),n.traverseVisible((function(n){n.isLight&&n.layers.test(e.layers)&&(f.pushLight(n),n.castShadow&&f.pushShadow(n))})),f.setupLights(d.physicallyCorrectLights),n.traverse((function(e){var o=e.material;if(o)if(Array.isArray(o))for(var r=0;r<o.length;r++){t(o[r],n,e)}else t(o,n,e)})),m.pop(),f=null};var Rn=null;function Dn(n){Rn&&Rn(n)}function Pn(){jn.stop()}function Fn(){jn.start()}var jn=new oi;function In(n,e,t,o){if(!1!==n.visible){if(n.layers.test(e.layers))if(n.isGroup)t=n.renderOrder;else if(n.isLOD)!0===n.autoUpdate&&n.update(e);else if(n.isLight)f.pushLight(n),n.castShadow&&f.pushShadow(n);else if(n.isSprite){if(!n.frustumCulled||j.intersectsSprite(n)){o&&G.setFromMatrixPosition(n.matrixWorld).applyMatrix4(L);var r=tn.update(n),a=n.material;a.visible&&u.push(n,r,a,t,G.z,null)}}else if((n.isMesh||n.isLine||n.isPoints)&&(n.isSkinnedMesh&&n.skeleton.frame!==Z.render.frame&&(n.skeleton.update(),n.skeleton.frame=Z.render.frame),!n.frustumCulled||j.intersectsObject(n))){o&&G.setFromMatrixPosition(n.matrixWorld).applyMatrix4(L);var i=tn.update(n),v=n.material;if(Array.isArray(v))for(var c=i.groups,l=0,s=c.length;l<s;l++){var p=c[l],m=v[p.materialIndex];m&&m.visible&&u.push(n,i,m,t,G.z,p)}else v.visible&&u.push(n,i,v,t,G.z,null)}for(var d=n.children,h=0,x=d.length;h<x;h++)In(d[h],e,t,o)}}function En(n,e,t,o){var r=n.opaque,a=n.transmissive,i=n.transparent;f.setupLightsView(t),a.length>0&&On(r,e,t),o&&Y.viewport(U.copy(o)),r.length>0&&Ln(r,e,t),a.length>0&&Ln(a,e,t),i.length>0&&Ln(i,e,t),Y.buffers.depth.setTest(!0),Y.buffers.depth.setMask(!0),Y.buffers.color.setMask(!0),Y.setPolygonOffset(!1)}function On(n,e,t){var o=X.isWebGL2;null===O&&(O=new Ro(1,1,{generateMipmaps:!0,type:q.has("EXT_color_buffer_half_float")?ae:Kn,minFilter:Qn,samples:o&&!0===i?4:0})),d.getDrawingBufferSize(A),o?O.setSize(A.x,A.y):O.setSize(eo(A.x),eo(A.y));var r=d.getRenderTarget();d.setRenderTarget(O),d.clear();var a=d.toneMapping;d.toneMapping=kn,Ln(n,e,t),d.toneMapping=a,J.updateMultisampleRenderTarget(O),J.updateRenderTargetMipmap(O),d.setRenderTarget(r)}function Ln(n,e,t){for(var o=!0===e.isScene?e.overrideMaterial:null,r=0,a=n.length;r<a;r++){var i=n[r],v=i.object,c=i.geometry,l=null===o?i.material:o,s=i.group;v.layers.test(t.layers)&&An(v,e,t,c,l,s)}}function An(n,e,t,o,r,a){n.onBeforeRender(d,e,t,o,r,a),n.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse,n.matrixWorld),n.normalMatrix.getNormalMatrix(n.modelViewMatrix),r.onBeforeRender(d,e,t,o,n,a),!0===r.transparent&&r.side===H?(r.side=W,r.needsUpdate=!0,d.renderBufferDirect(t,e,o,r,n,a),r.side=V,r.needsUpdate=!0,d.renderBufferDirect(t,e,o,r,n,a),r.side=H):d.renderBufferDirect(t,e,o,r,n,a),n.onAfterRender(d,e,t,o,r,a)}function Gn(n,e,t){!0!==e.isScene&&(e=N);var o=Q.get(n),r=f.state.lights,a=f.state.shadowsArray,i=r.state.version,v=on.getParameters(n,r.state,a,e,t),c=on.getProgramCacheKey(v),l=o.programs;o.environment=n.isMeshStandardMaterial?e.environment:null,o.fog=e.fog,o.envMap=(n.isMeshStandardMaterial?$:K).get(n.envMap||o.environment),void 0===l&&(n.addEventListener("dispose",zn),l=new Map,o.programs=l);var s=l.get(c);if(void 0!==s){if(o.currentProgram===s&&o.lightsStateVersion===i)return Nn(n,v),s}else v.uniforms=on.getUniforms(n),n.onBuild(t,v,d),n.onBeforeCompile(v,d),s=on.acquireProgram(v,c),l.set(c,s),o.uniforms=v.uniforms;var u=o.uniforms;(n.isShaderMaterial||n.isRawShaderMaterial)&&!0!==n.clipping||(u.clippingPlanes=cn.uniform),Nn(n,v),o.needsLights=Vn(n),o.lightsStateVersion=i,o.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotLightMatrix.value=r.state.spotLightMatrix,u.spotLightMap.value=r.state.spotLightMap,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix);var p=s.getUniforms(),m=Nv.seqWithValue(p.seq,u);return o.currentProgram=s,o.uniformsList=m,s}function Nn(n,e){var t=Q.get(n);t.outputEncoding=e.outputEncoding,t.instancing=e.instancing,t.skinning=e.skinning,t.morphTargets=e.morphTargets,t.morphNormals=e.morphNormals,t.morphColors=e.morphColors,t.morphTargetsCount=e.morphTargetsCount,t.numClippingPlanes=e.numClippingPlanes,t.numIntersection=e.numClipIntersection,t.vertexAlphas=e.vertexAlphas,t.vertexTangents=e.vertexTangents,t.toneMapping=e.toneMapping}function Bn(n,e,t,o,r){!0!==e.isScene&&(e=N),J.resetTextureUnits();var a=e.fog,i=o.isMeshStandardMaterial?e.environment:null,v=null===g?d.outputEncoding:!0===g.isXRRenderTarget?g.texture.encoding:vt,c=(o.isMeshStandardMaterial?$:K).get(o.envMap||i),l=!0===o.vertexColors&&!!t.attributes.color&&4===t.attributes.color.itemSize,s=!!o.normalMap&&!!t.attributes.tangent,u=!!t.morphAttributes.position,p=!!t.morphAttributes.normal,m=!!t.morphAttributes.color,h=o.toneMapped?d.toneMapping:kn,x=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,y=void 0!==x?x.length:0,U=Q.get(o),w=f.state.lights;if(!0===I&&(!0===E||n!==_)){var S=n===_&&o.id===b;cn.setState(o,n,S)}var M=!1;o.version===U.__version?U.needsLights&&U.lightsStateVersion!==w.state.version||U.outputEncoding!==v||r.isInstancedMesh&&!1===U.instancing?M=!0:r.isInstancedMesh||!0!==U.instancing?r.isSkinnedMesh&&!1===U.skinning?M=!0:r.isSkinnedMesh||!0!==U.skinning?U.envMap!==c||!0===o.fog&&U.fog!==a?M=!0:void 0===U.numClippingPlanes||U.numClippingPlanes===cn.numPlanes&&U.numIntersection===cn.numIntersection?(U.vertexAlphas!==l||U.vertexTangents!==s||U.morphTargets!==u||U.morphNormals!==p||U.morphColors!==m||U.toneMapping!==h||!0===X.isWebGL2&&U.morphTargetsCount!==y)&&(M=!0):M=!0:M=!0:M=!0:(M=!0,U.__version=o.version);var C=U.currentProgram;!0===M&&(C=Gn(o,e,r));var T=!1,R=!1,D=!1,P=C.getUniforms(),F=U.uniforms;if(Y.useProgram(C.program)&&(T=!0,R=!0,D=!0),o.id!==b&&(b=o.id,R=!0),T||_!==n){if(P.setValue(xn,"projectionMatrix",n.projectionMatrix),X.logarithmicDepthBuffer&&P.setValue(xn,"logDepthBufFC",2/(Math.log(n.far+1)/Math.LN2)),_!==n&&(_=n,R=!0,D=!0),o.isShaderMaterial||o.isMeshPhongMaterial||o.isMeshToonMaterial||o.isMeshStandardMaterial||o.envMap){var j=P.map.cameraPosition;void 0!==j&&j.setValue(xn,G.setFromMatrixPosition(n.matrixWorld))}(o.isMeshPhongMaterial||o.isMeshToonMaterial||o.isMeshLambertMaterial||o.isMeshBasicMaterial||o.isMeshStandardMaterial||o.isShaderMaterial)&&P.setValue(xn,"isOrthographic",!0===n.isOrthographicCamera),(o.isMeshPhongMaterial||o.isMeshToonMaterial||o.isMeshLambertMaterial||o.isMeshBasicMaterial||o.isMeshStandardMaterial||o.isShaderMaterial||o.isShadowMaterial||r.isSkinnedMesh)&&P.setValue(xn,"viewMatrix",n.matrixWorldInverse)}if(r.isSkinnedMesh){P.setOptional(xn,r,"bindMatrix"),P.setOptional(xn,r,"bindMatrixInverse");var L=r.skeleton;L&&(X.floatVertexTextures?(null===L.boneTexture&&L.computeBoneTexture(),P.setValue(xn,"boneTexture",L.boneTexture,J),P.setValue(xn,"boneTextureSize",L.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}var A=t.morphAttributes;if((void 0!==A.position||void 0!==A.normal||void 0!==A.color&&!0===X.isWebGL2)&&un.update(r,t,o,C),(R||U.receiveShadow!==r.receiveShadow)&&(U.receiveShadow=r.receiveShadow,P.setValue(xn,"receiveShadow",r.receiveShadow)),o.isMeshGouraudMaterial&&null!==o.envMap&&(F.envMap.value=c,F.flipEnvMap.value=c.isCubeTexture&&!1===c.isRenderTargetTexture?-1:1),R&&(P.setValue(xn,"toneMappingExposure",d.toneMappingExposure),U.needsLights&&qn(F,D),a&&!0===o.fog&&rn.refreshFogUniforms(F,a),rn.refreshMaterialUniforms(F,o,k,z,O),Nv.upload(xn,U.uniformsList,F,J)),o.isShaderMaterial&&!0===o.uniformsNeedUpdate&&(Nv.upload(xn,U.uniformsList,F,J),o.uniformsNeedUpdate=!1),o.isSpriteMaterial&&P.setValue(xn,"center",r.center),P.setValue(xn,"modelViewMatrix",r.modelViewMatrix),P.setValue(xn,"normalMatrix",r.normalMatrix),P.setValue(xn,"modelMatrix",r.matrixWorld),o.isShaderMaterial||o.isRawShaderMaterial)for(var B=o.uniformsGroups,q=0,V=B.length;q<V;q++)if(X.isWebGL2){var W=B[q];hn.update(W,C),hn.bind(W,C)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");return C}function qn(n,e){n.ambientLightColor.needsUpdate=e,n.lightProbe.needsUpdate=e,n.directionalLights.needsUpdate=e,n.directionalLightShadows.needsUpdate=e,n.pointLights.needsUpdate=e,n.pointLightShadows.needsUpdate=e,n.spotLights.needsUpdate=e,n.spotLightShadows.needsUpdate=e,n.rectAreaLights.needsUpdate=e,n.hemisphereLights.needsUpdate=e}function Vn(n){return n.isMeshLambertMaterial||n.isMeshToonMaterial||n.isMeshPhongMaterial||n.isMeshStandardMaterial||n.isShadowMaterial||n.isShaderMaterial&&!0===n.lights}jn.setAnimationLoop(Dn),"undefined"!==typeof self&&jn.setContext(self),this.setAnimationLoop=function(n){Rn=n,Un.setAnimationLoop(n),null===n?jn.stop():jn.start()},Un.addEventListener("sessionstart",Pn),Un.addEventListener("sessionend",Fn),this.render=function(n,e){if(void 0===e||!0===e.isCamera){if(!0!==h){!0===n.matrixWorldAutoUpdate&&n.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===Un.enabled&&!0===Un.isPresenting&&(!0===Un.cameraAutoUpdate&&Un.updateCamera(e),e=Un.getCamera()),!0===n.isScene&&n.onBeforeRender(d,n,e,g),(f=vn.get(n,m.length)).init(),m.push(f),L.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),j.setFromProjectionMatrix(L),E=this.localClippingEnabled,I=cn.init(this.clippingPlanes,E,e),(u=an.get(n,p.length)).init(),p.push(u),In(n,e,0,d.sortObjects),u.finish(),!0===d.sortObjects&&u.sort(C,T),!0===I&&cn.beginShadows();var t=f.state.shadowsArray;if(ln.render(t,n,e),!0===I&&cn.endShadows(),!0===this.info.autoReset&&this.info.reset(),sn.render(u,n),f.setupLights(d.physicallyCorrectLights),e.isArrayCamera)for(var o=e.cameras,r=0,a=o.length;r<a;r++){var i=o[r];En(u,n,i,i.viewport)}else En(u,n,e);null!==g&&(J.updateMultisampleRenderTarget(g),J.updateRenderTargetMipmap(g)),!0===n.isScene&&n.onAfterRender(d,n,e),dn.resetDefaultState(),b=-1,_=null,m.pop(),f=m.length>0?m[m.length-1]:null,p.pop(),u=p.length>0?p[p.length-1]:null}}else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")},this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return y},this.getRenderTarget=function(){return g},this.setRenderTargetTextures=function(n,e,t){Q.get(n.texture).__webglTexture=e,Q.get(n.depthTexture).__webglTexture=t;var o=Q.get(n);o.__hasExternalTextures=!0,o.__hasExternalTextures&&(o.__autoAllocateDepthBuffer=void 0===t,o.__autoAllocateDepthBuffer||!0===q.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),o.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(n,e){var t=Q.get(n);t.__webglFramebuffer=e,t.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;g=n,x=e,y=t;var o=!0,r=null,a=!1,i=!1;if(n){var v=Q.get(n);void 0!==v.__useDefaultFramebuffer?(Y.bindFramebuffer(36160,null),o=!1):void 0===v.__webglFramebuffer?J.setupRenderTarget(n):v.__hasExternalTextures&&J.rebindTextures(n,Q.get(n.texture).__webglTexture,Q.get(n.depthTexture).__webglTexture);var c=n.texture;(c.isData3DTexture||c.isDataArrayTexture||c.isCompressedArrayTexture)&&(i=!0);var l=Q.get(n).__webglFramebuffer;n.isWebGLCubeRenderTarget?(r=l[e],a=!0):r=X.isWebGL2&&n.samples>0&&!1===J.useMultisampledRTT(n)?Q.get(n).__webglMultisampledFramebuffer:l,U.copy(n.viewport),w.copy(n.scissor),S=n.scissorTest}else U.copy(R).multiplyScalar(k).floor(),w.copy(D).multiplyScalar(k).floor(),S=P;var s=Y.bindFramebuffer(36160,r);if(s&&X.drawBuffers&&o&&Y.drawBuffers(n,r),Y.viewport(U),Y.scissor(w),Y.setScissorTest(S),a){var u=Q.get(n.texture);xn.framebufferTexture2D(36160,36064,34069+e,u.__webglTexture,t)}else if(i){var f=Q.get(n.texture),p=e||0;xn.framebufferTextureLayer(36160,36064,f.__webglTexture,t||0,p)}b=-1},this.readRenderTargetPixels=function(n,e,t,o,r,a,i){if(n&&n.isWebGLRenderTarget){var v=Q.get(n).__webglFramebuffer;if(n.isWebGLCubeRenderTarget&&void 0!==i&&(v=v[i]),v){Y.bindFramebuffer(36160,v);try{var c=n.texture,l=c.format,s=c.type;if(l!==ue&&mn.convert(l)!==xn.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");var u=s===ae&&(q.has("EXT_color_buffer_half_float")||X.isWebGL2&&q.has("EXT_color_buffer_float"));if(s!==Kn&&mn.convert(s)!==xn.getParameter(35738)&&(s!==re||!(X.isWebGL2||q.has("OES_texture_float")||q.has("WEBGL_color_buffer_float")))&&!u)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=n.width-o&&t>=0&&t<=n.height-r&&xn.readPixels(e,t,o,r,mn.convert(l),mn.convert(s),a)}finally{var f=null!==g?Q.get(g).__webglFramebuffer:null;Y.bindFramebuffer(36160,f)}}}else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")},this.copyFramebufferToTexture=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=Math.pow(2,-t),r=Math.floor(e.image.width*o),a=Math.floor(e.image.height*o);J.setTexture2D(e,0),xn.copyTexSubImage2D(3553,t,0,0,n.x,n.y,r,a),Y.unbindTexture()},this.copyTextureToTexture=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=e.image.width,a=e.image.height,i=mn.convert(t.format),v=mn.convert(t.type);J.setTexture2D(t,0),xn.pixelStorei(37440,t.flipY),xn.pixelStorei(37441,t.premultiplyAlpha),xn.pixelStorei(3317,t.unpackAlignment),e.isDataTexture?xn.texSubImage2D(3553,o,n.x,n.y,r,a,i,v,e.image.data):e.isCompressedTexture?xn.compressedTexSubImage2D(3553,o,n.x,n.y,e.mipmaps[0].width,e.mipmaps[0].height,i,e.mipmaps[0].data):xn.texSubImage2D(3553,o,n.x,n.y,i,v,e.image),0===o&&t.generateMipmaps&&xn.generateMipmap(3553),Y.unbindTexture()},this.copyTextureToTexture3D=function(n,e,t,o){var r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;if(d.isWebGL1Renderer)console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");else{var a,i=n.max.x-n.min.x+1,v=n.max.y-n.min.y+1,c=n.max.z-n.min.z+1,l=mn.convert(o.format),s=mn.convert(o.type);if(o.isData3DTexture)J.setTexture3D(o,0),a=32879;else{if(!o.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");J.setTexture2DArray(o,0),a=35866}xn.pixelStorei(37440,o.flipY),xn.pixelStorei(37441,o.premultiplyAlpha),xn.pixelStorei(3317,o.unpackAlignment);var u=xn.getParameter(3314),f=xn.getParameter(32878),p=xn.getParameter(3316),m=xn.getParameter(3315),h=xn.getParameter(32877),x=t.isCompressedTexture?t.mipmaps[0]:t.image;xn.pixelStorei(3314,x.width),xn.pixelStorei(32878,x.height),xn.pixelStorei(3316,n.min.x),xn.pixelStorei(3315,n.min.y),xn.pixelStorei(32877,n.min.z),t.isDataTexture||t.isData3DTexture?xn.texSubImage3D(a,r,e.x,e.y,e.z,i,v,c,l,s,x.data):t.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),xn.compressedTexSubImage3D(a,r,e.x,e.y,e.z,i,v,c,l,x.data)):xn.texSubImage3D(a,r,e.x,e.y,e.z,i,v,c,l,s,x),xn.pixelStorei(3314,u),xn.pixelStorei(32878,f),xn.pixelStorei(3316,p),xn.pixelStorei(3315,m),xn.pixelStorei(32877,h),0===r&&o.generateMipmaps&&xn.generateMipmap(a),Y.unbindTexture()}},this.initTexture=function(n){n.isCubeTexture?J.setTextureCube(n,0):n.isData3DTexture?J.setTexture3D(n,0):n.isDataArrayTexture||n.isCompressedArrayTexture?J.setTexture2DArray(n,0):J.setTexture2D(n,0),Y.unbindTexture()},this.resetState=function(){x=0,y=0,g=null,Y.reset(),dn.reset()},"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}var Ic=function(n){_(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return b(t)}(jc);Ic.prototype.isWebGL1Renderer=!0;var Ec,Oc=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:25e-5;y(this,n),this.isFogExp2=!0,this.name="",this.color=new wo(e),this.density=t}return b(n,[{key:"clone",value:function(){return new n(this.color,this.density)}},{key:"toJSON",value:function(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}]),n}(),Lc=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;y(this,n),this.isFog=!0,this.name="",this.color=new wo(e),this.near=t,this.far=o}return b(n,[{key:"clone",value:function(){return new n(this.color,this.near,this.far)}},{key:"toJSON",value:function(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}]),n}(),Ac=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isScene=!0,n.type="Scene",n.background=null,n.environment=null,n.fog=null,n.backgroundBlurriness=0,n.overrideMaterial=null,"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:S(n)})),n}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),null!==n.background&&(this.background=n.background.clone()),null!==n.environment&&(this.environment=n.environment.clone()),null!==n.fog&&(this.fog=n.fog.clone()),this.backgroundBlurriness=n.backgroundBlurriness,null!==n.overrideMaterial&&(this.overrideMaterial=n.overrideMaterial.clone()),this.matrixAutoUpdate=n.matrixAutoUpdate,this}},{key:"toJSON",value:function(n){var e=D(U(t.prototype),"toJSON",this).call(this,n);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.backgroundBlurriness=this.backgroundBlurriness),e}},{key:"autoUpdate",get:function(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate},set:function(n){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=n}}]),t}(Lr),Gc=function(){function n(e,t){y(this,n),this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=Pt,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Zt()}return b(n,[{key:"onUploadCallback",value:function(){}},{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"setUsage",value:function(n){return this.usage=n,this}},{key:"copy",value:function(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this}},{key:"copyAt",value:function(n,e,t){n*=this.stride,t*=e.stride;for(var o=0,r=this.stride;o<r;o++)this.array[n+o]=e.array[t+o];return this}},{key:"set",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.array.set(n,e),this}},{key:"clone",value:function(n){void 0===n.arrayBuffers&&(n.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Zt()),void 0===n.arrayBuffers[this.array.buffer._uuid]&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);var e=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),t=new this.constructor(e,this.stride);return t.setUsage(this.usage),t}},{key:"onUpload",value:function(n){return this.onUploadCallback=n,this}},{key:"toJSON",value:function(n){return void 0===n.arrayBuffers&&(n.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Zt()),void 0===n.arrayBuffers[this.array.buffer._uuid]&&(n.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}]),n}(),Nc=new Oo,Bc=function(){function n(e,t,o){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];y(this,n),this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=o,this.normalized=!0===r}return b(n,[{key:"count",get:function(){return this.data.count}},{key:"array",get:function(){return this.data.array}},{key:"needsUpdate",set:function(n){this.data.needsUpdate=n}},{key:"applyMatrix4",value:function(n){for(var e=0,t=this.data.count;e<t;e++)Nc.fromBufferAttribute(this,e),Nc.applyMatrix4(n),this.setXYZ(e,Nc.x,Nc.y,Nc.z);return this}},{key:"applyNormalMatrix",value:function(n){for(var e=0,t=this.count;e<t;e++)Nc.fromBufferAttribute(this,e),Nc.applyNormalMatrix(n),this.setXYZ(e,Nc.x,Nc.y,Nc.z);return this}},{key:"transformDirection",value:function(n){for(var e=0,t=this.count;e<t;e++)Nc.fromBufferAttribute(this,e),Nc.transformDirection(n),this.setXYZ(e,Nc.x,Nc.y,Nc.z);return this}},{key:"setX",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.data.array[n*this.data.stride+this.offset]=e,this}},{key:"setY",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.data.array[n*this.data.stride+this.offset+1]=e,this}},{key:"setZ",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.data.array[n*this.data.stride+this.offset+2]=e,this}},{key:"setW",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.data.array[n*this.data.stride+this.offset+3]=e,this}},{key:"getX",value:function(n){var e=this.data.array[n*this.data.stride+this.offset];return this.normalized&&(e=to(e,this.array)),e}},{key:"getY",value:function(n){var e=this.data.array[n*this.data.stride+this.offset+1];return this.normalized&&(e=to(e,this.array)),e}},{key:"getZ",value:function(n){var e=this.data.array[n*this.data.stride+this.offset+2];return this.normalized&&(e=to(e,this.array)),e}},{key:"getW",value:function(n){var e=this.data.array[n*this.data.stride+this.offset+3];return this.normalized&&(e=to(e,this.array)),e}},{key:"setXY",value:function(n,e,t){return n=n*this.data.stride+this.offset,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array)),this.data.array[n+0]=e,this.data.array[n+1]=t,this}},{key:"setXYZ",value:function(n,e,t,o){return n=n*this.data.stride+this.offset,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array),o=oo(o,this.array)),this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=o,this}},{key:"setXYZW",value:function(n,e,t,o,r){return n=n*this.data.stride+this.offset,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array),o=oo(o,this.array),r=oo(r,this.array)),this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=o,this.data.array[n+3]=r,this}},{key:"clone",value:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");for(var t=[],o=0;o<this.count;o++)for(var r=o*this.data.stride+this.offset,a=0;a<this.itemSize;a++)t.push(this.data.array[r+a]);return new ea(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new n(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}},{key:"toJSON",value:function(n){if(void 0===n){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");for(var e=[],t=0;t<this.count;t++)for(var o=t*this.data.stride+this.offset,r=0;r<this.itemSize;r++)e.push(this.data.array[o+r]);return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===n.interleavedBuffers&&(n.interleavedBuffers={}),void 0===n.interleavedBuffers[this.data.uuid]&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}]),n}(),qc=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isSpriteMaterial=!0,o.type="SpriteMaterial",o.color=new wo(16777215),o.map=null,o.alphaMap=null,o.rotation=0,o.sizeAttenuation=!0,o.transparent=!0,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.rotation=n.rotation,this.sizeAttenuation=n.sizeAttenuation,this.fog=n.fog,this}}]),t}(Jr),Vc=new Oo,Wc=new Oo,Hc=new Oo,Xc=new ao,Yc=new ao,Zc=new pr,Qc=new Oo,Jc=new Oo,Kc=new Oo,$c=new ao,nl=new ao,el=new ao,tl=function(n){_(t,n);var e=z(t);function t(n){var o;if(y(this,t),(o=e.call(this)).isSprite=!0,o.type="Sprite",void 0===Ec){Ec=new ga;var r=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),a=new Gc(r,5);Ec.setIndex([0,1,2,0,2,3]),Ec.setAttribute("position",new Bc(a,3,0,!1)),Ec.setAttribute("uv",new Bc(a,2,3,!1))}return o.geometry=Ec,o.material=void 0!==n?n:new qc,o.center=new ao(.5,.5),o}return b(t,[{key:"raycast",value:function(n,e){null===n.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Wc.setFromMatrixScale(this.matrixWorld),Zc.copy(n.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse,this.matrixWorld),Hc.setFromMatrixPosition(this.modelViewMatrix),n.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Wc.multiplyScalar(-Hc.z);var t,o,r=this.material.rotation;0!==r&&(o=Math.cos(r),t=Math.sin(r));var a=this.center;ol(Qc.set(-.5,-.5,0),Hc,a,Wc,t,o),ol(Jc.set(.5,-.5,0),Hc,a,Wc,t,o),ol(Kc.set(.5,.5,0),Hc,a,Wc,t,o),$c.set(0,0),nl.set(1,0),el.set(1,1);var i=n.ray.intersectTriangle(Qc,Jc,Kc,!1,Vc);if(null!==i||(ol(Jc.set(-.5,.5,0),Hc,a,Wc,t,o),nl.set(0,1),null!==(i=n.ray.intersectTriangle(Qc,Kc,Jc,!1,Vc)))){var v=n.ray.origin.distanceTo(Vc);v<n.near||v>n.far||e.push({distance:v,point:Vc.clone(),uv:Zr.getUV(Vc,Qc,Jc,Kc,$c,nl,el,new ao),face:null,object:this})}}},{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),void 0!==n.center&&this.center.copy(n.center),this.material=n.material,this}}]),t}(Lr);function ol(n,e,t,o,r,a){Xc.subVectors(n,t).addScalar(.5).multiply(o),void 0!==r?(Yc.x=a*Xc.x-r*Xc.y,Yc.y=r*Xc.x+a*Xc.y):Yc.copy(Xc),n.copy(e),n.x+=Yc.x,n.y+=Yc.y,n.applyMatrix4(Zc)}var rl=new Oo,al=new Oo,il=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this))._currentLevel=0,n.type="LOD",Object.defineProperties(S(n),{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),n.autoUpdate=!0,n}return b(t,[{key:"copy",value:function(n){D(U(t.prototype),"copy",this).call(this,n,!1);for(var e=n.levels,o=0,r=e.length;o<r;o++){var a=e[o];this.addLevel(a.object.clone(),a.distance)}return this.autoUpdate=n.autoUpdate,this}},{key:"addLevel",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;e=Math.abs(e);var t,o=this.levels;for(t=0;t<o.length&&!(e<o[t].distance);t++);return o.splice(t,0,{distance:e,object:n}),this.add(n),this}},{key:"getCurrentLevel",value:function(){return this._currentLevel}},{key:"getObjectForDistance",value:function(n){var e=this.levels;if(e.length>0){var t,o;for(t=1,o=e.length;t<o&&!(n<e[t].distance);t++);return e[t-1].object}return null}},{key:"raycast",value:function(n,e){if(this.levels.length>0){rl.setFromMatrixPosition(this.matrixWorld);var t=n.ray.origin.distanceTo(rl);this.getObjectForDistance(t).raycast(n,e)}}},{key:"update",value:function(n){var e=this.levels;if(e.length>1){rl.setFromMatrixPosition(n.matrixWorld),al.setFromMatrixPosition(this.matrixWorld);var t,o,r=rl.distanceTo(al)/n.zoom;for(e[0].object.visible=!0,t=1,o=e.length;t<o&&r>=e[t].distance;t++)e[t-1].object.visible=!1,e[t].object.visible=!0;for(this._currentLevel=t-1;t<o;t++)e[t].object.visible=!1}}},{key:"toJSON",value:function(n){var e=D(U(t.prototype),"toJSON",this).call(this,n);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];for(var o=this.levels,r=0,a=o.length;r<a;r++){var i=o[r];e.object.levels.push({object:i.object.uuid,distance:i.distance})}return e}}]),t}(Lr),vl=new Oo,cl=new To,ll=new To,sl=new Oo,ul=new pr,fl=function(n){_(t,n);var e=z(t);function t(n,o){var r;return y(this,t),(r=e.call(this,n,o)).isSkinnedMesh=!0,r.type="SkinnedMesh",r.bindMode="attached",r.bindMatrix=new pr,r.bindMatrixInverse=new pr,r}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,this}},{key:"bind",value:function(n,e){this.skeleton=n,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}},{key:"pose",value:function(){this.skeleton.pose()}},{key:"normalizeSkinWeights",value:function(){for(var n=new To,e=this.geometry.attributes.skinWeight,t=0,o=e.count;t<o;t++){n.fromBufferAttribute(e,t);var r=1/n.manhattanLength();r!==1/0?n.multiplyScalar(r):n.set(1,0,0,0),e.setXYZW(t,n.x,n.y,n.z,n.w)}}},{key:"updateMatrixWorld",value:function(n){D(U(t.prototype),"updateMatrixWorld",this).call(this,n),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}},{key:"boneTransform",value:function(n,e){var t=this.skeleton,o=this.geometry;cl.fromBufferAttribute(o.attributes.skinIndex,n),ll.fromBufferAttribute(o.attributes.skinWeight,n),vl.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(var r=0;r<4;r++){var a=ll.getComponent(r);if(0!==a){var i=cl.getComponent(r);ul.multiplyMatrices(t.bones[i].matrixWorld,t.boneInverses[i]),e.addScaledVector(sl.copy(vl).applyMatrix4(ul),a)}}return e.applyMatrix4(this.bindMatrixInverse)}}]),t}(Oa),pl=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isBone=!0,n.type="Bone",n}return b(t)}(Lr),ml=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3?arguments[3]:void 0,v=arguments.length>4?arguments[4]:void 0,c=arguments.length>5?arguments[5]:void 0,l=arguments.length>6?arguments[6]:void 0,s=arguments.length>7?arguments[7]:void 0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:Bn,f=arguments.length>9&&void 0!==arguments[9]?arguments[9]:Bn,p=arguments.length>10?arguments[10]:void 0,m=arguments.length>11?arguments[11]:void 0;return y(this,t),(n=e.call(this,null,c,l,s,u,f,i,v,p,m)).isDataTexture=!0,n.image={data:o,width:r,height:a},n.generateMipmaps=!1,n.flipY=!1,n.unpackAlignment=1,n}return b(t)}(Co),dl=new pr,hl=new pr,xl=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];y(this,n),this.uuid=Zt(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}return b(n,[{key:"init",value:function(){var n=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*n.length),0===e.length)this.calculateInverses();else if(n.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(var t=0,o=this.bones.length;t<o;t++)this.boneInverses.push(new pr)}}},{key:"calculateInverses",value:function(){this.boneInverses.length=0;for(var n=0,e=this.bones.length;n<e;n++){var t=new pr;this.bones[n]&&t.copy(this.bones[n].matrixWorld).invert(),this.boneInverses.push(t)}}},{key:"pose",value:function(){for(var n=0,e=this.bones.length;n<e;n++){var t=this.bones[n];t&&t.matrixWorld.copy(this.boneInverses[n]).invert()}for(var o=0,r=this.bones.length;o<r;o++){var a=this.bones[o];a&&(a.parent&&a.parent.isBone?(a.matrix.copy(a.parent.matrixWorld).invert(),a.matrix.multiply(a.matrixWorld)):a.matrix.copy(a.matrixWorld),a.matrix.decompose(a.position,a.quaternion,a.scale))}}},{key:"update",value:function(){for(var n=this.bones,e=this.boneInverses,t=this.boneMatrices,o=this.boneTexture,r=0,a=n.length;r<a;r++){var i=n[r]?n[r].matrixWorld:hl;dl.multiplyMatrices(i,e[r]),dl.toArray(t,16*r)}null!==o&&(o.needsUpdate=!0)}},{key:"clone",value:function(){return new n(this.bones,this.boneInverses)}},{key:"computeBoneTexture",value:function(){var n=Math.sqrt(4*this.bones.length);n=no(n),n=Math.max(n,4);var e=new Float32Array(n*n*4);e.set(this.boneMatrices);var t=new ml(e,n,n,ue,re);return t.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=t,this.boneTextureSize=n,this}},{key:"getBoneByName",value:function(n){for(var e=0,t=this.bones.length;e<t;e++){var o=this.bones[e];if(o.name===n)return o}}},{key:"dispose",value:function(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}},{key:"fromJSON",value:function(n,e){this.uuid=n.uuid;for(var t=0,o=n.bones.length;t<o;t++){var r=n.bones[t],a=e[r];void 0===a&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),a=new pl),this.bones.push(a),this.boneInverses.push((new pr).fromArray(n.boneInverses[t]))}return this.init(),this}},{key:"toJSON",value:function(){var n={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};n.uuid=this.uuid;for(var e=this.bones,t=this.boneInverses,o=0,r=e.length;o<r;o++){var a=e[o];n.bones.push(a.uuid);var i=t[o];n.boneInverses.push(i.toArray())}return n}}]),n}(),yl=function(n){_(t,n);var e=z(t);function t(n,o,r){var a,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return y(this,t),(a=e.call(this,n,o,r)).isInstancedBufferAttribute=!0,a.meshPerAttribute=i,a}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.meshPerAttribute=n.meshPerAttribute,this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}}]),t}(ea),gl=new pr,bl=new pr,_l=[],Ul=new pr,wl=new Oa,Sl=function(n){_(t,n);var e=z(t);function t(n,o,r){var a;y(this,t),(a=e.call(this,n,o)).isInstancedMesh=!0,a.instanceMatrix=new yl(new Float32Array(16*r),16),a.instanceColor=null,a.count=r,a.frustumCulled=!1;for(var i=0;i<r;i++)a.setMatrixAt(i,Ul);return a}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.instanceMatrix.copy(n.instanceMatrix),null!==n.instanceColor&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,this}},{key:"getColorAt",value:function(n,e){e.fromArray(this.instanceColor.array,3*n)}},{key:"getMatrixAt",value:function(n,e){e.fromArray(this.instanceMatrix.array,16*n)}},{key:"raycast",value:function(n,e){var t=this.matrixWorld,o=this.count;if(wl.geometry=this.geometry,wl.material=this.material,void 0!==wl.material)for(var r=0;r<o;r++){this.getMatrixAt(r,gl),bl.multiplyMatrices(t,gl),wl.matrixWorld=bl,wl.raycast(n,_l);for(var a=0,i=_l.length;a<i;a++){var v=_l[a];v.instanceId=r,v.object=this,e.push(v)}_l.length=0}}},{key:"setColorAt",value:function(n,e){null===this.instanceColor&&(this.instanceColor=new yl(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*n)}},{key:"setMatrixAt",value:function(n,e){e.toArray(this.instanceMatrix.array,16*n)}},{key:"updateMorphTargets",value:function(){}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}}]),t}(Oa),Ml=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isLineBasicMaterial=!0,o.type="LineBasicMaterial",o.color=new wo(16777215),o.linewidth=1,o.linecap="round",o.linejoin="round",o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.linewidth=n.linewidth,this.linecap=n.linecap,this.linejoin=n.linejoin,this.fog=n.fog,this}}]),t}(Jr),zl=new Oo,kl=new Oo,Cl=new pr,Tl=new fr,Rl=new rr,Dl=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ga,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Ml;return y(this,t),(n=e.call(this)).isLine=!0,n.type="Line",n.geometry=o,n.material=r,n.updateMorphTargets(),n}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.material=n.material,this.geometry=n.geometry,this}},{key:"computeLineDistances",value:function(){var n=this.geometry;if(null===n.index){for(var e=n.attributes.position,t=[0],o=1,r=e.count;o<r;o++)zl.fromBufferAttribute(e,o-1),kl.fromBufferAttribute(e,o),t[o]=t[o-1],t[o]+=zl.distanceTo(kl);n.setAttribute("lineDistance",new sa(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}},{key:"raycast",value:function(n,e){var t=this.geometry,o=this.matrixWorld,r=n.params.Line.threshold,a=t.drawRange;if(null===t.boundingSphere&&t.computeBoundingSphere(),Rl.copy(t.boundingSphere),Rl.applyMatrix4(o),Rl.radius+=r,!1!==n.ray.intersectsSphere(Rl)){Cl.copy(o).invert(),Tl.copy(n.ray).applyMatrix4(Cl);var i=r/((this.scale.x+this.scale.y+this.scale.z)/3),v=i*i,c=new Oo,l=new Oo,s=new Oo,u=new Oo,f=this.isLineSegments?2:1,p=t.index,m=t.attributes.position;if(null!==p)for(var d=Math.max(0,a.start),h=Math.min(p.count,a.start+a.count)-1;d<h;d+=f){var x=p.getX(d),y=p.getX(d+1);if(c.fromBufferAttribute(m,x),l.fromBufferAttribute(m,y),!(Tl.distanceSqToSegment(c,l,u,s)>v)){u.applyMatrix4(this.matrixWorld);var g=n.ray.origin.distanceTo(u);g<n.near||g>n.far||e.push({distance:g,point:s.clone().applyMatrix4(this.matrixWorld),index:d,face:null,faceIndex:null,object:this})}}else for(var b=Math.max(0,a.start),_=Math.min(m.count,a.start+a.count)-1;b<_;b+=f){if(c.fromBufferAttribute(m,b),l.fromBufferAttribute(m,b+1),!(Tl.distanceSqToSegment(c,l,u,s)>v)){u.applyMatrix4(this.matrixWorld);var U=n.ray.origin.distanceTo(u);U<n.near||U>n.far||e.push({distance:U,point:s.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}}}},{key:"updateMorphTargets",value:function(){var n=this.geometry.morphAttributes,e=Object.keys(n);if(e.length>0){var t=n[e[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var o=0,r=t.length;o<r;o++){var a=t[o].name||String(o);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=o}}}}}]),t}(Lr),Pl=new Oo,Fl=new Oo,jl=function(n){_(t,n);var e=z(t);function t(n,o){var r;return y(this,t),(r=e.call(this,n,o)).isLineSegments=!0,r.type="LineSegments",r}return b(t,[{key:"computeLineDistances",value:function(){var n=this.geometry;if(null===n.index){for(var e=n.attributes.position,t=[],o=0,r=e.count;o<r;o+=2)Pl.fromBufferAttribute(e,o),Fl.fromBufferAttribute(e,o+1),t[o]=0===o?0:t[o-1],t[o+1]=t[o]+Pl.distanceTo(Fl);n.setAttribute("lineDistance",new sa(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}]),t}(Dl),Il=function(n){_(t,n);var e=z(t);function t(n,o){var r;return y(this,t),(r=e.call(this,n,o)).isLineLoop=!0,r.type="LineLoop",r}return b(t)}(Dl),El=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isPointsMaterial=!0,o.type="PointsMaterial",o.color=new wo(16777215),o.map=null,o.alphaMap=null,o.size=1,o.sizeAttenuation=!0,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.size=n.size,this.sizeAttenuation=n.sizeAttenuation,this.fog=n.fog,this}}]),t}(Jr),Ol=new pr,Ll=new fr,Al=new rr,Gl=new Oo,Nl=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ga,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new El;return y(this,t),(n=e.call(this)).isPoints=!0,n.type="Points",n.geometry=o,n.material=r,n.updateMorphTargets(),n}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.material=n.material,this.geometry=n.geometry,this}},{key:"raycast",value:function(n,e){var t=this.geometry,o=this.matrixWorld,r=n.params.Points.threshold,a=t.drawRange;if(null===t.boundingSphere&&t.computeBoundingSphere(),Al.copy(t.boundingSphere),Al.applyMatrix4(o),Al.radius+=r,!1!==n.ray.intersectsSphere(Al)){Ol.copy(o).invert(),Ll.copy(n.ray).applyMatrix4(Ol);var i=r/((this.scale.x+this.scale.y+this.scale.z)/3),v=i*i,c=t.index,l=t.attributes.position;if(null!==c)for(var s=Math.max(0,a.start),u=Math.min(c.count,a.start+a.count);s<u;s++){var f=c.getX(s);Gl.fromBufferAttribute(l,f),Bl(Gl,f,v,o,n,e,this)}else for(var p=Math.max(0,a.start),m=Math.min(l.count,a.start+a.count);p<m;p++)Gl.fromBufferAttribute(l,p),Bl(Gl,p,v,o,n,e,this)}}},{key:"updateMorphTargets",value:function(){var n=this.geometry.morphAttributes,e=Object.keys(n);if(e.length>0){var t=n[e[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var o=0,r=t.length;o<r;o++){var a=t[o].name||String(o);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=o}}}}}]),t}(Lr);function Bl(n,e,t,o,r,a,i){var v=Ll.distanceSqToPoint(n);if(v<t){var c=new Oo;Ll.closestPointToPoint(n,c),c.applyMatrix4(o);var l=r.ray.origin.distanceTo(c);if(l<r.near||l>r.far)return;a.push({distance:l,distanceToRay:Math.sqrt(v),point:c,index:e,face:null,object:i})}}var ql=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v,c,l,s){var u;y(this,t),(u=e.call(this,n,o,r,a,i,v,c,l,s)).isVideoTexture=!0,u.minFilter=void 0!==v?v:Xn,u.magFilter=void 0!==i?i:Xn,u.generateMipmaps=!1;var f=S(u);return"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback((function e(){f.needsUpdate=!0,n.requestVideoFrameCallback(e)})),u}return b(t,[{key:"clone",value:function(){return new this.constructor(this.image).copy(this)}},{key:"update",value:function(){var n=this.image;!1==="requestVideoFrameCallback"in n&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}]),t}(Co),Vl=function(n){_(t,n);var e=z(t);function t(n,o,r){var a;return y(this,t),(a=e.call(this,{width:n,height:o})).isFramebufferTexture=!0,a.format=r,a.magFilter=Bn,a.minFilter=Bn,a.generateMipmaps=!1,a.needsUpdate=!0,a}return b(t)}(Co),Wl=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v,c,l,s,u,f,p){var m;return y(this,t),(m=e.call(this,null,v,c,l,s,u,a,i,f,p)).isCompressedTexture=!0,m.image={width:o,height:r},m.mipmaps=n,m.flipY=!1,m.generateMipmaps=!1,m}return b(t)}(Co),Hl=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v){var c;return y(this,t),(c=e.call(this,n,o,r,i,v)).isCompressedArrayTexture=!0,c.image.depth=a,c.wrapR=Gn,c}return b(t)}(Wl),Xl=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v,c,l,s){var u;return y(this,t),(u=e.call(this,n,o,r,a,i,v,c,l,s)).isCanvasTexture=!0,u.needsUpdate=!0,u}return b(t)}(Co),Yl=function(){function n(){y(this,n),this.type="Curve",this.arcLengthDivisions=200}return b(n,[{key:"getPoint",value:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}},{key:"getPointAt",value:function(n,e){var t=this.getUtoTmapping(n);return this.getPoint(t,e)}},{key:"getPoints",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:5,e=[],t=0;t<=n;t++)e.push(this.getPoint(t/n));return e}},{key:"getSpacedPoints",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:5,e=[],t=0;t<=n;t++)e.push(this.getPointAt(t/n));return e}},{key:"getLength",value:function(){var n=this.getLengths();return n[n.length-1]}},{key:"getLengths",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var e,t=[],o=this.getPoint(0),r=0;t.push(0);for(var a=1;a<=n;a++)r+=(e=this.getPoint(a/n)).distanceTo(o),t.push(r),o=e;return this.cacheArcLengths=t,t}},{key:"updateArcLengths",value:function(){this.needsUpdate=!0,this.getLengths()}},{key:"getUtoTmapping",value:function(n,e){var t,o=this.getLengths(),r=0,a=o.length;t=e||n*o[a-1];for(var i,v=0,c=a-1;v<=c;)if((i=o[r=Math.floor(v+(c-v)/2)]-t)<0)v=r+1;else{if(!(i>0)){c=r;break}c=r-1}if(o[r=c]===t)return r/(a-1);var l=o[r];return(r+(t-l)/(o[r+1]-l))/(a-1)}},{key:"getTangent",value:function(n,e){var t=1e-4,o=n-t,r=n+t;o<0&&(o=0),r>1&&(r=1);var a=this.getPoint(o),i=this.getPoint(r),v=e||(a.isVector2?new ao:new Oo);return v.copy(i).sub(a).normalize(),v}},{key:"getTangentAt",value:function(n,e){var t=this.getUtoTmapping(n);return this.getTangent(t,e)}},{key:"computeFrenetFrames",value:function(n,e){for(var t=new Oo,o=[],r=[],a=[],i=new Oo,v=new pr,c=0;c<=n;c++){var l=c/n;o[c]=this.getTangentAt(l,new Oo)}r[0]=new Oo,a[0]=new Oo;var s=Number.MAX_VALUE,u=Math.abs(o[0].x),f=Math.abs(o[0].y),p=Math.abs(o[0].z);u<=s&&(s=u,t.set(1,0,0)),f<=s&&(s=f,t.set(0,1,0)),p<=s&&t.set(0,0,1),i.crossVectors(o[0],t).normalize(),r[0].crossVectors(o[0],i),a[0].crossVectors(o[0],r[0]);for(var m=1;m<=n;m++){if(r[m]=r[m-1].clone(),a[m]=a[m-1].clone(),i.crossVectors(o[m-1],o[m]),i.length()>Number.EPSILON){i.normalize();var d=Math.acos(Qt(o[m-1].dot(o[m]),-1,1));r[m].applyMatrix4(v.makeRotationAxis(i,d))}a[m].crossVectors(o[m],r[m])}if(!0===e){var h=Math.acos(Qt(r[0].dot(r[n]),-1,1));h/=n,o[0].dot(i.crossVectors(r[0],r[n]))>0&&(h=-h);for(var x=1;x<=n;x++)r[x].applyMatrix4(v.makeRotationAxis(o[x],h*x)),a[x].crossVectors(o[x],r[x])}return{tangents:o,normals:r,binormals:a}}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}},{key:"toJSON",value:function(){var n={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n}},{key:"fromJSON",value:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}}]),n}(),Zl=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2*Math.PI,l=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;return y(this,t),(n=e.call(this)).isEllipseCurve=!0,n.type="EllipseCurve",n.aX=o,n.aY=r,n.xRadius=a,n.yRadius=i,n.aStartAngle=v,n.aEndAngle=c,n.aClockwise=l,n.aRotation=s,n}return b(t,[{key:"getPoint",value:function(n,e){for(var t=e||new ao,o=2*Math.PI,r=this.aEndAngle-this.aStartAngle,a=Math.abs(r)<Number.EPSILON;r<0;)r+=o;for(;r>o;)r-=o;r<Number.EPSILON&&(r=a?0:o),!0!==this.aClockwise||a||(r===o?r=-o:r-=o);var i=this.aStartAngle+n*r,v=this.aX+this.xRadius*Math.cos(i),c=this.aY+this.yRadius*Math.sin(i);if(0!==this.aRotation){var l=Math.cos(this.aRotation),s=Math.sin(this.aRotation),u=v-this.aX,f=c-this.aY;v=u*l-f*s+this.aX,c=u*s+f*l+this.aY}return t.set(v,c)}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.aX=this.aX,n.aY=this.aY,n.xRadius=this.xRadius,n.yRadius=this.yRadius,n.aStartAngle=this.aStartAngle,n.aEndAngle=this.aEndAngle,n.aClockwise=this.aClockwise,n.aRotation=this.aRotation,n}},{key:"fromJSON",value:function(n){return D(U(t.prototype),"fromJSON",this).call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this}}]),t}(Yl),Ql=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v){var c;return y(this,t),(c=e.call(this,n,o,r,r,a,i,v)).isArcCurve=!0,c.type="ArcCurve",c}return b(t)}(Zl);function Jl(){var n=0,e=0,t=0,o=0;function r(r,a,i,v){n=r,e=i,t=-3*r+3*a-2*i-v,o=2*r-2*a+i+v}return{initCatmullRom:function(n,e,t,o,a){r(e,t,a*(t-n),a*(o-e))},initNonuniformCatmullRom:function(n,e,t,o,a,i,v){var c=(e-n)/a-(t-n)/(a+i)+(t-e)/i,l=(t-e)/i-(o-e)/(i+v)+(o-t)/v;r(e,t,c*=i,l*=i)},calc:function(r){var a=r*r;return n+e*r+t*a+o*(a*r)}}}var Kl=new Oo,$l=new Jl,ns=new Jl,es=new Jl,ts=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"centripetal",i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;return y(this,t),(n=e.call(this)).isCatmullRomCurve3=!0,n.type="CatmullRomCurve3",n.points=o,n.closed=r,n.curveType=a,n.tension=i,n}return b(t,[{key:"getPoint",value:function(n){var e,t,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,r=o,a=this.points,i=a.length,v=(i-(this.closed?0:1))*n,c=Math.floor(v),l=v-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/i)+1)*i:0===l&&c===i-1&&(c=i-2,l=1),this.closed||c>0?e=a[(c-1)%i]:(Kl.subVectors(a[0],a[1]).add(a[0]),e=Kl);var s=a[c%i],u=a[(c+1)%i];if(this.closed||c+2<i?t=a[(c+2)%i]:(Kl.subVectors(a[i-1],a[i-2]).add(a[i-1]),t=Kl),"centripetal"===this.curveType||"chordal"===this.curveType){var f="chordal"===this.curveType?.5:.25,p=Math.pow(e.distanceToSquared(s),f),m=Math.pow(s.distanceToSquared(u),f),d=Math.pow(u.distanceToSquared(t),f);m<1e-4&&(m=1),p<1e-4&&(p=m),d<1e-4&&(d=m),$l.initNonuniformCatmullRom(e.x,s.x,u.x,t.x,p,m,d),ns.initNonuniformCatmullRom(e.y,s.y,u.y,t.y,p,m,d),es.initNonuniformCatmullRom(e.z,s.z,u.z,t.z,p,m,d)}else"catmullrom"===this.curveType&&($l.initCatmullRom(e.x,s.x,u.x,t.x,this.tension),ns.initCatmullRom(e.y,s.y,u.y,t.y,this.tension),es.initCatmullRom(e.z,s.z,u.z,t.z,this.tension));return r.set($l.calc(l),ns.calc(l),es.calc(l)),r}},{key:"copy",value:function(n){D(U(t.prototype),"copy",this).call(this,n),this.points=[];for(var e=0,o=n.points.length;e<o;e++){var r=n.points[e];this.points.push(r.clone())}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);n.points=[];for(var e=0,o=this.points.length;e<o;e++){var r=this.points[e];n.points.push(r.toArray())}return n.closed=this.closed,n.curveType=this.curveType,n.tension=this.tension,n}},{key:"fromJSON",value:function(n){D(U(t.prototype),"fromJSON",this).call(this,n),this.points=[];for(var e=0,o=n.points.length;e<o;e++){var r=n.points[e];this.points.push((new Oo).fromArray(r))}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this}}]),t}(Yl);function os(n,e,t,o,r){var a=.5*(o-e),i=.5*(r-t),v=n*n;return(2*t-2*o+a+i)*(n*v)+(-3*t+3*o-2*a-i)*v+a*n+t}function rs(n,e,t,o){return function(n,e){var t=1-n;return t*t*e}(n,e)+function(n,e){return 2*(1-n)*n*e}(n,t)+function(n,e){return n*n*e}(n,o)}function as(n,e,t,o,r){return function(n,e){var t=1-n;return t*t*t*e}(n,e)+function(n,e){var t=1-n;return 3*t*t*n*e}(n,t)+function(n,e){return 3*(1-n)*n*n*e}(n,o)+function(n,e){return n*n*n*e}(n,r)}var is=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ao,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new ao,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new ao;return y(this,t),(n=e.call(this)).isCubicBezierCurve=!0,n.type="CubicBezierCurve",n.v0=o,n.v1=r,n.v2=a,n.v3=i,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,t=e,o=this.v0,r=this.v1,a=this.v2,i=this.v3;return t.set(as(n,o.x,r.x,a.x,i.x),as(n,o.y,r.y,a.y,i.y)),t}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n}},{key:"fromJSON",value:function(n){return D(U(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this}}]),t}(Yl),vs=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Oo,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Oo;return y(this,t),(n=e.call(this)).isCubicBezierCurve3=!0,n.type="CubicBezierCurve3",n.v0=o,n.v1=r,n.v2=a,n.v3=i,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,t=e,o=this.v0,r=this.v1,a=this.v2,i=this.v3;return t.set(as(n,o.x,r.x,a.x,i.x),as(n,o.y,r.y,a.y,i.y),as(n,o.z,r.z,a.z,i.z)),t}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n}},{key:"fromJSON",value:function(n){return D(U(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this}}]),t}(Yl),cs=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ao,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao;return y(this,t),(n=e.call(this)).isLineCurve=!0,n.type="LineCurve",n.v1=o,n.v2=r,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,t=e;return 1===n?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t}},{key:"getPointAt",value:function(n,e){return this.getPoint(n,e)}},{key:"getTangent",value:function(n,e){var t=e||new ao;return t.copy(this.v2).sub(this.v1).normalize(),t}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return D(U(t.prototype),"fromJSON",this).call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}(Yl),ls=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo;return y(this,t),(n=e.call(this)).isLineCurve3=!0,n.type="LineCurve3",n.v1=o,n.v2=r,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,t=e;return 1===n?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t}},{key:"getPointAt",value:function(n,e){return this.getPoint(n,e)}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return D(U(t.prototype),"fromJSON",this).call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}(Yl),ss=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ao,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new ao;return y(this,t),(n=e.call(this)).isQuadraticBezierCurve=!0,n.type="QuadraticBezierCurve",n.v0=o,n.v1=r,n.v2=a,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,t=e,o=this.v0,r=this.v1,a=this.v2;return t.set(rs(n,o.x,r.x,a.x),rs(n,o.y,r.y,a.y)),t}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return D(U(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}(Yl),us=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Oo;return y(this,t),(n=e.call(this)).isQuadraticBezierCurve3=!0,n.type="QuadraticBezierCurve3",n.v0=o,n.v1=r,n.v2=a,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,t=e,o=this.v0,r=this.v1,a=this.v2;return t.set(rs(n,o.x,r.x,a.x),rs(n,o.y,r.y,a.y),rs(n,o.z,r.z,a.z)),t}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return D(U(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}(Yl),fs=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return y(this,t),(n=e.call(this)).isSplineCurve=!0,n.type="SplineCurve",n.points=o,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,t=e,o=this.points,r=(o.length-1)*n,a=Math.floor(r),i=r-a,v=o[0===a?a:a-1],c=o[a],l=o[a>o.length-2?o.length-1:a+1],s=o[a>o.length-3?o.length-1:a+2];return t.set(os(i,v.x,c.x,l.x,s.x),os(i,v.y,c.y,l.y,s.y)),t}},{key:"copy",value:function(n){D(U(t.prototype),"copy",this).call(this,n),this.points=[];for(var e=0,o=n.points.length;e<o;e++){var r=n.points[e];this.points.push(r.clone())}return this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);n.points=[];for(var e=0,o=this.points.length;e<o;e++){var r=this.points[e];n.points.push(r.toArray())}return n}},{key:"fromJSON",value:function(n){D(U(t.prototype),"fromJSON",this).call(this,n),this.points=[];for(var e=0,o=n.points.length;e<o;e++){var r=n.points[e];this.points.push((new ao).fromArray(r))}return this}}]),t}(Yl),ps=Object.freeze({__proto__:null,ArcCurve:Ql,CatmullRomCurve3:ts,CubicBezierCurve:is,CubicBezierCurve3:vs,EllipseCurve:Zl,LineCurve:cs,LineCurve3:ls,QuadraticBezierCurve:ss,QuadraticBezierCurve3:us,SplineCurve:fs}),ms=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).type="CurvePath",n.curves=[],n.autoClose=!1,n}return b(t,[{key:"add",value:function(n){this.curves.push(n)}},{key:"closePath",value:function(){var n=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);n.equals(e)||this.curves.push(new cs(e,n))}},{key:"getPoint",value:function(n,e){for(var t=n*this.getLength(),o=this.getCurveLengths(),r=0;r<o.length;){if(o[r]>=t){var a=o[r]-t,i=this.curves[r],v=i.getLength(),c=0===v?0:1-a/v;return i.getPointAt(c,e)}r++}return null}},{key:"getLength",value:function(){var n=this.getCurveLengths();return n[n.length-1]}},{key:"updateArcLengths",value:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}},{key:"getCurveLengths",value:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var n=[],e=0,t=0,o=this.curves.length;t<o;t++)e+=this.curves[t].getLength(),n.push(e);return this.cacheLengths=n,n}},{key:"getSpacedPoints",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:40,e=[],t=0;t<=n;t++)e.push(this.getPoint(t/n));return this.autoClose&&e.push(e[0]),e}},{key:"getPoints",value:function(){for(var n,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:12,t=[],o=0,r=this.curves;o<r.length;o++)for(var a=r[o],i=a.isEllipseCurve?2*e:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?e*a.points.length:e,v=a.getPoints(i),c=0;c<v.length;c++){var l=v[c];n&&n.equals(l)||(t.push(l),n=l)}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}},{key:"copy",value:function(n){D(U(t.prototype),"copy",this).call(this,n),this.curves=[];for(var e=0,o=n.curves.length;e<o;e++){var r=n.curves[e];this.curves.push(r.clone())}return this.autoClose=n.autoClose,this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);n.autoClose=this.autoClose,n.curves=[];for(var e=0,o=this.curves.length;e<o;e++){var r=this.curves[e];n.curves.push(r.toJSON())}return n}},{key:"fromJSON",value:function(n){D(U(t.prototype),"fromJSON",this).call(this,n),this.autoClose=n.autoClose,this.curves=[];for(var e=0,o=n.curves.length;e<o;e++){var r=n.curves[e];this.curves.push((new ps[r.type]).fromJSON(r))}return this}}]),t}(Yl),ds=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).type="Path",o.currentPoint=new ao,n&&o.setFromPoints(n),o}return b(t,[{key:"setFromPoints",value:function(n){this.moveTo(n[0].x,n[0].y);for(var e=1,t=n.length;e<t;e++)this.lineTo(n[e].x,n[e].y);return this}},{key:"moveTo",value:function(n,e){return this.currentPoint.set(n,e),this}},{key:"lineTo",value:function(n,e){var t=new cs(this.currentPoint.clone(),new ao(n,e));return this.curves.push(t),this.currentPoint.set(n,e),this}},{key:"quadraticCurveTo",value:function(n,e,t,o){var r=new ss(this.currentPoint.clone(),new ao(n,e),new ao(t,o));return this.curves.push(r),this.currentPoint.set(t,o),this}},{key:"bezierCurveTo",value:function(n,e,t,o,r,a){var i=new is(this.currentPoint.clone(),new ao(n,e),new ao(t,o),new ao(r,a));return this.curves.push(i),this.currentPoint.set(r,a),this}},{key:"splineThru",value:function(n){var e=[this.currentPoint.clone()].concat(n),t=new fs(e);return this.curves.push(t),this.currentPoint.copy(n[n.length-1]),this}},{key:"arc",value:function(n,e,t,o,r,a){var i=this.currentPoint.x,v=this.currentPoint.y;return this.absarc(n+i,e+v,t,o,r,a),this}},{key:"absarc",value:function(n,e,t,o,r,a){return this.absellipse(n,e,t,t,o,r,a),this}},{key:"ellipse",value:function(n,e,t,o,r,a,i,v){var c=this.currentPoint.x,l=this.currentPoint.y;return this.absellipse(n+c,e+l,t,o,r,a,i,v),this}},{key:"absellipse",value:function(n,e,t,o,r,a,i,v){var c=new Zl(n,e,t,o,r,a,i,v);if(this.curves.length>0){var l=c.getPoint(0);l.equals(this.currentPoint)||this.lineTo(l.x,l.y)}this.curves.push(c);var s=c.getPoint(1);return this.currentPoint.copy(s),this}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.currentPoint.copy(n.currentPoint),this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.currentPoint=this.currentPoint.toArray(),n}},{key:"fromJSON",value:function(n){return D(U(t.prototype),"fromJSON",this).call(this,n),this.currentPoint.fromArray(n.currentPoint),this}}]),t}(ms),hs=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[new ao(0,-.5),new ao(.5,0),new ao(0,.5)],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:12,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2*Math.PI;y(this,t),(n=e.call(this)).type="LatheGeometry",n.parameters={points:o,segments:r,phiStart:a,phiLength:i},r=Math.floor(r),i=Qt(i,0,2*Math.PI);for(var v=[],c=[],l=[],s=[],u=[],f=1/r,p=new Oo,m=new ao,d=new Oo,h=new Oo,x=new Oo,g=0,b=0,_=0;_<=o.length-1;_++)switch(_){case 0:g=o[_+1].x-o[_].x,b=o[_+1].y-o[_].y,d.x=1*b,d.y=-g,d.z=0*b,x.copy(d),d.normalize(),s.push(d.x,d.y,d.z);break;case o.length-1:s.push(x.x,x.y,x.z);break;default:g=o[_+1].x-o[_].x,b=o[_+1].y-o[_].y,d.x=1*b,d.y=-g,d.z=0*b,h.copy(d),d.x+=x.x,d.y+=x.y,d.z+=x.z,d.normalize(),s.push(d.x,d.y,d.z),x.copy(h)}for(var U=0;U<=r;U++)for(var w=a+U*f*i,S=Math.sin(w),M=Math.cos(w),z=0;z<=o.length-1;z++){p.x=o[z].x*S,p.y=o[z].y,p.z=o[z].x*M,c.push(p.x,p.y,p.z),m.x=U/r,m.y=z/(o.length-1),l.push(m.x,m.y);var k=s[3*z+0]*S,C=s[3*z+1],T=s[3*z+0]*M;u.push(k,C,T)}for(var R=0;R<r;R++)for(var D=0;D<o.length-1;D++){var P=D+R*o.length,F=P,j=P+o.length,I=P+o.length+1,E=P+1;v.push(F,j,E),v.push(I,E,j)}return n.setIndex(v),n.setAttribute("position",new sa(c,3)),n.setAttribute("uv",new sa(l,2)),n.setAttribute("normal",new sa(u,3)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.points,n.segments,n.phiStart,n.phiLength)}}]),t}(ga),xs=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8;y(this,t);var v=new ds;return v.absarc(0,-r/2,o,1.5*Math.PI,0),v.absarc(0,r/2,o,0,.5*Math.PI),(n=e.call(this,v.getPoints(a),i)).type="CapsuleGeometry",n.parameters={radius:o,height:r,capSegments:a,radialSegments:i},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.length,n.capSegments,n.radialSegments)}}]),t}(hs),ys=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:8,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2*Math.PI;y(this,t),(n=e.call(this)).type="CircleGeometry",n.parameters={radius:o,segments:r,thetaStart:a,thetaLength:i},r=Math.max(3,r);var v=[],c=[],l=[],s=[],u=new Oo,f=new ao;c.push(0,0,0),l.push(0,0,1),s.push(.5,.5);for(var p=0,m=3;p<=r;p++,m+=3){var d=a+p/r*i;u.x=o*Math.cos(d),u.y=o*Math.sin(d),c.push(u.x,u.y,u.z),l.push(0,0,1),f.x=(c[m]/o+1)/2,f.y=(c[m+1]/o+1)/2,s.push(f.x,f.y)}for(var h=1;h<=r;h++)v.push(h,h+1,0);return n.setIndex(v),n.setAttribute("position",new sa(c,3)),n.setAttribute("normal",new sa(l,3)),n.setAttribute("uv",new sa(s,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.segments,n.thetaStart,n.thetaLength)}}]),t}(ga),gs=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,c=arguments.length>5&&void 0!==arguments[5]&&arguments[5],l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:2*Math.PI;y(this,t),(n=e.call(this)).type="CylinderGeometry",n.parameters={radiusTop:o,radiusBottom:r,height:a,radialSegments:i,heightSegments:v,openEnded:c,thetaStart:l,thetaLength:s};var u=S(n);i=Math.floor(i),v=Math.floor(v);var f=[],p=[],m=[],d=[],h=0,x=[],g=a/2,b=0;function _(){for(var n=new Oo,e=new Oo,t=0,c=(r-o)/a,y=0;y<=v;y++){for(var _=[],U=y/v,w=U*(r-o)+o,S=0;S<=i;S++){var M=S/i,z=M*s+l,k=Math.sin(z),C=Math.cos(z);e.x=w*k,e.y=-U*a+g,e.z=w*C,p.push(e.x,e.y,e.z),n.set(k,c,C).normalize(),m.push(n.x,n.y,n.z),d.push(M,1-U),_.push(h++)}x.push(_)}for(var T=0;T<i;T++)for(var R=0;R<v;R++){var D=x[R][T],P=x[R+1][T],F=x[R+1][T+1],j=x[R][T+1];f.push(D,P,j),f.push(P,F,j),t+=6}u.addGroup(b,t,0),b+=t}function U(n){for(var e=h,t=new ao,a=new Oo,v=0,c=!0===n?o:r,x=!0===n?1:-1,y=1;y<=i;y++)p.push(0,g*x,0),m.push(0,x,0),d.push(.5,.5),h++;for(var _=h,U=0;U<=i;U++){var w=U/i*s+l,S=Math.cos(w),M=Math.sin(w);a.x=c*M,a.y=g*x,a.z=c*S,p.push(a.x,a.y,a.z),m.push(0,x,0),t.x=.5*S+.5,t.y=.5*M*x+.5,d.push(t.x,t.y),h++}for(var z=0;z<i;z++){var k=e+z,C=_+z;!0===n?f.push(C,C+1,k):f.push(C+1,C,k),v+=3}u.addGroup(b,v,!0===n?1:2),b+=v}return _(),!1===c&&(o>0&&U(!0),r>0&&U(!1)),n.setIndex(f),n.setAttribute("position",new sa(p,3)),n.setAttribute("normal",new sa(m,3)),n.setAttribute("uv",new sa(d,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radiusTop,n.radiusBottom,n.height,n.radialSegments,n.heightSegments,n.openEnded,n.thetaStart,n.thetaLength)}}]),t}(ga),bs=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]&&arguments[4],c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:2*Math.PI;return y(this,t),(n=e.call(this,0,o,r,a,i,v,c,l)).type="ConeGeometry",n.parameters={radius:o,height:r,radialSegments:a,heightSegments:i,openEnded:v,thetaStart:c,thetaLength:l},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.height,n.radialSegments,n.heightSegments,n.openEnded,n.thetaStart,n.thetaLength)}}]),t}(gs),_s=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;y(this,t),(n=e.call(this)).type="PolyhedronGeometry",n.parameters={vertices:o,indices:r,radius:a,detail:i};var v=[],c=[];function l(n){for(var e=new Oo,t=new Oo,o=new Oo,a=0;a<r.length;a+=3)d(r[a+0],e),d(r[a+1],t),d(r[a+2],o),s(e,t,o,n)}function s(n,e,t,o){for(var r=o+1,a=[],i=0;i<=r;i++){a[i]=[];for(var v=n.clone().lerp(t,i/r),c=e.clone().lerp(t,i/r),l=r-i,s=0;s<=l;s++)a[i][s]=0===s&&i===r?v:v.clone().lerp(c,s/l)}for(var u=0;u<r;u++)for(var f=0;f<2*(r-u)-1;f++){var p=Math.floor(f/2);f%2===0?(m(a[u][p+1]),m(a[u+1][p]),m(a[u][p])):(m(a[u][p+1]),m(a[u+1][p+1]),m(a[u+1][p]))}}function u(n){for(var e=new Oo,t=0;t<v.length;t+=3)e.x=v[t+0],e.y=v[t+1],e.z=v[t+2],e.normalize().multiplyScalar(n),v[t+0]=e.x,v[t+1]=e.y,v[t+2]=e.z}function f(){for(var n=new Oo,e=0;e<v.length;e+=3){n.x=v[e+0],n.y=v[e+1],n.z=v[e+2];var t=g(n)/2/Math.PI+.5,o=b(n)/Math.PI+.5;c.push(t,1-o)}h(),p()}function p(){for(var n=0;n<c.length;n+=6){var e=c[n+0],t=c[n+2],o=c[n+4],r=Math.max(e,t,o),a=Math.min(e,t,o);r>.9&&a<.1&&(e<.2&&(c[n+0]+=1),t<.2&&(c[n+2]+=1),o<.2&&(c[n+4]+=1))}}function m(n){v.push(n.x,n.y,n.z)}function d(n,e){var t=3*n;e.x=o[t+0],e.y=o[t+1],e.z=o[t+2]}function h(){for(var n=new Oo,e=new Oo,t=new Oo,o=new Oo,r=new ao,a=new ao,i=new ao,l=0,s=0;l<v.length;l+=9,s+=6){n.set(v[l+0],v[l+1],v[l+2]),e.set(v[l+3],v[l+4],v[l+5]),t.set(v[l+6],v[l+7],v[l+8]),r.set(c[s+0],c[s+1]),a.set(c[s+2],c[s+3]),i.set(c[s+4],c[s+5]),o.copy(n).add(e).add(t).divideScalar(3);var u=g(o);x(r,s+0,n,u),x(a,s+2,e,u),x(i,s+4,t,u)}}function x(n,e,t,o){o<0&&1===n.x&&(c[e]=n.x-1),0===t.x&&0===t.z&&(c[e]=o/2/Math.PI+.5)}function g(n){return Math.atan2(n.z,-n.x)}function b(n){return Math.atan2(-n.y,Math.sqrt(n.x*n.x+n.z*n.z))}return l(i),u(a),f(),n.setAttribute("position",new sa(v,3)),n.setAttribute("normal",new sa(v.slice(),3)),n.setAttribute("uv",new sa(c,2)),0===i?n.computeVertexNormals():n.normalizeNormals(),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.vertices,n.indices,n.radius,n.details)}}]),t}(ga),Us=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,t);var a=(1+Math.sqrt(5))/2,i=1/a,v=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-a,0,-i,a,0,i,-a,0,i,a,-i,-a,0,-i,a,0,i,-a,0,i,a,0,-a,0,-i,a,0,-i,-a,0,i,a,0,i],c=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];return(n=e.call(this,v,c,o,r)).type="DodecahedronGeometry",n.parameters={radius:o,detail:r},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(_s),ws=new Oo,Ss=new Oo,Ms=new Oo,zs=new Zr,ks=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(y(this,t),(n=e.call(this)).type="EdgesGeometry",n.parameters={geometry:o,thresholdAngle:r},null!==o){for(var a=4,i=Math.pow(10,a),v=Math.cos(Xt*r),c=o.getIndex(),l=o.getAttribute("position"),s=c?c.count:l.count,u=[0,0,0],f=["a","b","c"],p=new Array(3),m={},d=[],h=0;h<s;h+=3){c?(u[0]=c.getX(h),u[1]=c.getX(h+1),u[2]=c.getX(h+2)):(u[0]=h,u[1]=h+1,u[2]=h+2);var x=zs.a,g=zs.b,b=zs.c;if(x.fromBufferAttribute(l,u[0]),g.fromBufferAttribute(l,u[1]),b.fromBufferAttribute(l,u[2]),zs.getNormal(Ms),p[0]="".concat(Math.round(x.x*i),",").concat(Math.round(x.y*i),",").concat(Math.round(x.z*i)),p[1]="".concat(Math.round(g.x*i),",").concat(Math.round(g.y*i),",").concat(Math.round(g.z*i)),p[2]="".concat(Math.round(b.x*i),",").concat(Math.round(b.y*i),",").concat(Math.round(b.z*i)),p[0]!==p[1]&&p[1]!==p[2]&&p[2]!==p[0])for(var _=0;_<3;_++){var U=(_+1)%3,w=p[_],S=p[U],M=zs[f[_]],z=zs[f[U]],k="".concat(w,"_").concat(S),C="".concat(S,"_").concat(w);C in m&&m[C]?(Ms.dot(m[C].normal)<=v&&(d.push(M.x,M.y,M.z),d.push(z.x,z.y,z.z)),m[C]=null):k in m||(m[k]={index0:u[_],index1:u[U],normal:Ms.clone()})}}for(var T in m)if(m[T]){var R=m[T],D=R.index0,P=R.index1;ws.fromBufferAttribute(l,D),Ss.fromBufferAttribute(l,P),d.push(ws.x,ws.y,ws.z),d.push(Ss.x,Ss.y,Ss.z)}n.setAttribute("position",new sa(d,3))}return n}return b(t)}(ga),Cs=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this,n)).uuid=Zt(),o.type="Shape",o.holes=[],o}return b(t,[{key:"getPointsHoles",value:function(n){for(var e=[],t=0,o=this.holes.length;t<o;t++)e[t]=this.holes[t].getPoints(n);return e}},{key:"extractPoints",value:function(n){return{shape:this.getPoints(n),holes:this.getPointsHoles(n)}}},{key:"copy",value:function(n){D(U(t.prototype),"copy",this).call(this,n),this.holes=[];for(var e=0,o=n.holes.length;e<o;e++){var r=n.holes[e];this.holes.push(r.clone())}return this}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);n.uuid=this.uuid,n.holes=[];for(var e=0,o=this.holes.length;e<o;e++){var r=this.holes[e];n.holes.push(r.toJSON())}return n}},{key:"fromJSON",value:function(n){D(U(t.prototype),"fromJSON",this).call(this,n),this.uuid=n.uuid,this.holes=[];for(var e=0,o=n.holes.length;e<o;e++){var r=n.holes[e];this.holes.push((new ds).fromJSON(r))}return this}}]),t}(ds),Ts=function(n,e){var t,o,r,a,i,v,c,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2,s=e&&e.length,u=s?e[0]*l:n.length,f=Rs(n,0,u,l,!0),p=[];if(!f||f.next===f.prev)return p;if(s&&(f=Os(n,e,f,l)),n.length>80*l){t=r=n[0],o=a=n[1];for(var m=l;m<u;m+=l)(i=n[m])<t&&(t=i),(v=n[m+1])<o&&(o=v),i>r&&(r=i),v>a&&(a=v);c=0!==(c=Math.max(r-t,a-o))?32767/c:0}return Ps(f,p,l,t,o,c,0),p};function Rs(n,e,t,o,r){var a,i;if(r===function(n,e,t,o){for(var r=0,a=e,i=t-o;a<t;a+=o)r+=(n[i]-n[a])*(n[a+1]+n[i+1]),i=a;return r}(n,e,t,o)>0)for(a=e;a<t;a+=o)i=Ks(a,n[a],n[a+1],i);else for(a=t-o;a>=e;a-=o)i=Ks(a,n[a],n[a+1],i);return i&&Hs(i,i.next)&&($s(i),i=i.next),i}function Ds(n,e){if(!n)return n;e||(e=n);var t,o=n;do{if(t=!1,o.steiner||!Hs(o,o.next)&&0!==Ws(o.prev,o,o.next))o=o.next;else{if($s(o),(o=e=o.prev)===o.next)break;t=!0}}while(t||o!==e);return e}function Ps(n,e,t,o,r,a,i){if(n){!i&&a&&function(n,e,t,o){var r=n;do{0===r.z&&(r.z=Ns(r.x,r.y,e,t,o)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==n);r.prevZ.nextZ=null,r.prevZ=null,function(n){var e,t,o,r,a,i,v,c,l=1;do{for(t=n,n=null,a=null,i=0;t;){for(i++,o=t,v=0,e=0;e<l&&(v++,o=o.nextZ);e++);for(c=l;v>0||c>0&&o;)0!==v&&(0===c||!o||t.z<=o.z)?(r=t,t=t.nextZ,v--):(r=o,o=o.nextZ,c--),a?a.nextZ=r:n=r,r.prevZ=a,a=r;t=o}a.nextZ=null,l*=2}while(i>1)}(r)}(n,o,r,a);for(var v,c,l=n;n.prev!==n.next;)if(v=n.prev,c=n.next,a?js(n,o,r,a):Fs(n))e.push(v.i/t|0),e.push(n.i/t|0),e.push(c.i/t|0),$s(n),n=c.next,l=c.next;else if((n=c)===l){i?1===i?Ps(n=Is(Ds(n),e,t),e,t,o,r,a,2):2===i&&Es(n,e,t,o,r,a):Ps(Ds(n),e,t,o,r,a,1);break}}}function Fs(n){var e=n.prev,t=n,o=n.next;if(Ws(e,t,o)>=0)return!1;for(var r=e.x,a=t.x,i=o.x,v=e.y,c=t.y,l=o.y,s=r<a?r<i?r:i:a<i?a:i,u=v<c?v<l?v:l:c<l?c:l,f=r>a?r>i?r:i:a>i?a:i,p=v>c?v>l?v:l:c>l?c:l,m=o.next;m!==e;){if(m.x>=s&&m.x<=f&&m.y>=u&&m.y<=p&&qs(r,v,a,c,i,l,m.x,m.y)&&Ws(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function js(n,e,t,o){var r=n.prev,a=n,i=n.next;if(Ws(r,a,i)>=0)return!1;for(var v=r.x,c=a.x,l=i.x,s=r.y,u=a.y,f=i.y,p=v<c?v<l?v:l:c<l?c:l,m=s<u?s<f?s:f:u<f?u:f,d=v>c?v>l?v:l:c>l?c:l,h=s>u?s>f?s:f:u>f?u:f,x=Ns(p,m,e,t,o),y=Ns(d,h,e,t,o),g=n.prevZ,b=n.nextZ;g&&g.z>=x&&b&&b.z<=y;){if(g.x>=p&&g.x<=d&&g.y>=m&&g.y<=h&&g!==r&&g!==i&&qs(v,s,c,u,l,f,g.x,g.y)&&Ws(g.prev,g,g.next)>=0)return!1;if(g=g.prevZ,b.x>=p&&b.x<=d&&b.y>=m&&b.y<=h&&b!==r&&b!==i&&qs(v,s,c,u,l,f,b.x,b.y)&&Ws(b.prev,b,b.next)>=0)return!1;b=b.nextZ}for(;g&&g.z>=x;){if(g.x>=p&&g.x<=d&&g.y>=m&&g.y<=h&&g!==r&&g!==i&&qs(v,s,c,u,l,f,g.x,g.y)&&Ws(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;b&&b.z<=y;){if(b.x>=p&&b.x<=d&&b.y>=m&&b.y<=h&&b!==r&&b!==i&&qs(v,s,c,u,l,f,b.x,b.y)&&Ws(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function Is(n,e,t){var o=n;do{var r=o.prev,a=o.next.next;!Hs(r,a)&&Xs(r,o,o.next,a)&&Qs(r,a)&&Qs(a,r)&&(e.push(r.i/t|0),e.push(o.i/t|0),e.push(a.i/t|0),$s(o),$s(o.next),o=n=a),o=o.next}while(o!==n);return Ds(o)}function Es(n,e,t,o,r,a){var i=n;do{for(var v=i.next.next;v!==i.prev;){if(i.i!==v.i&&Vs(i,v)){var c=Js(i,v);return i=Ds(i,i.next),c=Ds(c,c.next),Ps(i,e,t,o,r,a,0),void Ps(c,e,t,o,r,a,0)}v=v.next}i=i.next}while(i!==n)}function Os(n,e,t,o){var r,a,i,v=[];for(r=0,a=e.length;r<a;r++)(i=Rs(n,e[r]*o,r<a-1?e[r+1]*o:n.length,o,!1))===i.next&&(i.steiner=!0),v.push(Bs(i));for(v.sort(Ls),r=0;r<v.length;r++)t=As(v[r],t);return t}function Ls(n,e){return n.x-e.x}function As(n,e){var t=function(n,e){var t,o=e,r=-1/0,a=n.x,i=n.y;do{if(i<=o.y&&i>=o.next.y&&o.next.y!==o.y){var v=o.x+(i-o.y)*(o.next.x-o.x)/(o.next.y-o.y);if(v<=a&&v>r&&(r=v,t=o.x<o.next.x?o:o.next,v===a))return t}o=o.next}while(o!==e);if(!t)return null;var c,l=t,s=t.x,u=t.y,f=1/0;o=t;do{a>=o.x&&o.x>=s&&a!==o.x&&qs(i<u?a:r,i,s,u,i<u?r:a,i,o.x,o.y)&&(c=Math.abs(i-o.y)/(a-o.x),Qs(o,n)&&(c<f||c===f&&(o.x>t.x||o.x===t.x&&Gs(t,o)))&&(t=o,f=c)),o=o.next}while(o!==l);return t}(n,e);if(!t)return e;var o=Js(t,n);return Ds(o,o.next),Ds(t,t.next)}function Gs(n,e){return Ws(n.prev,n,e.prev)<0&&Ws(e.next,n,n.next)<0}function Ns(n,e,t,o,r){return(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=(n-t)*r|0)|n<<8))|n<<4))|n<<2))|n<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-o)*r|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Bs(n){var e=n,t=n;do{(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next}while(e!==n);return t}function qs(n,e,t,o,r,a,i,v){return(r-i)*(e-v)>=(n-i)*(a-v)&&(n-i)*(o-v)>=(t-i)*(e-v)&&(t-i)*(a-v)>=(r-i)*(o-v)}function Vs(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!function(n,e){var t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&Xs(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}(n,e)&&(Qs(n,e)&&Qs(e,n)&&function(n,e){var t=n,o=!1,r=(n.x+e.x)/2,a=(n.y+e.y)/2;do{t.y>a!==t.next.y>a&&t.next.y!==t.y&&r<(t.next.x-t.x)*(a-t.y)/(t.next.y-t.y)+t.x&&(o=!o),t=t.next}while(t!==n);return o}(n,e)&&(Ws(n.prev,n,e.prev)||Ws(n,e.prev,e))||Hs(n,e)&&Ws(n.prev,n,n.next)>0&&Ws(e.prev,e,e.next)>0)}function Ws(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function Hs(n,e){return n.x===e.x&&n.y===e.y}function Xs(n,e,t,o){var r=Zs(Ws(n,e,t)),a=Zs(Ws(n,e,o)),i=Zs(Ws(t,o,n)),v=Zs(Ws(t,o,e));return r!==a&&i!==v||(!(0!==r||!Ys(n,t,e))||(!(0!==a||!Ys(n,o,e))||(!(0!==i||!Ys(t,n,o))||!(0!==v||!Ys(t,e,o)))))}function Ys(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function Zs(n){return n>0?1:n<0?-1:0}function Qs(n,e){return Ws(n.prev,n,n.next)<0?Ws(n,e,n.next)>=0&&Ws(n,n.prev,e)>=0:Ws(n,e,n.prev)<0||Ws(n,n.next,e)<0}function Js(n,e){var t=new nu(n.i,n.x,n.y),o=new nu(e.i,e.x,e.y),r=n.next,a=e.prev;return n.next=e,e.prev=n,t.next=r,r.prev=t,o.next=t,t.prev=o,a.next=o,o.prev=a,o}function Ks(n,e,t,o){var r=new nu(n,e,t);return o?(r.next=o.next,r.prev=o,o.next.prev=r,o.next=r):(r.prev=r,r.next=r),r}function $s(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function nu(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}var eu=function(){function n(){y(this,n)}return b(n,null,[{key:"area",value:function(n){for(var e=n.length,t=0,o=e-1,r=0;r<e;o=r++)t+=n[o].x*n[r].y-n[r].x*n[o].y;return.5*t}},{key:"isClockWise",value:function(e){return n.area(e)<0}},{key:"triangulateShape",value:function(n,e){var t=[],o=[],r=[];tu(n),ou(t,n);var a=n.length;e.forEach(tu);for(var i=0;i<e.length;i++)o.push(a),a+=e[i].length,ou(t,e[i]);for(var v=Ts(t,o),c=0;c<v.length;c+=3)r.push(v.slice(c,c+3));return r}}]),n}();function tu(n){var e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function ou(n,e){for(var t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}var ru=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Cs([new ao(.5,.5),new ao(-.5,.5),new ao(-.5,-.5),new ao(.5,-.5)]),r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};y(this,t),(n=e.call(this)).type="ExtrudeGeometry",n.parameters={shapes:o,options:r},o=Array.isArray(o)?o:[o];for(var a=S(n),i=[],v=[],c=0,l=o.length;c<l;c++){var s=o[c];u(s)}function u(n){var e,t,o,c,l,s=[],u=void 0!==r.curveSegments?r.curveSegments:12,f=void 0!==r.steps?r.steps:1,p=void 0!==r.depth?r.depth:1,m=void 0===r.bevelEnabled||r.bevelEnabled,d=void 0!==r.bevelThickness?r.bevelThickness:.2,h=void 0!==r.bevelSize?r.bevelSize:d-.1,x=void 0!==r.bevelOffset?r.bevelOffset:0,y=void 0!==r.bevelSegments?r.bevelSegments:3,g=r.extrudePath,b=void 0!==r.UVGenerator?r.UVGenerator:au,_=!1;g&&(e=g.getSpacedPoints(f),_=!0,m=!1,t=g.computeFrenetFrames(f,!1),o=new Oo,c=new Oo,l=new Oo),m||(y=0,d=0,h=0,x=0);var U=n.extractPoints(u),w=U.shape,S=U.holes;if(!eu.isClockWise(w)){w=w.reverse();for(var M=0,z=S.length;M<z;M++){var k=S[M];eu.isClockWise(k)&&(S[M]=k.reverse())}}for(var C=eu.triangulateShape(w,S),T=w,R=0,D=S.length;R<D;R++){var P=S[R];w=w.concat(P)}function F(n,e,t){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(t).add(n)}var j=w.length,I=C.length;function E(n,e,t){var o,r,a,i=n.x-e.x,v=n.y-e.y,c=t.x-n.x,l=t.y-n.y,s=i*i+v*v,u=i*l-v*c;if(Math.abs(u)>Number.EPSILON){var f=Math.sqrt(s),p=Math.sqrt(c*c+l*l),m=e.x-v/f,d=e.y+i/f,h=((t.x-l/p-m)*l-(t.y+c/p-d)*c)/(i*l-v*c),x=(o=m+i*h-n.x)*o+(r=d+v*h-n.y)*r;if(x<=2)return new ao(o,r);a=Math.sqrt(x/2)}else{var y=!1;i>Number.EPSILON?c>Number.EPSILON&&(y=!0):i<-Number.EPSILON?c<-Number.EPSILON&&(y=!0):Math.sign(v)===Math.sign(l)&&(y=!0),y?(o=-v,r=i,a=Math.sqrt(s)):(o=i,r=v,a=Math.sqrt(s/2))}return new ao(o/a,r/a)}for(var O=[],L=0,A=T.length,G=A-1,N=L+1;L<A;L++,G++,N++)G===A&&(G=0),N===A&&(N=0),O[L]=E(T[L],T[G],T[N]);for(var B,q=[],V=O.concat(),W=0,H=S.length;W<H;W++){var X=S[W];B=[];for(var Y=0,Z=X.length,Q=Z-1,J=Y+1;Y<Z;Y++,Q++,J++)Q===Z&&(Q=0),J===Z&&(J=0),B[Y]=E(X[Y],X[Q],X[J]);q.push(B),V=V.concat(B)}for(var K=0;K<y;K++){for(var $=K/y,nn=d*Math.cos($*Math.PI/2),en=h*Math.sin($*Math.PI/2)+x,tn=0,on=T.length;tn<on;tn++){var rn=F(T[tn],O[tn],en);Pn(rn.x,rn.y,-nn)}for(var an=0,vn=S.length;an<vn;an++){var cn=S[an];B=q[an];for(var ln=0,sn=cn.length;ln<sn;ln++){var un=F(cn[ln],B[ln],en);Pn(un.x,un.y,-nn)}}}for(var fn=h+x,pn=0;pn<j;pn++){var mn=m?F(w[pn],V[pn],fn):w[pn];_?(c.copy(t.normals[0]).multiplyScalar(mn.x),o.copy(t.binormals[0]).multiplyScalar(mn.y),l.copy(e[0]).add(c).add(o),Pn(l.x,l.y,l.z)):Pn(mn.x,mn.y,0)}for(var dn=1;dn<=f;dn++)for(var hn=0;hn<j;hn++){var xn=m?F(w[hn],V[hn],fn):w[hn];_?(c.copy(t.normals[dn]).multiplyScalar(xn.x),o.copy(t.binormals[dn]).multiplyScalar(xn.y),l.copy(e[dn]).add(c).add(o),Pn(l.x,l.y,l.z)):Pn(xn.x,xn.y,p/f*dn)}for(var yn=y-1;yn>=0;yn--){for(var gn=yn/y,bn=d*Math.cos(gn*Math.PI/2),_n=h*Math.sin(gn*Math.PI/2)+x,Un=0,wn=T.length;Un<wn;Un++){var Sn=F(T[Un],O[Un],_n);Pn(Sn.x,Sn.y,p+bn)}for(var Mn=0,zn=S.length;Mn<zn;Mn++){var kn=S[Mn];B=q[Mn];for(var Cn=0,Tn=kn.length;Cn<Tn;Cn++){var Rn=F(kn[Cn],B[Cn],_n);_?Pn(Rn.x,Rn.y+e[f-1].y,e[f-1].x+bn):Pn(Rn.x,Rn.y,p+bn)}}}function Dn(n,e){for(var t=n.length;--t>=0;){var o=t,r=t-1;r<0&&(r=n.length-1);for(var a=0,i=f+2*y;a<i;a++){var v=j*a,c=j*(a+1);jn(e+o+v,e+r+v,e+r+c,e+o+c)}}}function Pn(n,e,t){s.push(n),s.push(e),s.push(t)}function Fn(n,e,t){In(n),In(e),In(t);var o=i.length/3,r=b.generateTopUV(a,i,o-3,o-2,o-1);En(r[0]),En(r[1]),En(r[2])}function jn(n,e,t,o){In(n),In(e),In(o),In(e),In(t),In(o);var r=i.length/3,v=b.generateSideWallUV(a,i,r-6,r-3,r-2,r-1);En(v[0]),En(v[1]),En(v[3]),En(v[1]),En(v[2]),En(v[3])}function In(n){i.push(s[3*n+0]),i.push(s[3*n+1]),i.push(s[3*n+2])}function En(n){v.push(n.x),v.push(n.y)}!function(){var n=i.length/3;if(m){for(var e=0,t=j*e,o=0;o<I;o++){var r=C[o];Fn(r[2]+t,r[1]+t,r[0]+t)}t=j*(e=f+2*y);for(var v=0;v<I;v++){var c=C[v];Fn(c[0]+t,c[1]+t,c[2]+t)}}else{for(var l=0;l<I;l++){var s=C[l];Fn(s[2],s[1],s[0])}for(var u=0;u<I;u++){var p=C[u];Fn(p[0]+j*f,p[1]+j*f,p[2]+j*f)}}a.addGroup(n,i.length/3-n,0)}(),function(){var n=i.length/3,e=0;Dn(T,e),e+=T.length;for(var t=0,o=S.length;t<o;t++){var r=S[t];Dn(r,e),e+=r.length}a.addGroup(n,i.length/3-n,1)}()}return n.setAttribute("position",new sa(i,3)),n.setAttribute("uv",new sa(v,2)),n.computeVertexNormals(),n}return b(t,[{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return function(n,e,t){if(t.shapes=[],Array.isArray(n))for(var o=0,r=n.length;o<r;o++){var a=n[o];t.shapes.push(a.uuid)}else t.shapes.push(n.uuid);t.options=Object.assign({},e),void 0!==e.extrudePath&&(t.options.extrudePath=e.extrudePath.toJSON());return t}(this.parameters.shapes,this.parameters.options,n)}}],[{key:"fromJSON",value:function(n,e){for(var o=[],r=0,a=n.shapes.length;r<a;r++){var i=e[n.shapes[r]];o.push(i)}var v=n.options.extrudePath;return void 0!==v&&(n.options.extrudePath=(new ps[v.type]).fromJSON(v)),new t(o,n.options)}}]),t}(ga),au={generateTopUV:function(n,e,t,o,r){var a=e[3*t],i=e[3*t+1],v=e[3*o],c=e[3*o+1],l=e[3*r],s=e[3*r+1];return[new ao(a,i),new ao(v,c),new ao(l,s)]},generateSideWallUV:function(n,e,t,o,r,a){var i=e[3*t],v=e[3*t+1],c=e[3*t+2],l=e[3*o],s=e[3*o+1],u=e[3*o+2],f=e[3*r],p=e[3*r+1],m=e[3*r+2],d=e[3*a],h=e[3*a+1],x=e[3*a+2];return Math.abs(v-s)<Math.abs(i-l)?[new ao(i,1-c),new ao(l,1-u),new ao(f,1-m),new ao(d,1-x)]:[new ao(v,1-c),new ao(s,1-u),new ao(p,1-m),new ao(h,1-x)]}};var iu=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,t);var a=(1+Math.sqrt(5))/2,i=[-1,a,0,1,a,0,-1,-a,0,1,-a,0,0,-1,a,0,1,a,0,-1,-a,0,1,-a,a,0,-1,a,0,1,-a,0,-1,-a,0,1],v=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];return(n=e.call(this,i,v,o,r)).type="IcosahedronGeometry",n.parameters={radius:o,detail:r},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(_s),vu=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,t);var a=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];return(n=e.call(this,a,i,o,r)).type="OctahedronGeometry",n.parameters={radius:o,detail:r},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(_s),cu=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:.5,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2*Math.PI;y(this,t),(n=e.call(this)).type="RingGeometry",n.parameters={innerRadius:o,outerRadius:r,thetaSegments:a,phiSegments:i,thetaStart:v,thetaLength:c},a=Math.max(3,a);for(var l=[],s=[],u=[],f=[],p=o,m=(r-o)/(i=Math.max(1,i)),d=new Oo,h=new ao,x=0;x<=i;x++){for(var g=0;g<=a;g++){var b=v+g/a*c;d.x=p*Math.cos(b),d.y=p*Math.sin(b),s.push(d.x,d.y,d.z),u.push(0,0,1),h.x=(d.x/r+1)/2,h.y=(d.y/r+1)/2,f.push(h.x,h.y)}p+=m}for(var _=0;_<i;_++)for(var U=_*(a+1),w=0;w<a;w++){var S=w+U,M=S,z=S+a+1,k=S+a+2,C=S+1;l.push(M,z,C),l.push(z,k,C)}return n.setIndex(l),n.setAttribute("position",new sa(s,3)),n.setAttribute("normal",new sa(u,3)),n.setAttribute("uv",new sa(f,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.innerRadius,n.outerRadius,n.thetaSegments,n.phiSegments,n.thetaStart,n.thetaLength)}}]),t}(ga),lu=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Cs([new ao(0,.5),new ao(-.5,-.5),new ao(.5,-.5)]),r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:12;y(this,t),(n=e.call(this)).type="ShapeGeometry",n.parameters={shapes:o,curveSegments:r};var a=[],i=[],v=[],c=[],l=0,s=0;if(!1===Array.isArray(o))f(o);else for(var u=0;u<o.length;u++)f(o[u]),n.addGroup(l,s,u),l+=s,s=0;function f(n){var e=i.length/3,t=n.extractPoints(r),o=t.shape,l=t.holes;!1===eu.isClockWise(o)&&(o=o.reverse());for(var u=0,f=l.length;u<f;u++){var p=l[u];!0===eu.isClockWise(p)&&(l[u]=p.reverse())}for(var m=eu.triangulateShape(o,l),d=0,h=l.length;d<h;d++){var x=l[d];o=o.concat(x)}for(var y=0,g=o.length;y<g;y++){var b=o[y];i.push(b.x,b.y,0),v.push(0,0,1),c.push(b.x,b.y)}for(var _=0,U=m.length;_<U;_++){var w=m[_],S=w[0]+e,M=w[1]+e,z=w[2]+e;a.push(S,M,z),s+=3}}return n.setIndex(a),n.setAttribute("position",new sa(i,3)),n.setAttribute("normal",new sa(v,3)),n.setAttribute("uv",new sa(c,2)),n}return b(t,[{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return function(n,e){if(e.shapes=[],Array.isArray(n))for(var t=0,o=n.length;t<o;t++){var r=n[t];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return e}(this.parameters.shapes,n)}}],[{key:"fromJSON",value:function(n,e){for(var o=[],r=0,a=n.shapes.length;r<a;r++){var i=e[n.shapes[r]];o.push(i)}return new t(o,n.curveSegments)}}]),t}(ga);var su=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:16,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:Math.PI;y(this,t),(n=e.call(this)).type="SphereGeometry",n.parameters={radius:o,widthSegments:r,heightSegments:a,phiStart:i,phiLength:v,thetaStart:c,thetaLength:l},r=Math.max(3,Math.floor(r)),a=Math.max(2,Math.floor(a));for(var s=Math.min(c+l,Math.PI),u=0,f=[],p=new Oo,m=new Oo,d=[],h=[],x=[],g=[],b=0;b<=a;b++){var _=[],U=b/a,w=0;0==b&&0==c?w=.5/r:b==a&&s==Math.PI&&(w=-.5/r);for(var S=0;S<=r;S++){var M=S/r;p.x=-o*Math.cos(i+M*v)*Math.sin(c+U*l),p.y=o*Math.cos(c+U*l),p.z=o*Math.sin(i+M*v)*Math.sin(c+U*l),h.push(p.x,p.y,p.z),m.copy(p).normalize(),x.push(m.x,m.y,m.z),g.push(M+w,1-U),_.push(u++)}f.push(_)}for(var z=0;z<a;z++)for(var k=0;k<r;k++){var C=f[z][k+1],T=f[z][k],R=f[z+1][k],D=f[z+1][k+1];(0!==z||c>0)&&d.push(C,T,D),(z!==a-1||s<Math.PI)&&d.push(T,R,D)}return n.setIndex(d),n.setAttribute("position",new sa(h,3)),n.setAttribute("normal",new sa(x,3)),n.setAttribute("uv",new sa(g,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.widthSegments,n.heightSegments,n.phiStart,n.phiLength,n.thetaStart,n.thetaLength)}}]),t}(ga),uu=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,t);var a=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];return(n=e.call(this,a,i,o,r)).type="TetrahedronGeometry",n.parameters={radius:o,detail:r},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(_s),fu=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.4,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:6,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI;y(this,t),(n=e.call(this)).type="TorusGeometry",n.parameters={radius:o,tube:r,radialSegments:a,tubularSegments:i,arc:v},a=Math.floor(a),i=Math.floor(i);for(var c=[],l=[],s=[],u=[],f=new Oo,p=new Oo,m=new Oo,d=0;d<=a;d++)for(var h=0;h<=i;h++){var x=h/i*v,g=d/a*Math.PI*2;p.x=(o+r*Math.cos(g))*Math.cos(x),p.y=(o+r*Math.cos(g))*Math.sin(x),p.z=r*Math.sin(g),l.push(p.x,p.y,p.z),f.x=o*Math.cos(x),f.y=o*Math.sin(x),m.subVectors(p,f).normalize(),s.push(m.x,m.y,m.z),u.push(h/i),u.push(d/a)}for(var b=1;b<=a;b++)for(var _=1;_<=i;_++){var U=(i+1)*b+_-1,w=(i+1)*(b-1)+_-1,S=(i+1)*(b-1)+_,M=(i+1)*b+_;c.push(U,w,M),c.push(w,S,M)}return n.setIndex(c),n.setAttribute("position",new sa(l,3)),n.setAttribute("normal",new sa(s,3)),n.setAttribute("uv",new sa(u,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.tube,n.radialSegments,n.tubularSegments,n.arc)}}]),t}(ga),pu=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.4,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:64,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:3;y(this,t),(n=e.call(this)).type="TorusKnotGeometry",n.parameters={radius:o,tube:r,tubularSegments:a,radialSegments:i,p:v,q:c},a=Math.floor(a),i=Math.floor(i);for(var l=[],s=[],u=[],f=[],p=new Oo,m=new Oo,d=new Oo,h=new Oo,x=new Oo,g=new Oo,b=new Oo,_=0;_<=a;++_){var U=_/a*v*Math.PI*2;F(U,v,c,o,d),F(U+.01,v,c,o,h),g.subVectors(h,d),b.addVectors(h,d),x.crossVectors(g,b),b.crossVectors(x,g),x.normalize(),b.normalize();for(var w=0;w<=i;++w){var S=w/i*Math.PI*2,M=-r*Math.cos(S),z=r*Math.sin(S);p.x=d.x+(M*b.x+z*x.x),p.y=d.y+(M*b.y+z*x.y),p.z=d.z+(M*b.z+z*x.z),s.push(p.x,p.y,p.z),m.subVectors(p,d).normalize(),u.push(m.x,m.y,m.z),f.push(_/a),f.push(w/i)}}for(var k=1;k<=a;k++)for(var C=1;C<=i;C++){var T=(i+1)*(k-1)+(C-1),R=(i+1)*k+(C-1),D=(i+1)*k+C,P=(i+1)*(k-1)+C;l.push(T,R,P),l.push(R,D,P)}function F(n,e,t,o,r){var a=Math.cos(n),i=Math.sin(n),v=t/e*n,c=Math.cos(v);r.x=o*(2+c)*.5*a,r.y=o*(2+c)*i*.5,r.z=o*Math.sin(v)*.5}return n.setIndex(l),n.setAttribute("position",new sa(s,3)),n.setAttribute("normal",new sa(u,3)),n.setAttribute("uv",new sa(f,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.tube,n.tubularSegments,n.radialSegments,n.p,n.q)}}]),t}(ga),mu=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new us(new Oo(-1,-1,0),new Oo(-1,1,0),new Oo(1,1,0)),r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:64,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,v=arguments.length>4&&void 0!==arguments[4]&&arguments[4];y(this,t),(n=e.call(this)).type="TubeGeometry",n.parameters={path:o,tubularSegments:r,radius:a,radialSegments:i,closed:v};var c=o.computeFrenetFrames(r,v);n.tangents=c.tangents,n.normals=c.normals,n.binormals=c.binormals;var l=new Oo,s=new Oo,u=new ao,f=new Oo,p=[],m=[],d=[],h=[];function x(){for(var n=0;n<r;n++)g(n);g(!1===v?r:0),_(),b()}function g(n){f=o.getPointAt(n/r,f);for(var e=c.normals[n],t=c.binormals[n],v=0;v<=i;v++){var u=v/i*Math.PI*2,d=Math.sin(u),h=-Math.cos(u);s.x=h*e.x+d*t.x,s.y=h*e.y+d*t.y,s.z=h*e.z+d*t.z,s.normalize(),m.push(s.x,s.y,s.z),l.x=f.x+a*s.x,l.y=f.y+a*s.y,l.z=f.z+a*s.z,p.push(l.x,l.y,l.z)}}function b(){for(var n=1;n<=r;n++)for(var e=1;e<=i;e++){var t=(i+1)*(n-1)+(e-1),o=(i+1)*n+(e-1),a=(i+1)*n+e,v=(i+1)*(n-1)+e;h.push(t,o,v),h.push(o,a,v)}}function _(){for(var n=0;n<=r;n++)for(var e=0;e<=i;e++)u.x=n/r,u.y=e/i,d.push(u.x,u.y)}return x(),n.setIndex(h),n.setAttribute("position",new sa(p,3)),n.setAttribute("normal",new sa(m,3)),n.setAttribute("uv",new sa(d,2)),n}return b(t,[{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this);return n.path=this.parameters.path.toJSON(),n}}],[{key:"fromJSON",value:function(n){return new t((new ps[n.path.type]).fromJSON(n.path),n.tubularSegments,n.radius,n.radialSegments,n.closed)}}]),t}(ga),du=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(y(this,t),(n=e.call(this)).type="WireframeGeometry",n.parameters={geometry:o},null!==o){var r=[],a=new Set,i=new Oo,v=new Oo;if(null!==o.index){var c=o.attributes.position,l=o.index,s=o.groups;0===s.length&&(s=[{start:0,count:l.count,materialIndex:0}]);for(var u=0,f=s.length;u<f;++u)for(var p=s[u],m=p.start,d=p.count,h=m,x=m+d;h<x;h+=3)for(var g=0;g<3;g++){var b=l.getX(h+g),_=l.getX(h+(g+1)%3);i.fromBufferAttribute(c,b),v.fromBufferAttribute(c,_),!0===hu(i,v,a)&&(r.push(i.x,i.y,i.z),r.push(v.x,v.y,v.z))}}else for(var U=o.attributes.position,w=0,S=U.count/3;w<S;w++)for(var M=0;M<3;M++){var z=3*w+M,k=3*w+(M+1)%3;i.fromBufferAttribute(U,z),v.fromBufferAttribute(U,k),!0===hu(i,v,a)&&(r.push(i.x,i.y,i.z),r.push(v.x,v.y,v.z))}n.setAttribute("position",new sa(r,3))}return n}return b(t)}(ga);function hu(n,e,t){var o="".concat(n.x,",").concat(n.y,",").concat(n.z,"-").concat(e.x,",").concat(e.y,",").concat(e.z),r="".concat(e.x,",").concat(e.y,",").concat(e.z,"-").concat(n.x,",").concat(n.y,",").concat(n.z);return!0!==t.has(o)&&!0!==t.has(r)&&(t.add(o),t.add(r),!0)}var xu=Object.freeze({__proto__:null,BoxGeometry:Aa,CapsuleGeometry:xs,CircleGeometry:ys,ConeGeometry:bs,CylinderGeometry:gs,DodecahedronGeometry:Us,EdgesGeometry:ks,ExtrudeGeometry:ru,IcosahedronGeometry:iu,LatheGeometry:hs,OctahedronGeometry:vu,PlaneGeometry:ai,PolyhedronGeometry:_s,RingGeometry:cu,ShapeGeometry:lu,SphereGeometry:su,TetrahedronGeometry:uu,TorusGeometry:fu,TorusKnotGeometry:pu,TubeGeometry:mu,WireframeGeometry:du}),yu=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isShadowMaterial=!0,o.type="ShadowMaterial",o.color=new wo(0),o.transparent=!0,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.fog=n.fog,this}}]),t}(Jr),gu=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this,n)).isRawShaderMaterial=!0,o.type="RawShaderMaterial",o}return b(t)}(qa),bu=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshStandardMaterial=!0,o.defines={STANDARD:""},o.type="MeshStandardMaterial",o.color=new wo(16777215),o.roughness=1,o.metalness=0,o.map=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.emissive=new wo(0),o.emissiveIntensity=1,o.emissiveMap=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.roughnessMap=null,o.metalnessMap=null,o.alphaMap=null,o.envMap=null,o.envMapIntensity=1,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.flatShading=!1,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jr),_u=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshPhysicalMaterial=!0,o.defines={STANDARD:"",PHYSICAL:""},o.type="MeshPhysicalMaterial",o.clearcoatMap=null,o.clearcoatRoughness=0,o.clearcoatRoughnessMap=null,o.clearcoatNormalScale=new ao(1,1),o.clearcoatNormalMap=null,o.ior=1.5,Object.defineProperty(S(o),"reflectivity",{get:function(){return Qt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(n){this.ior=(1+.4*n)/(1-.4*n)}}),o.iridescenceMap=null,o.iridescenceIOR=1.3,o.iridescenceThicknessRange=[100,400],o.iridescenceThicknessMap=null,o.sheenColor=new wo(0),o.sheenColorMap=null,o.sheenRoughness=1,o.sheenRoughnessMap=null,o.transmissionMap=null,o.thickness=0,o.thicknessMap=null,o.attenuationDistance=1/0,o.attenuationColor=new wo(1,1,1),o.specularIntensity=1,o.specularIntensityMap=null,o.specularColor=new wo(1,1,1),o.specularColorMap=null,o._sheen=0,o._clearcoat=0,o._iridescence=0,o._transmission=0,o.setValues(n),o}return b(t,[{key:"sheen",get:function(){return this._sheen},set:function(n){this._sheen>0!==n>0&&this.version++,this._sheen=n}},{key:"clearcoat",get:function(){return this._clearcoat},set:function(n){this._clearcoat>0!==n>0&&this.version++,this._clearcoat=n}},{key:"iridescence",get:function(){return this._iridescence},set:function(n){this._iridescence>0!==n>0&&this.version++,this._iridescence=n}},{key:"transmission",get:function(){return this._transmission},set:function(n){this._transmission>0!==n>0&&this.version++,this._transmission=n}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.ior=n.ior,this.iridescence=n.iridescence,this.iridescenceMap=n.iridescenceMap,this.iridescenceIOR=n.iridescenceIOR,this.iridescenceThicknessRange=x(n.iridescenceThicknessRange),this.iridescenceThicknessMap=n.iridescenceThicknessMap,this.sheen=n.sheen,this.sheenColor.copy(n.sheenColor),this.sheenColorMap=n.sheenColorMap,this.sheenRoughness=n.sheenRoughness,this.sheenRoughnessMap=n.sheenRoughnessMap,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this.thickness=n.thickness,this.thicknessMap=n.thicknessMap,this.attenuationDistance=n.attenuationDistance,this.attenuationColor.copy(n.attenuationColor),this.specularIntensity=n.specularIntensity,this.specularIntensityMap=n.specularIntensityMap,this.specularColor.copy(n.specularColor),this.specularColorMap=n.specularColorMap,this}}]),t}(bu),Uu=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshPhongMaterial=!0,o.type="MeshPhongMaterial",o.color=new wo(16777215),o.specular=new wo(1118481),o.shininess=30,o.map=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.emissive=new wo(0),o.emissiveIntensity=1,o.emissiveMap=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.specularMap=null,o.alphaMap=null,o.envMap=null,o.combine=Sn,o.reflectivity=1,o.refractionRatio=.98,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.flatShading=!1,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.specular.copy(n.specular),this.shininess=n.shininess,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jr),wu=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshToonMaterial=!0,o.defines={TOON:""},o.type="MeshToonMaterial",o.color=new wo(16777215),o.map=null,o.gradientMap=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.emissive=new wo(0),o.emissiveIntensity=1,o.emissiveMap=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.alphaMap=null,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.gradientMap=n.gradientMap,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.fog=n.fog,this}}]),t}(Jr),Su=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshNormalMaterial=!0,o.type="MeshNormalMaterial",o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.wireframe=!1,o.wireframeLinewidth=1,o.flatShading=!1,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.flatShading=n.flatShading,this}}]),t}(Jr),Mu=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshLambertMaterial=!0,o.type="MeshLambertMaterial",o.color=new wo(16777215),o.map=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.emissive=new wo(0),o.emissiveIntensity=1,o.emissiveMap=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.specularMap=null,o.alphaMap=null,o.envMap=null,o.combine=Sn,o.reflectivity=1,o.refractionRatio=.98,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.flatShading=!1,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jr),zu=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isMeshMatcapMaterial=!0,o.defines={MATCAP:""},o.type="MeshMatcapMaterial",o.color=new wo(16777215),o.matcap=null,o.map=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.alphaMap=null,o.flatShading=!1,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.defines={MATCAP:""},this.color.copy(n.color),this.matcap=n.matcap,this.map=n.map,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jr),ku=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).isLineDashedMaterial=!0,o.type="LineDashedMaterial",o.scale=1,o.dashSize=3,o.gapSize=1,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.scale=n.scale,this.dashSize=n.dashSize,this.gapSize=n.gapSize,this}}]),t}(Ml);function Cu(n,e,t){return Ru(n)?new n.constructor(n.subarray(e,void 0!==t?t:n.length)):n.slice(e,t)}function Tu(n,e,t){return!n||!t&&n.constructor===e?n:"number"===typeof e.BYTES_PER_ELEMENT?new e(n):Array.prototype.slice.call(n)}function Ru(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function Du(n){for(var e=n.length,t=new Array(e),o=0;o!==e;++o)t[o]=o;return t.sort((function(e,t){return n[e]-n[t]})),t}function Pu(n,e,t){for(var o=n.length,r=new n.constructor(o),a=0,i=0;i!==o;++a)for(var v=t[a]*e,c=0;c!==e;++c)r[i++]=n[v+c];return r}function Fu(n,e,t,o){for(var r=1,a=n[0];void 0!==a&&void 0===a[o];)a=n[r++];if(void 0!==a){var i=a[o];if(void 0!==i)if(Array.isArray(i))do{void 0!==(i=a[o])&&(e.push(a.time),t.push.apply(t,i)),a=n[r++]}while(void 0!==a);else if(void 0!==i.toArray)do{void 0!==(i=a[o])&&(e.push(a.time),i.toArray(t,t.length)),a=n[r++]}while(void 0!==a);else do{void 0!==(i=a[o])&&(e.push(a.time),t.push(i)),a=n[r++]}while(void 0!==a)}}var ju=Object.freeze({__proto__:null,arraySlice:Cu,convertArray:Tu,isTypedArray:Ru,getKeyframeOrder:Du,sortedArray:Pu,flattenJSON:Fu,subclip:function(n,e,t,o){var r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:30,a=n.clone();a.name=e;for(var i=[],v=0;v<a.tracks.length;++v){for(var c=a.tracks[v],l=c.getValueSize(),s=[],u=[],f=0;f<c.times.length;++f){var p=c.times[f]*r;if(!(p<t||p>=o)){s.push(c.times[f]);for(var m=0;m<l;++m)u.push(c.values[f*l+m])}}0!==s.length&&(c.times=Tu(s,c.times.constructor),c.values=Tu(u,c.values.constructor),i.push(c))}a.tracks=i;for(var d=1/0,h=0;h<a.tracks.length;++h)d>a.tracks[h].times[0]&&(d=a.tracks[h].times[0]);for(var x=0;x<a.tracks.length;++x)a.tracks[x].shift(-1*d);return a.resetDuration(),a},makeClipAdditive:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:30;o<=0&&(o=30);for(var r=t.tracks.length,a=e/o,i=function(e){var o=t.tracks[e],r=o.ValueTypeName;if("bool"===r||"string"===r)return"continue";var i=n.tracks.find((function(n){return n.name===o.name&&n.ValueTypeName===r}));if(void 0===i)return"continue";var v=0,c=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(v=c/3);var l=0,s=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(l=s/3);var u=o.times.length-1,f=void 0;if(a<=o.times[0]){var p=v,m=c-v;f=Cu(o.values,p,m)}else if(a>=o.times[u]){var d=u*c+v,h=d+c-v;f=Cu(o.values,d,h)}else{var x=o.createInterpolant(),y=v,g=c-v;x.evaluate(a),f=Cu(x.resultBuffer,y,g)}"quaternion"===r&&(new Eo).fromArray(f).normalize().conjugate().toArray(f);for(var b=i.times.length,_=0;_<b;++_){var U=_*s+l;if("quaternion"===r)Eo.multiplyQuaternionsFlat(i.values,U,f,0,i.values,U);else for(var w=s-2*l,S=0;S<w;++S)i.values[U+S]-=f[S]}},v=0;v<r;++v)i(v);return n.blendMode=ot,n}}),Iu=function(){function n(e,t,o,r){y(this,n),this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new t.constructor(o),this.sampleValues=t,this.valueSize=o,this.settings=null,this.DefaultSettings_={}}return b(n,[{key:"evaluate",value:function(n){var e=this.parameterPositions,t=this._cachedIndex,o=e[t],r=e[t-1];n:{e:{var a;t:{o:if(!(n<o)){for(var i=t+2;;){if(void 0===o){if(n<r)break o;return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}if(t===i)break;if(r=o,n<(o=e[++t]))break e}a=e.length;break t}if(n>=r)break n;var v=e[1];n<v&&(t=2,r=v);for(var c=t-2;;){if(void 0===r)return this._cachedIndex=0,this.copySampleValue_(0);if(t===c)break;if(o=r,n>=(r=e[--t-1]))break e}a=t,t=0}for(;t<a;){var l=t+a>>>1;n<e[l]?a=l:t=l+1}if(o=e[t],void 0===(r=e[t-1]))return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===o)return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}this._cachedIndex=t,this.intervalChanged_(t,r,o)}return this.interpolate_(t,r,n,o)}},{key:"getSettings_",value:function(){return this.settings||this.DefaultSettings_}},{key:"copySampleValue_",value:function(n){for(var e=this.resultBuffer,t=this.sampleValues,o=this.valueSize,r=n*o,a=0;a!==o;++a)e[a]=t[r+a];return e}},{key:"interpolate_",value:function(){throw new Error("call to abstract method")}},{key:"intervalChanged_",value:function(){}}]),n}(),Eu=function(n){_(t,n);var e=z(t);function t(n,o,r,a){var i;return y(this,t),(i=e.call(this,n,o,r,a))._weightPrev=-0,i._offsetPrev=-0,i._weightNext=-0,i._offsetNext=-0,i.DefaultSettings_={endingStart:$e,endingEnd:$e},i}return b(t,[{key:"intervalChanged_",value:function(n,e,t){var o=this.parameterPositions,r=n-2,a=n+1,i=o[r],v=o[a];if(void 0===i)switch(this.getSettings_().endingStart){case nt:r=n,i=2*e-t;break;case et:i=e+o[r=o.length-2]-o[r+1];break;default:r=n,i=t}if(void 0===v)switch(this.getSettings_().endingEnd){case nt:a=n,v=2*t-e;break;case et:a=1,v=t+o[1]-o[0];break;default:a=n-1,v=e}var c=.5*(t-e),l=this.valueSize;this._weightPrev=c/(e-i),this._weightNext=c/(v-t),this._offsetPrev=r*l,this._offsetNext=a*l}},{key:"interpolate_",value:function(n,e,t,o){for(var r=this.resultBuffer,a=this.sampleValues,i=this.valueSize,v=n*i,c=v-i,l=this._offsetPrev,s=this._offsetNext,u=this._weightPrev,f=this._weightNext,p=(t-e)/(o-e),m=p*p,d=m*p,h=-u*d+2*u*m-u*p,x=(1+u)*d+(-1.5-2*u)*m+(-.5+u)*p+1,y=(-1-f)*d+(1.5+f)*m+.5*p,g=f*d-f*m,b=0;b!==i;++b)r[b]=h*a[l+b]+x*a[c+b]+y*a[v+b]+g*a[s+b];return r}}]),t}(Iu),Ou=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),e.call(this,n,o,r,a)}return b(t,[{key:"interpolate_",value:function(n,e,t,o){for(var r=this.resultBuffer,a=this.sampleValues,i=this.valueSize,v=n*i,c=v-i,l=(t-e)/(o-e),s=1-l,u=0;u!==i;++u)r[u]=a[c+u]*s+a[v+u]*l;return r}}]),t}(Iu),Lu=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),e.call(this,n,o,r,a)}return b(t,[{key:"interpolate_",value:function(n){return this.copySampleValue_(n-1)}}]),t}(Iu),Au=function(){function n(e,t,o,r){if(y(this,n),void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Tu(t,this.TimeBufferType),this.values=Tu(o,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}return b(n,[{key:"InterpolantFactoryMethodDiscrete",value:function(n){return new Lu(this.times,this.values,this.getValueSize(),n)}},{key:"InterpolantFactoryMethodLinear",value:function(n){return new Ou(this.times,this.values,this.getValueSize(),n)}},{key:"InterpolantFactoryMethodSmooth",value:function(n){return new Eu(this.times,this.values,this.getValueSize(),n)}},{key:"setInterpolation",value:function(n){var e;switch(n){case Qe:e=this.InterpolantFactoryMethodDiscrete;break;case Je:e=this.InterpolantFactoryMethodLinear;break;case Ke:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){var t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(n===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this}},{key:"getInterpolation",value:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Qe;case this.InterpolantFactoryMethodLinear:return Je;case this.InterpolantFactoryMethodSmooth:return Ke}}},{key:"getValueSize",value:function(){return this.values.length/this.times.length}},{key:"shift",value:function(n){if(0!==n)for(var e=this.times,t=0,o=e.length;t!==o;++t)e[t]+=n;return this}},{key:"scale",value:function(n){if(1!==n)for(var e=this.times,t=0,o=e.length;t!==o;++t)e[t]*=n;return this}},{key:"trim",value:function(n,e){for(var t=this.times,o=t.length,r=0,a=o-1;r!==o&&t[r]<n;)++r;for(;-1!==a&&t[a]>e;)--a;if(++a,0!==r||a!==o){r>=a&&(r=(a=Math.max(a,1))-1);var i=this.getValueSize();this.times=Cu(t,r,a),this.values=Cu(this.values,r*i,a*i)}return this}},{key:"validate",value:function(){var n=!0,e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),n=!1);var t=this.times,o=this.values,r=t.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),n=!1);for(var a=null,i=0;i!==r;i++){var v=t[i];if("number"===typeof v&&isNaN(v)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,i,v),n=!1;break}if(null!==a&&a>v){console.error("THREE.KeyframeTrack: Out of order keys.",this,i,v,a),n=!1;break}a=v}if(void 0!==o&&Ru(o))for(var c=0,l=o.length;c!==l;++c){var s=o[c];if(isNaN(s)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,c,s),n=!1;break}}return n}},{key:"optimize",value:function(){for(var n=Cu(this.times),e=Cu(this.values),t=this.getValueSize(),o=this.getInterpolation()===Ke,r=n.length-1,a=1,i=1;i<r;++i){var v=!1,c=n[i];if(c!==n[i+1]&&(1!==i||c!==n[0]))if(o)v=!0;else for(var l=i*t,s=l-t,u=l+t,f=0;f!==t;++f){var p=e[l+f];if(p!==e[s+f]||p!==e[u+f]){v=!0;break}}if(v){if(i!==a){n[a]=n[i];for(var m=i*t,d=a*t,h=0;h!==t;++h)e[d+h]=e[m+h]}++a}}if(r>0){n[a]=n[r];for(var x=r*t,y=a*t,g=0;g!==t;++g)e[y+g]=e[x+g];++a}return a!==n.length?(this.times=Cu(n,0,a),this.values=Cu(e,0,a*t)):(this.times=n,this.values=e),this}},{key:"clone",value:function(){var n=Cu(this.times,0),e=Cu(this.values,0),t=new(0,this.constructor)(this.name,n,e);return t.createInterpolant=this.createInterpolant,t}}],[{key:"toJSON",value:function(n){var e,t=n.constructor;if(t.toJSON!==this.toJSON)e=t.toJSON(n);else{e={name:n.name,times:Tu(n.times,Array),values:Tu(n.values,Array)};var o=n.getInterpolation();o!==n.DefaultInterpolation&&(e.interpolation=o)}return e.type=n.ValueTypeName,e}}]),n}();Au.prototype.TimeBufferType=Float32Array,Au.prototype.ValueBufferType=Float32Array,Au.prototype.DefaultInterpolation=Je;var Gu=function(n){_(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return b(t)}(Au);Gu.prototype.ValueTypeName="bool",Gu.prototype.ValueBufferType=Array,Gu.prototype.DefaultInterpolation=Qe,Gu.prototype.InterpolantFactoryMethodLinear=void 0,Gu.prototype.InterpolantFactoryMethodSmooth=void 0;var Nu=function(n){_(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return b(t)}(Au);Nu.prototype.ValueTypeName="color";var Bu=function(n){_(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return b(t)}(Au);Bu.prototype.ValueTypeName="number";var qu=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),e.call(this,n,o,r,a)}return b(t,[{key:"interpolate_",value:function(n,e,t,o){for(var r=this.resultBuffer,a=this.sampleValues,i=this.valueSize,v=(t-e)/(o-e),c=n*i,l=c+i;c!==l;c+=4)Eo.slerpFlat(r,0,a,c-i,a,c,v);return r}}]),t}(Iu),Vu=function(n){_(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return b(t,[{key:"InterpolantFactoryMethodLinear",value:function(n){return new qu(this.times,this.values,this.getValueSize(),n)}}]),t}(Au);Vu.prototype.ValueTypeName="quaternion",Vu.prototype.DefaultInterpolation=Je,Vu.prototype.InterpolantFactoryMethodSmooth=void 0;var Wu=function(n){_(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return b(t)}(Au);Wu.prototype.ValueTypeName="string",Wu.prototype.ValueBufferType=Array,Wu.prototype.DefaultInterpolation=Qe,Wu.prototype.InterpolantFactoryMethodLinear=void 0,Wu.prototype.InterpolantFactoryMethodSmooth=void 0;var Hu=function(n){_(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return b(t)}(Au);Hu.prototype.ValueTypeName="vector";var Xu=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2?arguments[2]:void 0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:tt;y(this,n),this.name=e,this.tracks=o,this.duration=t,this.blendMode=r,this.uuid=Zt(),this.duration<0&&this.resetDuration()}return b(n,[{key:"resetDuration",value:function(){for(var n=0,e=0,t=this.tracks.length;e!==t;++e){var o=this.tracks[e];n=Math.max(n,o.times[o.times.length-1])}return this.duration=n,this}},{key:"trim",value:function(){for(var n=0;n<this.tracks.length;n++)this.tracks[n].trim(0,this.duration);return this}},{key:"validate",value:function(){for(var n=!0,e=0;e<this.tracks.length;e++)n=n&&this.tracks[e].validate();return n}},{key:"optimize",value:function(){for(var n=0;n<this.tracks.length;n++)this.tracks[n].optimize();return this}},{key:"clone",value:function(){for(var n=[],e=0;e<this.tracks.length;e++)n.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,n,this.blendMode)}},{key:"toJSON",value:function(){return this.constructor.toJSON(this)}}],[{key:"parse",value:function(n){for(var e=[],t=n.tracks,o=1/(n.fps||1),r=0,a=t.length;r!==a;++r)e.push(Yu(t[r]).scale(o));var i=new this(n.name,n.duration,e,n.blendMode);return i.uuid=n.uuid,i}},{key:"toJSON",value:function(n){for(var e=[],t=n.tracks,o={name:n.name,duration:n.duration,tracks:e,uuid:n.uuid,blendMode:n.blendMode},r=0,a=t.length;r!==a;++r)e.push(Au.toJSON(t[r]));return o}},{key:"CreateFromMorphTargetSequence",value:function(n,e,t,o){for(var r=e.length,a=[],i=0;i<r;i++){var v=[],c=[];v.push((i+r-1)%r,i,(i+1)%r),c.push(0,1,0);var l=Du(v);v=Pu(v,1,l),c=Pu(c,1,l),o||0!==v[0]||(v.push(r),c.push(c[0])),a.push(new Bu(".morphTargetInfluences["+e[i].name+"]",v,c).scale(1/t))}return new this(n,-1,a)}},{key:"findByName",value:function(n,e){var t=n;if(!Array.isArray(n)){var o=n;t=o.geometry&&o.geometry.animations||o.animations}for(var r=0;r<t.length;r++)if(t[r].name===e)return t[r];return null}},{key:"CreateClipsFromMorphTargetSequences",value:function(n,e,t){for(var o={},r=/^([\w-]*?)([\d]+)$/,a=0,i=n.length;a<i;a++){var v=n[a],c=v.name.match(r);if(c&&c.length>1){var l=c[1],s=o[l];s||(o[l]=s=[]),s.push(v)}}var u=[];for(var f in o)u.push(this.CreateFromMorphTargetSequence(f,o[f],e,t));return u}},{key:"parseAnimation",value:function(n,e){if(!n)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;for(var t=function(n,e,t,o,r){if(0!==t.length){var a=[],i=[];Fu(t,a,i,o),0!==a.length&&r.push(new n(e,a,i))}},o=[],r=n.name||"default",a=n.fps||30,i=n.blendMode,v=n.length||-1,c=n.hierarchy||[],l=0;l<c.length;l++){var s=c[l].keys;if(s&&0!==s.length)if(s[0].morphTargets){var u={},f=void 0;for(f=0;f<s.length;f++)if(s[f].morphTargets)for(var p=0;p<s[f].morphTargets.length;p++)u[s[f].morphTargets[p]]=-1;for(var m in u){for(var d=[],h=[],x=0;x!==s[f].morphTargets.length;++x){var y=s[f];d.push(y.time),h.push(y.morphTarget===m?1:0)}o.push(new Bu(".morphTargetInfluence["+m+"]",d,h))}v=u.length*a}else{var g=".bones["+e[l].name+"]";t(Hu,g+".position",s,"pos",o),t(Vu,g+".quaternion",s,"rot",o),t(Hu,g+".scale",s,"scl",o)}}return 0===o.length?null:new this(r,v,o,i)}}]),n}();function Yu(n){if(void 0===n.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");var e=function(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Bu;case"vector":case"vector2":case"vector3":case"vector4":return Hu;case"color":return Nu;case"quaternion":return Vu;case"bool":case"boolean":return Gu;case"string":return Wu}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}(n.type);if(void 0===n.times){var t=[],o=[];Fu(n.keys,t,o,"value"),n.times=t,n.values=o}return void 0!==e.parse?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}var Zu,Qu={enabled:!1,files:{},add:function(n,e){!1!==this.enabled&&(this.files[n]=e)},get:function(n){if(!1!==this.enabled)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}},Ju=b((function n(e,t,o){y(this,n);var r=this,a=!1,i=0,v=0,c=void 0,l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=o,this.itemStart=function(n){v++,!1===a&&void 0!==r.onStart&&r.onStart(n,i,v),a=!0},this.itemEnd=function(n){i++,void 0!==r.onProgress&&r.onProgress(n,i,v),i===v&&(a=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(n){void 0!==r.onError&&r.onError(n)},this.resolveURL=function(n){return c?c(n):n},this.setURLModifier=function(n){return c=n,this},this.addHandler=function(n,e){return l.push(n,e),this},this.removeHandler=function(n){var e=l.indexOf(n);return-1!==e&&l.splice(e,2),this},this.getHandler=function(n){for(var e=0,t=l.length;e<t;e+=2){var o=l[e],r=l[e+1];if(o.global&&(o.lastIndex=0),o.test(n))return r}return null}})),Ku=new Ju,$u=function(){function n(e){y(this,n),this.manager=void 0!==e?e:Ku,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}return b(n,[{key:"load",value:function(){}},{key:"loadAsync",value:function(n,e){var t=this;return new Promise((function(o,r){t.load(n,o,e,r)}))}},{key:"parse",value:function(){}},{key:"setCrossOrigin",value:function(n){return this.crossOrigin=n,this}},{key:"setWithCredentials",value:function(n){return this.withCredentials=n,this}},{key:"setPath",value:function(n){return this.path=n,this}},{key:"setResourcePath",value:function(n){return this.resourcePath=n,this}},{key:"setRequestHeader",value:function(n){return this.requestHeader=n,this}}]),n}(),nf={},ef=function(n){_(t,n);var e=z(t);function t(n,o){var r;return y(this,t),(r=e.call(this,n)).response=o,r}return b(t)}(k(Error)),tf=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this;void 0===n&&(n=""),void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);var a=Qu.get(n);if(void 0!==a)return this.manager.itemStart(n),setTimeout((function(){e&&e(a),r.manager.itemEnd(n)}),0),a;if(void 0===nf[n]){nf[n]=[],nf[n].push({onLoad:e,onProgress:t,onError:o});var i=new Request(n,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),v=this.mimeType,c=this.responseType;fetch(i).then((function(e){if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"===typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;var t=nf[n],o=e.body.getReader(),r=e.headers.get("Content-Length"),a=r?parseInt(r):0,i=0!==a,v=0,c=new ReadableStream({start:function(n){!function e(){o.read().then((function(o){var r=o.done,c=o.value;if(r)n.close();else{v+=c.byteLength;for(var l=new ProgressEvent("progress",{lengthComputable:i,loaded:v,total:a}),s=0,u=t.length;s<u;s++){var f=t[s];f.onProgress&&f.onProgress(l)}n.enqueue(c),e()}}))}()}});return new Response(c)}throw new ef('fetch for "'.concat(e.url,'" responded with ').concat(e.status,": ").concat(e.statusText),e)})).then((function(n){switch(c){case"arraybuffer":return n.arrayBuffer();case"blob":return n.blob();case"document":return n.text().then((function(n){return(new DOMParser).parseFromString(n,v)}));case"json":return n.json();default:if(void 0===v)return n.text();var e=/charset="?([^;"\s]*)"?/i.exec(v),t=e&&e[1]?e[1].toLowerCase():void 0,o=new TextDecoder(t);return n.arrayBuffer().then((function(n){return o.decode(n)}))}})).then((function(e){Qu.add(n,e);var t=nf[n];delete nf[n];for(var o=0,r=t.length;o<r;o++){var a=t[o];a.onLoad&&a.onLoad(e)}})).catch((function(e){var t=nf[n];if(void 0===t)throw r.manager.itemError(n),e;delete nf[n];for(var o=0,a=t.length;o<a;o++){var i=t[o];i.onError&&i.onError(e)}r.manager.itemError(n)})).finally((function(){r.manager.itemEnd(n)})),this.manager.itemStart(n)}else nf[n].push({onLoad:e,onProgress:t,onError:o})}},{key:"setResponseType",value:function(n){return this.responseType=n,this}},{key:"setMimeType",value:function(n){return this.mimeType=n,this}}]),t}($u),of=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new tf(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(n,(function(t){try{e(r.parse(JSON.parse(t)))}catch(a){o?o(a):console.error(a),r.manager.itemError(n)}}),t,o)}},{key:"parse",value:function(n){for(var e=[],t=0;t<n.length;t++){var o=Xu.parse(n[t]);e.push(o)}return e}}]),t}($u),rf=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=[],i=new Wl,v=new tf(this.manager);v.setPath(this.path),v.setResponseType("arraybuffer"),v.setRequestHeader(this.requestHeader),v.setWithCredentials(r.withCredentials);var c=0;function l(l){v.load(n[l],(function(n){var t=r.parse(n,!0);a[l]={width:t.width,height:t.height,format:t.format,mipmaps:t.mipmaps},6===(c+=1)&&(1===t.mipmapCount&&(i.minFilter=Xn),i.image=a,i.format=t.format,i.needsUpdate=!0,e&&e(i))}),t,o)}if(Array.isArray(n))for(var s=0,u=n.length;s<u;++s)l(s);else v.load(n,(function(n){var t=r.parse(n,!0);if(t.isCubemap){for(var o=t.mipmaps.length/t.mipmapCount,v=0;v<o;v++){a[v]={mipmaps:[]};for(var c=0;c<t.mipmapCount;c++)a[v].mipmaps.push(t.mipmaps[v*t.mipmapCount+c]),a[v].format=t.format,a[v].width=t.width,a[v].height=t.height}i.image=a}else i.image.width=t.width,i.image.height=t.height,i.mipmaps=t.mipmaps;1===t.mipmapCount&&(i.minFilter=Xn),i.format=t.format,i.needsUpdate=!0,e&&e(i)}),t,o);return i}}]),t}($u),af=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);var r=this,a=Qu.get(n);if(void 0!==a)return r.manager.itemStart(n),setTimeout((function(){e&&e(a),r.manager.itemEnd(n)}),0),a;var i=so("img");function v(){l(),Qu.add(n,this),e&&e(this),r.manager.itemEnd(n)}function c(e){l(),o&&o(e),r.manager.itemError(n),r.manager.itemEnd(n)}function l(){i.removeEventListener("load",v,!1),i.removeEventListener("error",c,!1)}return i.addEventListener("load",v,!1),i.addEventListener("error",c,!1),"data:"!==n.slice(0,5)&&void 0!==this.crossOrigin&&(i.crossOrigin=this.crossOrigin),r.manager.itemStart(n),i.src=n,i}}]),t}($u),vf=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=new Ya,a=new af(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);var i=0;function v(t){a.load(n[t],(function(n){r.images[t]=n,6===++i&&(r.needsUpdate=!0,e&&e(r))}),void 0,o)}for(var c=0;c<n.length;++c)v(c);return r}}]),t}($u),cf=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new ml,i=new tf(this.manager);return i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setPath(this.path),i.setWithCredentials(r.withCredentials),i.load(n,(function(n){var t=r.parse(n);t&&(void 0!==t.image?a.image=t.image:void 0!==t.data&&(a.image.width=t.width,a.image.height=t.height,a.image.data=t.data),a.wrapS=void 0!==t.wrapS?t.wrapS:Gn,a.wrapT=void 0!==t.wrapT?t.wrapT:Gn,a.magFilter=void 0!==t.magFilter?t.magFilter:Xn,a.minFilter=void 0!==t.minFilter?t.minFilter:Xn,a.anisotropy=void 0!==t.anisotropy?t.anisotropy:1,void 0!==t.encoding&&(a.encoding=t.encoding),void 0!==t.flipY&&(a.flipY=t.flipY),void 0!==t.format&&(a.format=t.format),void 0!==t.type&&(a.type=t.type),void 0!==t.mipmaps&&(a.mipmaps=t.mipmaps,a.minFilter=Qn),1===t.mipmapCount&&(a.minFilter=Xn),void 0!==t.generateMipmaps&&(a.generateMipmaps=t.generateMipmaps),a.needsUpdate=!0,e&&e(a,t))}),t,o),a}}]),t}($u),lf=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=new Co,a=new af(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(n,(function(n){r.image=n,r.needsUpdate=!0,void 0!==e&&e(r)}),t,o),r}}]),t}($u),sf=function(n){_(t,n);var e=z(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return y(this,t),(o=e.call(this)).isLight=!0,o.type="Light",o.color=new wo(n),o.intensity=r,o}return b(t,[{key:"dispose",value:function(){}},{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.color.copy(n.color),this.intensity=n.intensity,this}},{key:"toJSON",value:function(n){var e=D(U(t.prototype),"toJSON",this).call(this,n);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}]),t}(Lr),uf=function(n){_(t,n);var e=z(t);function t(n,o,r){var a;return y(this,t),(a=e.call(this,n,r)).isHemisphereLight=!0,a.type="HemisphereLight",a.position.copy(Lr.DefaultUp),a.updateMatrix(),a.groundColor=new wo(o),a}return b(t,[{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.groundColor.copy(n.groundColor),this}}]),t}(sf),ff=new pr,pf=new Oo,mf=new Oo,df=function(){function n(e){y(this,n),this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new ao(512,512),this.map=null,this.mapPass=null,this.matrix=new pr,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new ti,this._frameExtents=new ao(1,1),this._viewportCount=1,this._viewports=[new To(0,0,1,1)]}return b(n,[{key:"getViewportCount",value:function(){return this._viewportCount}},{key:"getFrustum",value:function(){return this._frustum}},{key:"updateMatrices",value:function(n){var e=this.camera,t=this.matrix;pf.setFromMatrixPosition(n.matrixWorld),e.position.copy(pf),mf.setFromMatrixPosition(n.target.matrixWorld),e.lookAt(mf),e.updateMatrixWorld(),ff.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ff),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(ff)}},{key:"getViewport",value:function(n){return this._viewports[n]}},{key:"getFrameExtents",value:function(){return this._frameExtents}},{key:"dispose",value:function(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}},{key:"copy",value:function(n){return this.camera=n.camera.clone(),this.bias=n.bias,this.radius=n.radius,this.mapSize.copy(n.mapSize),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"toJSON",value:function(){var n={};return 0!==this.bias&&(n.bias=this.bias),0!==this.normalBias&&(n.normalBias=this.normalBias),1!==this.radius&&(n.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(n.mapSize=this.mapSize.toArray()),n.camera=this.camera.toJSON(!1).object,delete n.camera.matrix,n}}]),n}(),hf=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this,new Wa(50,1,.5,500))).isSpotLightShadow=!0,n.focus=1,n}return b(t,[{key:"updateMatrices",value:function(n){var e=this.camera,o=2*Yt*n.angle*this.focus,r=this.mapSize.width/this.mapSize.height,a=n.distance||e.far;o===e.fov&&r===e.aspect&&a===e.far||(e.fov=o,e.aspect=r,e.far=a,e.updateProjectionMatrix()),D(U(t.prototype),"updateMatrices",this).call(this,n)}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.focus=n.focus,this}}]),t}(df),xf=function(n){_(t,n);var e=z(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Math.PI/3,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;return y(this,t),(r=e.call(this,n,o)).isSpotLight=!0,r.type="SpotLight",r.position.copy(Lr.DefaultUp),r.updateMatrix(),r.target=new Lr,r.distance=a,r.angle=i,r.penumbra=v,r.decay=c,r.map=null,r.shadow=new hf,r}return b(t,[{key:"power",get:function(){return this.intensity*Math.PI},set:function(n){this.intensity=n/Math.PI}},{key:"dispose",value:function(){this.shadow.dispose()}},{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.distance=n.distance,this.angle=n.angle,this.penumbra=n.penumbra,this.decay=n.decay,this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}}]),t}(sf),yf=new pr,gf=new Oo,bf=new Oo,_f=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this,new Wa(90,1,.5,500))).isPointLightShadow=!0,n._frameExtents=new ao(4,2),n._viewportCount=6,n._viewports=[new To(2,1,1,1),new To(0,1,1,1),new To(3,1,1,1),new To(1,1,1,1),new To(3,0,1,1),new To(1,0,1,1)],n._cubeDirections=[new Oo(1,0,0),new Oo(-1,0,0),new Oo(0,0,1),new Oo(0,0,-1),new Oo(0,1,0),new Oo(0,-1,0)],n._cubeUps=[new Oo(0,1,0),new Oo(0,1,0),new Oo(0,1,0),new Oo(0,1,0),new Oo(0,0,1),new Oo(0,0,-1)],n}return b(t,[{key:"updateMatrices",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.camera,o=this.matrix,r=n.distance||t.far;r!==t.far&&(t.far=r,t.updateProjectionMatrix()),gf.setFromMatrixPosition(n.matrixWorld),t.position.copy(gf),bf.copy(t.position),bf.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(bf),t.updateMatrixWorld(),o.makeTranslation(-gf.x,-gf.y,-gf.z),yf.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(yf)}}]),t}(df),Uf=function(n){_(t,n);var e=z(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return y(this,t),(r=e.call(this,n,o)).isPointLight=!0,r.type="PointLight",r.distance=a,r.decay=i,r.shadow=new _f,r}return b(t,[{key:"power",get:function(){return 4*this.intensity*Math.PI},set:function(n){this.intensity=n/(4*Math.PI)}},{key:"dispose",value:function(){this.shadow.dispose()}},{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.distance=n.distance,this.decay=n.decay,this.shadow=n.shadow.clone(),this}}]),t}(sf),wf=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this,new di(-5,5,5,-5,.5,500))).isDirectionalLightShadow=!0,n}return b(t)}(df),Sf=function(n){_(t,n);var e=z(t);function t(n,o){var r;return y(this,t),(r=e.call(this,n,o)).isDirectionalLight=!0,r.type="DirectionalLight",r.position.copy(Lr.DefaultUp),r.updateMatrix(),r.target=new Lr,r.shadow=new wf,r}return b(t,[{key:"dispose",value:function(){this.shadow.dispose()}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}}]),t}(sf),Mf=function(n){_(t,n);var e=z(t);function t(n,o){var r;return y(this,t),(r=e.call(this,n,o)).isAmbientLight=!0,r.type="AmbientLight",r}return b(t)}(sf),zf=function(n){_(t,n);var e=z(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:10;return y(this,t),(r=e.call(this,n,o)).isRectAreaLight=!0,r.type="RectAreaLight",r.width=a,r.height=i,r}return b(t,[{key:"power",get:function(){return this.intensity*this.width*this.height*Math.PI},set:function(n){this.intensity=n/(this.width*this.height*Math.PI)}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.width=n.width,this.height=n.height,this}},{key:"toJSON",value:function(n){var e=D(U(t.prototype),"toJSON",this).call(this,n);return e.object.width=this.width,e.object.height=this.height,e}}]),t}(sf),kf=function(){function n(){y(this,n),this.isSphericalHarmonics3=!0,this.coefficients=[];for(var e=0;e<9;e++)this.coefficients.push(new Oo)}return b(n,[{key:"set",value:function(n){for(var e=0;e<9;e++)this.coefficients[e].copy(n[e]);return this}},{key:"zero",value:function(){for(var n=0;n<9;n++)this.coefficients[n].set(0,0,0);return this}},{key:"getAt",value:function(n,e){var t=n.x,o=n.y,r=n.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*o),e.addScaledVector(a[2],.488603*r),e.addScaledVector(a[3],.488603*t),e.addScaledVector(a[4],t*o*1.092548),e.addScaledVector(a[5],o*r*1.092548),e.addScaledVector(a[6],.315392*(3*r*r-1)),e.addScaledVector(a[7],t*r*1.092548),e.addScaledVector(a[8],.546274*(t*t-o*o)),e}},{key:"getIrradianceAt",value:function(n,e){var t=n.x,o=n.y,r=n.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],1.023328*o),e.addScaledVector(a[2],1.023328*r),e.addScaledVector(a[3],1.023328*t),e.addScaledVector(a[4],.858086*t*o),e.addScaledVector(a[5],.858086*o*r),e.addScaledVector(a[6],.743125*r*r-.247708),e.addScaledVector(a[7],.858086*t*r),e.addScaledVector(a[8],.429043*(t*t-o*o)),e}},{key:"add",value:function(n){for(var e=0;e<9;e++)this.coefficients[e].add(n.coefficients[e]);return this}},{key:"addScaledSH",value:function(n,e){for(var t=0;t<9;t++)this.coefficients[t].addScaledVector(n.coefficients[t],e);return this}},{key:"scale",value:function(n){for(var e=0;e<9;e++)this.coefficients[e].multiplyScalar(n);return this}},{key:"lerp",value:function(n,e){for(var t=0;t<9;t++)this.coefficients[t].lerp(n.coefficients[t],e);return this}},{key:"equals",value:function(n){for(var e=0;e<9;e++)if(!this.coefficients[e].equals(n.coefficients[e]))return!1;return!0}},{key:"copy",value:function(n){return this.set(n.coefficients)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.coefficients,o=0;o<9;o++)t[o].fromArray(n,e+3*o);return this}},{key:"toArray",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.coefficients,o=0;o<9;o++)t[o].toArray(n,e+3*o);return n}}],[{key:"getBasisAt",value:function(n,e){var t=n.x,o=n.y,r=n.z;e[0]=.282095,e[1]=.488603*o,e[2]=.488603*r,e[3]=.488603*t,e[4]=1.092548*t*o,e[5]=1.092548*o*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*t*r,e[8]=.546274*(t*t-o*o)}}]),n}(),Cf=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new kf,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return y(this,t),(n=e.call(this,void 0,r)).isLightProbe=!0,n.sh=o,n}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.sh.copy(n.sh),this}},{key:"fromJSON",value:function(n){return this.intensity=n.intensity,this.sh.fromArray(n.sh),this}},{key:"toJSON",value:function(n){var e=D(U(t.prototype),"toJSON",this).call(this,n);return e.object.sh=this.sh.toArray(),e}}]),t}(sf),Tf=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this,n)).textures={},o}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new tf(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(n,(function(t){try{e(r.parse(JSON.parse(t)))}catch(a){o?o(a):console.error(a),r.manager.itemError(n)}}),t,o)}},{key:"parse",value:function(n){var e=this.textures;function o(n){return void 0===e[n]&&console.warn("THREE.MaterialLoader: Undefined texture",n),e[n]}var r=t.createMaterialFromType(n.type);if(void 0!==n.uuid&&(r.uuid=n.uuid),void 0!==n.name&&(r.name=n.name),void 0!==n.color&&void 0!==r.color&&r.color.setHex(n.color),void 0!==n.roughness&&(r.roughness=n.roughness),void 0!==n.metalness&&(r.metalness=n.metalness),void 0!==n.sheen&&(r.sheen=n.sheen),void 0!==n.sheenColor&&(r.sheenColor=(new wo).setHex(n.sheenColor)),void 0!==n.sheenRoughness&&(r.sheenRoughness=n.sheenRoughness),void 0!==n.emissive&&void 0!==r.emissive&&r.emissive.setHex(n.emissive),void 0!==n.specular&&void 0!==r.specular&&r.specular.setHex(n.specular),void 0!==n.specularIntensity&&(r.specularIntensity=n.specularIntensity),void 0!==n.specularColor&&void 0!==r.specularColor&&r.specularColor.setHex(n.specularColor),void 0!==n.shininess&&(r.shininess=n.shininess),void 0!==n.clearcoat&&(r.clearcoat=n.clearcoat),void 0!==n.clearcoatRoughness&&(r.clearcoatRoughness=n.clearcoatRoughness),void 0!==n.iridescence&&(r.iridescence=n.iridescence),void 0!==n.iridescenceIOR&&(r.iridescenceIOR=n.iridescenceIOR),void 0!==n.iridescenceThicknessRange&&(r.iridescenceThicknessRange=n.iridescenceThicknessRange),void 0!==n.transmission&&(r.transmission=n.transmission),void 0!==n.thickness&&(r.thickness=n.thickness),void 0!==n.attenuationDistance&&(r.attenuationDistance=n.attenuationDistance),void 0!==n.attenuationColor&&void 0!==r.attenuationColor&&r.attenuationColor.setHex(n.attenuationColor),void 0!==n.fog&&(r.fog=n.fog),void 0!==n.flatShading&&(r.flatShading=n.flatShading),void 0!==n.blending&&(r.blending=n.blending),void 0!==n.combine&&(r.combine=n.combine),void 0!==n.side&&(r.side=n.side),void 0!==n.shadowSide&&(r.shadowSide=n.shadowSide),void 0!==n.opacity&&(r.opacity=n.opacity),void 0!==n.transparent&&(r.transparent=n.transparent),void 0!==n.alphaTest&&(r.alphaTest=n.alphaTest),void 0!==n.depthTest&&(r.depthTest=n.depthTest),void 0!==n.depthWrite&&(r.depthWrite=n.depthWrite),void 0!==n.colorWrite&&(r.colorWrite=n.colorWrite),void 0!==n.stencilWrite&&(r.stencilWrite=n.stencilWrite),void 0!==n.stencilWriteMask&&(r.stencilWriteMask=n.stencilWriteMask),void 0!==n.stencilFunc&&(r.stencilFunc=n.stencilFunc),void 0!==n.stencilRef&&(r.stencilRef=n.stencilRef),void 0!==n.stencilFuncMask&&(r.stencilFuncMask=n.stencilFuncMask),void 0!==n.stencilFail&&(r.stencilFail=n.stencilFail),void 0!==n.stencilZFail&&(r.stencilZFail=n.stencilZFail),void 0!==n.stencilZPass&&(r.stencilZPass=n.stencilZPass),void 0!==n.wireframe&&(r.wireframe=n.wireframe),void 0!==n.wireframeLinewidth&&(r.wireframeLinewidth=n.wireframeLinewidth),void 0!==n.wireframeLinecap&&(r.wireframeLinecap=n.wireframeLinecap),void 0!==n.wireframeLinejoin&&(r.wireframeLinejoin=n.wireframeLinejoin),void 0!==n.rotation&&(r.rotation=n.rotation),1!==n.linewidth&&(r.linewidth=n.linewidth),void 0!==n.dashSize&&(r.dashSize=n.dashSize),void 0!==n.gapSize&&(r.gapSize=n.gapSize),void 0!==n.scale&&(r.scale=n.scale),void 0!==n.polygonOffset&&(r.polygonOffset=n.polygonOffset),void 0!==n.polygonOffsetFactor&&(r.polygonOffsetFactor=n.polygonOffsetFactor),void 0!==n.polygonOffsetUnits&&(r.polygonOffsetUnits=n.polygonOffsetUnits),void 0!==n.dithering&&(r.dithering=n.dithering),void 0!==n.alphaToCoverage&&(r.alphaToCoverage=n.alphaToCoverage),void 0!==n.premultipliedAlpha&&(r.premultipliedAlpha=n.premultipliedAlpha),void 0!==n.visible&&(r.visible=n.visible),void 0!==n.toneMapped&&(r.toneMapped=n.toneMapped),void 0!==n.userData&&(r.userData=n.userData),void 0!==n.vertexColors&&("number"===typeof n.vertexColors?r.vertexColors=n.vertexColors>0:r.vertexColors=n.vertexColors),void 0!==n.uniforms)for(var a in n.uniforms){var i=n.uniforms[a];switch(r.uniforms[a]={},i.type){case"t":r.uniforms[a].value=o(i.value);break;case"c":r.uniforms[a].value=(new wo).setHex(i.value);break;case"v2":r.uniforms[a].value=(new ao).fromArray(i.value);break;case"v3":r.uniforms[a].value=(new Oo).fromArray(i.value);break;case"v4":r.uniforms[a].value=(new To).fromArray(i.value);break;case"m3":r.uniforms[a].value=(new io).fromArray(i.value);break;case"m4":r.uniforms[a].value=(new pr).fromArray(i.value);break;default:r.uniforms[a].value=i.value}}if(void 0!==n.defines&&(r.defines=n.defines),void 0!==n.vertexShader&&(r.vertexShader=n.vertexShader),void 0!==n.fragmentShader&&(r.fragmentShader=n.fragmentShader),void 0!==n.glslVersion&&(r.glslVersion=n.glslVersion),void 0!==n.extensions)for(var v in n.extensions)r.extensions[v]=n.extensions[v];if(void 0!==n.size&&(r.size=n.size),void 0!==n.sizeAttenuation&&(r.sizeAttenuation=n.sizeAttenuation),void 0!==n.map&&(r.map=o(n.map)),void 0!==n.matcap&&(r.matcap=o(n.matcap)),void 0!==n.alphaMap&&(r.alphaMap=o(n.alphaMap)),void 0!==n.bumpMap&&(r.bumpMap=o(n.bumpMap)),void 0!==n.bumpScale&&(r.bumpScale=n.bumpScale),void 0!==n.normalMap&&(r.normalMap=o(n.normalMap)),void 0!==n.normalMapType&&(r.normalMapType=n.normalMapType),void 0!==n.normalScale){var c=n.normalScale;!1===Array.isArray(c)&&(c=[c,c]),r.normalScale=(new ao).fromArray(c)}return void 0!==n.displacementMap&&(r.displacementMap=o(n.displacementMap)),void 0!==n.displacementScale&&(r.displacementScale=n.displacementScale),void 0!==n.displacementBias&&(r.displacementBias=n.displacementBias),void 0!==n.roughnessMap&&(r.roughnessMap=o(n.roughnessMap)),void 0!==n.metalnessMap&&(r.metalnessMap=o(n.metalnessMap)),void 0!==n.emissiveMap&&(r.emissiveMap=o(n.emissiveMap)),void 0!==n.emissiveIntensity&&(r.emissiveIntensity=n.emissiveIntensity),void 0!==n.specularMap&&(r.specularMap=o(n.specularMap)),void 0!==n.specularIntensityMap&&(r.specularIntensityMap=o(n.specularIntensityMap)),void 0!==n.specularColorMap&&(r.specularColorMap=o(n.specularColorMap)),void 0!==n.envMap&&(r.envMap=o(n.envMap)),void 0!==n.envMapIntensity&&(r.envMapIntensity=n.envMapIntensity),void 0!==n.reflectivity&&(r.reflectivity=n.reflectivity),void 0!==n.refractionRatio&&(r.refractionRatio=n.refractionRatio),void 0!==n.lightMap&&(r.lightMap=o(n.lightMap)),void 0!==n.lightMapIntensity&&(r.lightMapIntensity=n.lightMapIntensity),void 0!==n.aoMap&&(r.aoMap=o(n.aoMap)),void 0!==n.aoMapIntensity&&(r.aoMapIntensity=n.aoMapIntensity),void 0!==n.gradientMap&&(r.gradientMap=o(n.gradientMap)),void 0!==n.clearcoatMap&&(r.clearcoatMap=o(n.clearcoatMap)),void 0!==n.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap=o(n.clearcoatRoughnessMap)),void 0!==n.clearcoatNormalMap&&(r.clearcoatNormalMap=o(n.clearcoatNormalMap)),void 0!==n.clearcoatNormalScale&&(r.clearcoatNormalScale=(new ao).fromArray(n.clearcoatNormalScale)),void 0!==n.iridescenceMap&&(r.iridescenceMap=o(n.iridescenceMap)),void 0!==n.iridescenceThicknessMap&&(r.iridescenceThicknessMap=o(n.iridescenceThicknessMap)),void 0!==n.transmissionMap&&(r.transmissionMap=o(n.transmissionMap)),void 0!==n.thicknessMap&&(r.thicknessMap=o(n.thicknessMap)),void 0!==n.sheenColorMap&&(r.sheenColorMap=o(n.sheenColorMap)),void 0!==n.sheenRoughnessMap&&(r.sheenRoughnessMap=o(n.sheenRoughnessMap)),r}},{key:"setTextures",value:function(n){return this.textures=n,this}}],[{key:"createMaterialFromType",value:function(n){return new{ShadowMaterial:yu,SpriteMaterial:qc,RawShaderMaterial:gu,ShaderMaterial:qa,PointsMaterial:El,MeshPhysicalMaterial:_u,MeshStandardMaterial:bu,MeshPhongMaterial:Uu,MeshToonMaterial:wu,MeshNormalMaterial:Su,MeshLambertMaterial:Mu,MeshDepthMaterial:gc,MeshDistanceMaterial:bc,MeshBasicMaterial:Kr,MeshMatcapMaterial:zu,LineDashedMaterial:ku,LineBasicMaterial:Ml,Material:Jr}[n]}}]),t}($u),Rf=function(){function n(){y(this,n)}return b(n,null,[{key:"decodeText",value:function(n){if("undefined"!==typeof TextDecoder)return(new TextDecoder).decode(n);for(var e="",t=0,o=n.length;t<o;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch(r){return e}}},{key:"extractUrlBase",value:function(n){var e=n.lastIndexOf("/");return-1===e?"./":n.slice(0,e+1)}},{key:"resolveURL",value:function(n,e){return"string"!==typeof n||""===n?"":(/^https?:\/\//i.test(e)&&/^\//.test(n)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(n)||/^data:.*,.*$/i.test(n)||/^blob:.*$/i.test(n)?n:e+n)}}]),n}(),Df=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isInstancedBufferGeometry=!0,n.type="InstancedBufferGeometry",n.instanceCount=1/0,n}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.instanceCount=n.instanceCount,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"toJSON",value:function(){var n=D(U(t.prototype),"toJSON",this).call(this,this);return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}}]),t}(ga),Pf=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new tf(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(n,(function(t){try{e(r.parse(JSON.parse(t)))}catch(a){o?o(a):console.error(a),r.manager.itemError(n)}}),t,o)}},{key:"parse",value:function(n){var e={},t={};function o(n,o){if(void 0!==e[o])return e[o];var r=n.interleavedBuffers[o],a=function(n,e){if(void 0!==t[e])return t[e];var o=n.arrayBuffers[e],r=new Uint32Array(o).buffer;return t[e]=r,r}(n,r.buffer),i=lo(r.type,a),v=new Gc(i,r.stride);return v.uuid=r.uuid,e[o]=v,v}var r=n.isInstancedBufferGeometry?new Df:new ga,a=n.data.index;if(void 0!==a){var i=lo(a.type,a.array);r.setIndex(new ea(i,1))}var v=n.data.attributes;for(var c in v){var l=v[c],s=void 0;if(l.isInterleavedBufferAttribute){var u=o(n.data,l.data);s=new Bc(u,l.itemSize,l.offset,l.normalized)}else{var f=lo(l.type,l.array);s=new(l.isInstancedBufferAttribute?yl:ea)(f,l.itemSize,l.normalized)}void 0!==l.name&&(s.name=l.name),void 0!==l.usage&&s.setUsage(l.usage),void 0!==l.updateRange&&(s.updateRange.offset=l.updateRange.offset,s.updateRange.count=l.updateRange.count),r.setAttribute(c,s)}var p=n.data.morphAttributes;if(p)for(var m in p){for(var d=p[m],h=[],x=0,y=d.length;x<y;x++){var g=d[x],b=void 0;if(g.isInterleavedBufferAttribute){var _=o(n.data,g.data);b=new Bc(_,g.itemSize,g.offset,g.normalized)}else{var U=lo(g.type,g.array);b=new ea(U,g.itemSize,g.normalized)}void 0!==g.name&&(b.name=g.name),h.push(b)}r.morphAttributes[m]=h}n.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);var w=n.data.groups||n.data.drawcalls||n.data.offsets;if(void 0!==w)for(var S=0,M=w.length;S!==M;++S){var z=w[S];r.addGroup(z.start,z.count,z.materialIndex)}var k=n.data.boundingSphere;if(void 0!==k){var C=new Oo;void 0!==k.center&&C.fromArray(k.center),r.boundingSphere=new rr(C,k.radius)}return n.name&&(r.name=n.name),n.userData&&(r.userData=n.userData),r}}]),t}($u),Ff=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=""===this.path?Rf.extractUrlBase(n):this.path;this.resourcePath=this.resourcePath||a;var i=new tf(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(n,(function(t){var a=null;try{a=JSON.parse(t)}catch(v){return void 0!==o&&o(v),void console.error("THREE:ObjectLoader: Can't parse "+n+".",v.message)}var i=a.metadata;void 0!==i&&void 0!==i.type&&"geometry"!==i.type.toLowerCase()?r.parse(a,e):console.error("THREE.ObjectLoader: Can't load "+n)}),t,o)}},{key:"loadAsync",value:function(){var n=T(P().mark((function n(e,t){var o,r,a,i,v,c;return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return o=this,r=""===this.path?Rf.extractUrlBase(e):this.path,this.resourcePath=this.resourcePath||r,(a=new tf(this.manager)).setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),n.next=9,a.loadAsync(e,t);case 9:if(i=n.sent,v=JSON.parse(i),void 0!==(c=v.metadata)&&void 0!==c.type&&"geometry"!==c.type.toLowerCase()){n.next=14;break}throw new Error("THREE.ObjectLoader: Can't load "+e);case 14:return n.next=16,o.parseAsync(v);case 16:return n.abrupt("return",n.sent);case 17:case"end":return n.stop()}}),n,this)})));return function(e,t){return n.apply(this,arguments)}}()},{key:"parse",value:function(n,e){var t=this.parseAnimations(n.animations),o=this.parseShapes(n.shapes),r=this.parseGeometries(n.geometries,o),a=this.parseImages(n.images,(function(){void 0!==e&&e(c)})),i=this.parseTextures(n.textures,a),v=this.parseMaterials(n.materials,i),c=this.parseObject(n.object,r,v,i,t),l=this.parseSkeletons(n.skeletons,c);if(this.bindSkeletons(c,l),void 0!==e){var s=!1;for(var u in a)if(a[u].data instanceof HTMLImageElement){s=!0;break}!1===s&&e(c)}return c}},{key:"parseAsync",value:function(){var n=T(P().mark((function n(e){var t,o,r,a,i,v,c,l;return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t=this.parseAnimations(e.animations),o=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,o),n.next=5,this.parseImagesAsync(e.images);case 5:return a=n.sent,i=this.parseTextures(e.textures,a),v=this.parseMaterials(e.materials,i),c=this.parseObject(e.object,r,v,i,t),l=this.parseSkeletons(e.skeletons,c),this.bindSkeletons(c,l),n.abrupt("return",c);case 12:case"end":return n.stop()}}),n,this)})));return function(e){return n.apply(this,arguments)}}()},{key:"parseShapes",value:function(n){var e={};if(void 0!==n)for(var t=0,o=n.length;t<o;t++){var r=(new Cs).fromJSON(n[t]);e[r.uuid]=r}return e}},{key:"parseSkeletons",value:function(n,e){var t={},o={};if(e.traverse((function(n){n.isBone&&(o[n.uuid]=n)})),void 0!==n)for(var r=0,a=n.length;r<a;r++){var i=(new xl).fromJSON(n[r],o);t[i.uuid]=i}return t}},{key:"parseGeometries",value:function(n,e){var t={};if(void 0!==n)for(var o=new Pf,r=0,a=n.length;r<a;r++){var i=void 0,v=n[r];switch(v.type){case"BufferGeometry":case"InstancedBufferGeometry":i=o.parse(v);break;default:v.type in xu?i=xu[v.type].fromJSON(v,e):console.warn('THREE.ObjectLoader: Unsupported geometry type "'.concat(v.type,'"'))}i.uuid=v.uuid,void 0!==v.name&&(i.name=v.name),!0===i.isBufferGeometry&&void 0!==v.userData&&(i.userData=v.userData),t[v.uuid]=i}return t}},{key:"parseMaterials",value:function(n,e){var t={},o={};if(void 0!==n){var r=new Tf;r.setTextures(e);for(var a=0,i=n.length;a<i;a++){var v=n[a];void 0===t[v.uuid]&&(t[v.uuid]=r.parse(v)),o[v.uuid]=t[v.uuid]}}return o}},{key:"parseAnimations",value:function(n){var e={};if(void 0!==n)for(var t=0;t<n.length;t++){var o=n[t],r=Xu.parse(o);e[r.uuid]=r}return e}},{key:"parseImages",value:function(n,e){var t,o=this,r={};function a(n){if("string"===typeof n){var e=n;return function(n){return o.manager.itemStart(n),t.load(n,(function(){o.manager.itemEnd(n)}),void 0,(function(){o.manager.itemError(n),o.manager.itemEnd(n)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:o.resourcePath+e)}return n.data?{data:lo(n.type,n.data),width:n.width,height:n.height}:null}if(void 0!==n&&n.length>0){var i=new Ju(e);(t=new af(i)).setCrossOrigin(this.crossOrigin);for(var v=0,c=n.length;v<c;v++){var l=n[v],s=l.url;if(Array.isArray(s)){for(var u=[],f=0,p=s.length;f<p;f++){var m=a(s[f]);null!==m&&(m instanceof HTMLImageElement?u.push(m):u.push(new ml(m.data,m.width,m.height)))}r[l.uuid]=new Mo(u)}else{var d=a(l.url);r[l.uuid]=new Mo(d)}}}return r}},{key:"parseImagesAsync",value:function(){var n=T(P().mark((function n(e){var t,o,r,a,i,v,c,l,s,u,f,p,m,d,h;return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(i=function(){return i=T(P().mark((function n(e){var o,a;return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if("string"!==typeof e){n.next=8;break}return a=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o=e)?o:t.resourcePath+o,n.next=5,r.loadAsync(a);case 5:return n.abrupt("return",n.sent);case 8:if(!e.data){n.next=12;break}return n.abrupt("return",{data:lo(e.type,e.data),width:e.width,height:e.height});case 12:return n.abrupt("return",null);case 13:case"end":return n.stop()}}),n)}))),i.apply(this,arguments)},a=function(n){return i.apply(this,arguments)},t=this,o={},!(void 0!==e&&e.length>0)){n.next=33;break}(r=new af(this.manager)).setCrossOrigin(this.crossOrigin),v=0,c=e.length;case 8:if(!(v<c)){n.next=33;break}if(l=e[v],s=l.url,!Array.isArray(s)){n.next=26;break}u=[],f=0,p=s.length;case 14:if(!(f<p)){n.next=23;break}return m=s[f],n.next=18,a(m);case 18:null!==(d=n.sent)&&(d instanceof HTMLImageElement?u.push(d):u.push(new ml(d.data,d.width,d.height)));case 20:f++,n.next=14;break;case 23:o[l.uuid]=new Mo(u),n.next=30;break;case 26:return n.next=28,a(l.url);case 28:h=n.sent,o[l.uuid]=new Mo(h);case 30:v++,n.next=8;break;case 33:return n.abrupt("return",o);case 34:case"end":return n.stop()}}),n,this)})));return function(e){return n.apply(this,arguments)}}()},{key:"parseTextures",value:function(n,e){function t(n,e){return"number"===typeof n?n:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",n),e[n])}var o={};if(void 0!==n)for(var r=0,a=n.length;r<a;r++){var i=n[r];void 0===i.image&&console.warn('THREE.ObjectLoader: No "image" specified for',i.uuid),void 0===e[i.image]&&console.warn("THREE.ObjectLoader: Undefined image",i.image);var v=e[i.image],c=v.data,l=void 0;Array.isArray(c)?(l=new Ya,6===c.length&&(l.needsUpdate=!0)):(l=c&&c.data?new ml:new Co,c&&(l.needsUpdate=!0)),l.source=v,l.uuid=i.uuid,void 0!==i.name&&(l.name=i.name),void 0!==i.mapping&&(l.mapping=t(i.mapping,jf)),void 0!==i.offset&&l.offset.fromArray(i.offset),void 0!==i.repeat&&l.repeat.fromArray(i.repeat),void 0!==i.center&&l.center.fromArray(i.center),void 0!==i.rotation&&(l.rotation=i.rotation),void 0!==i.wrap&&(l.wrapS=t(i.wrap[0],If),l.wrapT=t(i.wrap[1],If)),void 0!==i.format&&(l.format=i.format),void 0!==i.type&&(l.type=i.type),void 0!==i.encoding&&(l.encoding=i.encoding),void 0!==i.minFilter&&(l.minFilter=t(i.minFilter,Ef)),void 0!==i.magFilter&&(l.magFilter=t(i.magFilter,Ef)),void 0!==i.anisotropy&&(l.anisotropy=i.anisotropy),void 0!==i.flipY&&(l.flipY=i.flipY),void 0!==i.premultiplyAlpha&&(l.premultiplyAlpha=i.premultiplyAlpha),void 0!==i.unpackAlignment&&(l.unpackAlignment=i.unpackAlignment),void 0!==i.userData&&(l.userData=i.userData),o[i.uuid]=l}return o}},{key:"parseObject",value:function(n,e,t,o,r){var a,i,v;function c(n){return void 0===e[n]&&console.warn("THREE.ObjectLoader: Undefined geometry",n),e[n]}function l(n){if(void 0!==n){if(Array.isArray(n)){for(var e=[],o=0,r=n.length;o<r;o++){var a=n[o];void 0===t[a]&&console.warn("THREE.ObjectLoader: Undefined material",a),e.push(t[a])}return e}return void 0===t[n]&&console.warn("THREE.ObjectLoader: Undefined material",n),t[n]}}function s(n){return void 0===o[n]&&console.warn("THREE.ObjectLoader: Undefined texture",n),o[n]}switch(n.type){case"Scene":a=new Ac,void 0!==n.background&&(Number.isInteger(n.background)?a.background=new wo(n.background):a.background=s(n.background)),void 0!==n.environment&&(a.environment=s(n.environment)),void 0!==n.fog&&("Fog"===n.fog.type?a.fog=new Lc(n.fog.color,n.fog.near,n.fog.far):"FogExp2"===n.fog.type&&(a.fog=new Oc(n.fog.color,n.fog.density))),void 0!==n.backgroundBlurriness&&(a.backgroundBlurriness=n.backgroundBlurriness);break;case"PerspectiveCamera":a=new Wa(n.fov,n.aspect,n.near,n.far),void 0!==n.focus&&(a.focus=n.focus),void 0!==n.zoom&&(a.zoom=n.zoom),void 0!==n.filmGauge&&(a.filmGauge=n.filmGauge),void 0!==n.filmOffset&&(a.filmOffset=n.filmOffset),void 0!==n.view&&(a.view=Object.assign({},n.view));break;case"OrthographicCamera":a=new di(n.left,n.right,n.top,n.bottom,n.near,n.far),void 0!==n.zoom&&(a.zoom=n.zoom),void 0!==n.view&&(a.view=Object.assign({},n.view));break;case"AmbientLight":a=new Mf(n.color,n.intensity);break;case"DirectionalLight":a=new Sf(n.color,n.intensity);break;case"PointLight":a=new Uf(n.color,n.intensity,n.distance,n.decay);break;case"RectAreaLight":a=new zf(n.color,n.intensity,n.width,n.height);break;case"SpotLight":a=new xf(n.color,n.intensity,n.distance,n.angle,n.penumbra,n.decay);break;case"HemisphereLight":a=new uf(n.color,n.groundColor,n.intensity);break;case"LightProbe":a=(new Cf).fromJSON(n);break;case"SkinnedMesh":i=c(n.geometry),v=l(n.material),a=new fl(i,v),void 0!==n.bindMode&&(a.bindMode=n.bindMode),void 0!==n.bindMatrix&&a.bindMatrix.fromArray(n.bindMatrix),void 0!==n.skeleton&&(a.skeleton=n.skeleton);break;case"Mesh":i=c(n.geometry),v=l(n.material),a=new Oa(i,v);break;case"InstancedMesh":i=c(n.geometry),v=l(n.material);var u=n.count,f=n.instanceMatrix,p=n.instanceColor;(a=new Sl(i,v,u)).instanceMatrix=new yl(new Float32Array(f.array),16),void 0!==p&&(a.instanceColor=new yl(new Float32Array(p.array),p.itemSize));break;case"LOD":a=new il;break;case"Line":a=new Dl(c(n.geometry),l(n.material));break;case"LineLoop":a=new Il(c(n.geometry),l(n.material));break;case"LineSegments":a=new jl(c(n.geometry),l(n.material));break;case"PointCloud":case"Points":a=new Nl(c(n.geometry),l(n.material));break;case"Sprite":a=new tl(l(n.material));break;case"Group":a=new zc;break;case"Bone":a=new pl;break;default:a=new Lr}if(a.uuid=n.uuid,void 0!==n.name&&(a.name=n.name),void 0!==n.matrix?(a.matrix.fromArray(n.matrix),void 0!==n.matrixAutoUpdate&&(a.matrixAutoUpdate=n.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(void 0!==n.position&&a.position.fromArray(n.position),void 0!==n.rotation&&a.rotation.fromArray(n.rotation),void 0!==n.quaternion&&a.quaternion.fromArray(n.quaternion),void 0!==n.scale&&a.scale.fromArray(n.scale)),void 0!==n.castShadow&&(a.castShadow=n.castShadow),void 0!==n.receiveShadow&&(a.receiveShadow=n.receiveShadow),n.shadow&&(void 0!==n.shadow.bias&&(a.shadow.bias=n.shadow.bias),void 0!==n.shadow.normalBias&&(a.shadow.normalBias=n.shadow.normalBias),void 0!==n.shadow.radius&&(a.shadow.radius=n.shadow.radius),void 0!==n.shadow.mapSize&&a.shadow.mapSize.fromArray(n.shadow.mapSize),void 0!==n.shadow.camera&&(a.shadow.camera=this.parseObject(n.shadow.camera))),void 0!==n.visible&&(a.visible=n.visible),void 0!==n.frustumCulled&&(a.frustumCulled=n.frustumCulled),void 0!==n.renderOrder&&(a.renderOrder=n.renderOrder),void 0!==n.userData&&(a.userData=n.userData),void 0!==n.layers&&(a.layers.mask=n.layers),void 0!==n.children)for(var m=n.children,d=0;d<m.length;d++)a.add(this.parseObject(m[d],e,t,o,r));if(void 0!==n.animations)for(var h=n.animations,x=0;x<h.length;x++){var y=h[x];a.animations.push(r[y])}if("LOD"===n.type){void 0!==n.autoUpdate&&(a.autoUpdate=n.autoUpdate);for(var g=n.levels,b=0;b<g.length;b++){var _=g[b],U=a.getObjectByProperty("uuid",_.object);void 0!==U&&a.addLevel(U,_.distance)}}return a}},{key:"bindSkeletons",value:function(n,e){0!==Object.keys(e).length&&n.traverse((function(n){if(!0===n.isSkinnedMesh&&void 0!==n.skeleton){var t=e[n.skeleton];void 0===t?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(t,n.bindMatrix)}}))}}]),t}($u),jf={UVMapping:Fn,CubeReflectionMapping:jn,CubeRefractionMapping:In,EquirectangularReflectionMapping:En,EquirectangularRefractionMapping:On,CubeUVReflectionMapping:Ln},If={RepeatWrapping:An,ClampToEdgeWrapping:Gn,MirroredRepeatWrapping:Nn},Ef={NearestFilter:Bn,NearestMipmapNearestFilter:qn,NearestMipmapLinearFilter:Wn,LinearFilter:Xn,LinearMipmapNearestFilter:Yn,LinearMipmapLinearFilter:Qn},Of=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this,n)).isImageBitmapLoader=!0,"undefined"===typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"===typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),o.options={premultiplyAlpha:"none"},o}return b(t,[{key:"setOptions",value:function(n){return this.options=n,this}},{key:"load",value:function(n,e,t,o){void 0===n&&(n=""),void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);var r=this,a=Qu.get(n);if(void 0!==a)return r.manager.itemStart(n),setTimeout((function(){e&&e(a),r.manager.itemEnd(n)}),0),a;var i={};i.credentials="anonymous"===this.crossOrigin?"same-origin":"include",i.headers=this.requestHeader,fetch(n,i).then((function(n){return n.blob()})).then((function(n){return createImageBitmap(n,Object.assign(r.options,{colorSpaceConversion:"none"}))})).then((function(t){Qu.add(n,t),e&&e(t),r.manager.itemEnd(n)})).catch((function(e){o&&o(e),r.manager.itemError(n),r.manager.itemEnd(n)})),r.manager.itemStart(n)}}]),t}($u),Lf=function(){function n(){y(this,n)}return b(n,null,[{key:"getContext",value:function(){return void 0===Zu&&(Zu=new(window.AudioContext||window.webkitAudioContext)),Zu}},{key:"setContext",value:function(n){Zu=n}}]),n}(),Af=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new tf(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(n,(function(t){try{var a=t.slice(0);Lf.getContext().decodeAudioData(a,(function(n){e(n)}))}catch(i){o?o(i):console.error(i),r.manager.itemError(n)}}),t,o)}}]),t}($u),Gf=function(n){_(t,n);var e=z(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;y(this,t),(r=e.call(this,void 0,a)).isHemisphereLightProbe=!0;var i=(new wo).set(n),v=(new wo).set(o),c=new Oo(i.r,i.g,i.b),l=new Oo(v.r,v.g,v.b),s=Math.sqrt(Math.PI),u=s*Math.sqrt(.75);return r.sh.coefficients[0].copy(c).add(l).multiplyScalar(s),r.sh.coefficients[1].copy(c).sub(l).multiplyScalar(u),r}return b(t)}(Cf),Nf=function(n){_(t,n);var e=z(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;y(this,t),(o=e.call(this,void 0,r)).isAmbientLightProbe=!0;var a=(new wo).set(n);return o.sh.coefficients[0].set(a.r,a.g,a.b).multiplyScalar(2*Math.sqrt(Math.PI)),o}return b(t)}(Cf),Bf=new pr,qf=new pr,Vf=new pr,Wf=function(){function n(){y(this,n),this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Wa,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Wa,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}return b(n,[{key:"update",value:function(n){var e=this._cache;if(e.focus!==n.focus||e.fov!==n.fov||e.aspect!==n.aspect*this.aspect||e.near!==n.near||e.far!==n.far||e.zoom!==n.zoom||e.eyeSep!==this.eyeSep){e.focus=n.focus,e.fov=n.fov,e.aspect=n.aspect*this.aspect,e.near=n.near,e.far=n.far,e.zoom=n.zoom,e.eyeSep=this.eyeSep,Vf.copy(n.projectionMatrix);var t,o,r=e.eyeSep/2,a=r*e.near/e.focus,i=e.near*Math.tan(Xt*e.fov*.5)/e.zoom;qf.elements[12]=-r,Bf.elements[12]=r,t=-i*e.aspect+a,o=i*e.aspect+a,Vf.elements[0]=2*e.near/(o-t),Vf.elements[8]=(o+t)/(o-t),this.cameraL.projectionMatrix.copy(Vf),t=-i*e.aspect-a,o=i*e.aspect-a,Vf.elements[0]=2*e.near/(o-t),Vf.elements[8]=(o+t)/(o-t),this.cameraR.projectionMatrix.copy(Vf)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(qf),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(Bf)}}]),n}(),Hf=function(){function n(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];y(this,n),this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}return b(n,[{key:"start",value:function(){this.startTime=Xf(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}},{key:"stop",value:function(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}},{key:"getElapsedTime",value:function(){return this.getDelta(),this.elapsedTime}},{key:"getDelta",value:function(){var n=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){var e=Xf();n=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=n}return n}}]),n}();function Xf(){return("undefined"===typeof performance?Date:performance).now()}var Yf=new Oo,Zf=new Eo,Qf=new Oo,Jf=new Oo,Kf=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).type="AudioListener",n.context=Lf.getContext(),n.gain=n.context.createGain(),n.gain.connect(n.context.destination),n.filter=null,n.timeDelta=0,n._clock=new Hf,n}return b(t,[{key:"getInput",value:function(){return this.gain}},{key:"removeFilter",value:function(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}},{key:"getFilter",value:function(){return this.filter}},{key:"setFilter",value:function(n){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=n,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}},{key:"getMasterVolume",value:function(){return this.gain.gain.value}},{key:"setMasterVolume",value:function(n){return this.gain.gain.setTargetAtTime(n,this.context.currentTime,.01),this}},{key:"updateMatrixWorld",value:function(n){D(U(t.prototype),"updateMatrixWorld",this).call(this,n);var e=this.context.listener,o=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Yf,Zf,Qf),Jf.set(0,0,-1).applyQuaternion(Zf),e.positionX){var r=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(Yf.x,r),e.positionY.linearRampToValueAtTime(Yf.y,r),e.positionZ.linearRampToValueAtTime(Yf.z,r),e.forwardX.linearRampToValueAtTime(Jf.x,r),e.forwardY.linearRampToValueAtTime(Jf.y,r),e.forwardZ.linearRampToValueAtTime(Jf.z,r),e.upX.linearRampToValueAtTime(o.x,r),e.upY.linearRampToValueAtTime(o.y,r),e.upZ.linearRampToValueAtTime(o.z,r)}else e.setPosition(Yf.x,Yf.y,Yf.z),e.setOrientation(Jf.x,Jf.y,Jf.z,o.x,o.y,o.z)}}]),t}(Lr),$f=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this)).type="Audio",o.listener=n,o.context=n.context,o.gain=o.context.createGain(),o.gain.connect(n.getInput()),o.autoplay=!1,o.buffer=null,o.detune=0,o.loop=!1,o.loopStart=0,o.loopEnd=0,o.offset=0,o.duration=void 0,o.playbackRate=1,o.isPlaying=!1,o.hasPlaybackControl=!0,o.source=null,o.sourceType="empty",o._startedAt=0,o._progress=0,o._connected=!1,o.filters=[],o}return b(t,[{key:"getOutput",value:function(){return this.gain}},{key:"setNodeSource",value:function(n){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=n,this.connect(),this}},{key:"setMediaElementSource",value:function(n){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(n),this.connect(),this}},{key:"setMediaStreamSource",value:function(n){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(n),this.connect(),this}},{key:"setBuffer",value:function(n){return this.buffer=n,this.sourceType="buffer",this.autoplay&&this.play(),this}},{key:"play",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!0!==this.isPlaying){if(!1!==this.hasPlaybackControl){this._startedAt=this.context.currentTime+n;var e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}console.warn("THREE.Audio: this Audio has no playback control.")}else console.warn("THREE.Audio: Audio is already playing.")}},{key:"pause",value:function(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"stop",value:function(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"connect",value:function(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var n=1,e=this.filters.length;n<e;n++)this.filters[n-1].connect(this.filters[n]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}},{key:"disconnect",value:function(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var n=1,e=this.filters.length;n<e;n++)this.filters[n-1].disconnect(this.filters[n]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}},{key:"getFilters",value:function(){return this.filters}},{key:"setFilters",value:function(n){return n||(n=[]),!0===this._connected?(this.disconnect(),this.filters=n.slice(),this.connect()):this.filters=n.slice(),this}},{key:"setDetune",value:function(n){if(this.detune=n,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}},{key:"getDetune",value:function(){return this.detune}},{key:"getFilter",value:function(){return this.getFilters()[0]}},{key:"setFilter",value:function(n){return this.setFilters(n?[n]:[])}},{key:"setPlaybackRate",value:function(n){if(!1!==this.hasPlaybackControl)return this.playbackRate=n,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"getPlaybackRate",value:function(){return this.playbackRate}},{key:"onEnded",value:function(){this.isPlaying=!1}},{key:"getLoop",value:function(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}},{key:"setLoop",value:function(n){if(!1!==this.hasPlaybackControl)return this.loop=n,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"setLoopStart",value:function(n){return this.loopStart=n,this}},{key:"setLoopEnd",value:function(n){return this.loopEnd=n,this}},{key:"getVolume",value:function(){return this.gain.gain.value}},{key:"setVolume",value:function(n){return this.gain.gain.setTargetAtTime(n,this.context.currentTime,.01),this}}]),t}(Lr),np=new Oo,ep=new Eo,tp=new Oo,op=new Oo,rp=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this,n)).panner=o.context.createPanner(),o.panner.panningModel="HRTF",o.panner.connect(o.gain),o}return b(t,[{key:"disconnect",value:function(){D(U(t.prototype),"disconnect",this).call(this),this.panner.disconnect(this.gain)}},{key:"getOutput",value:function(){return this.panner}},{key:"getRefDistance",value:function(){return this.panner.refDistance}},{key:"setRefDistance",value:function(n){return this.panner.refDistance=n,this}},{key:"getRolloffFactor",value:function(){return this.panner.rolloffFactor}},{key:"setRolloffFactor",value:function(n){return this.panner.rolloffFactor=n,this}},{key:"getDistanceModel",value:function(){return this.panner.distanceModel}},{key:"setDistanceModel",value:function(n){return this.panner.distanceModel=n,this}},{key:"getMaxDistance",value:function(){return this.panner.maxDistance}},{key:"setMaxDistance",value:function(n){return this.panner.maxDistance=n,this}},{key:"setDirectionalCone",value:function(n,e,t){return this.panner.coneInnerAngle=n,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=t,this}},{key:"updateMatrixWorld",value:function(n){if(D(U(t.prototype),"updateMatrixWorld",this).call(this,n),!0!==this.hasPlaybackControl||!1!==this.isPlaying){this.matrixWorld.decompose(np,ep,tp),op.set(0,0,1).applyQuaternion(ep);var e=this.panner;if(e.positionX){var o=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(np.x,o),e.positionY.linearRampToValueAtTime(np.y,o),e.positionZ.linearRampToValueAtTime(np.z,o),e.orientationX.linearRampToValueAtTime(op.x,o),e.orientationY.linearRampToValueAtTime(op.y,o),e.orientationZ.linearRampToValueAtTime(op.z,o)}else e.setPosition(np.x,np.y,np.z),e.setOrientation(op.x,op.y,op.z)}}}]),t}($f),ap=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2048;y(this,n),this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}return b(n,[{key:"getFrequencyData",value:function(){return this.analyser.getByteFrequencyData(this.data),this.data}},{key:"getAverageFrequency",value:function(){for(var n=0,e=this.getFrequencyData(),t=0;t<e.length;t++)n+=e[t];return n/e.length}}]),n}(),ip=function(){function n(e,t,o){var r,a,i;switch(y(this,n),this.binding=e,this.valueSize=o,t){case"quaternion":r=this._slerp,a=this._slerpAdditive,i=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*o),this._workIndex=5;break;case"string":case"bool":r=this._select,a=this._select,i=this._setAdditiveIdentityOther,this.buffer=new Array(5*o);break;default:r=this._lerp,a=this._lerpAdditive,i=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*o)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=a,this._setIdentity=i,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}return b(n,[{key:"accumulate",value:function(n,e){var t=this.buffer,o=this.valueSize,r=n*o+o,a=this.cumulativeWeight;if(0===a){for(var i=0;i!==o;++i)t[r+i]=t[i];a=e}else{var v=e/(a+=e);this._mixBufferRegion(t,r,0,v,o)}this.cumulativeWeight=a}},{key:"accumulateAdditive",value:function(n){var e=this.buffer,t=this.valueSize,o=t*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,o,0,n,t),this.cumulativeWeightAdditive+=n}},{key:"apply",value:function(n){var e=this.valueSize,t=this.buffer,o=n*e+e,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,i=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){var v=e*this._origIndex;this._mixBufferRegion(t,o,v,1-r,e)}a>0&&this._mixBufferRegionAdditive(t,o,this._addIndex*e,1,e);for(var c=e,l=e+e;c!==l;++c)if(t[c]!==t[c+e]){i.setValue(t,o);break}}},{key:"saveOriginalState",value:function(){var n=this.binding,e=this.buffer,t=this.valueSize,o=t*this._origIndex;n.getValue(e,o);for(var r=t,a=o;r!==a;++r)e[r]=e[o+r%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}},{key:"restoreOriginalState",value:function(){var n=3*this.valueSize;this.binding.setValue(this.buffer,n)}},{key:"_setAdditiveIdentityNumeric",value:function(){for(var n=this._addIndex*this.valueSize,e=n+this.valueSize,t=n;t<e;t++)this.buffer[t]=0}},{key:"_setAdditiveIdentityQuaternion",value:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}},{key:"_setAdditiveIdentityOther",value:function(){for(var n=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize,t=0;t<this.valueSize;t++)this.buffer[e+t]=this.buffer[n+t]}},{key:"_select",value:function(n,e,t,o,r){if(o>=.5)for(var a=0;a!==r;++a)n[e+a]=n[t+a]}},{key:"_slerp",value:function(n,e,t,o){Eo.slerpFlat(n,e,n,e,n,t,o)}},{key:"_slerpAdditive",value:function(n,e,t,o,r){var a=this._workIndex*r;Eo.multiplyQuaternionsFlat(n,a,n,e,n,t),Eo.slerpFlat(n,e,n,e,n,a,o)}},{key:"_lerp",value:function(n,e,t,o,r){for(var a=1-o,i=0;i!==r;++i){var v=e+i;n[v]=n[v]*a+n[t+i]*o}}},{key:"_lerpAdditive",value:function(n,e,t,o,r){for(var a=0;a!==r;++a){var i=e+a;n[i]=n[i]+n[t+a]*o}}}]),n}(),vp="\\[\\]\\.:\\/",cp=new RegExp("[\\[\\]\\.:\\/]","g"),lp="[^\\[\\]\\.:\\/]",sp="[^"+vp.replace("\\.","")+"]",up=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",lp)+/(WCOD+)?/.source.replace("WCOD",sp)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",lp)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",lp)+"$"),fp=["material","materials","bones","map"],pp=function(){function n(e,t,o){y(this,n);var r=o||mp.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}return b(n,[{key:"getValue",value:function(n,e){this.bind();var t=this._targetGroup.nCachedObjects_,o=this._bindings[t];void 0!==o&&o.getValue(n,e)}},{key:"setValue",value:function(n,e){for(var t=this._bindings,o=this._targetGroup.nCachedObjects_,r=t.length;o!==r;++o)t[o].setValue(n,e)}},{key:"bind",value:function(){for(var n=this._bindings,e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].bind()}},{key:"unbind",value:function(){for(var n=this._bindings,e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].unbind()}}]),n}(),mp=function(){function n(e,t,o){y(this,n),this.path=t,this.parsedPath=o||n.parseTrackName(t),this.node=n.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}return b(n,[{key:"_getValue_unavailable",value:function(){}},{key:"_setValue_unavailable",value:function(){}},{key:"_getValue_direct",value:function(n,e){n[e]=this.targetObject[this.propertyName]}},{key:"_getValue_array",value:function(n,e){for(var t=this.resolvedProperty,o=0,r=t.length;o!==r;++o)n[e++]=t[o]}},{key:"_getValue_arrayElement",value:function(n,e){n[e]=this.resolvedProperty[this.propertyIndex]}},{key:"_getValue_toArray",value:function(n,e){this.resolvedProperty.toArray(n,e)}},{key:"_setValue_direct",value:function(n,e){this.targetObject[this.propertyName]=n[e]}},{key:"_setValue_direct_setNeedsUpdate",value:function(n,e){this.targetObject[this.propertyName]=n[e],this.targetObject.needsUpdate=!0}},{key:"_setValue_direct_setMatrixWorldNeedsUpdate",value:function(n,e){this.targetObject[this.propertyName]=n[e],this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_setValue_array",value:function(n,e){for(var t=this.resolvedProperty,o=0,r=t.length;o!==r;++o)t[o]=n[e++]}},{key:"_setValue_array_setNeedsUpdate",value:function(n,e){for(var t=this.resolvedProperty,o=0,r=t.length;o!==r;++o)t[o]=n[e++];this.targetObject.needsUpdate=!0}},{key:"_setValue_array_setMatrixWorldNeedsUpdate",value:function(n,e){for(var t=this.resolvedProperty,o=0,r=t.length;o!==r;++o)t[o]=n[e++];this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_setValue_arrayElement",value:function(n,e){this.resolvedProperty[this.propertyIndex]=n[e]}},{key:"_setValue_arrayElement_setNeedsUpdate",value:function(n,e){this.resolvedProperty[this.propertyIndex]=n[e],this.targetObject.needsUpdate=!0}},{key:"_setValue_arrayElement_setMatrixWorldNeedsUpdate",value:function(n,e){this.resolvedProperty[this.propertyIndex]=n[e],this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_setValue_fromArray",value:function(n,e){this.resolvedProperty.fromArray(n,e)}},{key:"_setValue_fromArray_setNeedsUpdate",value:function(n,e){this.resolvedProperty.fromArray(n,e),this.targetObject.needsUpdate=!0}},{key:"_setValue_fromArray_setMatrixWorldNeedsUpdate",value:function(n,e){this.resolvedProperty.fromArray(n,e),this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_getValue_unbound",value:function(n,e){this.bind(),this.getValue(n,e)}},{key:"_setValue_unbound",value:function(n,e){this.bind(),this.setValue(n,e)}},{key:"bind",value:function(){var e=this.node,t=this.parsedPath,o=t.objectName,r=t.propertyName,a=t.propertyIndex;if(e||(e=n.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,e){if(o){var i=t.objectIndex;switch(o){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(var v=0;v<e.length;v++)if(e[v].name===i){i=v;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);e=e.material.map;break;default:if(void 0===e[o])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[o]}if(void 0!==i){if(void 0===e[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[i]}}var c=e[r];if(void 0!==c){var l=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?l=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(l=this.Versioning.MatrixWorldNeedsUpdate);var s=this.BindingType.Direct;if(void 0!==a){if("morphTargetInfluences"===r){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[a]&&(a=e.morphTargetDictionary[a])}s=this.BindingType.ArrayElement,this.resolvedProperty=c,this.propertyIndex=a}else void 0!==c.fromArray&&void 0!==c.toArray?(s=this.BindingType.HasFromToArray,this.resolvedProperty=c):Array.isArray(c)?(s=this.BindingType.EntireArray,this.resolvedProperty=c):this.propertyName=r;this.getValue=this.GetterByBindingType[s],this.setValue=this.SetterByBindingTypeAndVersioning[s][l]}else{var u=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+r+" but it wasn't found.",e)}}else console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.")}},{key:"unbind",value:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}],[{key:"create",value:function(e,t,o){return e&&e.isAnimationObjectGroup?new n.Composite(e,t,o):new n(e,t,o)}},{key:"sanitizeNodeName",value:function(n){return n.replace(/\s/g,"_").replace(cp,"")}},{key:"parseTrackName",value:function(n){var e=up.exec(n);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+n);var t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},o=t.nodeName&&t.nodeName.lastIndexOf(".");if(void 0!==o&&-1!==o){var r=t.nodeName.substring(o+1);-1!==fp.indexOf(r)&&(t.nodeName=t.nodeName.substring(0,o),t.objectName=r)}if(null===t.propertyName||0===t.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+n);return t}},{key:"findNode",value:function(n,e){if(void 0===e||""===e||"."===e||-1===e||e===n.name||e===n.uuid)return n;if(n.skeleton){var t=n.skeleton.getBoneByName(e);if(void 0!==t)return t}if(n.children){var o=function n(t){for(var o=0;o<t.length;o++){var r=t[o];if(r.name===e||r.uuid===e)return r;var a=n(r.children);if(a)return a}return null}(n.children);if(o)return o}return null}}]),n}();mp.Composite=pp,mp.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},mp.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},mp.prototype.GetterByBindingType=[mp.prototype._getValue_direct,mp.prototype._getValue_array,mp.prototype._getValue_arrayElement,mp.prototype._getValue_toArray],mp.prototype.SetterByBindingTypeAndVersioning=[[mp.prototype._setValue_direct,mp.prototype._setValue_direct_setNeedsUpdate,mp.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[mp.prototype._setValue_array,mp.prototype._setValue_array_setNeedsUpdate,mp.prototype._setValue_array_setMatrixWorldNeedsUpdate],[mp.prototype._setValue_arrayElement,mp.prototype._setValue_arrayElement_setNeedsUpdate,mp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[mp.prototype._setValue_fromArray,mp.prototype._setValue_fromArray_setNeedsUpdate,mp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];var dp=function(){function n(){y(this,n),this.isAnimationObjectGroup=!0,this.uuid=Zt(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;var e={};this._indicesByUUID=e;for(var t=0,o=arguments.length;t!==o;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};var r=this;this.stats={objects:{get total(){return r._objects.length},get inUse(){return this.total-r.nCachedObjects_}},get bindingsPerObject(){return r._bindings.length}}}return b(n,[{key:"add",value:function(){for(var n=this._objects,e=this._indicesByUUID,t=this._paths,o=this._parsedPaths,r=this._bindings,a=r.length,i=void 0,v=n.length,c=this.nCachedObjects_,l=0,s=arguments.length;l!==s;++l){var u=arguments[l],f=u.uuid,p=e[f];if(void 0===p){p=v++,e[f]=p,n.push(u);for(var m=0,d=a;m!==d;++m)r[m].push(new mp(u,t[m],o[m]))}else if(p<c){i=n[p];var h=--c,x=n[h];e[x.uuid]=p,n[p]=x,e[f]=h,n[h]=u;for(var y=0,g=a;y!==g;++y){var b=r[y],_=b[h],U=b[p];b[p]=_,void 0===U&&(U=new mp(u,t[y],o[y])),b[h]=U}}else n[p]!==i&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}},{key:"remove",value:function(){for(var n=this._objects,e=this._indicesByUUID,t=this._bindings,o=t.length,r=this.nCachedObjects_,a=0,i=arguments.length;a!==i;++a){var v=arguments[a],c=v.uuid,l=e[c];if(void 0!==l&&l>=r){var s=r++,u=n[s];e[u.uuid]=l,n[l]=u,e[c]=s,n[s]=v;for(var f=0,p=o;f!==p;++f){var m=t[f],d=m[s],h=m[l];m[l]=d,m[s]=h}}}this.nCachedObjects_=r}},{key:"uncache",value:function(){for(var n=this._objects,e=this._indicesByUUID,t=this._bindings,o=t.length,r=this.nCachedObjects_,a=n.length,i=0,v=arguments.length;i!==v;++i){var c=arguments[i],l=c.uuid,s=e[l];if(void 0!==s)if(delete e[l],s<r){var u=--r,f=n[u],p=--a,m=n[p];e[f.uuid]=s,n[s]=f,e[m.uuid]=u,n[u]=m,n.pop();for(var d=0,h=o;d!==h;++d){var x=t[d],y=x[u],g=x[p];x[s]=y,x[u]=g,x.pop()}}else{var b=--a,_=n[b];b>0&&(e[_.uuid]=s),n[s]=_,n.pop();for(var U=0,w=o;U!==w;++U){var S=t[U];S[s]=S[b],S.pop()}}}this.nCachedObjects_=r}},{key:"subscribe_",value:function(n,e){var t=this._bindingsIndicesByPath,o=t[n],r=this._bindings;if(void 0!==o)return r[o];var a=this._paths,i=this._parsedPaths,v=this._objects,c=v.length,l=this.nCachedObjects_,s=new Array(c);o=r.length,t[n]=o,a.push(n),i.push(e),r.push(s);for(var u=l,f=v.length;u!==f;++u){var p=v[u];s[u]=new mp(p,n,e)}return s}},{key:"unsubscribe_",value:function(n){var e=this._bindingsIndicesByPath,t=e[n];if(void 0!==t){var o=this._paths,r=this._parsedPaths,a=this._bindings,i=a.length-1,v=a[i];e[n[i]]=t,a[t]=v,a.pop(),r[t]=r[i],r.pop(),o[t]=o[i],o.pop()}}}]),n}(),hp=function(){function n(e,t){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.blendMode;y(this,n),this._mixer=e,this._clip=t,this._localRoot=o,this.blendMode=r;for(var a=t.tracks,i=a.length,v=new Array(i),c={endingStart:$e,endingEnd:$e},l=0;l!==i;++l){var s=a[l].createInterpolant(null);v[l]=s,s.settings=c}this._interpolantSettings=c,this._interpolants=v,this._propertyBindings=new Array(i),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Ye,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}return b(n,[{key:"play",value:function(){return this._mixer._activateAction(this),this}},{key:"stop",value:function(){return this._mixer._deactivateAction(this),this.reset()}},{key:"reset",value:function(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}},{key:"isRunning",value:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}},{key:"isScheduled",value:function(){return this._mixer._isActiveAction(this)}},{key:"startAt",value:function(n){return this._startTime=n,this}},{key:"setLoop",value:function(n,e){return this.loop=n,this.repetitions=e,this}},{key:"setEffectiveWeight",value:function(n){return this.weight=n,this._effectiveWeight=this.enabled?n:0,this.stopFading()}},{key:"getEffectiveWeight",value:function(){return this._effectiveWeight}},{key:"fadeIn",value:function(n){return this._scheduleFading(n,0,1)}},{key:"fadeOut",value:function(n){return this._scheduleFading(n,1,0)}},{key:"crossFadeFrom",value:function(n,e,t){if(n.fadeOut(e),this.fadeIn(e),t){var o=this._clip.duration,r=n._clip.duration,a=r/o,i=o/r;n.warp(1,a,e),this.warp(i,1,e)}return this}},{key:"crossFadeTo",value:function(n,e,t){return n.crossFadeFrom(this,e,t)}},{key:"stopFading",value:function(){var n=this._weightInterpolant;return null!==n&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(n)),this}},{key:"setEffectiveTimeScale",value:function(n){return this.timeScale=n,this._effectiveTimeScale=this.paused?0:n,this.stopWarping()}},{key:"getEffectiveTimeScale",value:function(){return this._effectiveTimeScale}},{key:"setDuration",value:function(n){return this.timeScale=this._clip.duration/n,this.stopWarping()}},{key:"syncWith",value:function(n){return this.time=n.time,this.timeScale=n.timeScale,this.stopWarping()}},{key:"halt",value:function(n){return this.warp(this._effectiveTimeScale,0,n)}},{key:"warp",value:function(n,e,t){var o=this._mixer,r=o.time,a=this.timeScale,i=this._timeScaleInterpolant;null===i&&(i=o._lendControlInterpolant(),this._timeScaleInterpolant=i);var v=i.parameterPositions,c=i.sampleValues;return v[0]=r,v[1]=r+t,c[0]=n/a,c[1]=e/a,this}},{key:"stopWarping",value:function(){var n=this._timeScaleInterpolant;return null!==n&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(n)),this}},{key:"getMixer",value:function(){return this._mixer}},{key:"getClip",value:function(){return this._clip}},{key:"getRoot",value:function(){return this._localRoot||this._mixer._root}},{key:"_update",value:function(n,e,t,o){if(this.enabled){var r=this._startTime;if(null!==r){var a=(n-r)*t;a<0||0===t?e=0:(this._startTime=null,e=t*a)}e*=this._updateTimeScale(n);var i=this._updateTime(e),v=this._updateWeight(n);if(v>0){var c=this._interpolants,l=this._propertyBindings;if(this.blendMode===ot)for(var s=0,u=c.length;s!==u;++s)c[s].evaluate(i),l[s].accumulateAdditive(v);else for(var f=0,p=c.length;f!==p;++f)c[f].evaluate(i),l[f].accumulate(o,v)}}else this._updateWeight(n)}},{key:"_updateWeight",value:function(n){var e=0;if(this.enabled){e=this.weight;var t=this._weightInterpolant;if(null!==t){var o=t.evaluate(n)[0];e*=o,n>t.parameterPositions[1]&&(this.stopFading(),0===o&&(this.enabled=!1))}}return this._effectiveWeight=e,e}},{key:"_updateTimeScale",value:function(n){var e=0;if(!this.paused){e=this.timeScale;var t=this._timeScaleInterpolant;if(null!==t)e*=t.evaluate(n)[0],n>t.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}return this._effectiveTimeScale=e,e}},{key:"_updateTime",value:function(n){var e=this._clip.duration,t=this.loop,o=this.time+n,r=this._loopCount,a=t===Ze;if(0===n)return-1===r?o:a&&1===(1&r)?e-o:o;if(t===Xe){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));n:{if(o>=e)o=e;else{if(!(o<0)){this.time=o;break n}o=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:n<0?-1:1})}}else{if(-1===r&&(n>=0?(r=0,this._setEndings(!0,0===this.repetitions,a)):this._setEndings(0===this.repetitions,!0,a)),o>=e||o<0){var i=Math.floor(o/e);o-=e*i,r+=Math.abs(i);var v=this.repetitions-r;if(v<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,o=n>0?e:0,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:n>0?1:-1});else{if(1===v){var c=n<0;this._setEndings(c,!c,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=o,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=o;if(a&&1===(1&r))return e-o}return o}},{key:"_setEndings",value:function(n,e,t){var o=this._interpolantSettings;t?(o.endingStart=nt,o.endingEnd=nt):(o.endingStart=n?this.zeroSlopeAtStart?nt:$e:et,o.endingEnd=e?this.zeroSlopeAtEnd?nt:$e:et)}},{key:"_scheduleFading",value:function(n,e,t){var o=this._mixer,r=o.time,a=this._weightInterpolant;null===a&&(a=o._lendControlInterpolant(),this._weightInterpolant=a);var i=a.parameterPositions,v=a.sampleValues;return i[0]=r,v[0]=e,i[1]=r+n,v[1]=t,this}}]),n}(),xp=new Float32Array(1),yp=function(n){_(t,n);var e=z(t);function t(n){var o;return y(this,t),(o=e.call(this))._root=n,o._initMemoryManager(),o._accuIndex=0,o.time=0,o.timeScale=1,o}return b(t,[{key:"_bindAction",value:function(n,e){var t=n._localRoot||this._root,o=n._clip.tracks,r=o.length,a=n._propertyBindings,i=n._interpolants,v=t.uuid,c=this._bindingsByRootAndName,l=c[v];void 0===l&&(l={},c[v]=l);for(var s=0;s!==r;++s){var u=o[s],f=u.name,p=l[f];if(void 0!==p)++p.referenceCount,a[s]=p;else{if(void 0!==(p=a[s])){null===p._cacheIndex&&(++p.referenceCount,this._addInactiveBinding(p,v,f));continue}var m=e&&e._propertyBindings[s].binding.parsedPath;++(p=new ip(mp.create(t,f,m),u.ValueTypeName,u.getValueSize())).referenceCount,this._addInactiveBinding(p,v,f),a[s]=p}i[s].resultBuffer=p.buffer}}},{key:"_activateAction",value:function(n){if(!this._isActiveAction(n)){if(null===n._cacheIndex){var e=(n._localRoot||this._root).uuid,t=n._clip.uuid,o=this._actionsByClip[t];this._bindAction(n,o&&o.knownActions[0]),this._addInactiveAction(n,t,e)}for(var r=n._propertyBindings,a=0,i=r.length;a!==i;++a){var v=r[a];0===v.useCount++&&(this._lendBinding(v),v.saveOriginalState())}this._lendAction(n)}}},{key:"_deactivateAction",value:function(n){if(this._isActiveAction(n)){for(var e=n._propertyBindings,t=0,o=e.length;t!==o;++t){var r=e[t];0===--r.useCount&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(n)}}},{key:"_initMemoryManager",value:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;var n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}}},{key:"_isActiveAction",value:function(n){var e=n._cacheIndex;return null!==e&&e<this._nActiveActions}},{key:"_addInactiveAction",value:function(n,e,t){var o=this._actions,r=this._actionsByClip,a=r[e];if(void 0===a)a={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,r[e]=a;else{var i=a.knownActions;n._byClipCacheIndex=i.length,i.push(n)}n._cacheIndex=o.length,o.push(n),a.actionByRoot[t]=n}},{key:"_removeInactiveAction",value:function(n){var e=this._actions,t=e[e.length-1],o=n._cacheIndex;t._cacheIndex=o,e[o]=t,e.pop(),n._cacheIndex=null;var r=n._clip.uuid,a=this._actionsByClip,i=a[r],v=i.knownActions,c=v[v.length-1],l=n._byClipCacheIndex;c._byClipCacheIndex=l,v[l]=c,v.pop(),n._byClipCacheIndex=null,delete i.actionByRoot[(n._localRoot||this._root).uuid],0===v.length&&delete a[r],this._removeInactiveBindingsForAction(n)}},{key:"_removeInactiveBindingsForAction",value:function(n){for(var e=n._propertyBindings,t=0,o=e.length;t!==o;++t){var r=e[t];0===--r.referenceCount&&this._removeInactiveBinding(r)}}},{key:"_lendAction",value:function(n){var e=this._actions,t=n._cacheIndex,o=this._nActiveActions++,r=e[o];n._cacheIndex=o,e[o]=n,r._cacheIndex=t,e[t]=r}},{key:"_takeBackAction",value:function(n){var e=this._actions,t=n._cacheIndex,o=--this._nActiveActions,r=e[o];n._cacheIndex=o,e[o]=n,r._cacheIndex=t,e[t]=r}},{key:"_addInactiveBinding",value:function(n,e,t){var o=this._bindingsByRootAndName,r=this._bindings,a=o[e];void 0===a&&(a={},o[e]=a),a[t]=n,n._cacheIndex=r.length,r.push(n)}},{key:"_removeInactiveBinding",value:function(n){var e=this._bindings,t=n.binding,o=t.rootNode.uuid,r=t.path,a=this._bindingsByRootAndName,i=a[o],v=e[e.length-1],c=n._cacheIndex;v._cacheIndex=c,e[c]=v,e.pop(),delete i[r],0===Object.keys(i).length&&delete a[o]}},{key:"_lendBinding",value:function(n){var e=this._bindings,t=n._cacheIndex,o=this._nActiveBindings++,r=e[o];n._cacheIndex=o,e[o]=n,r._cacheIndex=t,e[t]=r}},{key:"_takeBackBinding",value:function(n){var e=this._bindings,t=n._cacheIndex,o=--this._nActiveBindings,r=e[o];n._cacheIndex=o,e[o]=n,r._cacheIndex=t,e[t]=r}},{key:"_lendControlInterpolant",value:function(){var n=this._controlInterpolants,e=this._nActiveControlInterpolants++,t=n[e];return void 0===t&&((t=new Ou(new Float32Array(2),new Float32Array(2),1,xp)).__cacheIndex=e,n[e]=t),t}},{key:"_takeBackControlInterpolant",value:function(n){var e=this._controlInterpolants,t=n.__cacheIndex,o=--this._nActiveControlInterpolants,r=e[o];n.__cacheIndex=o,e[o]=n,r.__cacheIndex=t,e[t]=r}},{key:"clipAction",value:function(n,e,t){var o=e||this._root,r=o.uuid,a="string"===typeof n?Xu.findByName(o,n):n,i=null!==a?a.uuid:n,v=this._actionsByClip[i],c=null;if(void 0===t&&(t=null!==a?a.blendMode:tt),void 0!==v){var l=v.actionByRoot[r];if(void 0!==l&&l.blendMode===t)return l;c=v.knownActions[0],null===a&&(a=c._clip)}if(null===a)return null;var s=new hp(this,a,e,t);return this._bindAction(s,c),this._addInactiveAction(s,i,r),s}},{key:"existingAction",value:function(n,e){var t=e||this._root,o=t.uuid,r="string"===typeof n?Xu.findByName(t,n):n,a=r?r.uuid:n,i=this._actionsByClip[a];return void 0!==i&&i.actionByRoot[o]||null}},{key:"stopAllAction",value:function(){for(var n=this._actions,e=this._nActiveActions-1;e>=0;--e)n[e].stop();return this}},{key:"update",value:function(n){n*=this.timeScale;for(var e=this._actions,t=this._nActiveActions,o=this.time+=n,r=Math.sign(n),a=this._accuIndex^=1,i=0;i!==t;++i){e[i]._update(o,n,r,a)}for(var v=this._bindings,c=this._nActiveBindings,l=0;l!==c;++l)v[l].apply(a);return this}},{key:"setTime",value:function(n){this.time=0;for(var e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(n)}},{key:"getRoot",value:function(){return this._root}},{key:"uncacheClip",value:function(n){var e=this._actions,t=n.uuid,o=this._actionsByClip,r=o[t];if(void 0!==r){for(var a=r.knownActions,i=0,v=a.length;i!==v;++i){var c=a[i];this._deactivateAction(c);var l=c._cacheIndex,s=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,s._cacheIndex=l,e[l]=s,e.pop(),this._removeInactiveBindingsForAction(c)}delete o[t]}}},{key:"uncacheRoot",value:function(n){var e=n.uuid,t=this._actionsByClip;for(var o in t){var r=t[o].actionByRoot[e];void 0!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}var a=this._bindingsByRootAndName[e];if(void 0!==a)for(var i in a){var v=a[i];v.restoreOriginalState(),this._removeInactiveBinding(v)}}},{key:"uncacheAction",value:function(n,e){var t=this.existingAction(n,e);null!==t&&(this._deactivateAction(t),this._removeInactiveAction(t))}}]),t}(Vt),gp=function(){function n(e){y(this,n),this.value=e}return b(n,[{key:"clone",value:function(){return new n(void 0===this.value.clone?this.value:this.value.clone())}}]),n}(),bp=0,_p=function(n){_(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isUniformsGroup=!0,Object.defineProperty(S(n),"id",{value:bp++}),n.name="",n.usage=Pt,n.uniforms=[],n}return b(t,[{key:"add",value:function(n){return this.uniforms.push(n),this}},{key:"remove",value:function(n){var e=this.uniforms.indexOf(n);return-1!==e&&this.uniforms.splice(e,1),this}},{key:"setName",value:function(n){return this.name=n,this}},{key:"setUsage",value:function(n){return this.usage=n,this}},{key:"dispose",value:function(){return this.dispatchEvent({type:"dispose"}),this}},{key:"copy",value:function(n){this.name=n.name,this.usage=n.usage;var e=n.uniforms;this.uniforms.length=0;for(var t=0,o=e.length;t<o;t++)this.uniforms.push(e[t].clone());return this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),t}(Vt),Up=function(n){_(t,n);var e=z(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return y(this,t),(r=e.call(this,n,o)).isInstancedInterleavedBuffer=!0,r.meshPerAttribute=a,r}return b(t,[{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n),this.meshPerAttribute=n.meshPerAttribute,this}},{key:"clone",value:function(n){var e=D(U(t.prototype),"clone",this).call(this,n);return e.meshPerAttribute=this.meshPerAttribute,e}},{key:"toJSON",value:function(n){var e=D(U(t.prototype),"toJSON",this).call(this,n);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}]),t}(Gc),wp=function(){function n(e,t,o,r,a){y(this,n),this.isGLBufferAttribute=!0,this.buffer=e,this.type=t,this.itemSize=o,this.elementSize=r,this.count=a,this.version=0}return b(n,[{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"setBuffer",value:function(n){return this.buffer=n,this}},{key:"setType",value:function(n,e){return this.type=n,this.elementSize=e,this}},{key:"setItemSize",value:function(n){return this.itemSize=n,this}},{key:"setCount",value:function(n){return this.count=n,this}}]),n}(),Sp=function(){function n(e,t){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;y(this,n),this.ray=new fr(e,t),this.near=o,this.far=r,this.camera=null,this.layers=new Sr,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}return b(n,[{key:"set",value:function(n,e){this.ray.set(n,e)}},{key:"setFromCamera",value:function(n,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}},{key:"intersectObject",value:function(n){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return zp(n,this,t,e),t.sort(Mp),t}},{key:"intersectObjects",value:function(n){for(var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],o=0,r=n.length;o<r;o++)zp(n[o],this,t,e);return t.sort(Mp),t}}]),n}();function Mp(n,e){return n.distance-e.distance}function zp(n,e,t,o){if(n.layers.test(e.layers)&&n.raycast(e,t),!0===o)for(var r=n.children,a=0,i=r.length;a<i;a++)zp(r[a],e,t,!0)}var kp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return y(this,n),this.radius=e,this.phi=t,this.theta=o,this}return b(n,[{key:"set",value:function(n,e,t){return this.radius=n,this.phi=e,this.theta=t,this}},{key:"copy",value:function(n){return this.radius=n.radius,this.phi=n.phi,this.theta=n.theta,this}},{key:"makeSafe",value:function(){var n=1e-6;return this.phi=Math.max(n,Math.min(Math.PI-n,this.phi)),this}},{key:"setFromVector3",value:function(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}},{key:"setFromCartesianCoords",value:function(n,e,t){return this.radius=Math.sqrt(n*n+e*e+t*t),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(n,t),this.phi=Math.acos(Qt(e/this.radius,-1,1))),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),Cp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return y(this,n),this.radius=e,this.theta=t,this.y=o,this}return b(n,[{key:"set",value:function(n,e,t){return this.radius=n,this.theta=e,this.y=t,this}},{key:"copy",value:function(n){return this.radius=n.radius,this.theta=n.theta,this.y=n.y,this}},{key:"setFromVector3",value:function(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}},{key:"setFromCartesianCoords",value:function(n,e,t){return this.radius=Math.sqrt(n*n+t*t),this.theta=Math.atan2(n,t),this.y=e,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),Tp=new ao,Rp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ao(1/0,1/0),t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao(-1/0,-1/0);y(this,n),this.isBox2=!0,this.min=e,this.max=t}return b(n,[{key:"set",value:function(n,e){return this.min.copy(n),this.max.copy(e),this}},{key:"setFromPoints",value:function(n){this.makeEmpty();for(var e=0,t=n.length;e<t;e++)this.expandByPoint(n[e]);return this}},{key:"setFromCenterAndSize",value:function(n,e){var t=Tp.copy(e).multiplyScalar(.5);return this.min.copy(n).sub(t),this.max.copy(n).add(t),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.min.copy(n.min),this.max.copy(n.max),this}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y}},{key:"getCenter",value:function(n){return this.isEmpty()?n.set(0,0):n.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(n){return this.isEmpty()?n.set(0,0):n.subVectors(this.max,this.min)}},{key:"expandByPoint",value:function(n){return this.min.min(n),this.max.max(n),this}},{key:"expandByVector",value:function(n){return this.min.sub(n),this.max.add(n),this}},{key:"expandByScalar",value:function(n){return this.min.addScalar(-n),this.max.addScalar(n),this}},{key:"containsPoint",value:function(n){return!(n.x<this.min.x||n.x>this.max.x||n.y<this.min.y||n.y>this.max.y)}},{key:"containsBox",value:function(n){return this.min.x<=n.min.x&&n.max.x<=this.max.x&&this.min.y<=n.min.y&&n.max.y<=this.max.y}},{key:"getParameter",value:function(n,e){return e.set((n.x-this.min.x)/(this.max.x-this.min.x),(n.y-this.min.y)/(this.max.y-this.min.y))}},{key:"intersectsBox",value:function(n){return!(n.max.x<this.min.x||n.min.x>this.max.x||n.max.y<this.min.y||n.min.y>this.max.y)}},{key:"clampPoint",value:function(n,e){return e.copy(n).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(n){return Tp.copy(n).clamp(this.min,this.max).sub(n).length()}},{key:"intersect",value:function(n){return this.min.max(n.min),this.max.min(n.max),this}},{key:"union",value:function(n){return this.min.min(n.min),this.max.max(n.max),this}},{key:"translate",value:function(n){return this.min.add(n),this.max.add(n),this}},{key:"equals",value:function(n){return n.min.equals(this.min)&&n.max.equals(this.max)}}]),n}(),Dp=new Oo,Pp=new Oo,Fp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo;y(this,n),this.start=e,this.end=t}return b(n,[{key:"set",value:function(n,e){return this.start.copy(n),this.end.copy(e),this}},{key:"copy",value:function(n){return this.start.copy(n.start),this.end.copy(n.end),this}},{key:"getCenter",value:function(n){return n.addVectors(this.start,this.end).multiplyScalar(.5)}},{key:"delta",value:function(n){return n.subVectors(this.end,this.start)}},{key:"distanceSq",value:function(){return this.start.distanceToSquared(this.end)}},{key:"distance",value:function(){return this.start.distanceTo(this.end)}},{key:"at",value:function(n,e){return this.delta(e).multiplyScalar(n).add(this.start)}},{key:"closestPointToPointParameter",value:function(n,e){Dp.subVectors(n,this.start),Pp.subVectors(this.end,this.start);var t=Pp.dot(Pp),o=Pp.dot(Dp)/t;return e&&(o=Qt(o,0,1)),o}},{key:"closestPointToPoint",value:function(n,e,t){var o=this.closestPointToPointParameter(n,e);return this.delta(t).multiplyScalar(o).add(this.start)}},{key:"applyMatrix4",value:function(n){return this.start.applyMatrix4(n),this.end.applyMatrix4(n),this}},{key:"equals",value:function(n){return n.start.equals(this.start)&&n.end.equals(this.end)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),jp=new Oo,Ip=function(n){_(t,n);var e=z(t);function t(n,o){var r;y(this,t),(r=e.call(this)).light=n,r.light.updateMatrixWorld(),r.matrix=n.matrixWorld,r.matrixAutoUpdate=!1,r.color=o;for(var a=new ga,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1],v=0,c=1;v<32;v++,c++){var l=v/32*Math.PI*2,s=c/32*Math.PI*2;i.push(Math.cos(l),Math.sin(l),1,Math.cos(s),Math.sin(s),1)}a.setAttribute("position",new sa(i,3));var u=new Ml({fog:!1,toneMapped:!1});return r.cone=new jl(a,u),r.add(r.cone),r.update(),r}return b(t,[{key:"dispose",value:function(){this.cone.geometry.dispose(),this.cone.material.dispose()}},{key:"update",value:function(){this.light.updateMatrixWorld();var n=this.light.distance?this.light.distance:1e3,e=n*Math.tan(this.light.angle);this.cone.scale.set(e,e,n),jp.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(jp),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}]),t}(Lr),Ep=new Oo,Op=new pr,Lp=new pr,Ap=function(n){_(t,n);var e=z(t);function t(n){var o;y(this,t);for(var r=Gp(n),a=new ga,i=[],v=[],c=new wo(0,0,1),l=new wo(0,1,0),s=0;s<r.length;s++){var u=r[s];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),v.push(c.r,c.g,c.b),v.push(l.r,l.g,l.b))}a.setAttribute("position",new sa(i,3)),a.setAttribute("color",new sa(v,3));var f=new Ml({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});return(o=e.call(this,a,f)).isSkeletonHelper=!0,o.type="SkeletonHelper",o.root=n,o.bones=r,o.matrix=n.matrixWorld,o.matrixAutoUpdate=!1,o}return b(t,[{key:"updateMatrixWorld",value:function(n){var e=this.bones,o=this.geometry,r=o.getAttribute("position");Lp.copy(this.root.matrixWorld).invert();for(var a=0,i=0;a<e.length;a++){var v=e[a];v.parent&&v.parent.isBone&&(Op.multiplyMatrices(Lp,v.matrixWorld),Ep.setFromMatrixPosition(Op),r.setXYZ(i,Ep.x,Ep.y,Ep.z),Op.multiplyMatrices(Lp,v.parent.matrixWorld),Ep.setFromMatrixPosition(Op),r.setXYZ(i+1,Ep.x,Ep.y,Ep.z),i+=2)}o.getAttribute("position").needsUpdate=!0,D(U(t.prototype),"updateMatrixWorld",this).call(this,n)}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(jl);function Gp(n){var e=[];!0===n.isBone&&e.push(n);for(var t=0;t<n.children.length;t++)e.push.apply(e,Gp(n.children[t]));return e}var Np=function(n){_(t,n);var e=z(t);function t(n,o,r){var a;y(this,t);var i=new su(o,4,2),v=new Kr({wireframe:!0,fog:!1,toneMapped:!1});return(a=e.call(this,i,v)).light=n,a.light.updateMatrixWorld(),a.color=r,a.type="PointLightHelper",a.matrix=a.light.matrixWorld,a.matrixAutoUpdate=!1,a.update(),a}return b(t,[{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}},{key:"update",value:function(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}]),t}(Oa),Bp=new Oo,qp=new wo,Vp=new wo,Wp=function(n){_(t,n);var e=z(t);function t(n,o,r){var a;y(this,t),(a=e.call(this)).light=n,a.light.updateMatrixWorld(),a.matrix=n.matrixWorld,a.matrixAutoUpdate=!1,a.color=r;var i=new vu(o);i.rotateY(.5*Math.PI),a.material=new Kr({wireframe:!0,fog:!1,toneMapped:!1}),void 0===a.color&&(a.material.vertexColors=!0);var v=i.getAttribute("position"),c=new Float32Array(3*v.count);return i.setAttribute("color",new ea(c,3)),a.add(new Oa(i,a.material)),a.update(),a}return b(t,[{key:"dispose",value:function(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}},{key:"update",value:function(){var n=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{var e=n.geometry.getAttribute("color");qp.copy(this.light.color),Vp.copy(this.light.groundColor);for(var t=0,o=e.count;t<o;t++){var r=t<o/2?qp:Vp;e.setXYZ(t,r.r,r.g,r.b)}e.needsUpdate=!0}n.lookAt(Bp.setFromMatrixPosition(this.light.matrixWorld).negate())}}]),t}(Lr),Hp=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4473924,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8947848;y(this,t),a=new wo(a),i=new wo(i);for(var v=r/2,c=o/r,l=o/2,s=[],u=[],f=0,p=0,m=-l;f<=r;f++,m+=c){s.push(-l,0,m,l,0,m),s.push(m,0,-l,m,0,l);var d=f===v?a:i;d.toArray(u,p),p+=3,d.toArray(u,p),p+=3,d.toArray(u,p),p+=3,d.toArray(u,p),p+=3}var h=new ga;h.setAttribute("position",new sa(s,3)),h.setAttribute("color",new sa(u,3));var x=new Ml({vertexColors:!0,toneMapped:!1});return(n=e.call(this,h,x)).type="GridHelper",n}return b(t,[{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(jl),Xp=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:64,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4473924,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:8947848;y(this,t),v=new wo(v),c=new wo(c);var l=[],s=[];if(r>1)for(var u=0;u<r;u++){var f=u/r*(2*Math.PI),p=Math.sin(f)*o,m=Math.cos(f)*o;l.push(0,0,0),l.push(p,0,m);var d=1&u?v:c;s.push(d.r,d.g,d.b),s.push(d.r,d.g,d.b)}for(var h=0;h<a;h++)for(var x=1&h?v:c,g=o-o/a*h,b=0;b<i;b++){var _=b/i*(2*Math.PI),U=Math.sin(_)*g,w=Math.cos(_)*g;l.push(U,0,w),s.push(x.r,x.g,x.b),_=(b+1)/i*(2*Math.PI),U=Math.sin(_)*g,w=Math.cos(_)*g,l.push(U,0,w),s.push(x.r,x.g,x.b)}var S=new ga;S.setAttribute("position",new sa(l,3)),S.setAttribute("color",new sa(s,3));var M=new Ml({vertexColors:!0,toneMapped:!1});return(n=e.call(this,S,M)).type="PolarGridHelper",n}return b(t,[{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(jl),Yp=new Oo,Zp=new Oo,Qp=new Oo,Jp=function(n){_(t,n);var e=z(t);function t(n,o,r){var a;y(this,t),(a=e.call(this)).light=n,a.light.updateMatrixWorld(),a.matrix=n.matrixWorld,a.matrixAutoUpdate=!1,a.color=r,void 0===o&&(o=1);var i=new ga;i.setAttribute("position",new sa([-o,o,0,o,o,0,o,-o,0,-o,-o,0,-o,o,0],3));var v=new Ml({fog:!1,toneMapped:!1});return a.lightPlane=new Dl(i,v),a.add(a.lightPlane),(i=new ga).setAttribute("position",new sa([0,0,0,0,0,1],3)),a.targetLine=new Dl(i,v),a.add(a.targetLine),a.update(),a}return b(t,[{key:"dispose",value:function(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}},{key:"update",value:function(){Yp.setFromMatrixPosition(this.light.matrixWorld),Zp.setFromMatrixPosition(this.light.target.matrixWorld),Qp.subVectors(Zp,Yp),this.lightPlane.lookAt(Zp),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Zp),this.targetLine.scale.z=Qp.length()}}]),t}(Lr),Kp=new Oo,$p=new Va,nm=function(n){_(t,n);var e=z(t);function t(n){var o;y(this,t);var r=new ga,a=new Ml({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],v=[],c={};function l(n,e){s(n),s(e)}function s(n){i.push(0,0,0),v.push(0,0,0),void 0===c[n]&&(c[n]=[]),c[n].push(i.length/3-1)}l("n1","n2"),l("n2","n4"),l("n4","n3"),l("n3","n1"),l("f1","f2"),l("f2","f4"),l("f4","f3"),l("f3","f1"),l("n1","f1"),l("n2","f2"),l("n3","f3"),l("n4","f4"),l("p","n1"),l("p","n2"),l("p","n3"),l("p","n4"),l("u1","u2"),l("u2","u3"),l("u3","u1"),l("c","t"),l("p","c"),l("cn1","cn2"),l("cn3","cn4"),l("cf1","cf2"),l("cf3","cf4"),r.setAttribute("position",new sa(i,3)),r.setAttribute("color",new sa(v,3)),(o=e.call(this,r,a)).type="CameraHelper",o.camera=n,o.camera.updateProjectionMatrix&&o.camera.updateProjectionMatrix(),o.matrix=n.matrixWorld,o.matrixAutoUpdate=!1,o.pointMap=c,o.update();var u=new wo(16755200),f=new wo(16711680),p=new wo(43775),m=new wo(16777215),d=new wo(3355443);return o.setColors(u,f,p,m,d),o}return b(t,[{key:"setColors",value:function(n,e,t,o,r){var a=this.geometry.getAttribute("color");a.setXYZ(0,n.r,n.g,n.b),a.setXYZ(1,n.r,n.g,n.b),a.setXYZ(2,n.r,n.g,n.b),a.setXYZ(3,n.r,n.g,n.b),a.setXYZ(4,n.r,n.g,n.b),a.setXYZ(5,n.r,n.g,n.b),a.setXYZ(6,n.r,n.g,n.b),a.setXYZ(7,n.r,n.g,n.b),a.setXYZ(8,n.r,n.g,n.b),a.setXYZ(9,n.r,n.g,n.b),a.setXYZ(10,n.r,n.g,n.b),a.setXYZ(11,n.r,n.g,n.b),a.setXYZ(12,n.r,n.g,n.b),a.setXYZ(13,n.r,n.g,n.b),a.setXYZ(14,n.r,n.g,n.b),a.setXYZ(15,n.r,n.g,n.b),a.setXYZ(16,n.r,n.g,n.b),a.setXYZ(17,n.r,n.g,n.b),a.setXYZ(18,n.r,n.g,n.b),a.setXYZ(19,n.r,n.g,n.b),a.setXYZ(20,n.r,n.g,n.b),a.setXYZ(21,n.r,n.g,n.b),a.setXYZ(22,n.r,n.g,n.b),a.setXYZ(23,n.r,n.g,n.b),a.setXYZ(24,e.r,e.g,e.b),a.setXYZ(25,e.r,e.g,e.b),a.setXYZ(26,e.r,e.g,e.b),a.setXYZ(27,e.r,e.g,e.b),a.setXYZ(28,e.r,e.g,e.b),a.setXYZ(29,e.r,e.g,e.b),a.setXYZ(30,e.r,e.g,e.b),a.setXYZ(31,e.r,e.g,e.b),a.setXYZ(32,t.r,t.g,t.b),a.setXYZ(33,t.r,t.g,t.b),a.setXYZ(34,t.r,t.g,t.b),a.setXYZ(35,t.r,t.g,t.b),a.setXYZ(36,t.r,t.g,t.b),a.setXYZ(37,t.r,t.g,t.b),a.setXYZ(38,o.r,o.g,o.b),a.setXYZ(39,o.r,o.g,o.b),a.setXYZ(40,r.r,r.g,r.b),a.setXYZ(41,r.r,r.g,r.b),a.setXYZ(42,r.r,r.g,r.b),a.setXYZ(43,r.r,r.g,r.b),a.setXYZ(44,r.r,r.g,r.b),a.setXYZ(45,r.r,r.g,r.b),a.setXYZ(46,r.r,r.g,r.b),a.setXYZ(47,r.r,r.g,r.b),a.setXYZ(48,r.r,r.g,r.b),a.setXYZ(49,r.r,r.g,r.b),a.needsUpdate=!0}},{key:"update",value:function(){var n=this.geometry,e=this.pointMap;$p.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),em("c",e,n,$p,0,0,-1),em("t",e,n,$p,0,0,1),em("n1",e,n,$p,-1,-1,-1),em("n2",e,n,$p,1,-1,-1),em("n3",e,n,$p,-1,1,-1),em("n4",e,n,$p,1,1,-1),em("f1",e,n,$p,-1,-1,1),em("f2",e,n,$p,1,-1,1),em("f3",e,n,$p,-1,1,1),em("f4",e,n,$p,1,1,1),em("u1",e,n,$p,.7,1.1,-1),em("u2",e,n,$p,-.7,1.1,-1),em("u3",e,n,$p,0,2,-1),em("cf1",e,n,$p,-1,0,1),em("cf2",e,n,$p,1,0,1),em("cf3",e,n,$p,0,-1,1),em("cf4",e,n,$p,0,1,1),em("cn1",e,n,$p,-1,0,-1),em("cn2",e,n,$p,1,0,-1),em("cn3",e,n,$p,0,-1,-1),em("cn4",e,n,$p,0,1,-1),n.getAttribute("position").needsUpdate=!0}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(jl);function em(n,e,t,o,r,a,i){Kp.set(r,a,i).unproject(o);var v=e[n];if(void 0!==v)for(var c=t.getAttribute("position"),l=0,s=v.length;l<s;l++)c.setXYZ(v[l],Kp.x,Kp.y,Kp.z)}var tm,om,rm=new Go,am=function(n){_(t,n);var e=z(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16776960;y(this,t);var a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),v=new ga;return v.setIndex(new ea(a,1)),v.setAttribute("position",new ea(i,3)),(o=e.call(this,v,new Ml({color:r,toneMapped:!1}))).object=n,o.type="BoxHelper",o.matrixAutoUpdate=!1,o.update(),o}return b(t,[{key:"update",value:function(n){if(void 0!==n&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&rm.setFromObject(this.object),!rm.isEmpty()){var e=rm.min,t=rm.max,o=this.geometry.attributes.position,r=o.array;r[0]=t.x,r[1]=t.y,r[2]=t.z,r[3]=e.x,r[4]=t.y,r[5]=t.z,r[6]=e.x,r[7]=e.y,r[8]=t.z,r[9]=t.x,r[10]=e.y,r[11]=t.z,r[12]=t.x,r[13]=t.y,r[14]=e.z,r[15]=e.x,r[16]=t.y,r[17]=e.z,r[18]=e.x,r[19]=e.y,r[20]=e.z,r[21]=t.x,r[22]=e.y,r[23]=e.z,o.needsUpdate=!0,this.geometry.computeBoundingSphere()}}},{key:"setFromObject",value:function(n){return this.object=n,this.update(),this}},{key:"copy",value:function(n,e){return D(U(t.prototype),"copy",this).call(this,n,e),this.object=n.object,this}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(jl),im=function(n){_(t,n);var e=z(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16776960;y(this,t);var a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],v=new ga;return v.setIndex(new ea(a,1)),v.setAttribute("position",new sa(i,3)),(o=e.call(this,v,new Ml({color:r,toneMapped:!1}))).box=n,o.type="Box3Helper",o.geometry.computeBoundingSphere(),o}return b(t,[{key:"updateMatrixWorld",value:function(n){var e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),D(U(t.prototype),"updateMatrixWorld",this).call(this,n))}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(jl),vm=function(n){_(t,n);var e=z(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:16776960;y(this,t);var i=a,v=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],c=new ga;c.setAttribute("position",new sa(v,3)),c.computeBoundingSphere(),(o=e.call(this,c,new Ml({color:i,toneMapped:!1}))).type="PlaneHelper",o.plane=n,o.size=r;var l=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],s=new ga;return s.setAttribute("position",new sa(l,3)),s.computeBoundingSphere(),o.add(new Oa(s,new Kr({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1}))),o}return b(t,[{key:"updateMatrixWorld",value:function(n){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),D(U(t.prototype),"updateMatrixWorld",this).call(this,n)}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}]),t}(Dl),cm=new Oo,lm=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo(0,0,1),r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo(0,0,0),a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:16776960,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.2*a,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.2*v;return y(this,t),(n=e.call(this)).type="ArrowHelper",void 0===tm&&((tm=new ga).setAttribute("position",new sa([0,0,0,0,1,0],3)),(om=new gs(0,.5,1,5,1)).translate(0,-.5,0)),n.position.copy(r),n.line=new Dl(tm,new Ml({color:i,toneMapped:!1})),n.line.matrixAutoUpdate=!1,n.add(n.line),n.cone=new Oa(om,new Kr({color:i,toneMapped:!1})),n.cone.matrixAutoUpdate=!1,n.add(n.cone),n.setDirection(o),n.setLength(a,v,c),n}return b(t,[{key:"setDirection",value:function(n){if(n.y>.99999)this.quaternion.set(0,0,0,1);else if(n.y<-.99999)this.quaternion.set(1,0,0,0);else{cm.set(n.z,0,-n.x).normalize();var e=Math.acos(n.y);this.quaternion.setFromAxisAngle(cm,e)}}},{key:"setLength",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2*n,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.2*e;this.line.scale.set(1,Math.max(1e-4,n-e),1),this.line.updateMatrix(),this.cone.scale.set(t,e,t),this.cone.position.y=n,this.cone.updateMatrix()}},{key:"setColor",value:function(n){this.line.material.color.set(n),this.cone.material.color.set(n)}},{key:"copy",value:function(n){return D(U(t.prototype),"copy",this).call(this,n,!1),this.line.copy(n.line),this.cone.copy(n.cone),this}},{key:"dispose",value:function(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}]),t}(Lr),sm=function(n){_(t,n);var e=z(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;y(this,t);var r=[0,0,0,o,0,0,0,0,0,0,o,0,0,0,0,0,0,o],a=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new ga;i.setAttribute("position",new sa(r,3)),i.setAttribute("color",new sa(a,3));var v=new Ml({vertexColors:!0,toneMapped:!1});return(n=e.call(this,i,v)).type="AxesHelper",n}return b(t,[{key:"setColors",value:function(n,e,t){var o=new wo,r=this.geometry.attributes.color.array;return o.set(n),o.toArray(r,0),o.toArray(r,3),o.set(e),o.toArray(r,6),o.toArray(r,9),o.set(t),o.toArray(r,12),o.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(jl),um=function(){function n(){y(this,n),this.type="ShapePath",this.color=new wo,this.subPaths=[],this.currentPath=null}return b(n,[{key:"moveTo",value:function(n,e){return this.currentPath=new ds,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,e),this}},{key:"lineTo",value:function(n,e){return this.currentPath.lineTo(n,e),this}},{key:"quadraticCurveTo",value:function(n,e,t,o){return this.currentPath.quadraticCurveTo(n,e,t,o),this}},{key:"bezierCurveTo",value:function(n,e,t,o,r,a){return this.currentPath.bezierCurveTo(n,e,t,o,r,a),this}},{key:"splineThru",value:function(n){return this.currentPath.splineThru(n),this}},{key:"toShapes",value:function(n){function e(n,e){for(var t=e.length,o=!1,r=t-1,a=0;a<t;r=a++){var i=e[r],v=e[a],c=v.x-i.x,l=v.y-i.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(i=e[a],c=-c,v=e[r],l=-l),n.y<i.y||n.y>v.y)continue;if(n.y===i.y){if(n.x===i.x)return!0}else{var s=l*(n.x-i.x)-c*(n.y-i.y);if(0===s)return!0;if(s<0)continue;o=!o}}else{if(n.y!==i.y)continue;if(v.x<=n.x&&n.x<=i.x||i.x<=n.x&&n.x<=v.x)return!0}}return o}var t,o,r,a=eu.isClockWise,i=this.subPaths;if(0===i.length)return[];var v=[];if(1===i.length)return o=i[0],(r=new Cs).curves=o.curves,v.push(r),v;var c=!a(i[0].getPoints());c=n?!c:c;var l,s,u=[],f=[],p=[],m=0;f[m]=void 0,p[m]=[];for(var d=0,h=i.length;d<h;d++)t=a(l=(o=i[d]).getPoints()),(t=n?!t:t)?(!c&&f[m]&&m++,f[m]={s:new Cs,p:l},f[m].s.curves=o.curves,c&&m++,p[m]=[]):p[m].push({h:o,p:l[0]});if(!f[0])return function(n){for(var e=[],t=0,o=n.length;t<o;t++){var r=n[t],a=new Cs;a.curves=r.curves,e.push(a)}return e}(i);if(f.length>1){for(var x=!1,y=0,g=0,b=f.length;g<b;g++)u[g]=[];for(var _=0,U=f.length;_<U;_++)for(var w=p[_],S=0;S<w.length;S++){for(var M=w[S],z=!0,k=0;k<f.length;k++)e(M.p,f[k].p)&&(_!==k&&y++,z?(z=!1,u[k].push(M)):x=!0);z&&u[_].push(M)}y>0&&!1===x&&(p=u)}for(var C=0,T=f.length;C<T;C++){r=f[C].s,v.push(r);for(var R=0,D=(s=p[C]).length;R<D;R++)r.holes.push(s[R].h)}return v}}]),n}(),fm=pm();function pm(){for(var n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),o=new Uint32Array(512),r=new Uint32Array(512),a=0;a<256;++a){var i=a-127;i<-27?(o[a]=0,o[256|a]=32768,r[a]=24,r[256|a]=24):i<-14?(o[a]=1024>>-i-14,o[256|a]=1024>>-i-14|32768,r[a]=-i-1,r[256|a]=-i-1):i<=15?(o[a]=i+15<<10,o[256|a]=i+15<<10|32768,r[a]=13,r[256|a]=13):i<128?(o[a]=31744,o[256|a]=64512,r[a]=24,r[256|a]=24):(o[a]=31744,o[256|a]=64512,r[a]=13,r[256|a]=13)}for(var v=new Uint32Array(2048),c=new Uint32Array(64),l=new Uint32Array(64),s=1;s<1024;++s){for(var u=s<<13,f=0;0===(8388608&u);)u<<=1,f-=8388608;u&=-8388609,f+=947912704,v[s]=u|f}for(var p=1024;p<2048;++p)v[p]=939524096+(p-1024<<13);for(var m=1;m<31;++m)c[m]=m<<23;c[31]=1199570944,c[32]=2147483648;for(var d=33;d<63;++d)c[d]=2147483648+(d-32<<23);c[63]=3347054592;for(var h=1;h<64;++h)32!==h&&(l[h]=1024);return{floatView:e,uint32View:t,baseTable:o,shiftTable:r,mantissaTable:v,exponentTable:c,offsetTable:l}}var mm=Object.freeze({__proto__:null,toHalfFloat:function(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=Qt(n,-65504,65504),fm.floatView[0]=n;var e=fm.uint32View[0],t=e>>23&511;return fm.baseTable[t]+((8388607&e)>>fm.shiftTable[t])},fromHalfFloat:function(n){var e=n>>10;return fm.uint32View[0]=fm.mantissaTable[fm.offsetTable[e]+(1023&n)]+fm.exponentTable[e],fm.floatView[0]}});function dm(){console.error("THREE.ImmediateRenderObject has been removed.")}var hm=function(n){_(t,n);var e=z(t);function t(n,o,r){var a;return y(this,t),console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),(a=e.call(this,n,o,r)).samples=4,a}return b(t)}(Ro),xm=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),e.call(this,n,o,r,a)}return b(t)}(Do),ym=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),e.call(this,n,o,r,a)}return b(t)}(Fo),gm=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v){return y(this,t),console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),e.call(this,n,o,r,a,i,v)}return b(t)}(Aa),bm=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),e.call(this,n,o,r,a)}return b(t)}(xs),_m=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),e.call(this,n,o,r,a)}return b(t)}(ys),Um=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v,c){return y(this,t),console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),e.call(this,n,o,r,a,i,v,c)}return b(t)}(bs),wm=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v,c,l){return y(this,t),console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),e.call(this,n,o,r,a,i,v,c,l)}return b(t)}(gs),Sm=function(n){_(t,n);var e=z(t);function t(n,o){return y(this,t),console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),e.call(this,n,o)}return b(t)}(Us),Mm=function(n){_(t,n);var e=z(t);function t(n,o){return y(this,t),console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),e.call(this,n,o)}return b(t)}(ru),zm=function(n){_(t,n);var e=z(t);function t(n,o){return y(this,t),console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),e.call(this,n,o)}return b(t)}(iu),km=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),e.call(this,n,o,r,a)}return b(t)}(hs),Cm=function(n){_(t,n);var e=z(t);function t(n,o){return y(this,t),console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),e.call(this,n,o)}return b(t)}(vu),Tm=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),e.call(this,n,o,r,a)}return b(t)}(ai),Rm=function(n){_(t,n);var e=z(t);function t(n,o,r,a){return y(this,t),console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),e.call(this,n,o,r,a)}return b(t)}(_s),Dm=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v){return y(this,t),console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),e.call(this,n,o,r,a,i,v)}return b(t)}(cu),Pm=function(n){_(t,n);var e=z(t);function t(n,o){return y(this,t),console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),e.call(this,n,o)}return b(t)}(lu),Fm=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v,c){return y(this,t),console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),e.call(this,n,o,r,a,i,v,c)}return b(t)}(su),jm=function(n){_(t,n);var e=z(t);function t(n,o){return y(this,t),console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),e.call(this,n,o)}return b(t)}(uu),Im=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i){return y(this,t),console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),e.call(this,n,o,r,a,i)}return b(t)}(fu),Em=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i,v){return y(this,t),console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),e.call(this,n,o,r,a,i,v)}return b(t)}(pu),Om=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i){return y(this,t),console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),e.call(this,n,o,r,a,i)}return b(t)}(mu);"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:F}})),"undefined"!==typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=F);var Lm=t(791),Am=t(585);function Gm(n){var e,t=new Set,o=function(n,o){var r="function"===typeof n?n(e):n;if(r!==e){var a=e;e=o?r:Object.assign({},e,r),t.forEach((function(n){return n(e,a)}))}},r=function(){return e},a={setState:o,getState:r,subscribe:function(n,o,a){return o||a?function(n){var o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Object.is;console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");var i=o(e);function v(){var t=o(e);if(!a(i,t)){var r=i;n(i=t,r)}}return t.add(v),function(){return t.delete(v)}}(n,o,a):(t.add(n),function(){return t.delete(n)})},destroy:function(){return t.clear()}};return e=n(o,r,a),a}var Nm="undefined"===typeof window||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent)?Lm.useEffect:Lm.useLayoutEffect;var Bm=t(258),qm=t.n(Bm),Vm=t(545);function Wm(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(n,e){return n===e};if(n===e)return!0;if(!n||!e)return!1;var o=n.length;if(e.length!==o)return!1;for(var r=0;r<o;r++)if(!t(n[r],e[r]))return!1;return!0}var Hm=[];function Xm(n,e){var t,o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=f(Hm);try{for(a.s();!(t=a.n()).done;){var i=t.value;if(Wm(e,i.keys,i.equal)){if(o)return;if(Object.prototype.hasOwnProperty.call(i,"error"))throw i.error;if(Object.prototype.hasOwnProperty.call(i,"response"))return i.response;if(!o)throw i.promise}}}catch(c){a.e(c)}finally{a.f()}var v={keys:e,equal:r.equal,promise:n.apply(void 0,x(e)).then((function(n){return v.response=n})).then((function(){r.lifespan&&r.lifespan>0&&setTimeout((function(){var n=Hm.indexOf(v);-1!==n&&Hm.splice(n,1)}),r.lifespan)})).catch((function(n){return v.error=n}))};if(Hm.push(v),!o)throw v.promise}var Ym,Zm,Qm=["children","key","ref"],Jm=["children","key","ref"],Km=["args","attach"],$m=["args","children"],nd=["args","children"],ed=["params"],td=function(n){return n&&n.isOrthographicCamera},od="undefined"!==typeof window&&(null!=(Ym=window.document)&&Ym.createElement||"ReactNative"===(null==(Zm=window.navigator)?void 0:Zm.product))?Lm.useLayoutEffect:Lm.useEffect;function rd(n){var e=Lm.useRef(n);return od((function(){e.current=n}),[n]),e}function ad(n){var e=n.set;return od((function(){return e(new Promise((function(){return null}))),function(){return e(!1)}}),[e]),null}var id=function(n){_(t,n);var e=z(t);function t(){var n;y(this,t);for(var o=arguments.length,r=new Array(o),a=0;a<o;a++)r[a]=arguments[a];return(n=e.call.apply(e,[this].concat(r))).state={error:!1},n}return b(t,[{key:"componentDidCatch",value:function(n){this.props.set(n)}},{key:"render",value:function(){return this.state.error?null:this.props.children}}]),t}(Lm.Component);id.getDerivedStateFromError=function(){return{error:!0}};var vd="__default";function cd(n){var e="undefined"!==typeof window?window.devicePixelRatio:1;return Array.isArray(n)?Math.min(Math.max(n[0],e),n[1]):n}var ld=function(n){var e;return null==(e=n.__r3f)?void 0:e.root.getState()},sd={obj:function(n){return n===Object(n)&&!sd.arr(n)&&"function"!==typeof n},fun:function(n){return"function"===typeof n},str:function(n){return"string"===typeof n},num:function(n){return"number"===typeof n},boo:function(n){return"boolean"===typeof n},und:function(n){return void 0===n},arr:function(n){return Array.isArray(n)},equ:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=t.arrays,r=void 0===o?"shallow":o,a=t.objects,i=void 0===a?"reference":a,v=t.strict,c=void 0===v||v;if(typeof n!==typeof e||!!n!==!!e)return!1;if(sd.str(n)||sd.num(n))return n===e;var l=sd.obj(n);if(l&&"reference"===i)return n===e;var s,u=sd.arr(n);if(u&&"reference"===r)return n===e;if((u||l)&&n===e)return!0;for(s in n)if(!(s in e))return!1;for(s in c?e:n)if(n[s]!==e[s])return!1;if(sd.und(s)){if(u&&0===n.length&&0===e.length)return!0;if(l&&0===Object.keys(n).length&&0===Object.keys(e).length)return!0;if(n!==e)return!1}return!0}};function ud(n){var e={nodes:{},materials:{}};return n&&n.traverse((function(n){n.name&&(e.nodes[n.name]=n),n.material&&!e.materials[n.material.name]&&(e.materials[n.material.name]=n.material)})),e}function fd(n,e){var t=n;return(null!=e&&e.primitive||!t.__r3f)&&(t.__r3f=u({type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null},e)),n}function pd(n,e){var t=n;if(e.includes("-")){var o=e.split("-"),r=o.pop();return t=o.reduce((function(n,e){return n[e]}),n),{target:t,key:r}}return{target:t,key:e}}var md=/-\d+$/;function dd(n,e,t){if(sd.str(t)){if(md.test(t)){var o=pd(n,t.replace(md,"")),r=o.target,a=o.key;Array.isArray(r[a])||(r[a]=[])}var i=pd(n,t),v=i.target,c=i.key;e.__r3f.previousAttach=v[c],v[c]=e}else e.__r3f.previousAttach=t(n,e)}function hd(n,e,t){var o,r;if(sd.str(t)){var a=pd(n,t),i=a.target,v=a.key,c=e.__r3f.previousAttach;void 0===c?delete i[v]:i[v]=c}else null==(o=e.__r3f)||null==o.previousAttach||o.previousAttach(n,e);null==(r=e.__r3f)||delete r.previousAttach}function xd(n,e){e.children,e.key,e.ref;var t,r=o(e,Qm),a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=(a.children,a.key,a.ref,o(a,Jm)),v=arguments.length>3&&void 0!==arguments[3]&&arguments[3],l=null!=(t=null==n?void 0:n.__r3f)?t:{},s=Object.entries(r),f=[];if(v)for(var p=Object.keys(i),m=0;m<p.length;m++)r.hasOwnProperty(p[m])||s.unshift([p[m],vd+"remove"]);s.forEach((function(e){var t,o=c(e,2),a=o[0],v=o[1];if((null==(t=n.__r3f)||!t.primitive||"object"!==a)&&!sd.equ(v,i[a])){if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(a))return f.push([a,v,!0,[]]);var l=[];for(var s in a.includes("-")&&(l=a.split("-")),f.push([a,v,!1,l]),r){var u=r[s];s.startsWith("".concat(a,"-"))&&f.push([s,u,!1,s.split("-")])}}}));var d=u({},r);return l.memoizedProps&&l.memoizedProps.args&&(d.args=l.memoizedProps.args),l.memoizedProps&&l.memoizedProps.attach&&(d.attach=l.memoizedProps.attach),{memoized:d,changes:f}}function yd(n,e){var t,o,a,l,s,u=null!=(t=n.__r3f)?t:{},f=u.root,p=null!=(o=null==f||null==f.getState?void 0:f.getState())?o:{},m=(l=e)&&l.memoized&&l.changes?e:xd(n,e),y=m.memoized,g=m.changes,b=u.eventCount;n.__r3f&&(n.__r3f.memoizedProps=y);for(var _=0;_<g.length;_++){var U,w=c(g[_],4),S=w[0],M=w[1],z=w[2],k=w[3],C=n,T=C[S];if(k.length&&(T=k.reduce((function(n,e){return n[e]}),n),!T||!T.set)){var R=k.reverse(),D=r(s=R)||h(s)||i(s)||v(),P=D[0];C=D.slice(1).reverse().reduce((function(n,e){return n[e]}),n),S=P}if(M===vd+"remove")if(T&&T.constructor)M=d(T.constructor,x(null!=(U=y.args)?U:[]));else if(C.constructor){var F,j=d(C.constructor,x(null!=(F=C.__r3f.memoizedProps.args)?F:[]));M=j[T],j.dispose&&j.dispose()}else M=0;if(z)M?u.handlers[S]=M:delete u.handlers[S],u.eventCount=Object.keys(u.handlers).length;else if(T&&T.set&&(T.copy||T instanceof Sr)){var I;if(Array.isArray(M))T.fromArray?T.fromArray(M):(I=T).set.apply(I,x(M));else if(T.copy&&M&&M.constructor&&T.constructor.name===M.constructor.name)T.copy(M);else if(void 0!==M){var E=T instanceof wo;!E&&T.setScalar?T.setScalar(M):T instanceof Sr&&M instanceof Sr?T.mask=M.mask:T.set(M);0}}else C[S]=M,!p.linear&&C[S]instanceof Co&&(C[S].encoding=ct);gd(n)}if(u.parent&&p.internal&&n.raycast&&b!==u.eventCount){var O=p.internal.interaction.indexOf(n);O>-1&&p.internal.interaction.splice(O,1),u.eventCount&&p.internal.interaction.push(n)}return g.length&&null!=(a=n.__r3f)&&a.parent&&bd(n),n}function gd(n){var e,t,o=null==(e=n.__r3f)||null==(t=e.root)||null==t.getState?void 0:t.getState();o&&0===o.internal.frames&&o.invalidate()}function bd(n){null==n.onUpdate||n.onUpdate(n)}function _d(n,e){n.manual||(td(n)?(n.left=e.width/-2,n.right=e.width/2,n.top=e.height/2,n.bottom=e.height/-2):n.aspect=e.width/e.height,n.updateProjectionMatrix(),n.updateMatrixWorld())}function Ud(n,e,t){var o=t.pop(),r=t.reduce((function(n,e){return n[e]}),n);return r[o]=e}function wd(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function Sd(n,e,t,o){var r=t.get(e);r&&(t.delete(e),0===t.size&&(n.delete(o),r.target.releasePointerCapture(o)))}function Md(n){function e(n){return n.filter((function(n){return["Move","Over","Enter","Out","Leave"].some((function(e){var t;return null==(t=n.__r3f)?void 0:t.handlers["onPointer"+e]}))}))}function t(e){var t,o=n.getState().internal,r=f(o.hovered.values());try{var a=function(){var n=t.value;if(!e.length||!e.find((function(e){return e.object===n.object&&e.index===n.index&&e.instanceId===n.instanceId}))){var r=n.eventObject.__r3f,a=null==r?void 0:r.handlers;if(o.hovered.delete(wd(n)),null!=r&&r.eventCount){var i=u(u({},n),{},{intersections:e});null==a.onPointerOut||a.onPointerOut(i),null==a.onPointerLeave||a.onPointerLeave(i)}}};for(r.s();!(t=r.n()).done;)a()}catch(i){r.e(i)}finally{r.f()}}function o(n,e){for(var t=0;t<e.length;t++){var o=e[t].__r3f;null==o||null==o.handlers.onPointerMissed||o.handlers.onPointerMissed(n)}}return{handlePointer:function(r){switch(r){case"onPointerLeave":case"onPointerCancel":return function(){return t([])};case"onLostPointerCapture":return function(e){var o=n.getState().internal;"pointerId"in e&&o.capturedMap.has(e.pointerId)&&(o.capturedMap.delete(e.pointerId),t([]))}}return function(a){var i=n.getState(),v=i.onPointerMissed,c=i.internal;c.lastEvent.current=a;var l="onPointerMove"===r,s="onClick"===r||"onContextMenu"===r||"onDoubleClick"===r,p=function(e,t){for(var o=n.getState(),r=new Set,a=[],i=t?t(o.internal.interaction):o.internal.interaction,v=0;v<i.length;v++){var c=ld(i[v]);c&&(c.raycaster.camera=void 0)}o.previousRoot||null==o.events.compute||o.events.compute(e,o);var l=i.flatMap((function(n){var t,o=ld(n);return o&&o.events.enabled&&null!==o.raycaster.camera?(void 0===o.raycaster.camera&&(null==o.events.compute||o.events.compute(e,o,null==(t=o.previousRoot)?void 0:t.getState()),void 0===o.raycaster.camera&&(o.raycaster.camera=null)),o.raycaster.camera?o.raycaster.intersectObject(n,!0):[]):[]})).sort((function(n,e){var t=ld(n.object),o=ld(e.object);return t&&o&&o.events.priority-t.events.priority||n.distance-e.distance})).filter((function(n){var e=wd(n);return!r.has(e)&&(r.add(e),!0)}));o.events.filter&&(l=o.events.filter(l,o));var s,p=f(l);try{for(p.s();!(s=p.n()).done;)for(var m=s.value,d=m.object;d;){var h;null!=(h=d.__r3f)&&h.eventCount&&a.push(u(u({},m),{},{eventObject:d})),d=d.parent}}catch(b){p.e(b)}finally{p.f()}if("pointerId"in e&&o.internal.capturedMap.has(e.pointerId)){var x,y=f(o.internal.capturedMap.get(e.pointerId).values());try{for(y.s();!(x=y.n()).done;){var g=x.value;r.has(wd(g.intersection))||a.push(g.intersection)}}catch(b){y.e(b)}finally{y.f()}}return a}(a,l?e:void 0),m=s?function(e){var t=n.getState().internal,o=e.offsetX-t.initialClick[0],r=e.offsetY-t.initialClick[1];return Math.round(Math.sqrt(o*o+r*r))}(a):0;"onPointerDown"===r&&(c.initialClick=[a.offsetX,a.offsetY],c.initialHits=p.map((function(n){return n.eventObject}))),s&&!p.length&&m<=2&&(o(a,c.interaction),v&&v(a)),l&&t(p),function(e,o,r,a){var i=n.getState();e.length&&function(){var n,v={stopped:!1},c=f(e);try{var l=function(){var c=n.value,l=ld(c.object)||i,s=l.raycaster,f=l.pointer,p=l.camera,m=l.internal,d=new Oo(f.x,f.y,0).unproject(p),h=function(n){var e,t;return null!=(e=null==(t=m.capturedMap.get(n))?void 0:t.has(c.eventObject))&&e},y=function(n){var e={intersection:c,target:o.target};m.capturedMap.has(n)?m.capturedMap.get(n).set(c.eventObject,e):m.capturedMap.set(n,new Map([[c.eventObject,e]])),o.target.setPointerCapture(n)},g=function(n){var e=m.capturedMap.get(n);e&&Sd(m.capturedMap,c.eventObject,e,n)},b={};for(var _ in o){var U=o[_];"function"!==typeof U&&(b[_]=U)}var w=u(u(u({},c),b),{},{pointer:f,intersections:e,stopped:v.stopped,delta:r,unprojectedPoint:d,ray:s.ray,camera:p,stopPropagation:function(){var n="pointerId"in o&&m.capturedMap.get(o.pointerId);if((!n||n.has(c.eventObject))&&(w.stopped=v.stopped=!0,m.hovered.size&&Array.from(m.hovered.values()).find((function(n){return n.eventObject===c.eventObject})))){var r=e.slice(0,e.indexOf(c));t([].concat(x(r),[c]))}},target:{hasPointerCapture:h,setPointerCapture:y,releasePointerCapture:g},currentTarget:{hasPointerCapture:h,setPointerCapture:y,releasePointerCapture:g},nativeEvent:o});if(a(w),!0===v.stopped)return"break"};for(c.s();!(n=c.n()).done&&"break"!==l(););}catch(s){c.e(s)}finally{c.f()}}()}(p,a,m,(function(n){var e=n.eventObject,t=e.__r3f,i=null==t?void 0:t.handlers;if(null!=t&&t.eventCount)if(l){if(i.onPointerOver||i.onPointerEnter||i.onPointerOut||i.onPointerLeave){var v=wd(n),u=c.hovered.get(v);u?u.stopped&&n.stopPropagation():(c.hovered.set(v,n),null==i.onPointerOver||i.onPointerOver(n),null==i.onPointerEnter||i.onPointerEnter(n))}null==i.onPointerMove||i.onPointerMove(n)}else{var f=i[r];f?s&&!c.initialHits.includes(e)||(o(a,c.interaction.filter((function(n){return!c.initialHits.includes(n)}))),f(n)):s&&c.initialHits.includes(e)&&o(a,c.interaction.filter((function(n){return!c.initialHits.includes(n)})))}}))}}}}var zd={};var kd,Cd=function(n){return!(null==n||!n.render)},Td=Lm.createContext(null);function Rd(n,e){var t={callback:n};return e.add(t),function(){e.delete(t)}}var Dd,Pd,Fd=new Set,jd=new Set,Id=new Set,Ed=function(n){return Rd(n,Fd)};function Od(n,e){if(n.size){var t,o=f(n.values());try{for(o.s();!(t=o.n()).done;){(0,t.value.callback)(e)}}catch(r){o.e(r)}finally{o.f()}}}function Ld(n,e){switch(n){case"before":return Od(Fd,e);case"after":return Od(jd,e);case"tail":return Od(Id,e)}}function Ad(n,e,t){var o=e.clock.getDelta();for("never"===e.frameloop&&"number"===typeof n&&(o=n-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=n),Dd=e.internal.subscribers,kd=0;kd<Dd.length;kd++)(Pd=Dd[kd]).ref.current(Pd.store.getState(),o,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),"always"===e.frameloop?1:e.internal.frames}function Gd(){var n=Lm.useContext(Td);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function Nd(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(n){return n},e=arguments.length>1?arguments[1]:void 0;return Gd()(n,e)}function Bd(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=Gd(),o=t.getState().internal.subscribe,r=rd(n);return od((function(){return o(r,e,t)}),[e,o,t]),null}function qd(n,e){return function(t){var o=new t;n&&n(o);for(var r=arguments.length,a=new Array(r>1?r-1:0),i=1;i<r;i++)a[i-1]=arguments[i];return Promise.all(a.map((function(n){return new Promise((function(t,r){return o.load(n,(function(n){n.scene&&Object.assign(n,ud(n.scene)),t(n)}),e,(function(e){return r(new Error("Could not load ".concat(n,": ").concat(e.message,")")))}))}))})))}}function Vd(n,e,t,o){var r=Array.isArray(e)?e:[e],a=function(n,e,t){return Xm(n,e,!1,t)}(qd(t,o),[n].concat(x(r)),{equal:sd.equ});return Array.isArray(e)?a:a[0]}Vd.preload=function(n,e,t){var o=Array.isArray(e)?e:[e];return function(n,e,t){Xm(n,e,!0,t)}(qd(t),[n].concat(x(o)))},Vd.clear=function(n,e){var t=Array.isArray(e)?e:[e];return function(n){if(void 0===n||0===n.length)Hm.splice(0,Hm.length);else{var e=Hm.find((function(e){return Wm(n,e.keys,e.equal)}));if(e){var t=Hm.indexOf(e);-1!==t&&Hm.splice(t,1)}}}([n].concat(x(t)))};var Wd=new Map,Hd=function(n){var e,t,o,r=!1;function a(i){t=requestAnimationFrame(a),r=!0,e=0,Ld("before",i);var v,c=f(n.values());try{for(c.s();!(v=c.n()).done;){var l,s=v.value;!(o=s.store.getState()).internal.active||!("always"===o.frameloop||o.internal.frames>0)||null!=(l=o.gl.xr)&&l.isPresenting||(e+=Ad(i,o))}}catch(u){c.e(u)}finally{c.f()}if(Ld("after",i),0===e)return Ld("tail",i),r=!1,cancelAnimationFrame(t)}return{loop:a,invalidate:function e(t){var o,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(!t)return n.forEach((function(n){return e(n.store.getState())}),i);null!=(o=t.gl.xr)&&o.isPresenting||!t.internal.active||"never"===t.frameloop||(t.internal.frames=Math.min(60,t.internal.frames+i),r||(r=!0,requestAnimationFrame(a)))},advance:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(t&&Ld("before",e),o)Ad(e,o,r);else{var a,i=f(n.values());try{for(i.s();!(a=i.n()).done;){var v=a.value;Ad(e,v.store.getState())}}catch(c){i.e(c)}finally{i.f()}}t&&Ld("after",e)}}}(Wd),Xd=Hd.invalidate,Yd=Hd.advance,Zd=function(n,e){function t(n,e,t){var r,a=e.args,i=void 0===a?[]:a,v=e.attach,c=o(e,Km),l="".concat(n[0].toUpperCase()).concat(n.slice(1));if("primitive"===n){if(void 0===c.object)throw new Error("R3F: Primitives without 'object' are invalid!");r=fd(c.object,{type:n,root:t,attach:v,primitive:!0})}else{var s=zd[l];if(!s)throw new Error("R3F: ".concat(l," is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively"));if(!Array.isArray(i))throw new Error("R3F: The args prop must be an array!");r=fd(d(s,x(i)),{type:n,root:t,attach:v,memoizedProps:{args:i}})}return void 0===r.__r3f.attach&&(r instanceof ga?r.__r3f.attach="geometry":r instanceof Jr&&(r.__r3f.attach="material")),"inject"!==l&&yd(r,c),r}function r(n,e){var t,o,r=!1;e&&(null!=(t=e.__r3f)&&t.attach?dd(n,e,e.__r3f.attach):e.isObject3D&&n.isObject3D&&(n.add(e),r=!0),r||null==(o=n.__r3f)||o.objects.push(e),e.__r3f||fd(e,{}),e.__r3f.parent=n,bd(e),gd(e))}function a(n,e,t){var o=!1;if(e){var r,a;if(null!=(r=e.__r3f)&&r.attach)dd(n,e,e.__r3f.attach);else if(e.isObject3D&&n.isObject3D){e.parent=n,e.dispatchEvent({type:"added"});var i=n.children.filter((function(n){return n!==e})),v=i.indexOf(t);n.children=[].concat(x(i.slice(0,v)),[e],x(i.slice(v))),o=!0}o||null==(a=n.__r3f)||a.objects.push(e),e.__r3f||fd(e,{}),e.__r3f.parent=n,bd(e),gd(e)}}function i(n,e){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n&&x(n).forEach((function(n){return v(e,n,t)}))}function v(n,e,t){if(e){var o,r,a;if(e.__r3f&&(e.__r3f.parent=null),null!=(o=n.__r3f)&&o.objects&&(n.__r3f.objects=n.__r3f.objects.filter((function(n){return n!==e}))),null!=(r=e.__r3f)&&r.attach)hd(n,e,e.__r3f.attach);else if(e.isObject3D&&n.isObject3D){var v;n.remove(e),null!=(v=e.__r3f)&&v.root&&function(n,e){var t=n.getState().internal;t.interaction=t.interaction.filter((function(n){return n!==e})),t.initialHits=t.initialHits.filter((function(n){return n!==e})),t.hovered.forEach((function(n,o){n.eventObject!==e&&n.object!==e||t.hovered.delete(o)})),t.capturedMap.forEach((function(n,o){Sd(t.capturedMap,e,n,o)}))}(e.__r3f.root,e)}var c,l=null==(a=e.__r3f)?void 0:a.primitive,s=void 0===t?null!==e.dispose&&!l:t;if(!l)i(null==(c=e.__r3f)?void 0:c.objects,e,s),i(e.children,e,s);e.__r3f&&(delete e.__r3f.root,delete e.__r3f.objects,delete e.__r3f.handlers,delete e.__r3f.memoizedProps,l||delete e.__r3f),s&&e.dispose&&"Scene"!==e.type&&(0,Vm.unstable_scheduleCallback)(Vm.unstable_IdlePriority,(function(){try{e.dispose()}catch(n){}})),gd(n)}}var l=function(){return console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.")};return{reconciler:qm()({createInstance:t,removeChild:v,appendChild:r,appendInitialChild:r,insertBefore:a,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:function(n,e){if(e){var t=n.getState().scene;t.__r3f&&(t.__r3f.root=n,r(t,e))}},removeChildFromContainer:function(n,e){e&&v(n.getState().scene,e)},insertInContainerBefore:function(n,e,t){if(e&&t){var o=n.getState().scene;o.__r3f&&a(o,e,t)}},getRootHostContext:function(){return null},getChildHostContext:function(n){return n},finalizeInitialChildren:function(n){var e,t=null!=(e=null==n?void 0:n.__r3f)?e:{};return Boolean(t.handlers)},prepareUpdate:function(n,e,t,r){if(n.__r3f.primitive&&r.object&&r.object!==n)return[!0];var a=r.args,i=void 0===a?[]:a,v=(r.children,o(r,$m)),c=t.args,l=void 0===c?[]:c,s=(t.children,o(t,nd));if(!Array.isArray(i))throw new Error("R3F: the args prop must be an array!");if(i.some((function(n,e){return n!==l[e]})))return[!0];var u=xd(n,v,s,!0);return u.changes.length?[!1,u]:null},commitUpdate:function(n,e,o,a,i,l){var s=c(e,2),u=s[0],p=s[1];u?function(n,e,o,a){var i,c=null==(i=n.__r3f)?void 0:i.parent;if(c){var l=t(e,o,n.__r3f.root);if(n.children){var s,u=f(n.children);try{for(u.s();!(s=u.n()).done;){var p=s.value;p.__r3f&&r(l,p)}}catch(m){u.e(m)}finally{u.f()}n.children=n.children.filter((function(n){return!n.__r3f}))}n.__r3f.objects.forEach((function(n){return r(l,n)})),n.__r3f.objects=[],v(c,n),r(c,l),l.raycast&&l.__r3f.eventCount&&l.__r3f.root.getState().internal.interaction.push(l),[a,a.alternate].forEach((function(n){null!==n&&(n.stateNode=l,n.ref&&("function"===typeof n.ref?n.ref(l):n.ref.current=l))}))}}(n,o,i,l):yd(n,p)},commitMount:function(n,e,t,o){var r,a=null!=(r=n.__r3f)?r:{};n.raycast&&a.handlers&&a.eventCount&&n.__r3f.root.getState().internal.interaction.push(n)},getPublicInstance:function(n){return n},prepareForCommit:function(){return null},preparePortalMount:function(n){return fd(n.getState().scene)},resetAfterCommit:function(){},shouldSetTextContent:function(){return!1},clearContainer:function(){return!1},hideInstance:function(n){var e,t=null!=(e=n.__r3f)?e:{},o=t.attach,r=t.parent;o&&r&&hd(r,n,o),n.isObject3D&&(n.visible=!1),gd(n)},unhideInstance:function(n,e){var t,o=null!=(t=n.__r3f)?t:{},r=o.attach,a=o.parent;r&&a&&dd(a,n,r),(n.isObject3D&&null==e.visible||e.visible)&&(n.visible=!0),gd(n)},createTextInstance:l,hideTextInstance:l,unhideTextInstance:l,getCurrentEventPriority:function(){return e?e():Am.DefaultEventPriority},beforeActiveInstanceBlur:function(){},afterActiveInstanceBlur:function(){},detachDeletedInstance:function(){},now:"undefined"!==typeof performance&&sd.fun(performance.now)?performance.now:sd.fun(Date.now)?Date.now:function(){return 0},scheduleTimeout:sd.fun(setTimeout)?setTimeout:void 0,cancelTimeout:sd.fun(clearTimeout)?clearTimeout:void 0}),applyProps:yd}}(0,(function(){var n,e="undefined"!==typeof self&&self||"undefined"!==typeof window&&window;if(!e)return Am.DefaultEventPriority;switch(null==(n=e.event)?void 0:n.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return Am.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return Am.ContinuousEventPriority;default:return Am.DefaultEventPriority}})),Qd=Zd.reconciler,Jd=Zd.applyProps,Kd={objects:"shallow",strict:!1},$d=function(n,e){var t="function"===typeof n?n(e):n;return Cd(t)?t:new jc(u({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0},n))};function nh(n,e){if(e)return e;if(n instanceof HTMLCanvasElement&&n.parentElement){var t=n.parentElement.getBoundingClientRect();return{width:t.width,height:t.height,top:t.top,left:t.left}}return{width:0,height:0,top:0,left:0}}function eh(n){var t=Wd.get(n),r=null==t?void 0:t.fiber,a=null==t?void 0:t.store;t&&console.warn("R3F.createRoot should only be called once!");var i,v="function"===typeof reportError?reportError:console.error,l=a||function(n,e){var t=function(n){var e="function"===typeof n?Gm(n):n,t=function(){var n,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e.getState,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.is,r=c((0,Lm.useReducer)((function(n){return n+1}),0),2)[1],a=e.getState(),i=(0,Lm.useRef)(a),v=(0,Lm.useRef)(t),l=(0,Lm.useRef)(o),s=(0,Lm.useRef)(!1),u=(0,Lm.useRef)();void 0===u.current&&(u.current=t(a));var f=!1;(i.current!==a||v.current!==t||l.current!==o||s.current)&&(n=t(a),f=!o(u.current,n)),Nm((function(){f&&(u.current=n),i.current=a,v.current=t,l.current=o,s.current=!1}));var p=(0,Lm.useRef)(a);Nm((function(){var n=function(){try{var n=e.getState(),t=v.current(n);l.current(u.current,t)||(i.current=n,u.current=t,r())}catch(o){s.current=!0,r()}},t=e.subscribe(n);return e.getState()!==p.current&&n(),t}),[]);var m=f?n:u.current;return(0,Lm.useDebugValue)(m),m};return Object.assign(t,e),t[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");var n=[t,e];return{next:function(){var e=n.length<=0;return{value:n.shift(),done:e}}}},t}((function(t,o){var r=new Oo,a=new Oo,i=new Oo;function v(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o().camera,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o().size,v=t.width,c=t.height,l=t.top,s=t.left,u=v/c;e instanceof Oo?i.copy(e):i.set.apply(i,x(e));var f=n.getWorldPosition(r).distanceTo(i);if(td(n))return{width:v/n.zoom,height:c/n.zoom,top:l,left:s,factor:1,distance:f,aspect:u};var p=n.fov*Math.PI/180,m=2*Math.tan(p/2)*f,d=m*(v/c);return{width:d,height:m,top:l,left:s,factor:v/d,distance:f,aspect:u}}var c=void 0,l=function(n){return t((function(e){return{performance:u(u({},e.performance),{},{current:n})}}))},s=new ao,f={set:t,get:o,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,invalidate:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return n(o(),e)},advance:function(n,t){return e(n,t,o())},legacy:!1,linear:!1,flat:!1,scene:fd(new Ac),controls:null,clock:new Hf,pointer:s,mouse:s,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:function(){var n=o();c&&clearTimeout(c),n.performance.current!==n.performance.min&&l(n.performance.min),c=setTimeout((function(){return l(o().performance.max)}),n.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:v},setEvents:function(n){return t((function(e){return u(u({},e),{},{events:u(u({},e.events),n)})}))},setSize:function(n,e,r,i,c){var l=o().camera,s={width:n,height:e,top:i||0,left:c||0,updateStyle:r};t((function(n){return{size:s,viewport:u(u({},n.viewport),v(l,a,s))}}))},setDpr:function(n){return t((function(e){var t=cd(n);return{viewport:u(u({},e.viewport),{},{dpr:t,initialDpr:e.viewport.initialDpr||t})}}))},setFrameloop:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"always",e=o().clock;e.stop(),e.elapsedTime=0,"never"!==n&&(e.start(),e.elapsedTime=0),t((function(){return{frameloop:n}}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:Lm.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:function(n,e,t){var r=o().internal;return r.priority=r.priority+(e>0?1:0),r.subscribers.push({ref:n,priority:e,store:t}),r.subscribers=r.subscribers.sort((function(n,e){return n.priority-e.priority})),function(){var t=o().internal;null!=t&&t.subscribers&&(t.priority=t.priority-(e>0?1:0),t.subscribers=t.subscribers.filter((function(e){return e.ref!==n})))}}}};return f})),o=t.getState(),r=o.size,a=o.viewport.dpr,i=o.camera;return t.subscribe((function(){var n=t.getState(),e=n.camera,o=n.size,v=n.viewport,c=n.gl,l=n.set;o===r&&v.dpr===a||(r=o,a=v.dpr,_d(e,o),c.setPixelRatio(v.dpr),c.setSize(o.width,o.height,o.updateStyle)),e!==i&&(i=e,l((function(n){return{viewport:u(u({},n.viewport),n.viewport.getCurrentViewport(e))}})))})),t.subscribe((function(e){return n(e)})),t}(Xd,Yd),s=r||Qd.createContainer(l,Am.ConcurrentRoot,null,!1,null,"",v,null);t||Wd.set(n,{fiber:s,store:l});var f=!1;return{configure:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.gl,a=t.size,v=t.events,c=t.onCreated,s=t.shadows,p=void 0!==s&&s,m=t.linear,d=void 0!==m&&m,h=t.flat,x=void 0!==h&&h,y=t.legacy,g=void 0!==y&&y,b=t.orthographic,_=void 0!==b&&b,U=t.frameloop,w=void 0===U?"always":U,S=t.dpr,M=void 0===S?[1,2]:S,z=t.performance,k=t.raycaster,C=t.camera,T=t.onPointerMissed,R=l.getState(),D=R.gl;R.gl||R.set({gl:D=$d(r,n)});var P=R.raycaster;P||R.set({raycaster:P=new Sp});var F=k||{},j=F.params,I=o(F,ed);if(sd.equ(I,P,Kd)||Jd(P,u({},I)),sd.equ(j,P.params,Kd)||Jd(P,{params:u(u({},P.params),j)}),!R.camera){var E=C instanceof Va,O=E?C:_?new di(0,0,0,0,.1,1e3):new Wa(75,0,.1,1e3);E||(O.position.z=5,C&&Jd(O,C),null!=C&&C.rotation||O.lookAt(0,0,0)),R.set({camera:O})}if(!R.xr){var L=function(n,e){var t=l.getState();"never"!==t.frameloop&&Yd(n,!0,t,e)},A=function(){var n=l.getState();n.gl.xr.enabled=n.gl.xr.isPresenting,n.gl.xr.setAnimationLoop(n.gl.xr.isPresenting?L:null),n.gl.xr.isPresenting||Xd(n)},G={connect:function(){var n=l.getState().gl;n.xr.addEventListener("sessionstart",A),n.xr.addEventListener("sessionend",A)},disconnect:function(){var n=l.getState().gl;n.xr.removeEventListener("sessionstart",A),n.xr.removeEventListener("sessionend",A)}};D.xr&&G.connect(),R.set({xr:G})}if(D.shadowMap){var N=sd.boo(p);if(N&&D.shadowMap.enabled!==p||!sd.equ(p,D.shadowMap,Kd)){var q=D.shadowMap.enabled;D.shadowMap.enabled=!!p,N?D.shadowMap.type=B:Object.assign(D.shadowMap,p),q!==D.shadowMap.enabled&&(D.shadowMap.needsUpdate=!0)}}Ud(e,g,["ColorManagement","legacyMode"]);var V=d?vt:ct,W=x?kn:Dn;D.outputEncoding!==V&&(D.outputEncoding=V),D.toneMapping!==W&&(D.toneMapping=W),R.legacy!==g&&R.set((function(){return{legacy:g}})),R.linear!==d&&R.set((function(){return{linear:d}})),R.flat!==x&&R.set((function(){return{flat:x}})),!r||sd.fun(r)||Cd(r)||sd.equ(r,D,Kd)||Jd(D,r),v&&!R.events.handlers&&R.set({events:v(l)}),M&&R.viewport.dpr!==cd(M)&&R.setDpr(M);var H=nh(n,a);return sd.equ(H,R.size,Kd)||R.setSize(H.width,H.height,H.updateStyle,H.top,H.left),R.frameloop!==w&&R.setFrameloop(w),R.onPointerMissed||R.set({onPointerMissed:T}),z&&!sd.equ(z,R.performance,Kd)&&R.set((function(n){return{performance:u(u({},n.performance),z)}})),i=c,f=!0,this},render:function(e){return f||this.configure(),Qd.updateContainer(Lm.createElement(th,{store:l,children:e,onCreated:i,rootElement:n}),s,null,(function(){})),l},unmount:function(){oh(n)}}}function th(n){var e=n.store,t=n.children,o=n.onCreated,r=n.rootElement;return od((function(){var n=e.getState();n.set((function(n){return{internal:u(u({},n.internal),{},{active:!0})}})),o&&o(n),e.getState().events.connected||null==n.events.connect||n.events.connect(r)}),[]),Lm.createElement(Td.Provider,{value:e},t)}function oh(n,e){var t=Wd.get(n),o=null==t?void 0:t.fiber;if(o){var r=null==t?void 0:t.store.getState();r&&(r.internal.active=!1),Qd.updateContainer(null,o,null,(function(){r&&setTimeout((function(){try{var t,o,a,i;null==r.events.disconnect||r.events.disconnect(),null==(t=r.gl)||null==(o=t.renderLists)||null==o.dispose||o.dispose(),null==(a=r.gl)||null==a.forceContextLoss||a.forceContextLoss(),null!=(i=r.gl)&&i.xr&&r.xr.disconnect(),function(n){for(var e in n.dispose&&"Scene"!==n.type&&n.dispose(),n)null==e.dispose||e.dispose(),delete n[e]}(r),Wd.delete(n),e&&e(n)}catch(v){}}),500)}))}}Qd.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:Lm.version});Lm.unstable_act;function rh(){return rh=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o])}return n},rh.apply(this,arguments)}var ah=t(494),ih=t.n(ah);function vh(n){var e=void 0===n?{debounce:0,scroll:!1,offsetSize:!1}:n,t=e.debounce,o=e.scroll,r=e.polyfill,a=e.offsetSize,i=r||("undefined"===typeof window?b((function n(){y(this,n)})):window.ResizeObserver);if(!i)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");var v=c((0,Lm.useState)({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),2),l=v[0],s=v[1],u=(0,Lm.useRef)({element:null,scrollContainers:null,resizeObserver:null,lastBounds:l}),f=t?"number"===typeof t?t:t.scroll:null,p=t?"number"===typeof t?t:t.resize:null,m=(0,Lm.useRef)(!1);(0,Lm.useEffect)((function(){return m.current=!0,function(){m.current=!1}}));var d=c((0,Lm.useMemo)((function(){var n=function(){if(u.current.element){var n=u.current.element.getBoundingClientRect(),e={left:n.left,top:n.top,width:n.width,height:n.height,bottom:n.bottom,right:n.right,x:n.x,y:n.y};u.current.element instanceof HTMLElement&&a&&(e.height=u.current.element.offsetHeight,e.width=u.current.element.offsetWidth),Object.freeze(e),m.current&&!sh(u.current.lastBounds,e)&&s(u.current.lastBounds=e)}};return[n,p?ih()(n,p):n,f?ih()(n,f):n]}),[s,a,f,p]),3),h=d[0],x=d[1],g=d[2];function _(){u.current.scrollContainers&&(u.current.scrollContainers.forEach((function(n){return n.removeEventListener("scroll",g,!0)})),u.current.scrollContainers=null),u.current.resizeObserver&&(u.current.resizeObserver.disconnect(),u.current.resizeObserver=null)}function U(){u.current.element&&(u.current.resizeObserver=new i(g),u.current.resizeObserver.observe(u.current.element),o&&u.current.scrollContainers&&u.current.scrollContainers.forEach((function(n){return n.addEventListener("scroll",g,{capture:!0,passive:!0})})))}var w,S,M;return w=g,S=Boolean(o),(0,Lm.useEffect)((function(){if(S){var n=w;return window.addEventListener("scroll",n,{capture:!0,passive:!0}),function(){window.removeEventListener("scroll",n,!0)}}}),[w,S]),M=x,(0,Lm.useEffect)((function(){var n=M;return window.addEventListener("resize",n),function(){window.removeEventListener("resize",n)}}),[M]),(0,Lm.useEffect)((function(){_(),U()}),[o,g,x]),(0,Lm.useEffect)((function(){return _}),[]),[function(n){n&&n!==u.current.element&&(_(),u.current.element=n,u.current.scrollContainers=ch(n),U())},l,h]}function ch(n){var e=[];if(!n||n===document.body)return e;var t=window.getComputedStyle(n);return[t.overflow,t.overflowX,t.overflowY].some((function(n){return"auto"===n||"scroll"===n}))&&e.push(n),[].concat(e,x(ch(n.parentElement)))}var lh=["x","y","top","bottom","left","right","width","height"],sh=function(n,e){return lh.every((function(t){return n[t]===e[t]}))},uh=Object.defineProperty,fh=Object.defineProperties,ph=Object.getOwnPropertyDescriptors,mh=Object.getOwnPropertySymbols,dh=Object.prototype.hasOwnProperty,hh=Object.prototype.propertyIsEnumerable,xh=function(n,e,t){return e in n?uh(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t},yh=function(n,e){for(var t in e||(e={}))dh.call(e,t)&&xh(n,t,e[t]);if(mh){var o,r=f(mh(e));try{for(r.s();!(o=r.n()).done;){t=o.value;hh.call(e,t)&&xh(n,t,e[t])}}catch(a){r.e(a)}finally{r.f()}}return n};function gh(n,e,t){if(n){if(!0===t(n))return n;for(var o=e?n.return:n.child;o;){var r=gh(o,e,t);if(r)return r;o=e?null:o.sibling}}}function bh(n){try{return Object.defineProperties(n,{_currentRenderer:{get:function(){return null},set:function(){}},_currentRenderer2:{get:function(){return null},set:function(){}}})}catch(e){return n}}var _h=bh(Lm.createContext(null)),Uh=function(n){_(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return b(t,[{key:"render",value:function(){return Lm.createElement(_h.Provider,{value:this._reactInternals},this.props.children)}}]),t}(Lm.Component),wh=Lm.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Sh=wh.ReactCurrentOwner,Mh=wh.ReactCurrentDispatcher;function zh(){var n=Lm.useContext(_h);if(!n)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");var e=Lm.useId(),t=Lm.useMemo((function(){var t;return null!=(t=Sh.current)?t:gh(n,!1,(function(n){for(var t=n.memoizedState;t;){if(t.memoizedState===e)return!0;t=t.next}}))}),[n,e]);return t}var kh=[],Ch=new WeakMap;function Th(){var n,e=zh();kh.splice(0,kh.length),gh(e,!0,(function(n){var e,t=null==(e=n.type)?void 0:e._context;t&&t!==_h&&kh.push(bh(t))}));var t,o=f(kh);try{for(o.s();!(t=o.n()).done;){var r=t.value,a=null==(n=Mh.current)?void 0:n.readContext(r);Ch.set(r,a)}}catch(i){o.e(i)}finally{o.f()}return Lm.useMemo((function(){return kh.reduce((function(n,e){return function(t){return Lm.createElement(n,null,Lm.createElement(e.Provider,(o=yh({},t),r={value:Ch.get(e)},fh(o,ph(r)))));var o,r}}),(function(n){return Lm.createElement(Uh,yh({},n))}))}),[])}var Rh=["children","fallback","resize","style","gl","events","eventSource","eventPrefix","shadows","linear","flat","legacy","orthographic","frameloop","dpr","performance","raycaster","camera","onPointerMissed","onCreated"],Dh={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function Ph(n){var e=Md(n).handlePointer;return{priority:1,enabled:!0,compute:function(n,e,t){e.pointer.set(n.offsetX/e.size.width*2-1,-n.offsetY/e.size.height*2+1),e.raycaster.setFromCamera(e.pointer,e.camera)},connected:void 0,handlers:Object.keys(Dh).reduce((function(n,t){return u(u({},n),{},l({},t,e(t)))}),{}),connect:function(e){var t,o=n.getState(),r=o.set,a=o.events;null==a.disconnect||a.disconnect(),r((function(n){return{events:u(u({},n.events),{},{connected:e})}})),Object.entries(null!=(t=a.handlers)?t:[]).forEach((function(n){var t=c(n,2),o=t[0],r=t[1],a=c(Dh[o],2),i=a[0],v=a[1];e.addEventListener(i,r,{passive:v})}))},disconnect:function(){var e,t=n.getState(),o=t.set,r=t.events;r.connected&&(Object.entries(null!=(e=r.handlers)?e:[]).forEach((function(n){var e=c(n,2),t=e[0],o=e[1];if(r&&r.connected instanceof HTMLElement){var a=c(Dh[t],1)[0];r.connected.removeEventListener(a,o)}})),o((function(n){return{events:u(u({},n.events),{},{connected:void 0})}})))}}}var Fh=Lm.forwardRef((function(n,t){var r=n.children,a=n.fallback,i=n.resize,v=n.style,l=n.gl,s=n.events,f=void 0===s?Ph:s,p=n.eventSource,m=n.eventPrefix,d=n.shadows,h=n.linear,x=n.flat,y=n.legacy,g=n.orthographic,b=n.frameloop,_=n.dpr,U=n.performance,w=n.raycaster,S=n.camera,M=n.onPointerMissed,z=n.onCreated,k=o(n,Rh);Lm.useMemo((function(){return n=e,void(zd=u(u({},zd),n));var n}),[]);var C=Th(),T=c(vh(u({scroll:!0,debounce:{scroll:50,resize:0}},i)),2),R=T[0],D=T[1],P=Lm.useRef(null),F=Lm.useRef(null),j=c(Lm.useState(null),2),I=j[0],E=j[1];Lm.useImperativeHandle(t,(function(){return P.current}));var O=rd(M),L=c(Lm.useState(!1),2),A=L[0],G=L[1],N=c(Lm.useState(!1),2),B=N[0],q=N[1];if(A)throw A;if(B)throw B;var V=Lm.useRef(null);D.width>0&&D.height>0&&I&&(V.current||(V.current=eh(I)),V.current.configure({gl:l,events:f,shadows:d,linear:h,flat:x,legacy:y,orthographic:g,frameloop:b,dpr:_,performance:U,raycaster:w,camera:S,size:D,onPointerMissed:function(){return null==O.current?void 0:O.current.apply(O,arguments)},onCreated:function(n){var e;null==n.events.connect||n.events.connect(p?(e=p)&&e.hasOwnProperty("current")?p.current:p:F.current),m&&n.setEvents({compute:function(n,e){var t=n[m+"X"],o=n[m+"Y"];e.pointer.set(t/e.size.width*2-1,-o/e.size.height*2+1),e.raycaster.setFromCamera(e.pointer,e.camera)}}),null==z||z(n)}}),V.current.render(Lm.createElement(C,null,Lm.createElement(id,{set:q},Lm.createElement(Lm.Suspense,{fallback:Lm.createElement(ad,{set:G})},r))))),od((function(){E(P.current)}),[]),Lm.useEffect((function(){if(I)return function(){return oh(I)}}),[I]);var W=p?"none":"auto";return Lm.createElement("div",rh({ref:F,style:u({position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:W},v)},k),Lm.createElement("div",{ref:R,style:{width:"100%",height:"100%"}},Lm.createElement("canvas",{ref:P,style:{display:"block"}},a)))})),jh=Lm.forwardRef((function(n,e){return Lm.createElement(Uh,null,Lm.createElement(Fh,rh({},n,{ref:e})))})),Ih=t(250),Eh=function(n){var e,t=new Set,o=function(n,o){var r="function"===typeof n?n(e):n;if(!Object.is(r,e)){var a=e;e=(null!=o?o:"object"!==typeof r)?r:Object.assign({},e,r),t.forEach((function(n){return n(e,a)}))}},r=function(){return e},a={setState:o,getState:r,subscribe:function(n){return t.add(n),function(){return t.delete(n)}},destroy:function(){console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),t.clear()}};return e=n(o,r,a),a},Oh=function(n){return n?Eh(n):Eh},Lh=t(327).useSyncExternalStoreWithSelector,Ah=!1;var Gh=function(n){"function"!==typeof n&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");var e="function"===typeof n?Oh(n):n,t=function(n,t){return function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.getState,t=arguments.length>2?arguments[2]:void 0;t&&!Ah&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),Ah=!0);var o=Lh(n.subscribe,n.getState,n.getServerState||n.getState,e,t);return(0,Lm.useDebugValue)(o),o}(e,n,t)};return Object.assign(t,e),t},Nh=function(n){return n?Gh(n):Gh},Bh=Nh((function(n,e){return{currentShader:Math.floor(600*Math.random())+1,information:!1,total:0,songPlaying:!1,songStartTime:0,songStatus:"off",startSong:function(){return n((function(n){return{songStatus:"playing"}})),n((function(n){return{songStartTime:Date.now()}})),n((function(n){return{songPlaying:!0}})),e().songStartTime},getSongTime:function(){return e().songStartTime},setSongOn:function(){},setSongOff:function(){n((function(n){return{songStartTime:0}}))},setCurrentShader:function(e){n((function(n){return{currentShader:e}}))},activateInformation:function(){n((function(n){return{information:!0}}))},deactivateInformation:function(){n((function(n){return{information:!1}}))},setTotal:function(e){n((function(n){return{total:e}}))}}})),qh="\n\n    float sdNumHorizontal(vec2 p)\n    {\n        vec2 newUv = p;\n        newUv.x += 0.125;\n        newUv.y -= 0.25;\n        vec2 uv1 = newUv;\n        vec2 uv2 = newUv;\n        uv1 = Rot(uv1, PI * 0.5);\n        uv1 /= .5;\n        uv1 -= 1.;\n\n        uv2 = Rot(uv2, -PI* .5);\n        uv2 /= .5;\n        uv2 -= 1.;\n        float shape1 = sdEqTriangle(uv1, 0.15);\n        shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n        float shape2 = sdBox(vec2(uv1.x + 0.5, uv1.y+0.75), vec2(0.33, 0.2815));\n        shape2 = 1. - smoothstep(0.1, 0.11, shape2);\n\n        float shape3 = sdEqTriangle(vec2(uv2.x, uv2.y-0.5), 0.15);\n        shape3 = 1. - smoothstep(0.1, 0.11, shape3);\n\n        return shape1 + shape2 + shape3;\n    }\n\n    float sdNumVertical(vec2 p){\n        vec2 newUv = p;\n        newUv.x += 0.125;\n        newUv.y -= 0.25;\n        vec2 uv1 = newUv;\n        vec2 uv3 = newUv;\n        vec2 uv4 = newUv;\n        uv1 = Rot(uv1, PI * 0.5);\n        uv1 /= .5;\n        uv1 -= 1.;\n\n        uv3 = Rot(uv3, PI * 1.5);\n        uv3 /= .5;\n        uv3 -= 1.;\n        uv3.x -= 0.2;\n        uv3.y += 0.1;\n\n        uv4 = Rot(uv4, PI * 1.5);\n        uv4 /= .5;\n        uv4 -= 1.;\n        uv4.y += 0.1;\n        uv4.x -= 0.52;\n\n        float shape1 = sdEqTriangle(vec2(uv1.x + 0.36125, uv1.y-0.01), 0.125);\n        shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n        float shape4 = sdEqTriangle(vec2(uv3.x, uv3.y), 0.14);\n        shape4 = 1. - smoothstep(0.1, 0.11, shape4);\n\n        float shape5 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.35, 0.325));\n        shape5 = 1. - smoothstep(0.1, 0.11, shape5);\n\n        float shape6 = sdEqTriangle(vec2(uv4), 0.14);\n        shape6 = 1. - smoothstep(0.1, 0.11, shape6);\n\n        float tri = ((shape4 + shape6 + shape1 ) );\n        float sq = sdBox(vec2(uv1.x + 0.859, uv1.y +0.442), vec2(0.3));\n        sq = 1. - smoothstep(0.1, 0.11, sq);\n        float shape7 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.3));\n        shape7 = 1. - smoothstep(0.1, 0.11, shape7);\n\n        return tri ;\n    }\n\n    float numNine(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeNine = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triRB;\n\n        return shapeNine;\n    }\n\n    float numEight(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeEight = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeEight;\n    }\n\n    float numSeven(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeSeven = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triR + triRB;\n\n        return shapeSeven;\n    }\n\n    float numSix(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeSix = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeSix;\n    }\n\n    float numFive(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeFive = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeFive;\n    }\n\n    float numFour(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRT = sdEqTriangle(vec2(p3.x + 0.79, p3.y-0.265), 0.14);\n        triRT = 1. - smoothstep(0.1, 0.11, triRT);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float triLT = sdEqTriangle(vec2(p4.x - 0.79, p4.y-0.265), 0.14);\n        triLT = 1. - smoothstep(0.1, 0.11, triLT);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeFour = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triRT + triRB + triLT;\n\n        return shapeFour;\n    }\n\n    float numThree(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeThree = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeThree;\n    }\n\n    float numTwo(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        shapevertical4 *= 0.1;\n        \n        float shapeTwo = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeTwo;\n    }\n\n    float numOne(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRT = sdEqTriangle(vec2(p3.x + 0.79, p3.y-0.265), 0.14);\n        triRT = 1. - smoothstep(0.1, 0.11, triRT);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        \n        float shapeOne = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triR + triRT + triRB;\n\n        return shapeOne;\n    }\n\n    float numZero(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        \n        float shapeZero = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triR + triL;\n\n        return shapeZero;\n    }\n\n    float sdZero(vec2 p)\n    {\n        vec2 p2 = p;\n        p2 *= 4.;\n        vec2 p3 = p2;\n        p3 = Rot(p3, PI);\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float z1 = sdArc(vec2(p2.x - 2., p2.y - 2.4), vec2(a * 0.7, a * 0.7), .36, b * 0.85 );\n        float z2 = sdArc(vec2(p3.x+1., p3.y+0.61), vec2(a * 0.7, a * 0.7), .36, b * 0.85 );\n        z1 = 1. - smoothstep(0.01, 0.02, z1);\n        z2 = 1. - smoothstep(0.01, 0.02, z2);\n        float z3=sdRoundedBox((vec2(p.x+0.088, p.y)), vec2(0.082, 0.275), vec4(0.075));\n        float z4=sdRoundedBox((vec2(p.x-0.088, p.y)), vec2(0.082, 0.275), vec4(0.075));\n        return z1 + z2 + z3 + z4;\n    }\n\n    float sdOne(vec2 p)\n    {\n        p.x -= 0.15;\n        vec2 vUv2 = p;\n        p = p * 2. - 0.5;\n        vUv2 = Rot(vUv2, PI * -0.25);\n        float x1 = sdRoundedBox(vec2(p.x + 0.275, p.y), vec2(0.17, 0.85), vec4(0.1, 0.1, 0.1, 0.1));\n        float x2 = sdRoundedBox(vec2(vUv2.x + 0.24, vUv2.y + 0.05), vec2(0.07, 0.2), vec4(0.1, 0.075, 0.1, 0.075));\n        return x1 + x2;\n    }\n\n    float sdTwo(vec2 p)\n    {\n        p.x += 0.1;\n        vec2 p2 = p;\n        p = p * 2. - 0.5;\n        vec2 p3 = p;\n        p3 = p3 * 2. - 1.;\n        p3.x -= 0.5;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        p3 = Rot(p3, PI * 1.85);\n        float x1 = sdArc(vec2(p3.x - 0.1, p3.y - 0.15), vec2(a * 0.8, a * 0.8), .35, b * 0.84 );\n        x1 = smoothstep(0.01, 0.02, x1);\n        p2 = Rot(p2, PI * -0.22);\n        float x2 = sdRoundedBox(vec2(p2.x - 0.122, p2.y - 0.05), vec2(0.075, 0.35), vec4(0.2, 0.1, 0.1, 0.1));\n        float x3 = sdRoundedBox(vec2(p.x - 0.25, p.y + 0.335), vec2(0.5, 0.155), vec4(0.1, 0.1, 0.1, 0.1));\n        return 1. - x1 + x2 + x3;\n    }\n\n    float sdThree(vec2 p)\n    {\n        p = p * 2. - 0.5;\n        p *= 1.2;\n        p.y += 0.125;\n        p = Rot(p, PI * -0.5);\n        p = p * 2. - 1.;\n        vec2 p2 = p;\n        vec2 p3 = p;\n        p2 = Rot(p2, PI * -0.7);\n        p3 = Rot(p3, PI * -0.7 * 2.);\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n\n        float x1 = sdArc(vec2(p.x, p.y), vec2(a * 0.8, a * 0.8), .45, b * 0.85 );\n        float x2 = sdArc(vec2(p.x + 0.9, p.y), vec2(a * 0.8, a * 0.8), .45, b * 0.85 );\n        float x3 = sdArc(vec2(p2.x - 1.2, p2.y - 0.39), vec2(a * 0.1, a * 0.1), .45, b * 0.85 );\n        float x4 = sdArc(vec2(p3.x - 0.43, p3.y - 1.99), vec2(a * 0.1, a * 0.1), .45, b * 0.85 );\n\n        x1 = 1. - smoothstep(0.01, 0.02, x1);\n        x2 = 1. - smoothstep(0.01, 0.02, x2);\n        x3 = 1. - smoothstep(0.01, 0.02, x3);\n        x4 = 1. - smoothstep(0.01, 0.02, x4);\n\n        return x1 + x2 + x3 + x4;\n    }\n\n    float sdFour(vec2 p)\n    {\n        float f1 = sdRoundedBox(vec2(p.x + 0.125, p.y - 0.09), vec2(0.07, 0.25), vec4(0.075));\n        float f2 = sdRoundedBox(vec2(p.x - 0.05, p.y + 0.), vec2(0.07, 0.425), vec4(0.075));\n        float f3 = sdRoundedBox(vec2(p.x + 0.00125, p.y - 0.0), vec2(0.3, 0.07), vec4(0.075));\n        return f1 + f2 + f3;\n    }\n\n    float sdFive(vec2 p)\n    {\n        p = p * 1.05;\n        p.x -= 0.05;\n        p.y -= 0.02;\n        float f1=sdRoundedBox((vec2(p.x+0.01, p.y-0.17)), vec2(0.275, 0.08), vec4(0.075));\n        float f2=sdRoundedBox((vec2(p.x + 0.03, p.y+0.17)), vec2(0.225, 0.08), vec4(0.075));\n        float f3=sdRoundedBox((vec2(p.x + 0.03, p.y+0.005)), vec2(0.245, 0.08), vec4(0.075));\n        float f4=sdRoundedBox((vec2(p.x+0.112, p.y-0.09)), vec2(0.08, 0.225), vec4(0.075));\n        vec2 p2 = p;\n        p2 = Rot(p2, PI * -0.5);\n        p2 *=4.;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float f5 = sdArc(vec2(p2.x - 2.35, p2.y - 2.09), vec2(a * 0.5, a * 0.5), .36, b * 0.85 );\n        f5 = 1. - smoothstep(0.0, 0.02, f5);\n        return f1 + f2 + f3 + f4 + f5;\n    }\n\n    float sdSix(vec2 p)\n    {\n        vec2 p2 = p;\n        vec2 p4 = p2;\n        p2 *= 4.;\n        vec2 p3 = p2;\n        p3 = Rot(p3, PI);\n        // p4 = Rot(p4, PI * 0.125);\n        p4 *= 4.;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float s1 = sdArc(vec2(p2.x - 2., p2.y - 1.7), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float s2 = sdArc(vec2(p3.x+1., p3.y+0.65), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float s3 = sdArc(vec2(p4.x - 1.945, p4.y - 2.35), vec2(a * 0.4, a * 0.4), .36, b * 0.82 );\n        s1 = 1. - smoothstep(0.01, 0.02, s1);\n        s2 = 1. - smoothstep(0.01, 0.02, s2);\n        s3 = 1. - smoothstep(0.01, 0.02, s3);\n        float s4=sdRoundedBox((vec2(p.x+0.092, p.y-0.035)), vec2(0.0725, 0.275), vec4(0.075));\n        return s1 + s2 + s3 + s4;\n    }\n\n    float sdSeven(vec2 p)\n    {\n        vec2 p2 = p;\n        float s1 = sdRoundedBox((vec2(p.x+0.01, p.y-0.17)), vec2(0.275, 0.08), vec4(0.075));\n        p2 = Rot(p2, PI * -0.127);\n        float s2 = sdRoundedBox((vec2(p2.x-0.016, p2.y+0.001)), vec2(0.08, 0.44), vec4(0.075));\n        return s1 + s2;\n    }\n\n    float sdEight(vec2 p)\n    {\n        p *= 4.;\n        vec2 p2 = p;\n        p2 = Rot(p2, PI);\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float e1 = sdArc(vec2(p.x - 2., p.y - 1.7), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float e2 = sdArc(vec2(p2.x+1., p2.y+0.65), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float e3 = sdArc(vec2(p.x - 2., p.y - 2.45), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float e4 = sdArc(vec2(p2.x+1., p2.y+1.5 * 0.95), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        e1 = 1. - smoothstep(0.01, 0.02, e1);\n        e2 = 1. - smoothstep(0.01, 0.02, e2);\n        e3 = 1. - smoothstep(0.01, 0.02, e3);\n        e4 = 1. - smoothstep(0.01, 0.02, e4);\n        return e1 + e2 + e3 + e4;\n    }\n\n    float sdNine(vec2 p)\n    {\n        p = Rot(p, PI);\n        vec2 p2 = p;\n        vec2 p4 = p2;\n        p2 *= 4.;\n        vec2 p3 = p2;\n        p3 = Rot(p3, PI);\n        // p4 = Rot(p4, PI * 0.125);\n        p4 *= 4.;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float n1 = sdArc(vec2(p2.x - 2., p2.y - 1.7), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float n2 = sdArc(vec2(p3.x+1., p3.y+0.65), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float n3 = sdArc(vec2(p4.x - 1.945, p4.y - 2.35), vec2(a * 0.4, a * 0.4), .36, b * 0.82 );\n        n1 = 1. - smoothstep(0.01, 0.02, n1);\n        n2 = 1. - smoothstep(0.01, 0.02, n2);\n        n3 = 1. - smoothstep(0.01, 0.02, n3);\n        float n4=sdRoundedBox((vec2(p.x+0.092, p.y-0.035)), vec2(0.0725, 0.275), vec4(0.075));\n        return n1 + n2 + n3 + n4;\n    }\n",Vh="\n    // #ifdef GL_ES\n    // precision highp float;\n    // #endif\n\n    precision highp float;\n\n    varying vec2 vUv;\n    #define PI 3.14159265359\n    #define TWO_PI 6.28318530718\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    uniform vec2 u_mouse;\n",Wh="\n//iquilezles.org/articls/distfunctions2d\nfloat sdRoundedBox(vec2 p, vec2 b, vec4 r)\n{\n    //p - point\n    //b - size of box\n    //r - round box - top right, bottom right, top left, bottom left\n    p = p * 2.0 - 1.;\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x = (p.y > 0.0) ? r.x : r.y;\n    vec2 q = abs(p)-b+r.x;\n    float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n    return 1. - smoothstep(0.01, 0.015, v);\n}\n\nfloat sdSpiral(vec2 p, float w, float k)\n{\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float n = floor(0.5/w + (log2(r/w)*k-a)/TWO_PI);\n    float ra = w * exp2((a+TWO_PI * (min(n+0., 0.) - 0.5))/k);\n    float rb = w * exp2((a+TWO_PI * (min(n+1., 0.) - 0.5))/k);\n    float d = min(abs(r-ra), abs(r-rb));\n    float spiral = min(d, length(p + vec2(w, 0.0)));\n    return 1. - smoothstep(0.01, 0.011, spiral);\n}\n\nfloat sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n{\n    //x - thickness\n    float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n    float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n    return (c - a);\n    \n}\n\nfloat sdBoxOutline(vec2 p, vec2 b)\n{\n    //p - point \n    //b -\n    p = p * 2.0 - 1.; \n    vec2 d = abs(p) - b;\n    float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    float y = length(max(d, 0.0)) + min(max(d.x + 0.05, d.y + 0.05), 0.0);\n    // x = 1. - smoothstep(0.01, 0.02, x);\n    // y = 1. - smoothstep(0.01, 0.02, y);\n    return 1.  - smoothstep(0.01, 0.2, y / x);\n}\n\nfloat rect( vec2 vUv, float height, float width)\n{\n    float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.001, vUv.x);\n    float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.001, 1. - vUv.x);\n    float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.001, 1. - vUv.y);\n    float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.001, vUv.y);\n    // return left * right * top * bottom;\n    float x = left * right * top * bottom;\n    // float y = x ;\n    return x;\n}\n\nfloat rectOutline(vec2 vUv, float height, float width)\n{\n    float y = rect(vUv, height, width);\n    float x = rect(vUv, height + 0.01, width + 0.01);\n    return x - y;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    //p - point \n    //b -\n    p = p * 2.0 - 1.; \n    vec2 d = abs(p) - b;\n    float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    return smoothstep(0.01, 0.012, x);\n}\n\nfloat quadraticBezier (float x, vec2 a){\n    // adapted from BEZMATH.PS (1993)\n    // by Don Lancaster, SYNERGETICS Inc. \n    // http://www.tinaja.com/text/bezmath.html\n  \n    float epsilon = 0.00001;\n    a.x = clamp(a.x,0.0,1.0); \n    a.y = clamp(a.y,0.0,1.0); \n    if (a.x == 0.5){\n      a += epsilon;\n    }\n    \n    // solve t from x (an inverse operation)\n    float om2a = 1.0 - 2.0 * a.x;\n    float t = (sqrt(a.x*a.x + om2a*x) - a.x)/om2a;\n    float y = (1.0-2.0*a.y)*(t*t) + (2.0*a.y)*t;\n    return y;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise2D(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat IterateMandelbrot( in vec2 c )\n{\n    const float B = 256.0;\n\n    float n = 0.0;\n    vec2 z  = vec2(0.);\n    for( int i=0; i<120; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c; // z = z\xb2 + c\n        if( dot(z,z)>(B*B) ) break;\n        n += 1.0 * u_time;\n    }\n\n    // float sn = n - log(log(length(z))/log(B))/log(2.0); // smooth iteration count\n    float sn = n - log2(log2(dot(z,z))) + 4.0;  // equivalent optimized smooth iteration count\n    \n    return sn;\n}\n\nfloat plot(vec2 p, float line, float thickness)\n{\n    return smoothstep(line - thickness, line, p.y) -\n           smoothstep(line, line + thickness, p.y);\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    p = p * 2.0 - 1.;\n    float x = length(p) - r;\n    return 1. - smoothstep(0.01, 0.03, x);\n}\n\nfloat sdCircleOutline(vec2 p, float r)\n{\n    p = p * 2.0 - 1.;\n    float x = length(p) - r;\n    float y = length(p) - r + 0.05;\n    float x1 = 1. - smoothstep(0.01, 0.03, x);\n    float y1 = 1. - smoothstep(0.01, 0.03, y);\n    return x1 - y1;\n}\n\nfloat circle(vec2 vUv, float radius)\n{\n    vec2 dist = vUv - vec2(0.5);\n    return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n}\n\nfloat cirOutline(vec2 vUv, float r)\n{\n    vec2 dist = vUv - vec2(0.5);\n    float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n    // float b = 1. - smoothstep(r + 0.01 - ((r + 0.01)), r + 0.01 + ((r + 0.02)), dot(dist, dist) * 4.);\n    float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.01), r + 0.01 + ((r + 0.011) * 0.012), dot(dist, dist) * 4.);\n    return b - a;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n    float v = length(pa - ba * h);\n    return 1. - smoothstep(0.01, 0.015, v);\n}\n\nvec2 Rot(vec2 vUv, float a){\n    vUv -= 0.5;\n    vUv = mat2(cos(a), -sin(a),\n            sin(a), cos(a)) * vUv;\n    vUv += 0.5;\n    return vUv;\n}\n\nfloat ndot(vec2 a, vec2 b)\n{\n    return a.x * b.x - a.y * b.y;\n}\n\nfloat sdRhombus(vec2 p, vec2 b)\n{\n    p = abs(p);\n    float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n    float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n    return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n}\n\nfloat dot2(vec2 a)\n{\n    return dot(a.x, a.y);\n}\n\nfloat trapezoid(vec2 p, float r1, float r2, float he)\n{\n    vec2 k1 = vec2(r2, he);\n    vec2 k2 = vec2(r2-r1, 2.0 * he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x, (p.y<0.)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2 * clamp(dot(k1-p,k2)/dot2(k2), 0., 1.);\n    float s = (cb.x < 0. && ca.y<0.)? -1.: 1.;\n    return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n}\n\nfloat sdEqTriangle(vec2 p, float size)\n{\n    p = p / size;\n    float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1.0/k;\n    if(p.x+k*p.y > 0.)\n    {\n        p = vec2(p.x-k*p.y, -k*p.x-p.y)/2.0; \n    }\n    p.x -= clamp(p.x, -2., 0.);\n    return -length(p) * sign(p.y);\n}\n\nfloat sdEqTriangleOutline(vec2 p, float size)\n{\n    float x = 1. - sdEqTriangle(p, size);\n    float y = 1. - sdEqTriangle(p, size + 0.025);\n    x = smoothstep(0.01, 0.021, x);\n    y = smoothstep(0.01, 0.021, y);\n    return y - x;\n}\n\nfloat sdArc(vec2 p, vec2 sc, float ra, float rb){\n    //sc is arc's aperture\n    p.x = abs(p.x);\n    sc = vec2(sin(sc.x), cos(sc.y));\n    if (sc.y * p.x > sc.x * p.y){\n        return length(p - sc*ra) - rb;\n    }\n    else {\n        return abs(length(p) - ra) - rb;\n    }\n}\n\nfloat sdTriIsosceles(vec2 p, vec2 q)\n{\n    p = Rot(p, PI);\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p,q)/dot(q,q), 0.0, 1.0);\n    vec2 b = p - q * vec2( clamp(p.x/q.x, 0., 1.), 1.);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a,a), s*(p.x*q.y-p.y*q.x)), \n                vec2(dot(b,b), s*(p.y-q.y)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdHexagram(vec2 p, float r)\n{\n    vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n    p -= 2.0 * min(dot(k.yx, p), 0.0) * k.yx;\n    p -= vec2(clamp(p.x, r*k.z, r*k.w), r);\n    return length(p) * sign(p.y);\n}\n\nfloat sdEgg(vec2 p, float ra, float rb)\n{\n    float k = sqrt(3.);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y < 0.0) ? length(vec2(p.x, p.y)) - r :\n            (k * (p.x + r) < p.y) ? length(vec2(p.x, p.y - k * r)) :\n            length(vec2(p.x + r, p.y)) -2.0 * r) - rb;\n}\n\nfloat sdPolygon(vec2 p, int sides, float scale)\n{\n    p = p * 2. - 1.;\n    float angle = atan(p.x, p.y) + PI;\n    float radius = TWO_PI/float(sides);\n    float d = cos(floor(.5 + angle/ radius) * radius - angle) * length(p);\n    return 1. - smoothstep(scale, scale + 0.01, d); \n}\n\nfloat sdPolygonOutline(vec2 p, int sides, float scale)\n{\n    float x = sdPolygon(p, sides, scale);\n    float y = sdPolygon(p, sides, scale + 0.05);\n    return y - x;\n}\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod(Pi0, 289.0);\n    Pi1 = mod(Pi1, 289.0);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 / 7.0;\n    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 / 7.0;\n    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}\n\nfloat Sphere_SDF(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat Box_SDF(vec3 point, vec3 size)\n{\n    vec3 q = abs(point) - size;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat Plane_SDF(vec3 point, vec3 normal, float h)\n{\n    return dot(point, normal) + h;\n}\n\nfloat Smooth_Difference_SDF(float shape1, float shape2, float value) \n{\n    float h = clamp(0.5 - 0.5 * (shape2 + shape1) / value, 0., 1.);\n    return mix(shape2, -shape1, h) + value * h * (1. - h);\n}\n\nfloat Smooth_Union_SDF( float shape1, float shape2, float value)\n{\n    float h = clamp( 0.5 + 0.5 * (shape2 - shape1)/value, 0., 1.);\n    return mix(shape2, shape1, h) - value * h * (1. - h);\n}\n\nfloat Smooth_Intersection_SDF(float shape1, float shape2, float value)\n{\n    float h = clamp(0.5 - 0.5 * (shape2 - shape1)/ value, 0., 1.);\n    return mix(shape2, shape1, h) + value * h * (1. - h);\n}\n\n",Hh=t(184),Xh=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Yh(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Xh,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Zh=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Qh(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Zh,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Jh=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Kh(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Jh,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $h=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$h,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ex=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ex,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ox=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ox,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ax=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ix(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ax,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ux=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ux,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var px=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:px,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _x=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ux(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_x,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Sx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Mx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float circleSDF(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF2(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF3(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF4(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF5(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF6(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float stroke(float x, float s, float w){\n        float d = step(s, x+w*.5) -\n                  step(s, x-w*.5);\n        return clamp(d, 0., 1.);\n    }\n    \n    \n    \n    void main(){\n        vec3 color = vec3(0.);\n    \n        color.rg += stroke(circleSDF(vec2(vUv.x + .125, vUv.y - 0.08)), 0.2, 0.03);\n        color.b += stroke(circleSDF2(vec2(vUv.x + .3 - .05, vUv.y - .2)), 0.2, 0.03);\n        color += stroke(circleSDF(vec2(vUv.x , vUv.y - .2)), 0.2, 0.03);\n        color.g += stroke(circleSDF(vec2(vUv.x - .124, vUv.y - .08)), 0.2, 0.03);\n        color.r += stroke(circleSDF(vec2(vUv.x  - .4 + .15, vUv.y - .2)), 0.2, 0.03);;\n        //color += stroke(circleSDF6(vec2(vUv)), 0.5, 0.02);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Mx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        vec3 color = vec3(0.);\n        color.gb += vUv.x - (sin(u_time) ) * 0.35;\n        color.gb *= vUv.y - (sin(u_time) ) * 0.35;\n        color.gb -= 0.1;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Cx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n\n// 2D Random\nfloat random(in vec2 st){\n    return fract(sin(dot(st.xy,\n                vec2(12.9898,78.233)))\n            *43758.5453123);\n        }\n\nfloat noise(in vec2 st){\n    vec2 i=floor(st);\n    vec2 f=fract(st);\n    \n    // Four corners in 2D of a tile\n    float a=random(i);\n    float b=random(i+vec2(1.,0.));\n    float c=random(i+vec2(0.,1.));\n    float d=random(i+vec2(1.,1.));\n    \n    // Smooth Interpolation\n    \n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u=f*f*(3.-2.*f);\n    // u = smoothstep(0.,1.,f);\n    \n    // Mix 4 coorners percentages\n    return mix(a,b,u.x)+\n    (c-a)*u.y*(1.-u.x)+\n    (d-b)*u.x*u.y;\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 5.);\n    float n = step(noise(pos + u_time), vUv.x);\n    float x = cnoise(vec3(n * vUv.y * u_time));\n    color += x * n - abs(sin(u_time));\n    color *= x + n + abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Rx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Tx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot(vec2 vUv){\n        return smoothstep(0.02, 0.0, abs(vUv.y - vUv.x));\n    }\n    \n    float plot2(vec2 vUv){\n        return smoothstep(.02,0.,abs(1. - vUv.y-vUv.x));\n    }\n    \n    \n    void main(){\n        float y = (sin(vUv.x) + abs(cos(u_time)) - 0.5);\n        vec3 color = vec3(y);\n        float pct = plot(vUv);\n        float pct2=plot2(vUv);\n        color = (0.5 - pct) * color + pct* vec3(1., 0., 0.);\n        color+=(0.5 - pct2)*color+pct2*vec3(1.,0.,0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Px(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Dx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Fx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // float plot(vec2 st){\n//     return smoothstep(0.02, 0.0, abs(st.y - st.x));\n// }\n\nfloat plot2(vec2 st, float pct){\n    return smoothstep(pct - 0.02, pct, st.y) - \n            smoothstep(pct, pct + 0.02, st.y);\n}\n\n// float plot(vec2 vUv, float pct){\n//     return smoothstep(pct-0.02, pct, vUv.y) - \n//            smoothstep(pct, pct+0.02, vUv.y);\n// }\n\nvoid main(){\n    //float y = vUv.x;\n    //float y2 = pow(vUv.x, 20.0);\n    //float y2 = sqrt(vUv.x * PI);\n    //float y = smoothstep(vUv, y);\n    float y2 = smoothstep(0.01, 0.9, abs(vUv.x * sin(u_time)));\n\n    vec3 color = vec3(y2);\n\n    float pct2 = plot2(vUv, y2);\n    color = (1.0 - pct2) * color + pct2 * vec3(1., 0., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Fx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ix=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot( vec2 st, float pct){\n        return smoothstep(pct - 0.02, pct, st.y) - \n               smoothstep(pct, pct + 0.02, st.y);\n    }\n    \n    void main(){\n        float y = abs(sin((vUv.x * PI) + u_time) * 0.5) ;\n        y /= abs(cos((vUv.y * PI) + u_time) * 0.5);\n        vec3 color = vec3(tan(y + u_time));\n        gl_FragColor = vec4(color, 0.2);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ex(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ix,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ox=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        float y = smoothstep(0.2, 0.5, vUv.x) - smoothstep(0.5, 0.8, vUv.x);\n        y+= smoothstep(0.2, 0.5, vUv.y) - smoothstep(0.5, 0.8, vUv.y);\n        y -= abs(cos(u_time * 0.5));\n        vec3 color = vec3(abs(sin(y + u_time)));\n        color.x = sin(u_time);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ox,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ax=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        float y = step(distance(abs(sin(u_time)), abs(sin(PI))), vUv.x);\n        float x = step(distance(abs(sin(u_time)), abs(cos(PI))), vUv.y);\n        vec3 color = vec3(y * x);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Gx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ax,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Nx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        //float y=step(.5,vUv.x);\n        float y = step(abs(sin(u_time * 0.2)),vUv.y);\n        float x =step(abs(cos(u_time * 0.8)),vUv.x);\n        float z =step(abs(sin(u_time * 0.5)),vUv.y);\n    \n    \n        vec3 color=vec3(y, x, z);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Bx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Nx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot(vec2 st,float pct){\n        return abs(smoothstep(pct-.1,pct,st.y)-\n        smoothstep(pct,pct+.1,st.y));\n    }\n    \n    void main(){\n        float y = smoothstep(0.01, 0.99, vUv.x);\n        float x=smoothstep(.01,.99,vUv.y);\n        vec3 color = vec3(0.);\n    \n        float pct = plot(sin(vUv * u_time * PI),sin(y * u_time * 0.5 * PI));\n        float pct2 =plot(cos(vUv * u_time),cos(x * u_time * 0.5));\n    \n        color = (1. - pct) * color + pct * vec3(0., 1., 0.);\n        color *=(1.-pct2)*color+pct2*vec3(0.,1.,0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Vx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct-0.01, pct, vUv.y) - \n                smoothstep(pct, pct + 0.1, vUv.y);\n    }\n    \n    \n    void main(){\n        float y = smoothstep(0.1 + abs(atan(u_time)), 0.9 - abs(atan(u_time)) , 0.5 + abs(tan(vUv.x * 20. * abs(cos(u_time * 0.25)))));\n        float x = smoothstep(0.9 - abs(atan(u_time)), 0.1 + abs(atan(u_time)),0.5 +  abs(tan(vUv.y * 20. *abs(cos(u_time * 0.25)))));\n        vec3 color = vec3(y * x);\n    \n        float pct = plot(vUv, (y * x) );\n        color = (1.0 - pct) * color + pct * vec3(0., 1., 0.);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Hx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Wx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        float y = step(vUv.x, abs(cos((vUv.y + u_time))) * abs(cos((vUv.y + u_time) * 1.)) * abs(sin(vUv.y + u_time)) * abs(sin((vUv.y + u_time) * 2.)));\n        vec3  color = vec3(y);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Yx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Xx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Zx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        float y = mod(cos(vUv.y * u_time) + 1., cos(PI +PI +sin(u_time)));\n        float x = mod(cos(vUv.x * u_time) + 1., cos(PI + PI +sin(u_time)));\n        vec3 color = vec3(y-x, x/y, x*y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Qx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Zx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Jx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 getRadialUv(vec2 vUv){\n        float angle = atan(vUv.x, vUv.y);\n        vec2 radialUv = vec2(0.);\n        radialUv.x = angle/(PI * 2. ) + .9 *abs(cos(u_time));\n        radialUv.y = 1. - pow(1. - length(vUv), 4.);\n        return radialUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vec2 radialUv = getRadialUv(vUv);\n        vec2 color = vec2(radialUv);\n        gl_FragColor = vec4(color, 1., 0.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Kx(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Jx,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $x=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Exponential impulse iquilezles.org\nfloat expImpulse(float x, float k){\n    float h = k*x;\n    return h* exp(1.-h);\n}\n\n//sinc curve original iquilezles.org\n// float sinc(float x,float k)\n// {\n//     float a=PI*((k*x-1.);\n//     return sin(a)/a;\n// }\n\n//Sinc curve  - modified\nfloat sinc(float x, float k){\n    float a = PI * ((k*x - 0.5));\n    return abs(sin(a))/ abs(cos(a));\n}\n\nvoid main(){\n    // float y = expImpulse(vUv.x, vUv.y / sin(u_time * 0.02) * 10.0);\n    float y=sinc(sin(vUv.y * 20.), sin(u_time * 0.25));\n    float x=sinc(sin(vUv.x * 20.), sin(u_time * 0.25));\n    vec3 color = vec3(cos(y) + sin(x));\n    gl_FragColor = vec4(y * x + vUv.x, vUv.y, 0.5, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ny(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$x,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ey=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n      }\n      \n      void main(){\n          float y = 0.1 * cos((10.0 * vUv.x) + (5. *  u_time));\n          float line = smoothstep(1. - clamp(distance(y + (sin(vUv.y)), 0.5) * 1., 0., 1.), 1., 0.99);\n          float line2 = smoothstep(1. - clamp(distance(y + (cos(vUv.y)), 0.5) * 1., 0., 1.), 1., 0.99);\n          vec3 color = vec3(line + line2);\n      \n          float pct = plot(vUv, sin(line));\n          color = (1. - line) * color + sin(pct) * vec3(0., 0., 0.);\n      \n          gl_FragColor = vec4(color, 1.);\n      }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ty(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ey,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float sinc(float x, float k){\n        float a = PI * ((k * x) - 1.);\n        return sin(a)/a;\n    }\n    \n    //plot function from bookofshaders.com\n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct - 0.01, pct, vUv.y) -\n               smoothstep(pct, pct + 0.1, vUv.y);\n    }\n    \n    \n    void main(){\n        float y = sinc(u_time, vUv.x);\n        vec3 color = vec3(y);\n        float pct = plot(vUv * 1.75 -0.5, y);\n        color = vec3(1. - pct);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ry(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ay=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float sinc(float x,float k){\n        float a=PI*((k*x)-1.);\n        return sin(a)/a;\n    }\n    \n    //exponential impulse iquilezles.org\n    float expImpulse(float x,float k)\n    {\n        float h=k*x;\n        return h*exp(1.-h);\n    }\n    float expImpulse2(float x,float k)\n    {\n        float h=(k + 0.25)*x;\n        return h*exp(1.-h);\n    }\n    float expImpulse3(float x,float k)\n    {\n        float h=(k + 0.5)*x;\n        return h*exp(1.-h);\n    }\n    \n    //plot function from bookofshaders.com\n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.01,pct,vUv.y)-\n        smoothstep(pct,pct+.1,vUv.y);\n    }\n    \n    void main(){\n        float y=expImpulse(u_time,clamp(vUv.x, 0.0, 1.0));\n        float x=expImpulse2(u_time,clamp(vUv.x, 0.0, 1.0));\n        float z=expImpulse3(u_time,clamp(vUv.x,0.,1.));\n    \n        vec3 color=vec3(y);\n        float pct=plot(vUv*1.75-.5,y);\n        float pct2=plot(vUv*1.75-.5,x);\n        float pct3=plot(vUv*1.75-.5,z);\n        color=vec3(1.-pct);\n        color*=vec3(1.-pct2);\n        color*=vec3(1.-pct3);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ay,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n      }\n      \n      void main(){\n          float a = sin(vUv.x * u_time) * 0.25 + 0.5;//sin\n          float b = cos(vUv.x * u_time) * 0.25 + 0.5;//cos\n      \n          vec3 color = vec3(1.0);\n      \n          float pct = plot(vUv, a);\n          float pct2 = plot(vUv, b);\n      \n          color *= (1.0 - pct) * color + pct * vec3(1.0, 0.0, 0.0);\n          color *= (1.0 - pct2) * color + pct2 * vec3(0.0, 0.0, 1.0);\n          \n          gl_FragColor = vec4(color, 1.);\n      }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ly=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n      }\n      \n      //parabola iquilezles.org\n      float parabola( float x, float k ){\n          return pow(4.0 * x * (1.0 - x), k);\n      }\n      \n      \n      void main(){\n          float y = parabola(vUv.x, 2. + (sin(u_time)));\n          float x = parabola(vUv.x, 4. + (sin(u_time)));\n          float z = parabola(vUv.x, 8. + (sin(u_time)));\n          vec3 color = vec3(0.);\n      \n          float pct = plot(vUv, y);\n          float pct2 = plot(vUv, x);\n          float pct3 = plot(vUv, z);\n      \n          color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);\n          color += (1.0-pct2)*color+pct2*vec3(1.0,0.0,0.0);\n          color += (1.0-pct3)*color+pct3*vec3(0.0,0.0,1.0);\n      \n          gl_FragColor = vec4(color, 1.);\n      }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ly,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //plot function bookofshaders\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n    }\n    \n    //easing functions easings.net/#easeInElastic\n    float easeInElastic(float x){\n        float y = (2.0 * PI) / 3.;\n        return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * u_time * (0.25)))) ;\n    }\n    \n    void main(){\n        float y = easeInElastic(vUv.x) - 0.5;\n    \n        vec3 color = vec3(y);\n    \n        float pct = plot(vUv, y);\n        color = pct * vec3(0., 1., 0.);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var py=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-0.2, pct, st.y + 0.5) -\n            smoothstep( pct, pct+0.2, st.y + 0.5);\n  }\n  \n  float plotX(vec2 st, float pct){\n    return  smoothstep( pct-0.2, pct, st.x + 0.5) -\n            smoothstep( pct, pct+0.2, st.x + 0.5);\n  }\n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * 2.0 ))) ;\n  }\n  \n  void main(){\n      float y =  easeInElastic(vUv.x) - 0.25;\n      float x =  easeInElastic(vUv.y) - 0.25;\n      float z = easeInElastic(1. - vUv.x) - 0.5;\n      float a = easeInElastic(1. - vUv.y) - 0.5;\n  \n      vec3 color = vec3(y);\n  \n      float pct = plotY(vUv, y + 0.25);\n      float pct2 = plotX(vUv, x + 0.25);\n      float pct3 = plotY(vUv, z);\n      float pct4 = plotX(vUv, a);\n  \n      color = pct * vec3(1., 0., 0.);\n      color *= pct2 * vec3(1., 1., 0.);\n      //color *= pct3 * vec3(0., 1., 0.);\n      //color += pct4 * vec3(1., 0., 0.);\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function my(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:py,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders plot function\nfloat plot(vec2 st,float pct){\n    return smoothstep(pct-.8,pct,st.y)-\n    smoothstep(pct,pct+.8,st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(atan(vUv.x - 0.5, vUv.y - 0.5) * u_time * sin(u_time * 0.5));\n    float x = sin(vUv.x);\n    float y = sin(vUv.y);\n    vec3 color = vec3(x);\n    color += vec3(y);\n\n    //float pct = plot(vUv, y);\n    //color += pct * vec3(0.0, 1.0, 1.0);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //sinc curve iquilezles.org\nfloat sinc(float x,float k){\n    float a=PI*((k*x)-1.);\n    return sin(a)/a ;\n}\n\n//plot function bookofshaders\nfloat plot(vec2 st, float pct){\n  \n  return  smoothstep( pct-0.02, pct, st.x + 0.5) -\n          smoothstep( pct, pct+0.2, st.x + 0.5);\n}\n\nfloat plot2(vec2 st, float pct){\n  \n  return  smoothstep( pct-0.02, pct, st.y + 0.5) -\n          smoothstep( pct, pct+0.2, st.y + 0.5);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vUv -= 0.5; \n    float y = sinc((vUv.y - 0.5 * PI), u_time  * 0.5);\n    float x = sinc((vUv.x - 0.5 * PI), u_time  * 0.5);\n    \n    vec3 color = vec3(0.);\n\n    float pct = plot(vUv - 0.5, y);\n    float pct2 = plot2(vUv - 0.5, x);\n\n    color += pct * vec3(1., 0., 0.);\n    color *= pct2 * vec3(1., 0., 0.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-0.02, pct, st.y +2.5) -\n            smoothstep( pct, pct+0.25, st.y + 2.5);\n  }\n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * 1.5 ))) ;\n  }\n  \n  void main(){\n      vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.7);\n      vUv *= 2.75;\n      float y = easeInElastic(abs(sin(vUv.x)) * 1.25);\n      float x = easeInElastic(abs(cos(vUv.y)) * 1.25);\n  \n      vec3 color = vec3(0.);\n  \n      float pct = plotY(vUv, y * x);\n      color += pct  * vec3(0., 1., 1.);\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function by(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _y=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-.02, pct, st.y + 0.5) -\n            smoothstep( pct, pct+.25, st.y + 0.5);\n  }\n  \n  float plotX(vec2 st, float pct){\n    return  smoothstep( pct-.02, pct, st.x + 0.5) -\n            smoothstep( pct, pct+.25, st.x + 0.5);\n  }\n  \n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * cos((x * 10. - 10.75) * y - (u_time * 2.0 ))) ;\n  }\n  \n  float easeInElastic2(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * 2.0 ))) ;\n  }\n  \n  void main(){\n      vec2 vUv = vec2(vUv.x, vUv.y);\n      vUv *= 0.5;\n      vUv += 0.3;\n  \n      float y =  easeInElastic(vUv.x);\n      float x =  easeInElastic2(vUv.y);\n  \n      vec3 color = vec3(y);\n  \n      float pct = 1. -plotY(vUv, y);\n      float pct2 = 1. - plotX(vUv, x);\n    \n      color = pct * vec3(1., 0., 0.);\n      color += pct2 * vec3(1., 0., 0.);\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_y,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec3 colorA = vec3(0.788, 0.262, 0.250);\nvec3 colorB = vec3(0.250, 0.474, 0.788);\n\nfloat easeInQuad(float x){\n    return x * x;\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    float pct = easeInQuad(vUv.x);\n    pct += sin(u_time);\n    color = mix(colorA, colorB, pct);\n    color -= mix(colorB, colorA, pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Sy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var My=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\n\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\n//bookofshaders\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 3.0;\n    vec3 color = vec3(0.0);\n    color = rgb2hsb(vec3(vUv.x, vUv.y, abs(sin(u_time * 0.5))));\n    color -= rgb2hsb(vec3(vUv.x, vUv.y, abs(cos(u_time * 0.5))));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:My,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ky=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 centeredUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    centeredUv *= 10.0;\n    float t = u_time * .05;\n    //vUv += M;\n    centeredUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(sin(centeredUv.y), sin(centeredUv.x));\n    float radius = length(centeredUv) * 200.0;\n    color = 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.25)))) - 0.25, radius, 1.));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Cy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ky,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ty=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c){\n    vec3 rgb=clamp(abs(mod(c.x*6.+vec3(3.8,1.,7.),\n6.)-3.)-1.,\n0.,\n1.);\nrgb=rgb*rgb*(3.-2.*rgb);\nreturn c.z*mix(vec3(1.),rgb,c.y);\n}\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec2 centeredUv=vec2(vUv.x-.5,vUv.y-.5);\n    centeredUv*=10.;\n    float t=u_time*.05;\n    centeredUv*=Rot(t*10.);\n    vec3 color=vec3(0.);\n    float angle=abs(tan(dot(abs(cos(centeredUv.x)), abs(sin(centeredUv.y)))) * abs(cos(u_time * 0.5)));\n    float radius=length(centeredUv)*2000.;\n    color=1. - hsb2rgb(vec3((angle/(TWO_PI /3.))+.5,radius, 1.));\n    gl_FragColor=vec4(color.x , color.y, color.z ,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ry(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ty,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    void main(){\n        vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n        vUv *= 25.0;\n        float t = u_time * 0.25;\n        vUv*=Rot(t*1.);\n        vec3 color=vec3(0.);\n        float angle=abs(tan(dot(abs(cos(vUv.x)),abs(sin(vUv.y))))*abs(cos(u_time*.25)));\n        float radius=length(vUv) * 0.5;\n        color = vec3(((angle * radius)/ PI) + (cos(u_time)), tan(radius * angle) , tan(radius * angle));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Py(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Dy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Fy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 10.0;\n    float t = u_time * .05;\n    vUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(sin(vUv.y), sin(vUv.x));\n    float radius = length(vUv) * 2.0;\n    color = 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.5)))), abs(tan(angle + u_time)) , u_time * 0.5));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Fy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Iy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vUv *= 10.0;\n        float t = u_time * .05;\n        vUv *= Rot(t * 5.0);\n        vec3 color = vec3(0.);\n        float radius = length(tan(vUv + (sin(vUv.y))) * 0.08);\n        color = vec3(tan(vUv.x + cos(vUv.y + u_time)), tan(1. - vUv.x + cos(vUv.y + u_time)), tan(vUv.x + cos(vUv.y + u_time)));\n        vec3 newColor = vec3(color.x * radius, color.y * radius, color.z * radius);\n        gl_FragColor = vec4(newColor, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ey(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Iy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Oy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 10.0;\n    float t = u_time * .05;\n    vUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(cos(vUv.y), cos(vUv.x));\n    float radius = length(vUv) * 200.0;\n    color = vec3(vUv.x * angle, vUv.y * angle, 1.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ly(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Oy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ay=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-.5, pct, st.y + 0.5) -\n            smoothstep( pct, pct+.5, st.y + 0.5);\n  }\n  \n  //  Function from I\xf1igo Quiles\n  //  https://www.shadertoy.com/view/MsS3Wc\n  vec3 hsb2rgb( in vec3 c ){\n      vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                               6.0)-3.0)-1.0,\n                       0.0,\n                       1.0 );\n      rgb = rgb*rgb*(3.0-2.0*rgb);\n      return c.z * mix(vec3(1.0), rgb, c.y);\n  }\n  \n  \n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (sin( - u_time * 0.25)) / 3.;\n      return pow(2., 10. * x - 10.) * cos((x * 10. - 10.75) * y - (u_time * 0.5)) ;\n  }\n  \n  \n  void main(){\n      vec2 vUv = vec2(vUv.x - 1.5 , vUv.y - 1.5 );\n      vUv *= 1.0;\n      //vec3 color = vec3(0.);\n      float angle = dot(sin(vUv.y), cos(vUv.x));\n      float radius = length(vUv) * 2.0;\n  \n      float y =  easeInElastic(vUv.x * angle * radius);\n  \n      vec3 color = vec3(y);\n  \n      float pct =plotY(vUv, y * radius * angle);\n    \n      color = hsb2rgb(vec3(y + cos(u_time), y + cos(u_time), y * pct));\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Gy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ay,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ny=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vUv *= 5.0;\n        float t = u_time * .05;\n        vUv *= Rot(t * 5.0);\n        vUv *= length(vUv * sin(t));\n        vec3 color = vec3(0.);\n        float radius = length(cos((vUv * sin(u_time)) + (cos(vUv.y))) * 0.08);\n        color = vec3(tan(vUv.x + cos(vUv.y + u_time)), tan(1. - vUv.x + cos(vUv.y + u_time)), tan(vUv.x + cos(vUv.y + u_time)));\n        vec3 newColor = vec3(color.x * radius * abs(cos(u_time)), color.y * radius * abs(sin(u_time)), color.z * radius );\n        gl_FragColor = vec4(newColor, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function By(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ny,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //plot function from book of shaders\nfloat plot(vec2 st, float pct){\n    return  smoothstep( pct-1.5, pct, st.y) -\n            smoothstep( pct, pct+1.5, st.y);\n  }\n  \n  float plot2(vec2 st, float pct){\n    return  smoothstep( pct-1., pct, st.x) -\n            smoothstep( pct, pct+1., st.x);\n  }\n  \n  mat2 Rot(float a){\n      float s = sin(a);\n      float c = cos(a);\n      return mat2(c, -s, s, c);\n  }\n  \n  void main(){\n      vec2 vUv = vec2(vUv.x -0.5, vUv.y - 0.5);\n      vUv *= 10.0;\n      float t = u_time * .05;\n      vUv *= Rot(t * 5.0);\n      float a = sin(vUv.x + u_time * (atan(sin(u_time + vUv.x), vUv.y)));//sin\n      //float b = cos(vUv.y * (dot(cos(u_time * vUv.y), vUv.y)));//cos\n  \n      vec3 color = vec3(0.);\n  \n      float pct = plot(vUv, a);\n      //float pct2 = plot2(vUv, b);\n      float radius = length(cos((vUv * sin(u_time)) + (cos(vUv.y))) * 0.08);\n      color = (1.0 - pct) * color + pct * vec3(vUv.x, vUv.y, 1.);\n      \n      // vec3 newColor = vec3(color.x * radius * abs(cos(u_time)), color.y * radius * abs(sin(u_time)), color.z * radius );\n      //gl_FragColor = vec4(newColor, 1.);\n  \n      //color = (1.0 - pct) * color + pct * vec3(1.0, 0.0, 0.0);\n      //color *= (1.0 - pct2) * color + pct2 * vec3(0.0, 0.0, 1.0);\n      \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Vy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    \n    //  Function from I\xf1igo Quiles\n    //  https://www.shadertoy.com/view/MsS3Wc\n    vec3 hsb2rgb(in vec3 c){\n        vec3 rgb=clamp(abs(mod(c.x*6.+vec3(3.8,1.,7.),\n    6.)-3.)-1.,\n    0.,\n    1.);\n    rgb=rgb*rgb*(3.-2.*rgb);\n    return c.z*mix(vec3(1.),rgb,c.y);\n    }\n    \n    //pixel deck\n    vec2 rotate(vec2 vUv, float a){\n        vUv = mat2(cos(a), - sin(a), sin(a), cos(a)) * vUv * 0.5;\n        return vUv;\n    }\n    float stroke(float x, float s, float w){\n        float d = step(s, x + w * 0.5) - \n                    step(s, x -w * 0.5);\n        return clamp(d, 0., 1.);\n    }\n    float fill(float x, float size){\n        return 1. - step(size, x);\n    }\n    float rectSDF(vec2 vUv, vec2 s){\n        vUv = vUv * 2. - 1.;\n        return max(abs(vUv.x/s.x), abs(vUv.y/s.y));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x , vUv.y );\n        vUv -= 0.5;\n        vUv *= 6.25;\n        vUv = rotate(vUv, radians(180. * (u_time * u_time) ));\n        float y = 0.;\n        vec3 color = vec3(y);\n        y = fill(rectSDF(vUv, vec2(1.5)), 1.5);\n        y -= 1. - stroke(vUv.x, 0.9, 0.1);\n        y -= 1. - stroke(vUv.y,0.9, 0.1);\n        color = vec3(y);\n        gl_FragColor = vec4(color.x + (sin(u_time * 0.1)), color.y + (sin(u_time * 0.2)), color.z + (cos(u_time * 0.1)), 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Hy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Wy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 5.0;\n    float t = u_time * .05;\n    vUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(cos(vUv.y * sin(u_time * 0.25)), cos(vUv.x * sin(u_time * 0.25)));\n    float radius = length(vUv);\n    color = 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.5)))) * radius, abs(tan(angle + u_time)) , radius * angle * u_time - 0.5));\n    gl_FragColor = vec4(1. - color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Yy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Xy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Zy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //pixeldeck\nfloat starSDF(vec2 vUv, int V, float s){\n    //vUv = vUv * 5. - 2.5;\n    float a  = atan(vUv.y, vUv.x)/TWO_PI;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5)/ float(V) + mix(s, -s, step(.5, fract(seg)))) * TWO_PI;\n    return abs(dot(vec2(cos(a), sin(a)), vUv));\n}\n\n//  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y-0.5);\n    vUv *= 5.;\n    vec3 color = vec3(0.);\n    float t = u_time * .1;\n    vUv *= Rot(t * 10.0);\n    float s = starSDF(vUv.yx, 5, .1);\n    color += 1. - step(.7, s);\n    //color *= 1. - step(.7, s);\n    float angle = dot(cos(vUv.y * sin(u_time * 0.25)), cos(vUv.x * sin(u_time * 0.25)));\n    float radius = length(vUv);\n    color *= 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.25)))), abs(tan(angle + u_time)) , (u_time) * 0.25));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Qy(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Zy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Jy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// //Rectangle function\nfloat createRect(in vec2 vUv, in vec2 start, in vec2 dim){\n    vec2 bottomLeft = step(start, vUv);\n    vec2 topRight = step(1. - start -dim, 1.0 - vUv);\n    float pct = bottomLeft.x * bottomLeft.y * topRight.x * topRight.y;\n    return pct;\n}\n\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x + 0.48, vUv.y + 0.48);\n    vUv *= 10.;\n    float angle = dot(sin(vUv.y - 0.5), sin(vUv.x - 0.5));\n    // float radius = length((vUv * 2.0 - 0.5) );\n    float barX = step(0.4, mod(vUv.x * 10.0 - 0.2, 1.0)) * step(0.8, mod(vUv.y * 10.0, 1.0));\n    float barY = step(0.8, mod(vUv.x * 10.0, 1.0)) * step(0.4, mod(vUv.y * 10.0 - 0.2, 1.0));\n    float strength = barX + barY;\n    float circle = step(circleSDF(vUv), 1.0);\n    vec3 color = vec3(strength);\n    float radius = length(cos((vUv * sin(u_time)) + (cos(vUv.y))) * 0.08);\n    color *= vec3(tan(vUv.x + cos(vUv.y + u_time)), tan(1. - vUv.x + cos(vUv.y + u_time)), tan(vUv.x + cos(vUv.y + u_time)));\n    vec3 newColor = vec3(color.x + atan(0.5 * u_time) * radius * (sin(u_time )), color.y + atan(0.5 * u_time) * radius * (cos(u_time)), color.z * radius );\n    newColor -= strength;\n    gl_FragColor = vec4(newColor, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ky(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Jy,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $y=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Rectangle function\nfloat createRect(in vec2 vUv, in vec2 start, in vec2 dim){\n    vec2 bottomLeft = step(start, vUv);\n    vec2 topRight = step(1. - start -dim, 1.0 - vUv);\n    float pct = bottomLeft.x * bottomLeft.y * topRight.x * topRight.y;\n    return pct;\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 3.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    float y = createRect(vUv, vec2(-0.62, 0.0), vec2(1.5, 0.25));\n    float x = createRect(vUv, vec2(0.0, -0.62), vec2(0.25, 1.5));\n    float shape = x - y;\n    vec3 color = vec3(shape);\n    float angle = dot(atan(vUv.y * sin(u_time * 0.25)), atan(vUv.x * sin(u_time * 0.25)));\n    float radius = length(vUv - 0.5) * 20.;\n    color *= vec3(sin(color.x * (sin(u_time * sin(radius)))), sin(color.y * (cos(u_time * sin(radius)))), sin(color.z * (sin(u_time * sin(radius)))));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ng(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$y,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 2.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    float circle = circleSDF(vUv + 0.5);\n    float angle = dot(vUv.y, vUv.x);\n    float radius = length(vUv) * 100.0;\n    vec3 color = vec3(0.);\n    color = hsb2rgb(vec3((angle/TWO_PI * (u_time)) , sin(radius * sin(u_time * 0.25)), 1.0));\n    color -=  tan(circle);\n    gl_FragColor = vec4(color.x, color.y, color.z, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var og=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 2.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    float circle = circleSDF(vUv + 0.5);\n    float angle = dot(vUv.y, vUv.x);\n    float radius = length(vUv) * 1000.0;\n    //vec3 color = vec3(0.);\n    \n    vec3 color =  vec3(tan(circle));\n    color += hsb2rgb(vec3(atan(circle,angle * radius/TWO_PI) *1. -  abs(cos(u_time * 0.25))));\n    gl_FragColor = vec4(color.x + sin(u_time), color.y - sin(u_time), color.z + cos(u_time), 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:og,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ag=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c){\n    vec3 rgb=clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),\n            6.)-3.)-1.,\n            0.,\n            1.);\n    rgb=rgb*rgb*(3.-2.*rgb);\n    return c.z*mix(vec3(1.),rgb,c.y);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv-.5)*2.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv - 0.5);\n    vUv *= 3.0;\n    float angle=atan(vUv.y,vUv.x);\n    float radius=length(vUv)*5.;\n    float circle=circleSDF(vUv+.5);\n    vec3 color=vec3(tan(circle + u_time));\n    color += 1. - hsb2rgb(vec3(atan(radius, angle)  + sin(u_time), atan(radius,angle)+cos(u_time), atan(radius,angle) +cos(u_time)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ig(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ag,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv-0.25);\n    vUv *= 2.0;\n    float angle = dot(vUv.y , vUv.x);\n    float radius = length(vUv- 0.5) * 10.0;\n    vec3 color = vec3 (cos(vUv.x), sin(vUv.y + u_time* 0.2), 0.);\n    color *= vec3(step(circleSDF(vUv), 1.9));\n    color *= hsb2rgb(vec3(u_time + radius * sin(vUv.x + vUv.y), u_time + radius, u_time + radius));\n    gl_FragColor = vec4(color , 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//book of shaders\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.5, pct, st.y) -\n          smoothstep( pct, pct+0.5, st.y);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv - 0.5);\n    vUv *= 4.0 + sin(u_time);\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    vec3 color = vec3(0.);\n    color += 1. - hsb2rgb(vec3(cos(vUv.x * vUv.y), u_time * PI, 1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ug=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        //vec2 vUv = vec2(vUv);\n        vec3 color = vec3(0.);\n        // float left = step(0.1, vUv.x);\n        // float bottom = step(0.1, vUv.y);\n        vec2 bordersBottomLeft = step(vec2(0.1 * abs(sin(u_time * 0.75))), vUv);\n        vec2 bordersTopRight = step(vec2(0.1 * abs(sin(u_time * 0.75))), 1.0 - vUv);\n        float pct = bordersBottomLeft.x * bordersBottomLeft.y * bordersTopRight.x * bordersTopRight.y;\n        color = vec3(pct);\n        gl_FragColor = vec4(vec3(vUv.x * color.x, vUv.y * color.y, color.z), 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ug,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rect(vec2 vUv, vec2 s){\n        vec2 bl = step(vec2(s), vUv);\n        vec2 tr = step(vec2(s), 1. - vUv);\n        return bl.x * bl.y * tr.x * tr.y;\n    }\n    \n    void main(){\n        //vec2 vUv = vec2(vUv - 0.5);\n        vec3 color = vec3(vUv.x * vUv.y);\n        // vec2 bl = step(vec2(0.5), vUv);\n        // vec2 tr = step(vec2(0.1), 1. - vUv);\n        // float pct = bl.x * bl.y * tr.x * tr.y;\n        // float pct2 = 1. - (bl.x  * bl.y * tr.x * tr.y);\n        // color *= vec3(pct2);\n        // color += vec3(pct);\n        float pct = rect(vec2(vUv.x + 0.25 * sin(u_time), vUv.y + 0.25 * cos(u_time)), vec2(0.25));\n        float pct2 = rect(vec2(vUv.x - 0.25 * cos(u_time), vUv.y - 0.25 * sin(u_time)), vec2(0.25));\n        vec3 finalColor = vec3(pct * abs(cos(u_time)), pct * 0.2,  pct * 0.8);\n        finalColor += vec3(pct2 * abs(sin(u_time)), pct2 * 0.8, 0.2);\n        color = finalColor;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rect(vec2 vUv, vec2 s){\n        vec2 bl = step(vec2(s), vUv);\n        vec2 tr = step(vec2(s), 1. - vUv);\n        return bl.x * bl.y * tr.x * tr.y;\n    }\n    \n    //pixel deck\n    float fill(float x, float size){\n        return 1. - step(size, x);\n    }\n    //pixel deck\n    //triangle SDF\n    float triSDF(vec2 vUv){\n        vUv = (vUv * 2. - 1.) * 2.;\n        return max(abs(vUv.x) * 0.866025 + vUv.y * 0.5, -vUv.y * 0.5);\n    } \n    \n    void main(){\n        //vec2 vUv = vec2(vUv - 0.5);\n        vec3 color = vec3(vUv.x * vUv.y);\n        float pct = fill(triSDF(vec2(vUv.x + 0.25 * sin(u_time * 0.5), vUv.y + 0.25 * cos(u_time* 0.5))), 0.35);\n        float pct2 = fill(triSDF(vec2(vUv.x + 0.25 * cos(u_time* 0.5), vUv.y - 0.25 * sin(u_time* 0.5))), 0.35);\n        float pct3 = fill(triSDF(vec2(vUv.x - 0.25 * cos(u_time* 0.5), vUv.y + 0.25 * sin(u_time* 0.5))), 0.35);\n        float pct4 = fill(triSDF(vec2(vUv.x + 0. * sin(u_time* 0.5), vUv.y + 0. * cos(u_time* 0.5))), 0.35);\n        vec3 finalColor = vec3(pct * abs(sin(u_time)), pct * 0.2,  pct * 0.8);\n        finalColor += vec3(pct2 * abs(sin(u_time)), pct2 * 0.8, pct2 * 0.1);\n        finalColor += vec3(pct3 * abs(sin(u_time)), pct3 * 0.4, pct3 * 0.3);\n        finalColor += vec3(pct4 * abs(cos(u_time)), pct4 * 0.2, pct4 * 0.5);\n        color = finalColor;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float triSDF(vec2 vUv){\n        vUv=(vUv*2.-1.)*2.;\n        return max(abs(vUv.x)*.866025+vUv.y*.5,-vUv.y*.5);\n    }\n    \n    //rotation function\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    \n    void main(){\n        vec2 newvUv = vec2(vUv + 1.5 );\n    \n        newvUv *= 20.25;\n        float t=sin(u_time*.75);\n        \n        vec3 color=vec3(0.);\n        float pct = triSDF(vec2(vUv.x,vUv.y));\n        color = vec3(pct, pct, pct);\n        color.xy*=Rot(t);\n        color.yz*=Rot(t);\n        color.xz*=Rot(t);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //pixel deck\nfloat fill(float x, float size){\n    return 1. - step(size, x);\n}\n//pixel deck\n//triangle SDF\nfloat triSDF(vec2 vUv){\n    vUv = (vUv * 2. - 1.) * 2.;\n    return max(abs(vUv.x) * 0.866025 + vUv.y * 0.5, -vUv.y * 0.5);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv - 0.5);\n    vUv *= 2.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    vec3 color = vec3(0.);\n    float tri = fill(triSDF(vUv + 0.5), 1.0);\n    float tri2 = fill(triSDF(vUv + 0.3), 1.25);\n    float tri3 = fill(triSDF(vec2(vUv.x + 0.15, vUv.y + 0.25)), 1.);\n    color = vec3(abs(sin(tri + u_time * vUv.x)), abs(cos(tri + u_time + vUv.y)), (sin(tri + 0.2 + u_time)));\n    vec3 finalColor = vec3(vUv, 1.);\n    vec3 color2 = vec3(tri2);\n    vec3 color3 = vec3(tri3);\n    finalColor += color;\n    finalColor *= color2;\n    finalColor -= color3;\n    gl_FragColor = vec4(finalColor, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _g=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //pixel deck\nfloat fill(float x, float size){\n    return 1. - step(size, x);\n}\n//pixel deck\n//triangle SDF\nfloat triSDF(vec2 vUv){\n    vUv = (vUv * 2. - 1.) * 2.;\n    return max(abs(vUv.x) * 0.866025 + vUv.y * 0.5, -vUv.y * 0.5);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vec3 color = vec3(0.);\n    float angle = dot(vUv.y , vUv.x);\n    float radius = length(vUv- 0.5) * 10.0;\n    float tri = 1. - fill(triSDF(vUv), 0.5);\n    float tri2 = fill(triSDF(vec2(vUv.x, vUv.y + 0.1)), 0.4);\n    float tri3 = 1. - fill(triSDF(vec2(vUv.x, vUv.y + 0.2)), 0.3);\n    float shape = float(tri + tri2 * tri3);\n    color = vec3(shape);\n    color += hsb2rgb(vec3(u_time + radius * sin(vUv.x - 0.25 + vUv.y), u_time + radius, u_time + radius));\n    gl_FragColor = vec4(vec3(shape, shape + color.y, shape), 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ug(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_g,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rect(vec2 size, vec2 vUv){\n        vec2 bl = step(size, vUv);\n        vec2 tr = step(size, 1. - vUv);\n        return bl.x * bl.y * tr.x * tr.y;\n    }\n    \n    //rotation function\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x - 0.75, vUv.y - 0.5);\n        vUv *= 5.0;\n        float t = u_time;\n        vUv *= Rot(t);\n        vec3 color = vec3(0.);\n        float pct = rect(vec2(0.3, 0.49), vUv + sin(u_time));\n        float pct2 = rect(vec2(0.3, 0.49), vec2(vUv.x, vUv.y + 0.5 )+ cos(u_time));\n        float pct3 = rect(vec2(0.49, 0.3), vec2(vUv.x, vUv.y + 0.5 )+ cos(u_time));\n        float pct4 = rect(vec2(0.49, 0.3), vUv + sin(u_time));\n        float pct5 = rect(vec2(0.3, 0.49), vec2(vUv.x, vUv.y + 1.) + sin(u_time));\n        float pct6 = rect(vec2(0.49, 0.3), vec2(vUv.x, vUv.y + 1.) + sin(u_time));\n        color = vec3(0.);\n        color.g += pct;\n        color.r += pct2;\n        color.r += pct3;\n        color.g += pct4;\n        color.b += pct5;\n        color.b += pct6;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Sg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Mg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    //a\n    float pct = smoothstep(0.1, 0.15, distance(vUv, vec2(0.8 * cos(u_time), 1. * abs(sin(u_time)))));\n    float pct2 = smoothstep(0.1, 0.15, distance(vUv, vec2(0.5, 1. * abs(cos(u_time)))));\n    float pct3 = smoothstep(0.1, 0.15, distance(vUv, vec2(0.2, 1. * abs(sin(u_time)))));\n    color = vec3(pct);\n    color *= vec3(pct2);\n    color *= vec3(pct3);\n\n    color.x = sin(color.x * u_time * 0.25);\n    color.y = sin(color.y * u_time * 0.25);\n    color.z = sin(color.z * u_time * 0.25); \n    // //b\n    // vec2 vUv = vec2(vUv) - 0.5;\n    // float pct = length(vUv);\n    // color = vec3(pct);\n\n    // //c\n    // vec2 vUv = vec2(vUv) - 0.5;\n    // float pct = sqrt(vUv.x * vUv.x + vUv.y * vUv.y);\n    // color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Mg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        float y = step(distance(vUv, vec2(0.5, 0.5)), 0.5);\n        float x = 1. - step(distance(vUv, vec2(0.5, 0.5)), 0.49);\n        float cir1 = step(distance(vUv, vec2(0.74, 0.49)), 0.25);\n        float cir2 = step(distance(vUv, vec2(0.25, 0.52)), 0.24);\n        x+=step(vUv.y,.5);\n        vec3 color = vec3(y * x);\n        color += vec3(cir1);\n        color -= vec3(cir2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Cg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //circle sdf\nfloat circ(vec2 vUv, vec2 pos, float size){\n    return 1. - step(size, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    float y1 = circ(vUv, vec2(0.1, 1. * abs(sin(u_time * 0.9))), 0.05);\n    float y2 = circ(vUv, vec2(0.2, 1. * abs(sin(u_time * 0.85))), 0.05);\n    float y3 = circ(vUv, vec2(0.3, 1. * abs(sin(u_time * 0.80))), 0.05);\n    float y4 = circ(vUv, vec2(0.4, 1. * abs(sin(u_time * 0.75))), 0.05);\n    float y5 = circ(vUv, vec2(0.5, 1. * abs(sin(u_time * 0.70))), 0.05);\n    float y6 = circ(vUv, vec2(0.6, 1. * abs(sin(u_time * 0.65))), 0.05);\n    float y7 = circ(vUv, vec2(0.7, 1. * abs(sin(u_time * 0.60))), 0.05);\n    float y8 = circ(vUv, vec2(0.8, 1. * abs(sin(u_time * 0.55))), 0.05);\n    float y9 = circ(vUv, vec2(0.9, 1. * abs(sin(u_time * 0.50))), 0.05);\n\n    vec3 color = vec3(y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8 + y9);\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Rg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Tg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //circle sdf\nfloat circ(vec2 vUv,vec2 pos,float size){\n    return 1.-step(size,distance(vUv,pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y) - 0.5;\n    vUv *= 2.0;\n    float y1=circ(vUv,vec2(.5*(sin(u_time*.1 * 2.)),.5*(cos(u_time*.1))),.05);\n    float y2=circ(vUv,vec2(.5*(sin(u_time*.2* 2.)),.5*(cos(u_time*.2))),.05);\n    float y3=circ(vUv,vec2(.5*(sin(u_time*.3* 2.)),.5*(cos(u_time*.3))),.05);\n    float y4=circ(vUv,vec2(.5*(sin(u_time*.4* 2.)),.5*(cos(u_time*.4))),.05);\n    float y5=circ(vUv,vec2(.5*(sin(u_time*.5* 2.)),.5*(cos(u_time*.5))),.05);\n    float y6=circ(vUv,vec2(.5*(sin(u_time*.6* 2.)),.5*(cos(u_time*.6))),.05);\n    float y7=circ(vUv,vec2(.5*(sin(u_time*.7* 2.)),.5*(cos(u_time*.7))),.05);\n    float y8=circ(vUv,vec2(.5*(sin(u_time*.8* 2.)),.5*(cos(u_time*.8))),.05);\n    float y9=circ(vUv,vec2(.5*(sin(u_time*.9* 2.)),.5*(cos(u_time*.9))),.05);\n    float y10=circ(vUv,vec2(.5*(sin(u_time*1.0*2.)),.5*(cos(u_time*1.0))),.05);\n    float y11=circ(vUv,vec2(.5*(sin(u_time*1.1*2.)),.5*(cos(u_time*1.1))),.05);\n    float y12=circ(vUv,vec2(.5*(sin(u_time*1.2*2.)),.5*(cos(u_time*1.2))),.05);\n    float y13=circ(vUv,vec2(.5*(sin(u_time*1.3*2.)),.5*(cos(u_time*1.3))),.05);\n    float y14=circ(vUv,vec2(.5*(sin(u_time*1.4*2.)),.5*(cos(u_time*1.4))),.05);\n    float y15=circ(vUv,vec2(.5*(sin(u_time*1.5*2.)),.5*(cos(u_time*1.5))),.05);\n    float y16=circ(vUv,vec2(.5*(sin(u_time*1.6*2.)),.5*(cos(u_time*1.6))),.05);\n    float y17=circ(vUv,vec2(.5*(sin(u_time*1.7*2.)),.5*(cos(u_time*1.7))),.05);\n    float y18=circ(vUv,vec2(.5*(sin(u_time*1.8*2.)),.5*(cos(u_time*1.8))),.05);\n    float y19=circ(vUv,vec2(.5*(sin(u_time*1.9*2.)),.5*(cos(u_time*1.9))),.05);\n    float y20=circ(vUv,vec2(.5*(sin(u_time*2.0*2.)),.5*(cos(u_time*2.0))),.05);\n    \n    vec3 color=vec3(y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8 + y9 + y10 + y11 + y12 + y13 + y14 + y15 + y16 + y17 + y18 + y19 + y20);\n    \n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Pg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Dg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Fg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //circle sdf\nfloat circ(vec2 vUv,vec2 pos,float size){\n    return 1.-step(size,distance(vUv,pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y)-.5;\n    vUv*=2.;\n    float y1=circ(vUv,vec2(0.,0.),abs(cos(u_time * .1)));\n    float y2=circ(vUv,vec2(0.,0.),abs(cos(u_time * .2)));\n    float y3=circ(vUv,vec2(0.,0.),abs(cos(u_time * .3)));\n    float y4=circ(vUv,vec2(0.,0.),abs(cos(u_time * .4)));\n    float y5=circ(vUv,vec2(0.,0.),abs(cos(u_time * .5)));\n    float y6=circ(vUv,vec2(0.,0.),abs(cos(u_time * .6)));\n    float y7=circ(vUv,vec2(0.,0.),abs(cos(u_time * .7)));\n    float y8=circ(vUv,vec2(0.,0.),abs(cos(u_time * .8)));\n    float y9=circ(vUv,vec2(0.,0.),abs(cos(u_time * .9)));\n\n    vec3 color=vec3(0.);\n    color.b-=y1 * y9 / abs(sin(u_time));\n    color.r-=y2 * y8 / abs(sin(u_time));\n    color.g-=y3 * y7 / abs(sin(u_time));\n    color.r+=y4 * y6 / abs(sin(u_time));\n    color.b+=y5 * y1 / abs(sin(u_time));\n    color.g-=y6 * y4 / abs(sin(u_time));\n    color.b+=y7 * y3 / abs(sin(u_time));\n    color.r-=y8 * y2 / abs(sin(u_time));\n    color.g+=y9 * y1 / abs(sin(u_time));\n    \n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Fg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ig=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n\n//circle sdf\nfloat circ(vec2 vUv, vec2 pos, float size){\n    return 1. - step(size, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 1.5;\n    vec3 color = vec3(0.);\n    float c1 = circ(vUv, vec2(0.5 * sin(u_time * 1.10), 0.5 * cos(u_time -1.10)), 0.025);\n    float c2 = circ(vUv, vec2(0.5 * sin(u_time * 1.15), 0.5 * cos(u_time -1.15)), 0.025);\n    float c3 = circ(vUv, vec2(0.5 * sin(u_time * 1.20), 0.5 * cos(u_time -1.20)), 0.025);\n    float c4 = circ(vUv, vec2(0.5 * sin(u_time * 1.25), 0.5 * cos(u_time -1.25)), 0.025);\n    float c5 = circ(vUv, vec2(0.5 * sin(u_time * 1.30), 0.5 * cos(u_time -1.30)), 0.025);\n    float c6 = circ(vUv, vec2(0.5 * sin(u_time * 1.35), 0.5 * cos(u_time -1.35)), 0.025);\n    float c7 = circ(vUv, vec2(0.5 * sin(u_time * 1.40), 0.5 * cos(u_time -1.40)), 0.025);\n    float c8 = circ(vUv, vec2(0.5 * sin(u_time * 1.45), 0.5 * cos(u_time -1.45)), 0.025);\n    float c9 = circ(vUv, vec2(0.5 * sin(u_time * 1.50), 0.5 * cos(u_time -1.50)), 0.025);\n    float c10 = circ(vUv, vec2(0.5 * sin(u_time * 1.55), 0.5 * cos(u_time - 1.55)), 0.025);\n    float c11 = circ(vUv, vec2(0.5 * sin(u_time * 1.60), 0.5 * cos(u_time - 1.60)), 0.025);\n    float c12 = circ(vUv, vec2(0.5 * sin(u_time * 1.65), 0.5 * cos(u_time - 1.65)), 0.025);\n    float c13 = circ(vUv, vec2(0.5 * sin(u_time * 1.70), 0.5 * cos(u_time - 1.70)), 0.025);\n    float c14 = circ(vUv, vec2(0.5 * sin(u_time * 1.75), 0.5 * cos(u_time - 1.75)), 0.025);\n    float c15 = circ(vUv, vec2(0.5 * sin(u_time * 1.80), 0.5 * cos(u_time - 1.80)), 0.025);\n    float c16 = circ(vUv, vec2(0.5 * sin(u_time * 1.85), 0.5 * cos(u_time - 1.85)), 0.025);\n    float c17 = circ(vUv, vec2(0.5 * sin(u_time * 1.90), 0.5 * cos(u_time - 1.90)), 0.025);\n    float c18 = circ(vUv, vec2(0.5 * sin(u_time * 1.95), 0.5 * cos(u_time - 1.95)), 0.025);\n    float c19 = circ(vUv, vec2(0.5 * sin(u_time * 2.00), 0.5 * cos(u_time - 2.00)), 0.025);\n    float c20 = circ(vUv, vec2(0.5 * sin(u_time * 2.05), 0.5 * cos(u_time - 2.05)), 0.025);\n    float c21 = circ(vUv, vec2(0.5 * sin(u_time * 2.10), 0.5 * cos(u_time - 2.10)), 0.025);\n    float c22 = circ(vUv, vec2(0.5 * sin(u_time * 2.15), 0.5 * cos(u_time - 2.15)), 0.025);\n    float c23 = circ(vUv, vec2(0.5 * sin(u_time * 2.20), 0.5 * cos(u_time - 2.20)), 0.025);\n    float c24 = circ(vUv, vec2(0.5 * sin(u_time * 2.25), 0.5 * cos(u_time - 2.25)), 0.025);\n    float c25 = circ(vUv, vec2(0.5 * sin(u_time * 2.30), 0.5 * cos(u_time - 2.30)), 0.025);\n    float c26 = circ(vUv, vec2(0.5 * sin(u_time * 2.35), 0.5 * cos(u_time - 2.35)), 0.025);\n    float c27 = circ(vUv, vec2(0.5 * sin(u_time * 2.40), 0.5 * cos(u_time - 2.40)), 0.025);\n    float c28 = circ(vUv, vec2(0.5 * sin(u_time * 2.45), 0.5 * cos(u_time - 2.45)), 0.025);\n    float c29 = circ(vUv, vec2(0.5 * sin(u_time * 2.50), 0.5 * cos(u_time - 2.50)), 0.025);\n    float c30 = circ(vUv, vec2(0.5 * sin(u_time * 2.55), 0.5 * cos(u_time - 2.55)), 0.025);\n    float c31 = circ(vUv, vec2(0.5 * sin(u_time * 2.60), 0.5 * cos(u_time - 2.60)), 0.025);\n    float c32 = circ(vUv, vec2(0.5 * sin(u_time * 2.65), 0.5 * cos(u_time - 2.65)), 0.025);\n    float c33 = circ(vUv, vec2(0.5 * sin(u_time * 2.70), 0.5 * cos(u_time - 2.70)), 0.025);\n    float c34 = circ(vUv, vec2(0.5 * sin(u_time * 2.75), 0.5 * cos(u_time - 2.75)), 0.025);\n    float c35 = circ(vUv, vec2(0.5 * sin(u_time * 2.80), 0.5 * cos(u_time - 2.80)), 0.025);\n    float c36 = circ(vUv, vec2(0.5 * sin(u_time * 2.85), 0.5 * cos(u_time - 2.85)), 0.025);\n    float c37 = circ(vUv, vec2(0.5 * sin(u_time * 2.90), 0.5 * cos(u_time - 2.90)), 0.025);\n    float c38 = circ(vUv, vec2(0.5 * sin(u_time * 2.95), 0.5 * cos(u_time - 2.95)), 0.025);\n    float c39 = circ(vUv, vec2(0.5 * sin(u_time * 3.00), 0.5 * cos(u_time - 3.00)), 0.025);\n    float c40 = circ(vUv, vec2(0.5 * sin(u_time * 3.05), 0.5 * cos(u_time - 3.05)), 0.025);\n    float c41 = circ(vUv, vec2(0.5 * sin(u_time * 3.10), 0.5 * cos(u_time - 3.10)), 0.025);\n    float c42 = circ(vUv, vec2(0.5 * sin(u_time * 3.15), 0.5 * cos(u_time - 3.15)), 0.025);\n    float c43 = circ(vUv, vec2(0.5 * sin(u_time * 3.20), 0.5 * cos(u_time - 3.20)), 0.025);\n    float c44 = circ(vUv, vec2(0.5 * sin(u_time * 3.25), 0.5 * cos(u_time - 3.25)), 0.025);\n    float c45 = circ(vUv, vec2(0.5 * sin(u_time * 3.30), 0.5 * cos(u_time - 3.30)), 0.025);\n    float c46 = circ(vUv, vec2(0.5 * sin(u_time * 3.35), 0.5 * cos(u_time - 3.35)), 0.025);\n    float c47 = circ(vUv, vec2(0.5 * sin(u_time * 3.40), 0.5 * cos(u_time - 3.40)), 0.025);\n    float c48 = circ(vUv, vec2(0.5 * sin(u_time * 3.45), 0.5 * cos(u_time - 3.45)), 0.025);\n    float c49 = circ(vUv, vec2(0.5 * sin(u_time * 3.50), 0.5 * cos(u_time - 3.50)), 0.025);\n    float c50 = circ(vUv, vec2(0.5 * sin(u_time * 3.55), 0.5 * cos(u_time - 3.55)), 0.025);\n    color.rg += c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8 + c9 + c10 +\n             c11 + c12 + c13 + c14 + c15 + c16 + c17 + c18 + c19 + c20 +\n             c21 + c22 + c23 + c24 + c25 + c26 + c27 + c28 + c29 + c30 +\n             c31 + c32 + c33 + c34 + c35 + c36 + c37 + c38 + c39 + c40 +\n             c41 + c42 + c43 + c44 + c45 + c46 + c47 + c48 + c49 + c50;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Eg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ig,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Og=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    float t = u_time;\n    vUv *= Rot(t);\n    float d1 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.15 * 1.1)-.1,0.));\n    float d2 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.25 * 2.1)-.1,0.));\n    float d3 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.35 * 3.1)-.1,0.));\n    float d4 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.45 * 4.1)-.1,0.));\n    float d5 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.55 * 5.1)-.1,0.));\n    float d6 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.65 * 6.1)-.1,0.));\n    float d7 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.75 * 7.1)-.1,0.));\n    float d8 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.85 * 8.1)-.1,0.));\n    //d = length( max(abs(vUv)-.3,0.) );\n    vec3 color = vec3(0.);\n    color = vec3(fract(d1 * 10.));\n    color += vec3(fract(d2 * 10.));\n    color += vec3(fract(d3 * 10.));\n    color += vec3(fract(d4 * 10.));\n    color += vec3(fract(d5 * 10.));\n    color += vec3(fract(d6 * 10.));\n    color += vec3(fract(d7 * 10.));\n    color += vec3(fract(d8 * 10.));\n    //color = vec3(step(0.3, d) * step(d, 0.4));\n    //color = vec3(smoothstep(0.3, 0.4, d) * smoothstep(0.6, 0.5, d));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Og,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ag=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 4. -2.;\n        float d1 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.0 * 1.2) - 0.0, vUv.y + cos(u_time *  1.0 * 1.2) - 0.0)) - 0.25));\n        float d2 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.1 * 1.2) - 0.0, vUv.y + sin(u_time *  1.1 * 1.2) - 0.0)) - 0.25));\n        float d3 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.2 * 1.2) - 0.1, vUv.y + sin(u_time *  1.2 * 1.2) - 0.1)) - 0.25));\n        float d4 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.3 * 1.2) - 0.1, vUv.y + cos(u_time *  1.3 * 1.2) - 0.1)) - 0.25));\n        float d5 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.4 * 1.2) + 0.1, vUv.y + sin(u_time *  1.4 * 1.2) + 0.1)) - 0.25));\n        float d6 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.5 * 1.2) + 0.1, vUv.y + cos(u_time *  1.5 * 1.2) + 0.1)) - 0.25));\n        float d7 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.6 * 1.2) + 0.1, vUv.y + sin(u_time *  1.6 * 1.2) - 0.1)) - 0.25));\n        float d8 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.7 * 1.2) + 0.1, vUv.y + cos(u_time *  1.7 * 1.2) - 0.1)) - 0.25));\n        float d9 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.8 * 1.2) - 0.1, vUv.y + sin(u_time *  1.8 * 1.2) + 0.1)) - 0.25));\n        float d10 = step(0.05, length(abs(vec2(vUv.x +sin(u_time * 1.9 * 1.2) - 0.1, vUv.y + cos(u_time *  1.9 * 1.2) + 0.1)) - 0.25));\n    \n        vec3 color = vec3(0.);\n        color = vec3(d1 * d2 * d3 * d4 * d5 * d6 * d7 * d8 * d9 * d10);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Gg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ag,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ng=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 4. -2.;\n        float d1 = step(0.1*  abs(sin(2.0 * u_time)), length(abs(vec2(vUv.x - 1.50, vUv.y + cos(u_time *  3.0 * 0.75))) - 0.25));\n        float d2 = step(0.1*  abs(sin(2.1 * u_time)), length(abs(vec2(vUv.x - 1.25, vUv.y + cos(u_time *  3.1 * 0.75))) - 0.25));\n        float d3 = step(0.1*  abs(sin(2.2 * u_time)), length(abs(vec2(vUv.x - 1.00, vUv.y + cos(u_time *  3.2 * 0.75))) - 0.25));\n        float d4 = step(0.1*  abs(sin(2.3 * u_time)), length(abs(vec2(vUv.x - 0.75, vUv.y + cos(u_time *  3.3 * 0.75))) - 0.25));\n        float d5 = step(0.1*  abs(sin(2.4 * u_time)), length(abs(vec2(vUv.x - 0.50, vUv.y + cos(u_time *  3.4 * 0.75))) - 0.25));\n        float d6 = step(0.1*  abs(sin(2.5 * u_time)), length(abs(vec2(vUv.x - 0.25, vUv.y + cos(u_time *  3.5 * 0.75))) - 0.25));\n        float d7 = step(0.1*  abs(sin(2.6 * u_time)), length(abs(vec2(vUv.x + 0.00, vUv.y + cos(u_time *  3.6 * 0.75))) - 0.25));\n        float d8 = step(0.1*  abs(sin(2.7 * u_time)), length(abs(vec2(vUv.x + 0.25, vUv.y + cos(u_time *  3.7 * 0.75))) - 0.25));\n        float d9 = step(0.1*  abs(sin(2.8 * u_time)), length(abs(vec2(vUv.x + 0.50, vUv.y + cos(u_time *  3.8 * 0.75))) - 0.25));\n        float d10 =step(0.1*  abs(sin(2.9 * u_time)), length(abs(vec2(vUv.x + 0.75, vUv.y + cos(u_time *  3.9 * 0.75))) - 0.25));\n        float d11 =step(0.1*  abs(sin(3.0 * u_time)), length(abs(vec2(vUv.x + 1.00, vUv.y + cos(u_time *  4.0 * 0.75))) - 0.25));\n        float d12 =step(0.1*  abs(sin(3.1 * u_time)), length(abs(vec2(vUv.x + 1.25, vUv.y + cos(u_time *  4.1 * 0.75))) - 0.25));\n        float d13 =step(0.1*  abs(sin(3.2 * u_time)), length(abs(vec2(vUv.x + 1.50, vUv.y + cos(u_time *  4.2 * 0.75))) - 0.25));\n    \n        vec3 color = vec3(0.);\n        color = 1. - vec3(d1 * d2 * d3 * d4 * d5 * d6 * d7 * d8 * d9 * d10 * d11 * d12 * d13);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Bg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ng,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rotation function\nmat2 RotClock(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nmat2 RotCounter(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    float t=u_time*.25 - 0.5;\n    \n    vec3 color = vec3(0.);\n    \n    vec2 pos = vec2(0.5 - vUv.x, 0.5 - vUv.y);\n    pos*=RotClock(t*1.)*2.;\n    float r=length(pos)*2.;\n    float a=atan(pos.y,pos.x);\n    \n    vec2 pos2=vec2(.28-vUv.x,.72-vUv.y);\n    pos2*= RotCounter(t*1.)*2.;\n    float r2=length(pos2)*2.;\n    float a2=atan(pos2.y,pos2.x);\n\n    vec2 pos3=vec2(.78-vUv.x,.64-vUv.y);\n    pos3*=RotCounter(t*1.)*2.;\n    float r3=length(pos3)*2.;\n    float a3=atan(pos3.y,pos3.x);\n\n    vec2 pos4=vec2(.55-vUv.x,.19-vUv.y);\n    pos4*=RotCounter(t*1.)*2.;\n    float r4=length(pos4)*2.;\n    float a4=atan(pos4.y,pos4.x);\n    \n    \n    float f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;\n    float f2=smoothstep(-.5,1.,cos(a2*10.))*.2+.5;\n    float f3=smoothstep(-.5,1.,cos(a3*10.))*.2+.5;\n    float f4=smoothstep(-.5,1.,cos(a4*10.))*.2+.5;\n\n    vec3 d1=vec3(1.-smoothstep(f, f + 0.02, r));\n    vec3 d2=vec3(1.-smoothstep(f2,f2+.02,r2));\n    vec3 d3=vec3(1.-smoothstep(f3,f3+.02,r3));\n    vec3 d4=vec3(1.-smoothstep(f4,f4+.02,r4));\n\n    color = d1;\n    color += d2;\n    color += d3;\n    color+=d4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Vg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rotation function\nmat2 RotClock(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. -1.;\n\n    vec2 pos=vec2(vUv.x,vUv.y * abs(cos(u_time * 0.5)));\n    vec2 pos2=vec2(vUv.x * abs(sin(u_time)),vUv.y);\n    vec2 pos3=vec2(vUv.x * abs(cos(u_time)),vUv.y);\n    float t=u_time*.25-.5;\n    pos*=RotClock(t*1.);\n    pos2*=RotClock(t*1.);\n    pos3*=RotClock(t*1.);\n    \n    int tri = 3;\n    int quad= 4;\n    int pent =5;\n    int hex = 6;\n    float a = atan(pos.x, pos.y) + PI ;\n    float a2=atan(pos2.x,pos2.y)+PI;\n    float a3=atan(pos3.x,pos3.y)+PI;\n    float r3=TWO_PI/float(tri) ;\n    float r4=TWO_PI/float(quad);\n    float r6=TWO_PI/float(hex) ;\n    float d3=cos(floor(.5+a/r3)*r3 - a)*(length(vUv)) * 3.0;\n    float d4=cos(floor(.5+a2/r4)*r4 - a2)*(length(vUv)) * 1.0;\n    float d6=cos(floor(.5+a3/r6)*r6 - a3)*(length(vUv)) * 0.5;\n    float shape3= (1.-smoothstep(.4,.41,d3));\n    float shape4= (1.-smoothstep(.4,.41,d4));\n    float shape6= (1.-smoothstep(.4,.41,d6));\n    //shape = vec3(d);\n    color.xz += shape3 - 0.1;\n    color.y += shape4;\n    color.z += shape6;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Hg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Wg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n        float d = length((vec2((vUv.x) - (sin(u_time/2.)), (vUv.y) - cos(u_time/2.))) );\n        d *= atan(d, d);\n        d *= step(0.05, d);\n        float d2=length((vec2((vUv.x) - (cos(u_time/2.)),(vUv.y) - sin(u_time/2.))) );\n        d2*=atan(d2, d2);\n        d2*=step(.05,d2);\n        color = vec3(d / vUv.x, d +  vUv.y, 0.5);\n        color += vec3(d2 / vUv.x, d2 + vUv.y, 0.5);\n        color *= vec3(d);\n        color *= vec3(d2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Yg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Xg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Zg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = vUv * 3.0 - 1.5;\n        float t = u_time * u_time;\n        vUv *= Rot(t);\n        float r = length(vec2(vUv.x, vUv.y));\n        float a = atan(vUv.x, vUv.y);\n        float f = cos(a * 3.);\n        float shape = 1. - smoothstep(f, f + 0.02, r);\n        color = vec3(shape * vUv.x, shape * vUv.y, shape * vUv.x * vUv.y);  \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Qg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Zg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Jg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        float t = u_time * 0.75;\n        vUv *= Rot(t);\n        vec3 color = vec3(0.);\n        int N = 3;\n        float a  = dot(vUv.x, vUv.y) * TWO_PI * 1. - sin(u_time + TWO_PI);\n        float r = PI/(float(N) * 1.  - (sin(u_time)));\n        float d = cos(floor(.5 + a / r) * r - a) * length(vUv);\n        float shape = 1.0 - smoothstep(.05, 0.9, d);\n        color = vec3(shape * vUv.x + shape, shape * vUv.y + shape, shape);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Kg(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Jg,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $g=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. -2.;\n        float t = u_time * 0.75;\n        vUv *= Rot(t);\n        int sides = 3;\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/float(sides);\n        float shape = cos(floor(.5 + a/r) * r -a) * length(vUv + atan(sin(u_time * 0.5)));\n        float shape2 = cos(floor(.5 + a/r) * r -a) * length(vUv + atan(cos(u_time * 0.75)));\n        float shape3 = cos(floor(.5 + a/r) * r -a) * length(vUv + atan(sin(u_time * 0.6)));\n        float str = 1.0 - smoothstep(.2, .41, shape);\n        float str2 = 1.0 - smoothstep(.2, .41, shape2);\n        float str3 = 1.0 - smoothstep(.2, .41, shape3);\n        color = vec3(str, str, vUv.y * str * vUv.x);\n        color += vec3(str2, vUv.y * str2 * vUv.x, str2);\n        color += vec3(vUv.y * str3 * vUv.x, str3, str3);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$g,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 6. - 3.;\n        float a  = atan(vUv.x + cos(u_time) * 2.0, vUv.y + sin(u_time) * 2.0) + (sin(u_time * 0.5) * 3.0);\n        float r = TWO_PI/3.;\n        float d = sin(floor(.8 + a/r) * r -a ) * length(vUv);\n        float shape = 1.0 - smoothstep(.4, .41, d);\n        vec3 color = vec3(0.);\n        color = vec3(shape - 0.2, shape - 0.5, shape + 0.3);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ob=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rotation function\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 3. - 1.5;\n    float t=u_time*.25;\n    vUv*=Rot(t*1.);\n    vec3 color = vec3(0.);\n    float r = sin(vUv.x * TWO_PI);\n    float s = cos(vUv.y * TWO_PI);\n    float q = cos(vUv.y * TWO_PI * sin(u_time * 0.5));\n    float p = sin(vUv.x * TWO_PI * sin(u_time * 0.5));\n    float str = r * s + q  + p;\n    float shape = smoothstep(.8, .81, str);\n    color = vec3(shape);\n    color *= q;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ob,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ab=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rotation function\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vUv = vUv * 2. - 1.;\n    vec2 r1=abs(vUv);\n    r1*=Rot(sin(u_time) );\n    vec2 r2=abs(vUv);\n    r2*=Rot(sin(u_time * .25) );\n    vec2 r3=abs(vUv);\n    r3*=Rot(sin(u_time * .50) );\n    vec2 r4=abs(vUv);\n    r4*=Rot(sin(u_time * .75) );\n    vec2 r5=abs(vUv);\n    r5*=Rot(sin(u_time * 1.25) );\n    float s1=max(r1.x,r1.y);\n    float s2=max(r2.x,r2.y);\n    float s3=max(r3.x,r3.y);\n    float s4=max(r4.x,r4.y);\n    float s5=max(r5.x,r5.y);\n    float shape1=step(.4,s1);\n    float shape2=step(s2,.5);\n    float shape3=step(.6,s3);\n    float shape4=step(s4,.3);\n    float shape5=step(.2,s5);\n    vec3 color = vec3(0.);\n    color = vec3(shape1 * shape2);\n    color += vec3(shape3);\n    color += vec3(shape4);\n    color *= vec3(shape5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ib(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ab,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * (6. * sin(u_time * 0.5)) - (3. * sin(u_time * 0.5));\n        vec2 r1=vUv;\n        r1*=Rot(sin(-u_time * 0.5 * 3.));\n        vec2 r2=vUv;\n        r2*=Rot(sin(u_time * 0.4 * 3.));\n        vec2 r3=vUv;\n        r3*=Rot(sin(u_time * 0.6 * 3.));\n        vec2 r4=vUv;\n        r4*=Rot(sin(-u_time * 0.3 * 3.));\n        vec2 r5=vUv;\n        r5*=Rot(sin(u_time * 0.2 * 3.));\n        vec2 r6=vUv;\n        r6*=Rot(sin(-u_time * 0.1 * 3.));\n        vec3 color = vec3(0.);\n        int N = 6;\n        float a1=atan(r1.x,r1.y);\n        float a2=atan(r2.x,r2.y);\n        float a3=atan(r3.x,r3.y);\n        float a4=atan(r4.x,r4.y);\n        float a5=atan(r5.x,r5.y);\n        float a6=atan(r6.x,r6.y);\n        float b = 6.28319 / float(N);\n        vec3 shape1=vec3(smoothstep(.5, .51, cos(floor(.5 + a1/b) * b - a1) * length(vec2(vUv.x,vUv.y))));\n        vec3 shape2=vec3(smoothstep(1.1,1.11,cos(floor(.5+a2/b)*b-a2)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape3=vec3(smoothstep(.1,.11,cos(floor(.5+a3/b)*b-a3)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape4=vec3(smoothstep(1.5,1.51,cos(floor(.5+a4/b)*b-a4)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape5=vec3(smoothstep(2.1,2.11,cos(floor(.5+a5/b)*b-a5)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape6=vec3(smoothstep(2.51,2.51,cos(floor(.5+a6/b)*b-a6)*length(vec2(vUv.x,vUv.y))));\n        color = shape3;\n        color -= shape1;\n        color += shape2;\n        color -= shape4;\n        color += shape5;\n        color -= shape6;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. - 2.;\n        vec3 color = vec3(0.);\n        float cir1 = circle(vec2(vUv.x + sin(u_time * 1.0), vUv.y - 1.00), 0.0125);\n        float cir2 = circle(vec2(vUv.x + sin(u_time * 1.1), vUv.y - 0.75), 0.0125);\n        float cir3 = circle(vec2(vUv.x + sin(u_time * 1.2), vUv.y - 0.50), 0.0125);\n        float cir4 = circle(vec2(vUv.x + sin(u_time * 1.3), vUv.y - 0.25), 0.0125);\n        float cir5 = circle(vec2(vUv.x + sin(u_time * 1.4), vUv.y - 0.00), 0.0125);\n        float cir6 = circle(vec2(vUv.x + sin(u_time * 1.5), vUv.y + 0.25), 0.0125);\n        float cir7 = circle(vec2(vUv.x + sin(u_time * 1.6), vUv.y + 0.50), 0.0125);\n        float cir8 = circle(vec2(vUv.x + sin(u_time * 1.7), vUv.y + 0.75), 0.0125);\n        float cir9 = circle(vec2(vUv.x + sin(u_time * 1.8), vUv.y + 1.00), 0.0125);\n    \n        float cirv1 = circle(vec2(vUv.x  - 1.00, vUv.y  + sin(u_time * 1.0)), 0.0125);\n        float cirv2 = circle(vec2(vUv.x  - 0.75, vUv.y  + sin(u_time * 1.1)), 0.0125);\n        float cirv3 = circle(vec2(vUv.x  - 0.50, vUv.y  + sin(u_time * 1.2)), 0.0125);\n        float cirv4 = circle(vec2(vUv.x  - 0.25, vUv.y  + sin(u_time * 1.3)), 0.0125);\n        float cirv5 = circle(vec2(vUv.x  - 0.00, vUv.y  + sin(u_time * 1.4)), 0.0125);\n        float cirv6 = circle(vec2(vUv.x  + 0.25, vUv.y  + sin(u_time * 1.5)), 0.0125);\n        float cirv7 = circle(vec2(vUv.x  + 0.50, vUv.y  + sin(u_time * 1.6)), 0.0125);\n        float cirv8 = circle(vec2(vUv.x  + 0.75, vUv.y  + sin(u_time * 1.7)), 0.0125);\n        float cirv9 = circle(vec2(vUv.x  + 1.00, vUv.y  + sin(u_time * 1.8)), 0.0125);\n        color = vec3(cir1 + cir2 + cir3 + cir4 + cir5 + cir6 + cir7 + cir8 + cir9);\n        color += vec3(cirv1 + cirv2 + cirv3 + cirv4 + cirv5 + cirv6 + cirv7 + cirv8 + cirv9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ub=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 pos = vec2(0.5) - vec2(vUv.x + 0.3, vUv.y);\n        vec2 pos2 = vec2(0.5) - vec2(vUv.x, vUv.y);\n        vec2 pos3 = vec2(0.5) - vec2(vUv.x - 0.3, vUv.y);\n        vec2 pos4 = vec2(0.5) - vec2(vUv.x + 0.3, vUv.y + 0.3);\n        vec2 pos5 = vec2(0.5) - vec2(vUv.x, vUv.y + 0.3);\n        vec2 pos6 = vec2(0.5) - vec2(vUv.x - 0.3, vUv.y + 0.3);\n        vec2 pos7 = vec2(0.5) - vec2(vUv.x + 0.3, vUv.y - 0.3);\n        vec2 pos8 = vec2(0.5) - vec2(vUv.x, vUv.y - 0.3);\n        vec2 pos9 = vec2(0.5) - vec2(vUv.x - 0.3, vUv.y - 0.3);\n        vec3 color = vec3(0.);\n        float t = u_time * 0.75;\n        pos *= Rot(t);\n        pos2 *= Rot(t * 1.5);\n        pos3 *= Rot(t * 2.0);\n        pos4 *= Rot(t * 2.5);\n        pos5 *= Rot(t * 3.0);\n        pos6 *= Rot(t * 3.5);\n        pos7 *= Rot(t * 2.0);\n        pos8 *= Rot(t * 3.5);\n        pos9 *= Rot(t * 3.0);\n        float r1 = length(pos) * 7.0;\n        float r2 = length(pos2) * 7.0;\n        float r3 = length(pos3) * 7.0;\n        float r4 = length(pos4) * 7.0;\n        float r5 = length(pos5) * 7.0;\n        float r6 = length(pos6) * 7.0;\n        float r7 = length(pos7) * 7.0;\n        float r8 = length(pos8) * 7.0;\n        float r9 = length(pos9) * 7.0;\n        float a = atan(pos.y, pos.x);\n        float a2 = atan(pos2.y, pos2.x);\n        float a3 = atan(pos3.y, pos3.x);\n        float a4 = atan(pos4.y, pos4.x);\n        float a5 = atan(pos5.y, pos5.x);\n        float a6 = atan(pos6.y, pos6.x);\n        float a7 = atan(pos7.y, pos7.x);\n        float a8 = atan(pos8.y, pos8.x);\n        float a9 = atan(pos9.y, pos9.x);\n        float f = cos(a * 3.);\n        float f2 = cos(a2 * 3.);\n        float f3 = cos(a3 * 3.);\n        float f4 = cos(a4 * 3.);\n        float f5 = cos(a5 * 3.);\n        float f6 = cos(a6 * 3.);\n        float f7 = cos(a7 * 3.);\n        float f8 = cos(a8 * 3.);\n        float f9 = cos(a9 * 3.);\n        float shape = 1. - smoothstep(f, f + 0.02, r1);\n        float shape2 = 1. - smoothstep(f2, f2 + 0.02, r2);\n        float shape3 = 1. - smoothstep(f3, f3 + 0.02, r3);\n        float shape4 = 1. - smoothstep(f4, f4 + 0.02, r4);\n        float shape5 = 1. - smoothstep(f5, f5 + 0.02, r5);\n        float shape6 = 1. - smoothstep(f6, f6 + 0.02, r6);\n        float shape7 = 1. - smoothstep(f7, f7 + 0.02, r7);\n        float shape8 = 1. - smoothstep(f8, f8 + 0.02, r8);\n        float shape9 = 1. - smoothstep(f9, f9 + 0.02, r9);\n        color = vec3(shape + shape2 + shape3 + shape4 + shape5 + shape6 + shape7 + shape8 + shape9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ub,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 uv = smoothstep(size, size + vec2(0.001), vUv);\n    uv *= smoothstep(size, size + vec2(0.001), vec2(1.0) - vUv);\n    return uv.x * uv.y;\n}\n\n//cross sdf book of shaders\nfloat cross1(vec2 vUv, float size){\n    return box(vUv, vec2(size, size/4.)) + box(vUv, vec2(size/4., size));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n    vec2 translate = vec2((sin(u_time)), abs(cos(u_time)));\n    vUv += translate * 0.5;\n    float shape = cross1(vUv, 0.5);\n    color = vec3(shape);\n    color += vec3(vUv.x, vUv.y, 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var db=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 uv = smoothstep(size, size + vec2(0.001), vUv);\n    uv *= smoothstep(size, size + vec2(0.001), vec2(1.0) - vUv);\n    return uv.x * uv.y;\n}\n\n//cross sdf book of shaders\nfloat cross1(vec2 vUv, float size){\n    return box(vUv, vec2(size, size/4.)) + box(vUv, vec2(size/4., size));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 newUv = vUv;\n    vUv = vUv * 3. - 1.;\n    newUv = newUv * 3. - 1.;\n    vec2 translate = vec2(cos(u_time), sin(u_time));\n    vUv += translate;\n    //newUv += translate;\n    vec3 color = vec3(0.);\n    float shape = cross1(newUv, 0.5);\n    color = vec3(vUv, 0.);\n    color += vec3(shape);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:db,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 uv = smoothstep(size, size + vec2(0.001), vUv);\n    uv *= smoothstep(size, size + vec2(0.001), vec2(1.0) - vUv);\n    return uv.x * uv.y;\n}\n\n//cross sdf book of shaders\nfloat cross1(vec2 vUv, float size){\n    return box(vUv, vec2(size, size/4.)) + box(vUv, vec2(size/4., size));\n}\n\n//rotation 2d book of shaders\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vec2 newUv = vUv;\n    vUv = vUv * 2. - 0.5;\n    newUv = newUv * 2. - 1.;\n    newUv = rotate2d(cos(u_time) * PI) * newUv;\n    newUv += vec2(0.5);\n    vec3 color = vec3(0.);\n    float shape = cross1(newUv, 0.5);\n    float shape2 = cross1(vec2(newUv.x, newUv.y - 0.65), 0.5);\n    float shape3 = cross1(vec2(newUv.x, newUv.y + 0.65), 0.5);\n    float shape4 = cross1(vec2(newUv.x - 0.65, newUv.y), 0.5);\n    float shape5 = cross1(vec2(newUv.x + 0.65, newUv.y), 0.5);\n    color = vec3(shape + shape2 + shape3 + shape4 + shape5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv,vec2 size){\n    size=vec2(.5)-size*.5;\n    vec2 uv=smoothstep(size,size+vec2(.001),vUv);\n    uv*=smoothstep(size,size+vec2(.001),vec2(1.)-vUv);\n    return uv.x*uv.y;\n}\n\n//cross sdf book of shaders\nfloat crossSDF(vec2 vUv,float size){\n    return box(vUv,vec2(size,size/4.))+box(vUv,vec2(size/4.,size));\n}\n\n//rotation 2d book of shaders\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n//scale 2d book of shaders\nmat2 scale(vec2 s){\n    return mat2(s.x, 0.0,\n                0.0, s.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vec2 newUv = vUv;\n    newUv = newUv * 2. - 1.;\n    newUv = rotate2d(sin(u_time) * PI) * newUv;\n    newUv += vec2(0.5);\n    newUv -= vec2(0.5);\n    newUv = scale(vec2(sin(u_time) + 1.)) * newUv;\n    newUv += vec2(0.5);\n    //vUv = rotate2d(sin(u_time) * PI) * vUv;\n    vec3 color = vec3(0.);\n    float shape = crossSDF(newUv, 0.5);\n    color += vec3(shape);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _b=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // YUV to RGB matrix book of shaders\nmat3 yuv2rgb=mat3(1.,0.,1.13983,\n    1.,-.39465,-.58060,\n    1.,2.03211,0.);\n\n// RGB to YUV matrix book of shaders\nmat3 rgb2yuv=mat3(.2126,.7152,.0722,\n    -.09991,-.33609,.43600,\n    .615,-.5586,-.05639);\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= 0.5;\n    vUv *= 4.0;\n    float cir = 1. - smoothstep(1.0, 1.01, distance(vec2(vUv.x + 0.5, vUv.y + 0.5), vec2(0.5)));\n    vec3 color = rgb2yuv * vec3(sin(u_time), vUv.x + sin(u_time), vUv.y + cos(u_time));\n    color *= vec3(cir);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ub(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_b,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float cir(vec2 vUv,vec2 pos,float s){\n        return 1.-smoothstep(s,s+.01,distance(vUv,pos));\n    }\n    \n    mat2 scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 0.5;\n        vec2 newUv = vUv;\n        newUv -= vec2(0.5);\n        newUv = scale(vec2(sin((u_time * 1.5) + 1.0/1.5) + 2.0)) * newUv;\n        newUv += vec2(0.5);\n    \n        vec2 newUv2=vUv;\n        newUv2-=vec2(.5);\n        newUv2=scale(vec2(sin((u_time * 1.5) + 2.0/1.5) +2.))*newUv2;\n        newUv2+=vec2(.5);\n    \n        vec2 newUv3=vUv;\n        newUv3-=vec2(.5);\n        newUv3=scale(vec2(sin((u_time * 1.5) + 3.0/1.5) +2.))*newUv3;\n        newUv3+=vec2(.5);\n    \n        vec2 newUv4=vUv;\n        newUv4-=vec2(.5);\n        newUv4=scale(vec2(sin((u_time * 1.5) + 4.0/1.5) +2.))*newUv4;\n        newUv4+=vec2(.5);\n    \n        vec2 newUv5=vUv;\n        newUv5-=vec2(.5);\n        newUv5=scale(vec2(sin((u_time * 1.5) + 5.0/1.5) +2.))*newUv5;\n        newUv5+=vec2(.5);\n    \n        vec3 color = vec3(0.);\n        float c1=cir(newUv ,vec2(-0.2,.5),.1);\n        float c2=cir(newUv2,vec2(.15,.5),.1);\n        float c3=cir(newUv3,vec2(.5,.5),.1);\n        float c4=cir(newUv4,vec2(0.85,.5),.1);\n        float c5=cir(newUv5,vec2(1.2,.5),.1);\n        color = vec3(c1 + c2 + c3 + c4 + c5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Sb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Mb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float x){\n        return mat2(cos(x), -sin(x),\n                    sin(x), cos(x));\n    }\n    \n    mat2 Scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n    \n        vec2 newUv = vUv;\n        newUv -= vec2(0.5);\n        newUv = Scale(vec2(sin(u_time) )) * newUv;\n        newUv += vec2(0.5);\n        \n        vec2 newUv2 = vUv;\n        newUv2 -= vec2(0.5);\n        newUv2 = Scale(vec2((sin(u_time) + 1.25))) * newUv2;\n        newUv2 += vec2(0.5);\n        \n        vec2 newUv3 = vUv;\n        newUv3 -= vec2(0.5);\n        newUv3 = Scale(vec2((sin(u_time) + 1.5))) * newUv3;\n        newUv3 += vec2(0.5);\n    \n        vec2 newUv4 = vUv;\n        newUv4 -= vec2(0.5);\n        newUv4 = Scale(vec2((sin(u_time) + 1.85))) * newUv4;\n        newUv4 += vec2(0.5);\n    \n        vec2 newUv5 = vUv;\n        newUv5 -= vec2(0.5);\n        newUv5 = Scale(vec2((sin(u_time) + 1.95))) * newUv5;\n        newUv5 += vec2(0.5);\n    \n        vec2 newUv6 = vUv;\n        newUv6 -= vec2(0.5);\n        newUv6 = Scale(vec2((sin(u_time) + 1.0))) * newUv6;\n        newUv6 += vec2(0.5);\n    \n        float shape = Cir(newUv, vec2(0.5), 0.5) - Cir(newUv, vec2(0.5), 0.45);\n        float shape2 = Cir(newUv2, vec2(0.5), 0.4) - Cir(newUv2, vec2(0.5), 0.35);\n        float shape3 = Cir(newUv3, vec2(0.5), 0.3) - Cir(newUv3, vec2(0.5), 0.25);\n        float shape4 = Cir(newUv4, vec2(0.5), 0.2) - Cir(newUv4, vec2(0.5), 0.15);\n        float shape5 = Cir(newUv5, vec2(0.5), 0.6) - Cir(newUv5, vec2(0.5), 0.55);\n        float shape6 = Cir(newUv6, vec2(0.5), 0.7) - Cir(newUv6, vec2(0.5), 0.65);\n        \n    \n        color = vec3(shape + shape2 + shape3 + shape4 + shape5 + shape6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Mb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 rotate2d(float angle){\n        return mat2(cos(angle), -sin(angle),\n                    sin(angle), cos(angle));\n    }\n    \n    float box(vec2 vUv, vec2 size){\n        vUv = vUv * 2. - 1.0;\n        size = vec2(0.5) - size * 0.5;\n        vUv = rotate2d(cos(u_time) * PI) * vUv;\n        vUv += vec2(0.5);\n        vec2 sdf = smoothstep(size, size+vec2(0.01), vUv);\n        sdf *= smoothstep(size, size+vec2(0.01), vec2(1.0) - vUv);\n        vec2 newUv = vUv; \n        newUv -= vec2(0.5);\n        newUv = rotate2d(sin(u_time) * PI) * newUv;\n        newUv += vec2(0.5);\n        vec2 sdf2 = smoothstep(size, size + vec2(0.01), newUv);\n        sdf2 *= smoothstep(size, size + vec2(0.01), vec2(1.0) - newUv);\n        return (sdf.x * sdf.y) + (sdf2.x * sdf2.y);\n    }\n    \n    float shape(vec2 vUv, float size){\n        return box(vUv, vec2(size, size/8.)) +\n               box(vUv, vec2(size/8., size));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float x = shape(vUv, 1.5);\n        color = vec3(x, x * sin(u_time), x*cos(u_time));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Cb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //box sdf\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 sdf = smoothstep(size, size+vec2(0.01), vUv);\n    sdf *= smoothstep(size, size+vec2(0.01), vec2(1.0) - vUv);\n    return sdf.x * sdf.y;\n}\n\nfloat Cir(vec2 vUv, vec2 pos, float size){\n    return (1. - smoothstep(size, size + 0.01, distance(vUv, pos))) * smoothstep(size/2., size/2. + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.25, vUv.y - 0.5);\n    vUv = vUv * 2.0;\n    vec3 color = vec3(0.);\n    vec2 onevUv = vec2(vUv.x + 0.36, vUv.y);\n    onevUv.y += abs(sin(u_time * 0.75 + 0.1));\n    float oneShape = box(onevUv, vec2(0.09, 0.3));\n    color = vec3(oneShape);\n    vec2 twovUv = vec2(vUv.x, vUv.y);\n    twovUv.y += abs(sin(u_time * 0.75));\n    float twoShape = Cir(twovUv, vec2(0.4, 0.5), 0.15);\n    color += vec3(twoShape);\n    vec2 threevUv = vec2(vUv);\n    threevUv.y += abs(sin(u_time * 0.75 - 0.1));\n    float threeShape = Cir(threevUv, vec2(0.76, 0.5), 0.15);\n    color += vec3(threeShape + cos(u_time), threeShape, threeShape + sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Rb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Tb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Db=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 newUv = vec2(vUv);\n        newUv.x += abs(sin(u_time * 0.45))/ 5.5 - 0.1;\n        // newUv.y += abs(sin(u_time * 0.75))/ 50. - 0.1;\n        float shape1 = cir(vUv, vec2(0.35, 0.7), 0.1);\n        float shape2 = cir(newUv, vec2(0.35, 0.7), 0.05);\n        float shape3 = cir(vUv, vec2(0.65, 0.7), 0.1);\n        float shape4 = cir(newUv, vec2(0.65, 0.7), 0.05);\n        float shape5 = cir(vUv, vec2(0.5, 0.35), 0.2);\n        float shape6 = cir(vUv, vec2(0.5, 0.3), 0.2);\n        color = vec3(shape1);\n        color -= vec3(shape2);\n        color += vec3(shape3);\n        color -= vec3(shape4);\n        color += vec3(shape5);\n        color -= vec3(shape6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Pb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Db,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Fb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vec3 color=vec3(0.);\n    \n        vec2 uv1=vUv;\n        uv1=uv1*2.-.5;\n        vec2 t1=vec2(cos(u_time*PI*.100),sin(u_time*PI*.480));\n        uv1+=t1*.75;\n    \n        vec2 uv2=vUv;\n        uv2=uv2*2.-.5;\n        vec2 t2=vec2(cos(u_time*PI*.120),sin(u_time*PI*.460));\n        uv2+=t2*.75;\n    \n        vec2 uv3=vUv;\n        uv3=uv3*2.-.5;\n        vec2 t3=vec2(cos(u_time*PI*.140),sin(u_time*PI*.440));\n        uv3+=t3*.75;\n    \n        vec2 uv4=vUv;\n        uv4=uv4*2.-.5;\n        vec2 t4=vec2(cos(u_time*PI*.160),sin(u_time*PI*.420));\n        uv4+=t4*.75;\n    \n        vec2 uv5=vUv;\n        uv5=uv5*2.-.5;\n        vec2 t5=vec2(cos(u_time*PI*.180),sin(u_time*PI*.400));\n        uv5+=t5*.75;\n    \n        vec2 uv6=vUv;\n        uv6=uv6*2.-.5;\n        vec2 t6=vec2(cos(u_time*PI*.200),sin(u_time*PI*.380));\n        uv6+=t6*.75;\n    \n        vec2 uv7=vUv;\n        uv7=uv7*2.-.5;\n        vec2 t7=vec2(cos(u_time*PI*.220),sin(u_time*PI*.360));\n        uv7+=t7*.75;\n    \n        vec2 uv8=vUv;\n        uv8=uv8*2.-.5;\n        vec2 t8=vec2(cos(u_time*PI*.240),sin(u_time*PI*.340));\n        uv8+=t8*.75;\n    \n        vec2 uv9=vUv;\n        uv9=uv9*2.-.5;\n        vec2 t9=vec2(cos(u_time*PI*.260),sin(u_time*PI*.320));\n        uv9+=t9*.75;\n    \n        vec2 uv10=vUv;\n        uv10=uv10*2.-.5;\n        vec2 t10=vec2(cos(u_time*PI*.280),sin(u_time*PI*.300));\n        uv10+=t10*.75;\n    \n        vec2 uv11=vUv;\n        uv11=uv11*2.-.5;\n        vec2 t11=vec2(cos(u_time*PI*.300),sin(u_time*PI*.280));\n        uv11+=t11*.75;\n    \n        vec2 uv12=vUv;\n        uv12=uv12*2.-.5;\n        vec2 t12=vec2(cos(u_time*PI*.320),sin(u_time*PI*.260));\n        uv12+=t12*.75;\n    \n        vec2 uv13=vUv;\n        uv13=uv13*2.-.5;\n        vec2 t13=vec2(cos(u_time*PI*.340),sin(u_time*PI*.240));\n        uv13+=t13*.75;\n    \n        vec2 uv14=vUv;\n        uv14=uv14*2.-.5;\n        vec2 t14=vec2(cos(u_time*PI*.360),sin(u_time*PI*.220));\n        uv14+=t14*.75;\n    \n        vec2 uv15=vUv;\n        uv15=uv15*2.-.5;\n        vec2 t15=vec2(cos(u_time*PI*.380),sin(u_time*PI*.200));\n        uv15+=t15*.75;\n    \n        vec2 uv16=vUv;\n        uv16=uv16*2.-.5;\n        vec2 t16=vec2(cos(u_time*PI*.400),sin(u_time*PI*.180));\n        uv16+=t16*.75;\n    \n        vec2 uv17=vUv;\n        uv17=uv17*2.-.5;\n        vec2 t17=vec2(cos(u_time*PI*.420),sin(u_time*PI*.160));\n        uv17+=t17*.75;\n    \n        vec2 uv18=vUv;\n        uv18=uv18*2.-.5;\n        vec2 t18=vec2(cos(u_time*PI*.440),sin(u_time*PI*.140));\n        uv18+=t18*.75;\n    \n        vec2 uv19=vUv;\n        uv19=uv19*2.-.5;\n        vec2 t19=vec2(cos(u_time*PI*.460),sin(u_time*PI*.120));\n        uv19+=t19*.75;\n    \n        vec2 uv20=vUv;\n        uv20=uv20*2.-.5;\n        vec2 t20=vec2(cos(u_time*PI*.480),sin(u_time*PI*.100));\n        uv20+=t20*.75;\n        \n        float c1= Cir(uv1,vec2(.5,.5),.05);\n        float c2= Cir(uv2,vec2(.5,.5),.05);\n        float c3= Cir(uv3,vec2(.5,.5),.05);\n        float c4= Cir(uv4,vec2(.5,.5),.05);\n        float c5= Cir(uv5,vec2(.5,.5),.05);\n        float c6= Cir(uv6,vec2(.5,.5),.05);\n        float c7= Cir(uv7,vec2(.5,.5),.05);\n        float c8= Cir(uv8,vec2(.5,.5),.05);\n        float c9= Cir(uv9,vec2(.5,.5),.05);\n        float c10=Cir(uv10,vec2(.5,.5),.05);\n        float c11=Cir(uv11,vec2(.5,.5),.05);\n        float c12=Cir(uv12,vec2(.5,.5),.05);\n        float c13=Cir(uv13,vec2(.5,.5),.05);\n        float c14=Cir(uv14,vec2(.5,.5),.05);\n        float c15=Cir(uv15,vec2(.5,.5),.05);\n        float c16=Cir(uv16,vec2(.5,.5),.05);\n        float c17=Cir(uv17,vec2(.5,.5),.05);\n        float c18=Cir(uv18,vec2(.5,.5),.05);\n        float c19=Cir(uv19,vec2(.5,.5),.05);\n        float c20=Cir(uv20,vec2(.5,.5),.05);\n    \n    \n        color += vec3(c1+c2+c3+c4+c5 \n                      +c6+c7+c8+c9+c10+\n                      c11+c12+c13+c14+c15+\n                      +c16+c17+c18+c19+c20);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Fb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ib=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //triangle\nfloat Tri(vec2 vUv, float size){\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI / 3.;\n    float d = cos(floor(.5 + a/r) * r - a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\n//rotate\nmat2 Rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\n//Cir\nfloat Cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n\n    vec2 t1vUv = vUv;\n    t1vUv=Rot(sin(u_time * 0.25)*PI)*t1vUv;\n    float t1 = Tri(t1vUv, 0.1) - Tri(t1vUv, 0.075);\n    \n    vec2 t2vUv = vUv;\n    t2vUv = Rot(PI) * t2vUv;\n    t2vUv = Rot(sin(u_time * 0.25) * PI) * t2vUv;\n    float t2 = Tri(vec2(t2vUv.x, t2vUv.y), 0.1) - Tri(vec2(t2vUv.x, t2vUv.y), 0.075);\n\n    float c = Cir(vUv, vec2(0.0), 0.3) - Cir(vUv, vec2(0.0), 0.275);\n    color = vec3(t1 + t2);\n    color += vec3(c);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Eb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ib,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ob=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Shape(vec2 vUv, float x){\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * 2.5;\n        float a = atan(pos.y, pos.x);\n        float f = abs(cos(a * 4.) * sin(u_time * x));\n        return 1. - smoothstep(f, f + 0.02, r);\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        uv1 -= vec2(0.5);\n        uv1 = Rot(sin(u_time * PI * 0.5)) * uv1;\n        uv1 += vec2(0.5);\n    \n        vec2 uv2 = vUv;\n        uv2 -= vec2(0.5);\n        uv2 = Rot(sin(u_time * PI * 0.45)) * uv2;\n        uv2 += vec2(0.5);\n    \n        vec2 uv3 = vUv;\n        uv3 -= vec2(0.5);\n        uv3 = Rot(sin(u_time * PI * 0.4)) * uv3;\n        uv3 += vec2(0.5);\n        float s1 = Shape(uv1, 0.5);\n        float s2 = Shape(uv2, 0.61);\n        float s3 = Shape(uv3, 0.71);\n        color.r = s1 * abs(sin(u_time));\n        color.g = s2 * abs(cos(u_time));\n        color.b = s3;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ob,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ab=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float Tri(vec2 vUv, float size){\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.;\n        float d = cos(floor(.5 + a/r) * r -a) * length(vUv);\n        return 1. - smoothstep(size, size + 0.01, d);\n    }\n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x - 0.1, vUv.y + 0.1);\n        vUv = vUv * 9. - 4.5;\n    \n        //vUv -= vec2(1.5);\n        //vUv = Rot(PI * 0.75 + u_time) * vUv;\n        //vUv += vec2(1.5);\n    \n        vec2 rotUv1 = vUv;\n    \n        vec2 rotUv2 = Rot((PI)) * vUv;\n        rotUv2.y  = rotUv2.y + 0.22 ;\n        rotUv2.x = rotUv2.x + 0.45;\n    \n        vec2 rotUv3 = Rot((PI)) * vUv;\n        rotUv3.y  = rotUv3.y + 0.22;\n        rotUv3.x = rotUv3.x - 0.45;\n    \n        vec2 rotUv4 =  vUv;\n        rotUv4.x = rotUv4.x - 0.9 / abs(sin(u_time));\n    \n        vec2 rotUv5 =  vUv;\n        rotUv5.x = rotUv5.x + 0.9;\n    \n        vec2 rotUv6 = Rot(PI) * vUv;\n        rotUv6.y = rotUv6.y + 0.95;\n        \n        vec2 rotUv7 =  vUv;\n        rotUv7.x = rotUv7.x + 0.45;\n        rotUv7.y = rotUv7.y - 0.725;\n    \n        vec2 rotUv8 =  vUv;\n        rotUv8.x = rotUv8.x - 0.45;\n        rotUv8.y = rotUv8.y - 0.725;\n    \n        vec2 rotUv9 = Rot((PI)) * vUv;\n        rotUv9.y  = rotUv9.y + 0.22;\n        rotUv9.x = rotUv9.x - 1.35;\n    \n        vec2 rotUv10 = vUv;\n        rotUv10.x = rotUv10.x + 1.8;\n    \n        vec2 rotUv11 = Rot(PI) * vUv;\n        rotUv11.x = rotUv11.x - 0.9;\n        rotUv11.y = rotUv11.y + 0.95;\n    \n        vec2 rotUv12 = vUv;\n        rotUv12.x = rotUv12.x + 1.35 / abs(sin(u_time));\n        rotUv12.y = rotUv12.y - .725;\n    \n        vec2 rotUv13 = vUv;\n        rotUv13.y = rotUv13.y - 1.45 / abs(sin(u_time));\n    \n        vec2 rotUv14 = vUv;\n        rotUv14.y = rotUv14.y - 1.45;\n        rotUv14.x = rotUv14.x + 0.9;\n    \n        vec2 rotUv15 = Rot(PI) * vUv;\n        rotUv15.y = rotUv15.y + 1.675;\n        rotUv15.x = rotUv15.x - 0.45;\n    \n        vec2 rotUv16 = vUv;\n        rotUv16.y = rotUv16.y - 2.18;\n        rotUv16.x = rotUv16.x + 0.44;\n    \n        vec2 translate1 = vec2(cos(u_time), sin(u_time));\n        //rotUv16 += translate1 * 0.1;\n    \n        // rotUv1 =  vec2(rotUv1.x  + sin(u_time), rotUv1.y  + cos(u_time));\n        // rotUv2 =  vec2(rotUv2.x  + sin(u_time), rotUv2.y  + cos(u_time));\n        // rotUv3 =  vec2(rotUv3.x  + sin(u_time), rotUv3.y  + cos(u_time));\n        // rotUv4 =  vec2(rotUv4.x  + sin(u_time), rotUv4.y  + cos(u_time));\n        // rotUv5 =  vec2(rotUv5.x  + sin(u_time), rotUv5.y  + cos(u_time));\n        // rotUv6 =  vec2(rotUv6.x  + sin(u_time), rotUv6.y  + cos(u_time));\n        // rotUv7 =  vec2(rotUv7.x  + sin(u_time), rotUv7.y  + cos(u_time));\n        // rotUv8 =  vec2(rotUv8.x  + sin(u_time), rotUv8.y  + cos(u_time));\n        // rotUv9 =  vec2(rotUv9.x  + sin(u_time), rotUv9.y  + cos(u_time));\n        // rotUv10 = vec2(rotUv10.x + sin(u_time), rotUv10.y + cos(u_time));\n        // rotUv11 = vec2(rotUv11.x + sin(u_time), rotUv11.y + cos(u_time));\n        // rotUv12 = vec2(rotUv12.x + sin(u_time), rotUv12.y + cos(u_time));\n        // rotUv13 = vec2(rotUv13.x + sin(u_time), rotUv13.y + cos(u_time));\n        // rotUv14 = vec2(rotUv14.x + sin(u_time), rotUv14.y + cos(u_time));\n        // rotUv15 = vec2(rotUv15.x + sin(u_time), rotUv15.y + cos(u_time));\n        // rotUv16 = vec2(rotUv16.x + sin(u_time), rotUv16.y + cos(u_time));\n    \n        float tri1 = Tri(rotUv1, 0.2);\n        float tri2 = Tri(rotUv2, 0.2);\n        float tri3 = Tri(rotUv3, 0.2);\n        float tri4 = Tri(rotUv4, 0.2);\n        float tri5 = Tri(rotUv5, 0.2);\n        float tri6 = Tri(rotUv6, 0.2);\n        float tri7 = Tri(rotUv7, 0.2);\n        float tri8 = Tri(rotUv8, 0.2);\n        float tri9 = Tri(rotUv9, 0.2);\n        float tri10 = Tri(rotUv10, 0.2);\n        float tri11 = Tri(rotUv11, 0.2);\n        float tri12 = Tri(rotUv12, 0.2);\n        float tri13 = Tri(rotUv13, 0.2);\n        float tri14 = Tri(rotUv14, 0.2);\n        float tri15 = Tri(rotUv15, 0.2);\n        float tri16 = Tri(rotUv16, 0.2);\n    \n        color = vec3(tri1 + tri2 + tri3 + tri4 + tri5 + tri6 + tri7 + tri8 + tri9 + tri10 + tri11 + tri12 + tri13 + tri14 + tri15 + tri16);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Gb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ab,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Nb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float SquareIn(vec2 vUv, float size){\n        float a  = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/4.;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return (1.0 - smoothstep(size, size + 0.01, d)) - (1. - smoothstep(size - (size * 0.1), size - (size * 0.1) + 0.01, d));\n    }\n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n    \n        vec2 uv1 = vUv;\n        uv1 = Rot(sin(u_time * 0.25) * PI) * uv1;\n    \n        vec2 uv2 = vUv;\n        uv2 = Rot(cos(u_time * 0.25) * PI) * uv2;\n    \n        vec2 uv3 = vUv;\n        uv3 = Rot(sin(u_time * 0.35) * PI) * uv3;\n    \n        vec2 uv4 = vUv;\n        uv4 = Rot(cos(u_time * 0.35) * PI) * uv4;\n    \n        vec2 uv5 = vUv;\n        uv5 = Rot(sin(u_time * 0.45) * PI) * uv5;\n    \n        vec2 uv6 = vUv;\n        uv6 = Rot(cos(u_time * 0.45) * PI) * uv6;\n    \n        vec2 uv7 = vUv;\n        uv7 = Rot(sin(u_time * 0.50) * PI) * uv7;\n    \n        vec2 uv8 = vUv;\n        uv8 = Rot(cos(u_time * 0.50) * PI) * uv8;\n    \n        float s1 = SquareIn(uv1, 0.5);\n        float s2 = SquareIn(uv2, 0.5);\n    \n        float s3 = SquareIn(uv3, 0.25);\n        float s4 = SquareIn(uv4, 0.25);\n    \n        float s5 = SquareIn(uv5, 0.75);\n        float s6 = SquareIn(uv6, 0.75);\n    \n        float s7 = SquareIn(uv7, 0.125);\n        float s8 = SquareIn(uv8, 0.125);\n    \n        color = vec3(s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Bb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Nb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float shape(vec2 vUv){\n        float r = length(vUv);\n        float a  = atan(vUv.x, vUv.y);\n        float f = cos(a * dot(vUv.x,vUv.y));\n        return 1. - smoothstep(f, f + 0.01, r);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), - sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. - 2.;\n        vec3 color = vec3(0.);\n        vec2 cirUv1 = vUv;\n        cirUv1 = Rot(sin(0.25) * PI) * cirUv1;\n        vec2 cirUv2 = vUv;\n        cirUv2 = Rot(-sin(0.25) * PI) * cirUv2;\n        vec2 cirUv3 = vUv;\n        float s1 = shape(vUv);\n        float c1 = cir(vec2(cirUv1.x * 1.25, cirUv1.y * 2.5), vec2(0.35, -0.95), 0.5);\n        float c1p = cir(vec2(cirUv1.x * 1.25, cirUv1.y * 2.5), vec2(0.35, -0.95), 0.025);\n        float c2 = cir(vec2(cirUv2.x * 1.25, cirUv2.y * 2.5), vec2(-0.35, -0.95), 0.5);\n        float c2p = cir(vec2(cirUv2.x * 1.25, cirUv2.y * 2.5), vec2(-0.35, -0.95), 0.025);\n        float c3 = cir(vUv, vec2(-0.05, -0.5), 0.01);\n        float c4 = cir(vUv, vec2(0.05, -0.5), 0.01);\n        float c5 = cir(vec2(cirUv3.x / 2.0, cirUv3.y * 2.0), vec2(0., -1.45), 0.1);\n        color.g = (s1 - c1 - c2 - c3 - c4 - c5 + c1p + c2p) * abs(sin(u_time));\n        color.b = (s1-c1-c2 - c3 - c4 -c5 + c1p + c2p) * abs(cos(u_time));\n        color.r = 0.;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Vb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        size = vec2(0.5) - size * 0.5;\n        vec2 box = smoothstep(size, size + vec2(0.01), vUv);\n        box *= smoothstep(size, size + vec2(0.01), vec2(1.0)- vUv);\n        return box.x * box.y;\n    }\n    \n    float Cross(vec2 vUv, float size){\n        return Box(vUv, vec2(size, size/4.)) + \n               Box(vUv, vec2(size/4., size));\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n        vUv -= vec2(0.5);\n        vUv = Rot(sin(u_time) * PI) * vUv;\n        vUv += vec2(0.5);\n        float c1 = Cir(vUv, vec2(0.5), 0.45);\n        float c2 = 1. - Cir(vUv, vec2(0.5), 0.75);\n        float b1 = Cross(vUv, 1.);\n        color = vec3(c1 + c2 - b1);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Hb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Wb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    mat2 Scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 2. + 0.5;\n        vec3 color = vec3(0.);\n    \n        vec2 uv1 = vUv;\n        uv1 = uv1 - 0.5;\n        uv1 = Scale(vec2((sin(u_time * 0.25 * vUv *  vUv)) + 1.0 )) * uv1;\n        uv1 = uv1 + 0.5;\n    \n        vec2 uv2 = vUv;\n        uv2 = uv2 - 0.5;\n        uv2 = Scale(vec2((sin(u_time * 0.45 * vUv *  vUv)) + 1.0 )) * uv2;\n        uv2 = uv2 + 0.5;\n    \n        vec2 uv3 = vUv;\n        uv3 = uv3 - 0.5;\n        uv3 = Scale(vec2((sin(u_time * 0.65 * vUv * vUv)) + 1.0 )) * uv3;\n        uv3 = uv3 + 0.5;\n    \n        vec2 uv4 = vUv;\n        uv4 = uv4 - 0.5;\n        uv4 = Scale(vec2((sin(u_time * 0.85 * vUv * vUv)) + 1.0 )) * uv4;\n        uv4 = uv4 + 0.5;\n    \n        vec2 uv5 = vUv;\n        uv5 = uv5 - 0.5;\n        uv5 = Scale(vec2((sin(u_time * 1.05 * vUv * vUv)) + 1.0 )) * uv5;\n        uv5 = uv5 + 0.5;\n    \n        vec2 uv6 = vUv;\n        uv6 = uv6 - 0.5;\n        uv6 = Scale(vec2((sin(u_time * 1.25 * vUv * vUv)) + 1.0 )) * uv6;\n        uv6 = uv6 + 0.5;\n        \n        float c1 = Cir(uv1, vec2(0.5), 0.1);\n        float c2 = Cir(uv2, vec2(0.5), 0.1);\n        float c3 = Cir(uv3, vec2(0.5), 0.1);\n        float c4 = Cir(uv4, vec2(0.5), 0.1);\n        float c5 = Cir(uv5, vec2(0.5), 0.1);\n        float c6 = Cir(uv6, vec2(0.5), 0.1);\n    \n        color.g = c1 + c2 * cos(u_time);\n        color.b = c3 + c4 * sin(u_time);\n        color.r = c5 + c6 * cos(u_time);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Yb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Xb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Zb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Box(vec2 vUv,vec2 size){\n        size=vec2(.5)-size*.5;\n        vec2 box=smoothstep(size,size+vec2(.01),vUv);\n        box*=smoothstep(size,size+vec2(.01),vec2(1.)-vUv);\n        return box.x*box.y;\n    }\n    \n    float Cross(vec2 vUv,float size){\n        return Box(vUv,vec2(size,size/4.))+\n        Box(vUv,vec2(size/4.,size));\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a),-sin(a),\n        sin(a),cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 6. - 3.;\n        vec3 color = vec3(0.);\n    \n        vec2 uv1=vUv;\n        uv1=vec2(uv1.x+tan(u_time *1.0),uv1.y);\n        uv1-=vec2(.5);\n        uv1=Rot(sin(u_time)*PI)*uv1;\n        uv1+=vec2(.5);\n    \n        vec2 uv2=vUv;\n        uv2=vec2(uv2.x+tan(u_time *1.1),uv2.y + 0.25);\n        uv2-=vec2(.5);\n        uv2=Rot(sin(u_time)*PI)*uv2;\n        uv2+=vec2(.5);\n    \n        vec2 uv3=vUv;\n        uv3=vec2(uv3.x+tan(u_time *1.2),uv3.y - 0.25);\n        uv3-=vec2(.5);\n        uv3=Rot(sin(u_time)*PI)*uv3;\n        uv3+=vec2(.5);\n    \n        vec2 uv4=vUv;\n        uv4=vec2(uv4.x+tan(u_time *1.3),uv4.y + 0.50);\n        uv4-=vec2(.5);\n        uv4=Rot(sin(u_time)*PI)*uv4;\n        uv4+=vec2(.5);\n    \n        vec2 uv5=vUv;\n        uv5=vec2(uv5.x+tan(u_time *1.4),uv5.y - 0.50);\n        uv5-=vec2(.5);\n        uv5=Rot(sin(u_time)*PI)*uv5;\n        uv5+=vec2(.5);\n    \n        vec2 uv6=vUv;\n        uv6=vec2(uv6.x+tan(u_time*1.5),uv6.y + 0.75);\n        uv6-=vec2(.5);\n        uv6=Rot(sin(u_time)*PI)*uv6;\n        uv6+=vec2(.5);\n    \n        vec2 uv7=vUv;\n        uv7=vec2(uv7.x+tan(u_time*1.6),uv7.y - 0.75);\n        uv7-=vec2(.5);\n        uv7=Rot(sin(u_time)*PI)*uv7;\n        uv7+=vec2(.5);\n    \n        vec2 uv8=vUv;\n        uv8=vec2(uv8.x+tan(u_time*1.7),uv8.y + 1.00);\n        uv8-=vec2(.5);\n        uv8=Rot(sin(u_time)*PI)*uv8;\n        uv8+=vec2(.5);\n    \n        vec2 uv9=vUv;\n        uv9=vec2(uv9.x+tan(u_time*1.8),uv9.y-1.0);\n        uv9-=vec2(.5);\n        uv9=Rot(sin(u_time)*PI)*uv9;\n        uv9+=vec2(.5);\n    \n        vec2 uv11=vUv;\n        uv11=vec2(uv11.x+.00,uv11.y+tan(u_time*1.0));\n        uv11-=vec2(.5);\n        uv11=Rot(sin(u_time)*PI)*uv11;\n        uv11+=vec2(.5);\n    \n        vec2 uv12=vUv;\n        uv12=vec2(uv12.x+.25,uv12.y+tan(u_time*1.1));\n        uv12-=vec2(.5);\n        uv12=Rot(sin(u_time)*PI)*uv12;\n        uv12+=vec2(.5);\n    \n        vec2 uv13=vUv;\n        uv13=vec2(uv13.x-.25,uv13.y+tan(u_time*1.2));\n        uv13-=vec2(.5);\n        uv13=Rot(sin(u_time)*PI)*uv13;\n        uv13+=vec2(.5);\n    \n        vec2 uv14=vUv;\n        uv14=vec2(uv14.x+.50,uv14.y+tan(u_time*1.3));\n        uv14-=vec2(.5);\n        uv14=Rot(sin(u_time)*PI)*uv14;\n        uv14+=vec2(.5);\n    \n        vec2 uv15=vUv;\n        uv15=vec2(uv15.x-.50,uv15.y+tan(u_time*1.4));\n        uv15-=vec2(.5);\n        uv15=Rot(sin(u_time)*PI)*uv15;\n        uv15+=vec2(.5);\n    \n        vec2 uv16=vUv;\n        uv16=vec2(uv16.x+.75,uv16.y+tan(u_time*1.5));\n        uv16-=vec2(.5);\n        uv16=Rot(sin(u_time)*PI)*uv16;\n        uv16+=vec2(.5);\n    \n        vec2 uv17=vUv;\n        uv17=vec2(uv17.x-.75,uv17.y+tan(u_time*1.6));\n        uv17-=vec2(.5);\n        uv17=Rot(sin(u_time)*PI)*uv17;\n        uv17+=vec2(.5);\n    \n        vec2 uv18=vUv;\n        uv18=vec2(uv18.x+1.,uv18.y+tan(u_time*1.7));\n        uv18-=vec2(.5);\n        uv18=Rot(sin(u_time)*PI)*uv18;\n        uv18+=vec2(.5);\n    \n        vec2 uv19=vUv;\n        uv19=vec2(uv19.x-1.,uv19.y+tan(u_time*1.8));\n        uv19-=vec2(.5);\n        uv19=Rot(sin(u_time)*PI)*uv19;\n        uv19+=vec2(.5);\n    \n        float c1=Cross(uv1,.2);\n        float c2=Cross(uv2,.2);\n        float c3=Cross(uv3,.2);\n        float c4=Cross(uv4,.2);\n        float c5=Cross(uv5,.2);\n        float c6=Cross(uv6,.2);\n        float c7=Cross(uv7,.2);\n        float c8=Cross(uv8,.2);\n        float c9=Cross(uv9,.2);\n    \n        float c11=Cross(uv11,.2);\n        float c12=Cross(uv12,.2);\n        float c13=Cross(uv13,.2);\n        float c14=Cross(uv14,.2);\n        float c15=Cross(uv15,.2);\n        float c16=Cross(uv16,.2);\n        float c17=Cross(uv17,.2);\n        float c18=Cross(uv18,.2);\n        float c19=Cross(uv19,.2);\n        \n        color = vec3(c1+c2+c3+c4+c5+c6+c7+c8+c9+\n                     c11+c12+c13+c14+c15+c16+c17+c18+c19);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Qb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Zb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Jb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        float x = 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n        float y = 1. - smoothstep(size * 0.95, (size * 0.95)+0.01, distance(vUv, pos));\n        return x - y;\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        vec2 box = smoothstep(size, size+vec2(0.01), vUv);\n        box *= smoothstep(size, size+vec2(0.01), 1.0 - vUv);\n        return box.x * box.y;\n    }\n    \n    float Tri(vec2 vUv, float size){\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.0;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return 1.0 - smoothstep(size, size+0.01, d);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y-0.1);\n        //vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n        vec2 cirUv = vUv;\n        cirUv = vec2(cirUv.x, cirUv.y+0.05);\n        float c1 = Cir(cirUv, vec2(0.5), 0.35);\n        vec2 starUv = vUv;\n        starUv = starUv * 2. - 1.;\n        starUv = vec2(starUv.x, starUv.y-0.15);\n        vec2 starUv2 = vUv;\n        starUv2 = starUv2 * 2. - 1.;\n        starUv2 = vec2(starUv2.x, starUv2.y+0.125);\n        vec2 starUv3 = vUv;\n        starUv3 = starUv3 * 2. - 1.;\n        vec2 boxUv = vUv;\n        boxUv = boxUv * 2. - 0.5;\n        boxUv = vec2(boxUv.x, boxUv.y+0.25);\n        float s1 = Tri(starUv, 0.1);\n        float s2 = Tri(starUv2, 0.14);\n        float s3 = Tri(starUv3, 0.12);\n        float s4 = Box(boxUv, vec2(0.45, 0.3) );\n        color = vec3(c1 + s1 + s2 + s3 + s4);\n        gl_FragColor =  vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Kb(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Jb,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $b=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size+0.01, vUv);\n        b *= smoothstep(size, size+0.01, 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 boxUv = vUv;\n        boxUv -= vec2(0.5);\n        boxUv = Rot((u_time) *0.5) * boxUv;\n        boxUv += vec2(0.5);\n        \n        vec2 cirUv2=vUv;\n        vec2 translate2=vec2(sin(u_time * 2.0),cos(u_time * 2.0));\n        cirUv2+=translate2*0.15;\n    \n        vec2 cirUv3=vUv;\n        vec2 translate3=vec2(0.,cos(u_time*2.));\n        cirUv3+=translate3*.3;\n    \n        vec2 cirUv4=vUv;\n        vec2 translate4=vec2(sin(u_time*2.),0.);\n        cirUv4+=translate4*.3;\n    \n        float box1 = Box(boxUv, vec2(0.15));\n        float box2 = Box(boxUv, vec2(0.14));\n        float cir2 = Cir(cirUv2, vec2(0.5, 0.5), 0.05);\n        float cir3=  Cir(cirUv3,vec2(.5,.5),.05);\n        float cir4=  Cir(cirUv4,vec2(.5,.5),.05);\n    \n        color = vec3(box2 - box1);\n        color += cir2;\n        color += cir3; \n        color += cir4;\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function n_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$b,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var e_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float BoxBorder(vec2 vUv, vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        float box1 = b.x * b.y;\n        vec2 b2 = smoothstep(size - vec2(0.01), (size - vec2(0.01)) + vec2(0.01), vUv);\n        b2 *=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1. - vUv);\n        float box2 = b2.x * b2.y;\n        return box2 - box1;\n    }\n    \n    float CirBorder(vec2 vUv, vec2 pos, float size){\n        float a = 1.  - smoothstep(size, size + 0.01, distance(vUv, pos));\n        float b = 1. - smoothstep(size - 0.01, size, distance(vUv, pos));\n        return a - b;\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n    \n        vec2 uv1 = vUv;\n        uv1-=vec2(0.5);\n        uv1=Rot(sin(u_time)*PI)*uv1;\n        uv1+=vec2(0.5);\n    \n        vec2 uv2=vUv;\n        uv2-=vec2(.5);\n        uv2=Rot(sin(u_time * 1.02)*PI)*uv2;\n        uv2+=vec2(.5);\n    \n        vec2 uv3=vUv;\n        uv3-=vec2(.5);\n        uv3=Rot(sin(u_time * 1.04)*PI)*uv3;\n        uv3+=vec2(.5);\n    \n        vec2 uv4=vUv;\n        uv4-=vec2(.5);\n        uv4=Rot(sin(u_time*1.06)*PI)*uv4;\n        uv4+=vec2(.5);\n    \n        vec2 uv5=vUv;\n        uv5-=vec2(.5);\n        uv5=Rot(sin(u_time*1.08)*PI)*uv5;\n        uv5+=vec2(.5);\n    \n        vec3 color = vec3(0.);\n        float b1 = BoxBorder(uv1, vec2(0.25));\n        float c1 = CirBorder(vUv, vec2(0.5), 0.25);\n        float b2=BoxBorder(uv2,vec2(.3));\n        float c2=CirBorder(vUv,vec2(.5),.2);\n        float b3=BoxBorder(uv3,vec2(.35));\n        float c3=CirBorder(vUv,vec2(.5),.15);\n        float b4=BoxBorder(uv4,vec2(.40));\n        float c4=CirBorder(vUv,vec2(.5),.1);\n        float b5=BoxBorder(uv5,vec2(.45));\n        float c5=CirBorder(vUv,vec2(.5),.05);\n        color = vec3(b1 + c1 + b2 + c2 + b3 + c3 + b4 + c4 + b5 + c5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function t_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:e_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var o_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                 sin(a), cos(a)) * vec2(vUv.x * cos(u_time * 0.25), vUv.y * sin(u_time * 0.25));\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.);\n        vUv = Rot(vUv, PI * 0.25 * u_time);\n        color = vec3(vUv, 0.0);\n        color = vec3(Cir(vUv, vec2(0.5), 0.2));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function r_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:o_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var a_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Rot(vUv, PI * u_time * 0.25);\n        vUv = Tile(vUv, 10.5);\n        float c = Cir(vUv, vec2(0.5), 0.25);\n        color += vec3(c * abs(sin(u_time)), c * abs(cos(u_time)), c * abs(sin(u_time)));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function i_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:a_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var v_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv, float z){\n        vUv *= z;\n        return fract(vUv);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.);\n        vUv = Rot(vUv, PI * u_time * 0.25);\n        color = vec3(BoxBorder(vUv, vec2(0.05)));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function c_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:v_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var l_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        vUv = fract(vUv);\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vUv = vUv * sin(u_time * 0.25);\n        //vUv = Rot(vUv, cos(u_time) + PI + 2.0) * vUv;\n        vec3 color = vec3(0.);\n    \n        vec2 boxUv = vUv;\n        boxUv = Tile(boxUv, 3.0);\n        boxUv=Rot(boxUv, sin(u_time * 0.5)*PI);\n        float box = BoxBorder(boxUv, vec2(0.25));\n    \n        vec2 boxUv2=vUv;\n        boxUv2=Tile(vec2(boxUv2.x - 1.5, boxUv2.y - 1.5),3.);\n        boxUv2=Rot(boxUv2,cos(u_time * 0.5)*PI);\n        float box2=BoxBorder(boxUv2,vec2(.25));\n    \n    \n        color = vec3(box + box2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function s_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:l_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var u_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv,float zoom){\n        vUv*=zoom;\n        vUv.x+=(step(1.,mod(vUv.y,2.))*.5) * sin(u_time);\n    \n        \n        //vUv.y-=step(1.,mod(vUv.x,2.));\n        // vUv.y += step(1., mod(vUv.x, 4.0)) * sin(u_time);\n        //vUv.y += cos(u_time);\n        return fract(vUv);\n    }\n    \n    vec2 Tile2(vec2 vUv,float zoom){\n        vUv*=zoom;\n        vUv.x+=(step(1.,mod(vUv.y,2.))*.5) * sin(u_time);\n        \n        //vUv.y-=step(1.,mod(vUv.x,2.));\n        // vUv.y += step(1., mod(vUv.x, 4.0)) * sin(u_time);\n        //vUv.y += cos(u_time);\n        return fract(vUv);\n    }\n    \n    \n    \n    float Tri(vec2 vUv,float size){\n        vUv-=.5;\n        float a=atan(vUv.x,vUv.y)+PI;\n        float r=TWO_PI/3.;\n        float d=cos(floor(.5+a/r)*r-a)*length(vUv);\n        return 1.-smoothstep(size,size+.01,d);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vec3 color=vec3(0.);\n        \n        vec2 newUv=vUv;\n        newUv.y+=cos(u_time*.1);\n        newUv=Tile(newUv,6.);\n        float t1=Tri(newUv,.25);\n    \n        vec2 newUv2=vUv;\n        newUv2 = Rot(newUv2, (PI));\n        newUv2.y += cos(u_time * 0.1);\n        newUv2 =Tile2(newUv2,6.);\n        float t2=Tri(newUv2,.25);\n    \n        color=vec3(t1+t2);\n        \n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function f_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:u_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var p_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x-=step(1.,mod(vUv.y,2.))+u_time;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * (0.5 + u_time);\n        \n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n    \n            }else{\n                vUv.x-= fract(t) * 2.;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;\n            } else {\n                vUv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Tri(vec2 vUv, float size){\n        vUv -= 0.5;\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.0;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return 1.0 - smoothstep(size, size+0.01, d);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 10.0, 0.25);\n        float c1 = Cir(vUv, vec2(0.5), 0.25);\n    \n        vec2 newUv = vUv;\n        newUv = Rot(vUv, sin(u_time + 2.0) * PI);\n        float t1 = Tri(newUv, 0.1);\n        \n        color = vec3(c1 - t1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function m_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:p_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var d_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    vec2 Tiles(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*8.)>.5){\n                vUv.x+=fract(t)*2.;\n                \n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        }else{\n            if(fract(vUv.x * 8.)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tiles(vUv, 2., 0.25);\n        float b1 = Box(vUv, vec2(0.25));\n        color = vec3(b1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function h_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:d_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var x_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        vUv = fract(vUv);\n        return vUv;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Truchet(vec2 vUv){\n        vUv *= 2.0;\n        float index = 0.0;\n        index += step(1., mod(vUv.x, 2.0));\n        index += step(1., mod(vUv.y, 2.0)) * 2.0;\n        vUv = fract(vUv);\n        if(index == 1.0){\n            vUv = Rot(vUv, PI * 0.5 * sin(u_time));\n        } else if (index == 2.0){\n            vUv = Rot(vUv, PI * -0.5 * sin(u_time));\n        } else if (index == 3.0){\n            vUv = Rot(vUv, PI);\n        }\n        return vUv;\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 c1 = vec3(Cir(vUv, vec2(0.5), 0.35));\n        vUv = Rot(vUv, (u_time * 0.25));\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 3.);\n        vUv = Truchet(vUv);\n        vec3 pattern = vec3(step(vUv.x,vUv.y));\n        \n        color = c1 * pattern;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function y_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:x_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var g_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    vec2 Translate(vec2 vUv){\n        vUv.x = vUv.x + sin(u_time) * 0.25;\n        vUv.y = vUv.y + cos(u_time) * 0.25;\n        return vUv;\n    }\n    \n    vec2 Translate2(vec2 vUv){\n        vUv.x = vUv.x + cos(u_time) * 0.25;\n        vUv.y = vUv.y + sin(u_time) * 0.25;\n        return vUv;\n    }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        float index = 0.0;\n        index += step(1., mod(vUv.x, 2.0));\n        index += step(1., mod(vUv.y, 2.0)) * 2.0;\n        vUv = fract(vUv);\n        if(index == 1.0){\n            vUv = Translate(vUv);\n        } else if (index == 2.0){\n            vUv = Translate2(vUv);\n        } else if (index == 3.0){\n            vUv = Translate(vUv);\n        } else{\n            vUv = Translate2(vUv);\n        }\n        vUv = fract(vUv);\n        return vUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.0);\n        float c = Cir(vUv, vec2(0.5), 0.15);\n        color = vec3(c);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function b_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:g_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var __=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float angle){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(angle), -sin(angle),\n    //                sin(angle), cos(angle)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        float x = 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n        float y = 1. - smoothstep(size * 0.25, (size * 0.25) + 0.01, distance(vUv, pos));\n        return x - y;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        uv1=Rot(vUv,(u_time*PI * 0.15));\n        uv1 = Tile(uv1, 3.0);\n        float pattern1 = Cir(uv1, vec2(0.5), (0.005 + abs(sin(u_time * 0.5)/1.)));\n        color = vec3(pattern1 * abs(sin(u_time * 0.25)), pattern1 * abs(cos(u_time * 0.25)), 1.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function U_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:__,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var w_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv -= 0.5;\n        vUv *= zoom + sin(u_time / 1.0);\n        vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    \n    float Tri(vec2 vUv,float size){\n        vUv-=.5;\n        \n        float a=atan(vUv.x,vUv.y)+PI;\n        float r=TWO_PI/3.;\n        float d=cos(floor(.5+a/r)*r-a)*length(vUv);\n        float s1 = 1. - smoothstep(size,size+.01,d);\n        return s1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.0);\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, -sin(PI + u_time));\n        vUv=Rot(vUv,sin(PI+u_time));\n        float s1 = Tri(vUv, 0.25);\n        float s2 = Tri(newUv,.1);\n        color = vec3(s1 - s2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function S_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:w_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var M_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * (0.5 + u_time);\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float angle){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(angle), -sin(angle),\n    //                sin(angle), cos(angle)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n                vUv.x-= sin(u_time);\n            }else{\n                vUv.x-= fract(t) * 2.;\n                vUv.x+= cos(u_time);\n            }\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;\n                vUv.y -= sin(u_time);\n            } else {\n                vUv.y -= fract(t) * 2.;\n                vUv.y += cos(u_time);\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        float b1 = b.x * b.y;\n        vec2 bb = smoothstep(size-0.05, (size-0.05) + vec2(0.01), vUv);\n        bb *= smoothstep(size-0.05, (size-0.05) + vec2(0.01), 1. - vUv);\n        float b2 = bb.x * bb.y;\n        return b2 - b1;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 8.0, 0.1);\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, (sin(u_time + 2.0) * PI * 2.0) * 0.25);\n        float box = Box(newUv, vec2(0.025));\n        float cir = Cir(vUv, vec2(0.5), 0.25);\n        color = vec3(box + cir);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function z_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:M_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var k_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile1(vec2 vUv, float z){\n        vUv *= z;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n       float x = 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n       float y = 1. - smoothstep((size + 0.02), (size + 0.02) + 0.01, distance(vUv, pos));\n       return y - x;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        vUv = Tile1(vUv, 4.0);\n        vec2 newUv = vUv;\n        vUv = Rot(vUv, -sin(u_time * 0.5) * PI);\n        float p1 = Cir(vUv, vec2(0.5), 0.25);\n        float p2 = Cir(vUv, vec2(0.275, 0.5), 0.25);\n        float p3 = Cir(vUv, vec2(0.725, 0.5), 0.25);\n        float p4 = Cir(vUv, vec2(0.5, 0.275), 0.25);\n        float p5 = Cir(vUv, vec2(0.5, 0.725), 0.25);\n        vec3 pattern1 = vec3(p1 + p2 + p3 + p4 + p5);\n        \n        \n        newUv = Rot(newUv, sin(u_time * 0.5) * PI);\n        float p6 = Cir(newUv, vec2(0.5), 0.1);\n        float p7 = Cir(newUv, vec2(0.29, 0.5), 0.1);\n        float p8 = Cir(newUv, vec2(0.71, 0.5), 0.1);\n        float p9 = Cir(newUv, vec2(0.5, 0.29), 0.1);\n        float p10 = Cir(newUv, vec2(0.5, 0.71), 0.1);\n        vec3 pattern2 = vec3(p6 + p7 + p8 + p9 + p10);\n    \n        color = pattern1;\n        color += pattern2;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function C_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:k_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var T_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2 - box1;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv, float z){\n        vUv *= z;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 4.0);\n    \n        vec2 uv1 = vUv;\n        uv1 = Rot(uv1, PI * (0.5 * sin(u_time)));\n        float b = BoxBorder(uv1, vec2(0.15));\n        color = vec3(b);\n    \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, PI * (0.25 * sin(u_time)));\n        float b2 = BoxBorder(uv2, vec2(0.15));\n        color += vec3(b2);\n    \n        vec2 uv3 = vUv;\n        uv3 = Rot(uv3, PI * (0.125 * sin(u_time)));\n        float b3 = BoxBorder(uv3, vec2(0.15));\n        color += vec3(b3);\n    \n        vec2 uv4 = vUv;\n        uv4 = Rot(uv4, PI * ((0.125/2.0) * sin(u_time)));\n        float b4 = BoxBorder(uv4, vec2(0.15));\n        color += vec3(b4);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function R_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:T_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var D_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    //PIXEL SPIRIT\n    float Stroke(float x, float s, float w){\n        float d = smoothstep(s, s+0.01, x + w * 0.5) - smoothstep (s, s + 0.01,x-w * 0.5);\n        return clamp(d, 0., 1.);\n    }\n    \n    float Flip(float v, float pct){\n        return mix(v, 1. - v, pct);\n    }\n    \n    float Cir(vec2 vUv){\n        return length(vUv - 0.5) * 2.;\n    }\n    \n    vec3 Bridge(vec3 c, float d, float s, float w){\n        c *= 1. - Stroke(d, s, w * 2.);\n        return c + Stroke(d, s, w);\n    }\n    //PIXEL SPIRIT\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        //vUv = vUv * 2.0 - 0.5;\n        vUv = Tile(vUv, 2.0);\n        vUv.x = Flip(vUv.x, step(0.5, vUv.y));\n        vec2 offset =  vec2(.15/2.0, .0);\n        vec2 offset2 =  vec2(.45/2.0, .0);\n        vUv = Rot(vUv, sin(u_time));\n        float l = Cir(vUv + offset);\n        float r = Cir(vUv - offset);\n        float b = Cir(vUv + offset2);\n        float t = Cir(vUv - offset2);\n        color += Stroke(l, .4/2.0, .075/2.0);\n        color = Bridge(color, r, .4/2.0, .075/2.0);\n        //color += Stroke(b, .4, .075);\n        color = Bridge(color, b, .4/2.0, .075/2.0);\n        color = Bridge(color, t, .4/2.0, .075/2.0);\n        //color = Bridge(color, t, .4, .075);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function P_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:D_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var F_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile1(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n            }else{\n                vUv.x-= fract(t) * 2.; \n            }\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;  \n            } else {\n                vUv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    float Square(vec2 vUv, vec2 size){\n        vec2 s = smoothstep(size, size + vec2(0.01), vUv);\n        s *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return s.x * s.y;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        uv1 = Tile2(uv1, 5.0, 0.1);\n        uv1 =  Rot(uv1, sin(u_time) * PI);\n        float c1 = Cir(uv1, vec2(0.5), 0.25);\n        float s1 = Square(uv1, vec2(0.25));\n        float c2 = Cir(uv1, vec2(0.5), 0.125);\n        vec3 shape1 = vec3(s1 -c1 + c2);\n        color = shape1;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function j_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:F_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var I_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile(vec2 vUv, float zoom, float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    mat2 Scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    float CirOutline(vec2 vUv, vec2 pos, float size){\n        float outer = 1. - smoothstep((size + 0.025), (size + 0.025) + 0.01, distance(vUv, pos));\n        float inner = 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n        return outer - inner;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        vec2 uv2 = vUv;\n        uv1 = Tile(uv1, 4.0, 0.25);\n        uv2 = Tile(uv2,4., 0.25);\n        uv2 -= vec2(0.5);\n        uv2 = Scale(vec2(sin(u_time * 1.5) + 1.65)) * uv2;\n        uv2+=vec2(.5);\n        float c1 = CirOutline(uv1, vec2(0.5), 0.475);\n        float c2 = Cir(uv2, vec2(0.5), 0.25);\n        color = vec3(c1 + c2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function E_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:I_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var O_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.05),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.05),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    vec2 Tile(vec2 vUv,float zoom,float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    float Cir(vec2 vUv,vec2 pos,float size){\n        return 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Rot(vUv, PI * 0.25);\n        vUv = Tile(vUv, 4.0, 0.125);\n        vec2 uv1 = vUv;\n        uv1 = Rot(vUv, sin(u_time) * PI);\n        float b1 = BoxBorder(uv1, vec2(0.15));\n        float c1=CirOutline(vUv,vec2(.5),.475);\n        float c2=Cir(vUv,vec2(.5),.25);\n        float c3=Cir(vUv,vec2(.5),.25 /2.0);\n        vec3 shape = vec3(b1 + c1 + c2 - c3);\n        color = shape;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function L_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:O_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var A_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    vec2 Tile(vec2 vUv,float zoom,float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    float Cir(vec2 vUv,vec2 pos,float size){\n        return 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 translate = vec2(cos(u_time), sin(u_time));\n        vUv = Tile(vUv, 4.0, 0.25);\n        float c1 = CirOutline(vUv, vec2(0.5), 0.47);\n        float b1 = BoxBorder(vUv, vec2(0.));\n        vUv += vec2(translate.x * 0.25, translate.y * 0.25 + 0.25);\n        \n        float s1 = Cir(vUv, vec2(0.5, 0.75), 0.25);\n        float s2 = Cir(vUv, vec2(0.5, 0.25), 0.25);\n        \n        float shape = s1;\n        color = vec3(c1);\n        color += shape;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function G_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:A_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var N_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv -= 0.5;\n        vUv = Tile(vUv, 5.0 * sin(u_time * 0.05 * 2.0));\n        float c1 = CirOutline(vUv, vec2(0.5,0.75), 0.25);\n        float c2 = CirOutline(vUv, vec2(0.75,0.75), 0.25);\n        float c3 = CirOutline(vUv, vec2(0.5,0.5), 0.25);\n        float c4 = CirOutline(vUv, vec2(0.75,0.5), 0.25);\n        float c5 = CirOutline(vUv, vec2(0.5,0.25), 0.25);\n        float c6 = CirOutline(vUv, vec2(0.25,0.75), 0.25);\n        float c7 = CirOutline(vUv, vec2(0.25,0.25), 0.25);\n        float c8 = CirOutline(vUv, vec2(0.25,0.75), 0.25);\n        float c9 = CirOutline(vUv, vec2(0.25,0.5), 0.25);\n        float c10 =CirOutline(vUv, vec2(0.75,0.25), 0.25);\n        color = vec3(c1+c2+c3+c4+c5+c6+c7+c8+c9+c10);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function B_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:N_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var q_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.02),vUv);\n        b*=smoothstep(size,size+vec2(.02),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = Rot(vUv, sin(u_time * 0.05) * PI);\n        vUv -= 0.5;\n        vUv = Tile(vUv, 3.0 + sin(u_time * 0.5));\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, PI * 0.25);\n        vec2 uv3 = uv1;\n        vec2 uv4 = uv2;\n        vec2 uv5 = uv1;\n        vec2 uv6 = uv2;\n        uv3.x += 0.25;\n        uv4.x += 0.25;\n        uv4.y -= 0.25;\n        uv5.x -= 0.25;\n        uv6.x -= 0.25;\n        uv6.y += 0.25;\n        float b1 = BoxBorder(uv1, vec2(0.2));\n        float b2 = BoxBorder(uv2, vec2(0.2));\n        float b3 = BoxBorder(uv3, vec2(0.2));\n        float b4 = BoxBorder(uv4, vec2(0.2));\n        float b5 = BoxBorder(uv5, vec2(0.2));\n        float b6 = BoxBorder(uv6, vec2(0.2));\n        vec3 shape1 = vec3(b1 + b2);\n        vec3 shape2 = vec3(b3 + b4);\n        vec3 shape3 = vec3(b5 + b6);\n        color = shape1 + shape2 + shape3;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function V_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:q_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var W_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float random = rand(vUv);\n        color = vec3(random);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function H_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:W_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var X_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(14.29384023894, 89.28340928374))));\n    }\n    \n    vec2 truchetPattern(vec2 vUv, float index){\n        index = fract((index - 0.5) * 2.0);\n        if(index > 0.75 *sin(u_time * 0.1) ){\n            vUv = vec2(1.0) - vUv;\n        } else if (index > 0.5 *sin(u_time * 0.1)){\n            vUv = vec2(1.0- vUv.x , vUv.y);\n        } else if (index > 0.25 * sin(u_time * 0.1)){\n            vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 8.0;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = truchetPattern(fpos , random(ipos));\n        float pattern = smoothstep(tile.x-0.3,tile.x,tile.y)-\n                smoothstep(tile.x,tile.x+0.3,tile.y);\n        float circles = (step(length(tile),0.6) -\n                  step(length(tile),0.4) ) +\n                 (step(length(tile-vec2(1.)),0.6) -\n                  step(length(tile-vec2(1.)),0.4) );\n        color = vec3(circles);\n        //color = vec3(fpos, 0.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Y_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:X_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Z_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders random function\nfloat random(vec2 vUv){\n    return fract(sin(dot(vUv.xy,\n                vec2(12.9898,78.233)))*\n            43758.5453123 - fract(u_time));\n        }\n\nvec2 Tile2(vec2 vUv,float zoom,float speed){\n    vUv*=zoom;\n    float t=u_time*speed;\n    if(fract(t)>.5){\n        if(fract(vUv.y*.5)>.5){\n            vUv.x+=fract(t)*2.;\n        }else{\n            vUv.x-=fract(t)*2.;\n        }\n    }else{\n        if(fract(vUv.x*.5)>.5){\n            vUv.y+=fract(t)*2.;\n        }else{\n            vUv.y-=fract(t)*2.;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv=Tile2(vUv,5.,0.0001);\n    vec3 color=vec3(0.);\n    vUv *= 10.;\n    vec2 i = floor(vUv);\n    vec2 f = fract(vUv);\n    \n    float shape = random((i));\n    \n    color = vec3(shape+sin(u_time), shape-cos(u_time), 0.);\n    \n    gl_FragColor = vec4(color, random(i));\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Q_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Z_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var J_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy,\n                vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    //book of shaders\n    vec2 truchet(vec2 vUv, float index){\n        index = fract((index - 0.5) * 2.0);\n        if(index > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (index > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (index > 0.25){\n            vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.125),(size+.125)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0);\n        vUv *= 5.0;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = truchet(fpos, random(ipos));\n        float y = CirOutline(tile, vec2(0.5), 0.35);\n        y *= smoothstep(tile.x-.3,tile.x,abs(tile.y + sin(u_time)))-\n            smoothstep(tile.x,tile.x+.3,abs(tile.y + cos(u_time)));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function K_(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:J_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float rand (float x){\n        return fract(sin(x) * 1000000.0);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025) * rand(15.5),(size+.085)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01 ,distance(vUv ,pos ));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = Rot(vUv, sin(u_time * 5000.) * PI );\n        vec3 color = vec3(0.);\n        float cir = CirOutline(vUv, vec2(0.5), 0.25);\n        color = vec3(cir);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand (float x){\n        return fract(sin(x) * 100000.0);\n    }\n    \n    float Plot(vec2 vUv, float x){\n        return smoothstep(x - (0.01), x, vUv.y) -\n               smoothstep(x, x + (0.02), vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv;\n        float y = 1. - rand(vUv.x + (u_time * 0.000005) );\n        float pct = Plot(vUv, y);\n        vec3 color = vec3(0.);\n        color = vec3(pct);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.4859, 75.2389234))) * 45687.28934720);\n    }\n    \n    float rand2(float x){\n        return fract(sin(x) * 10000.0);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand2(100. + p * 0.00001) + rand2(p.x) * 0.5);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n    \n        vec2 grid = vec2(20.0, 15.0);\n        vUv *= grid;\n    \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n    \n        vec2 vel = vec2(u_time * (rand2(1.0)) * max(grid.x, grid.y));\n        vel *= vec2(0.0, 1.0) * rand2(1.0 + ipos.x);\n    \n        vec2 offset = vec2(0., 0.);\n        color.g = pattern(vUv + offset, vel, rand2(0.2) * 0.9);\n    \n        color *= step(0.5, fpos.x);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.4859, 75.2389234))) * 45687.28934720);\n    }\n    \n    float rand2(float x){\n        return fract(sin(x) * 10000.0);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand2(100. + p * 0.00001) + rand2(p.x) * 0.1);\n    }\n    \n    float pattern2(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand2(100. + p * 0.00001) + rand2(p.y) * 0.1);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n    \n        vec2 grid = vec2(50.0, 50.0) ;\n        vUv *= grid;\n    \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n    \n        vec2 vel = vec2(u_time * (rand2(10.0)) * max(grid.y, grid.x));\n        vel *= vec2(-1., 0.0) * rand2(1.0 + ipos.y);\n    \n        vec2 vel2 = vec2(u_time * (rand2(10.0)) * max(grid.y, grid.x));\n        vel2 *= vec2(0.0, 1.0) * rand2(1.0 + ipos.x);\n    \n        vec2 offset = vec2(0., 0.);\n        color.r = pattern(vUv + offset, vel, rand2(0.1) * 0.5);\n        color.g = pattern2(vUv + offset, vel2, rand2(0.1) * 0.15);\n    \n        color *= 1. - step(0.99999999, fpos.y);\n        color += step(0.99999, fpos.x);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        \n        vec2 b=smoothstep(size,size+vec2(.02),vUv);\n        b*=smoothstep(size,size+vec2(.02),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        float x = random(vec2(vUv));\n        vec3 color = vec3(0.);\n        vec2 ipos = floor(vUv); //integer\n        vec2 fpos = fract(vUv); //fraction\n        float b1 = BoxBorder(vUv, vec2(0.0) + x * abs(sin(u_time * 0.25)));\n        color = vec3(b1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // vec2 Rot(vec2 vUv,float a){\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float random(in float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(12.9898,78.233)))*43758.5453123);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv,vec2 v,float t){\n        vec2 p=floor(vUv+v);\n        return step(t,random(100.+p*.00001)+random(p.x)*.1);\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        \n        vUv=vUv*2.-1.;\n        vec2 cUv=vUv;\n        vUv = Rot(vUv, u_time * 0.25);\n        \n        vec3 color=vec3(0.);\n    \n        vec2 grid=vec2(25.,5.);\n        vUv*=grid + sin(u_time);\n    \n        \n        \n        vec2 ipos=floor(vUv);\n        vec2 fpos=fract(vUv);\n    \n        vec2 vel=vec2(u_time*.2*max(grid.y +sin(u_time),grid.x ));\n        vel*=vec2(0.,1.)*random(1.+ipos.x);\n    \n        vec2 vel2=vec2(u_time*0.2* max(grid.x +sin(u_time) ,grid.y + sin(u_time)));\n        vel2*=vec2(-1.,0.)*random(1.+ipos.y);\n    \n        vec2 offset2=vec2(1.1,1.0);\n        vec2 offset=vec2(1.0,1.1);\n        \n        color= vec3(pattern(vUv+offset,vel2,1.0));\n        color+= vec3(pattern(vUv+offset2,vel,1.0));\n    \n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nfloat plot(vec2 vUv,float pct){\n    return smoothstep(pct-.04,pct,vUv.y)-\n    smoothstep(pct,pct+.04,vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv.x *= 0.5;\n    vUv.y *= 0.5;\n    vUv.y -= 0.0;\n    vec2 ipos=floor(vUv);// integer\n    vec2 fpos=fract(vUv);// fraction\n    vec3 color = vec3(0.);\n    float y = fract(sin(vUv.x + sin(u_time)) * 100000.0);\n    float pct = plot(vUv, y);\n    color = (1. - pct) * color + pct * vec3(0.0, 1., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    \nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(14.4385, 89.2384972))) * 56937.29837492);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 20.0;\n    vec2 ipos = floor(vec2(vUv.x, vUv.y + (u_time)));\n    vec2 fpos = fract(vUv);\n    float pattern = rand2(vec2(ipos.x + (0.0000025 * u_time), ipos.y));\n    color.b = (pattern);\n    color *= 1. - vec3(fpos, 0.0);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand2(float x){\n        return fract(sin(x) * 56937.29837492);\n    }\n    \n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(14.4385, 89.2384972))) * 56937.29837492);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 2.0 - 1.0;\n        vec2 cUv = vUv;\n        vUv = vec2(rand2(vUv.x) + (u_time * 0.0000002), rand2(vUv.y));\n        vUv = vUv * 20.;\n        vec3 color = vec3(0.);\n        float x = rand2(vec2(vUv.x, vUv.y));\n        float y = pow((x), 100.);\n        float cir = Cir(cUv, vec2((0.5 * x) + sin(u_time * 0.5), 0.5), 0.25);\n        float cir2 = Cir(cUv, vec2(0.5, (0.5 * x) + sin(u_time * 0.5)), 0.25);\n        color = vec3(cir + cir2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.9898, 78.233))) * 43758.649273);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 10.0;\n        vec2 ipos = floor(vec2(vUv.x - u_time, vUv.y));\n        vec2 fpos = fract(vec2(vUv.x + u_time, vUv.y));\n        vec3 color = vec3(0.);\n        float y = rand2(ipos);\n        float x = rand2(fpos);\n    \n        color = vec3(y*x * y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//random\n\nfloat rand2(in float x){\n    return fract(sin(x)*1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(23.487503, 89.37610982))) * 45873.34028347);\n}\n\n//book of shaders\nvec2 truchetPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.) - vUv;\n    } else if (i > 0.5) {\n        vUv = vec2(1. - vUv.x, vUv.y);\n    } else if (i > 0.25) {\n        vUv = 1. - vec2(1. - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= 0.5;\n    vUv.x += u_time * 0.1;\n    vec3 color=vec3(0.);\n    vec2 grid=vec2(12.,12.);\n    vUv *= grid;\n    vec2 ipos = floor(vUv); //integer\n    vec2 fpos = fract(vUv); //fraction\n    vec2 tile = truchetPattern(fpos, rand2(ipos * sin(u_time*.000000125)) );\n    float c = (step(length(tile ),.6)-\n         step(length(tile ),0.4) ) +\n        (step(length(tile-vec2(1.) ),0.6) -\n         step(length(tile-vec2(1.) ),0.4) );\n    color = 1. - vec3(c);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _U=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.4859, 75.2389234))) * 45687.28934720);\n    }\n    \n    float rand2(float x){\n        return fract(sin(x) * 10000.0);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand2(100. + p * 0.00001) + rand2(p.x) * 0.5);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n    \n        vec2 grid = vec2(10.0, 15.0);\n        vUv *= grid;\n    \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n    \n        vec2 vel = vec2(u_time * (rand2(1.0)) * max(grid.x, grid.y));\n        vel *= vec2(0.0, 1.0) * rand2(1.0 + ipos.x);\n    \n        vec2 offset = vec2(0., 0.);\n        color.r = pattern(vUv + offset, vel, rand2(0.2) * 0.9);\n    \n        color *= step(0.5, fpos.x);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_U,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float cirOutline(vec2 vUv,vec2 pos,float size){\n        float x=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        float y=1.-smoothstep((size*.25)+size,(size*.25)+size+.01,distance(vUv,pos));\n        return y-x;\n    }\n    \n    // float randx(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy,vec2(12.9898,78.233)))*43724.3497231);\n    // }\n    \n    float rand1(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand2(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand3(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand4(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand5(float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv=vUv*2.-1.;\n        vec3 color=vec3(0.);\n        vec2 translate1=vec2(rand(vec2(rand1(.5)))+sin(u_time));\n        vec2 translate2=vec2(rand(vec2(rand2(.5)))-cos(u_time));\n        vec2 translate3=vec2(rand(vec2(rand3(.5)))+sin(u_time));\n        vec2 translate4=vec2(rand(vec2(rand4(.5)))-cos(u_time));\n        vec2 translate5=vec2(rand(vec2(rand5(.5)))+sin(u_time));\n        float shape1=cirOutline(vUv,(vec2(rand1(.5),rand1(.1)))*translate1,rand1(.5));\n        float shape2=cirOutline(vUv,(vec2(rand2(.4),rand2(.2)))*translate2,rand2(.5));\n        float shape3=cirOutline(vUv,(vec2(rand3(.3),rand3(.3)))*translate3,rand3(.5));\n        float shape4=cirOutline(vUv,(vec2(rand4(.2),rand4(.4)))*translate4,rand4(.5));\n        float shape5=cirOutline(vUv,(vec2(rand5(.1),rand5(.5)))*translate5,rand5(.5));\n        color=vec3(shape1+shape2+shape3+shape4+shape5);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // float rand(vec2 vUv){\n    //     return fract(cos(dot((vec2(vUv.x, vUv.y + (u_time * 0.001))),vec2(12.9898,78.233)))*43724.3497231 * abs(sin(u_time*.0000075))) ;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv.x *=0.15;\n        vUv.y*=0.15;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        float y = rand(vec2(ipos.x, fpos.y));\n        color.r = y;\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(748.3247298, 89.45870348))) * 2387402.3847293);\n    // }\n    \n    vec2 Pattern(vec2 vUv, float i){\n        i = fract((i - 0.5) * 2.0);\n        if(i > 0.8 + (0.1 * cos(u_time))){\n            vUv = vec2(1.0) - vUv;\n        }else if (i > 0.6 + (0.1 * cos(u_time))){\n            vUv = vec2(1.0 - vUv.y, vUv.x);\n        }else if (i > 0.4 + (0.1 * cos(u_time))){\n            vUv = 1.0 - vec2(1.0 - vUv.y, vUv.x);\n        }\n        return vUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        \n        vec3 color = vec3(0.);\n        vUv *= 20. * sin(u_time * 0.1) + 20.0;\n        vUv.x += 0.25;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = Pattern(fpos, rand(ipos));\n        float y = smoothstep(tile.x - 0.1, tile.x, tile.y)-\n                  smoothstep(tile.x, tile.x + 0.1, tile.y);\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(34.89327402, 347023874))) * 23469273.38497290347);\n    // }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n    \n            }else{\n                vUv.x-= fract(t) * 2. ;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2. ;\n            } else {\n                vUv.y -= fract(t) * 2. ;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 5.5, 0.5);\n        //vUv *= 20.;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        float shape = cir(vUv, vec2(rand(fpos)), 0.25);\n        \n        \n        color = vec3(shape);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand(float x) {\n        return fract(sin(x)*1e4);\n    }\n    //random\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(12.483017652, 87.8729301234))) * 49763419.2834798234);\n    // }\n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i - 0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        }else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0 - vUv.x, - vUv.y);\n        }\n        return vUv;\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 8.0;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand(ipos * u_time * 0.000000001));\n        float s = step(tile.y, tile.x) + rand(fpos);\n        color = vec3(s);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //random\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.483017652, 87.8729301234))) * 49763419.2834798234);\n}\n\nfloat rand2(float x) {\n    return fract(sin(x)*1e4);\n}\n\n//book of shaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    }else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, - vUv.y);\n    }\n    return vUv;\n}\n\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 10.0;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand2(ipos * u_time * 0.000000001));\n    float y = abs(sin(tile.x));\n    float s = plot(tile, y);\n    color = vec3(s);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.34739482, 74.237492837))) * 2347081.3978489230);\n}\n\n//bookofshaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    } else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 15.;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand2(ipos * u_time * 0.000000001));\n    float y = 1. - smoothstep(0.25, 0.26, distance(tile, vec2(0.5)));\n    float s = plot(tile, y / abs(sin(u_time)));\n    color = vec3(s);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.34739482, 74.237492837))) * 2347081.3978489230);\n}\n\n//bookofshaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    } else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\n//plot function\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 10.;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(ipos, rand2(ipos) + abs(sin(u_time * 0.25)));\n    float y = sin(tile.x);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x) * 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(46.3469872, 98.3468))) * 67382.4684018202);\n}\n\n//pattern\nfloat pattern(vec2 vUv, vec2 pos, float size){\n    vec2 p = floor(vUv + pos);\n    float y = distance(vUv, pos);\n    return step(size, rand2(100.+p * 0.000001) + rand2(p.x) * 0.5);\n}\n\nfloat pattern2(vec2 vUv,vec2 pos,float size){\n    vec2 p=floor(vUv+pos);\n    float y=distance(vUv,pos);\n    return step(size,rand2(100.+p*.000001)+rand2(p.x)*.95);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 grid = vec2(25., 25.);\n    vUv *= grid;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 vel = vec2(u_time * 2. * max(grid.x, grid.y));\n    vel *= vec2(-1., 0.0) * rand2(1.+ipos.y);\n    vec2 vel2=vec2(u_time*2.*max(grid.x,grid.y));\n    vel2*=vec2(0.,1.)*rand2(1.+ipos.x);\n    vec2 offset = vec2(0.1, 0.);\n    float y = pattern(vUv, vel, 0.75);\n    float x=pattern(vUv,vel2,.95);\n    color = vec3(x + y);\n    color*=step(.2,fpos.x);\n    color*=step(.2,fpos.y);\n    gl_FragColor = vec4(1.-color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    uniform float u_rand;\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(25. * u_rand, 98. * u_rand))) * 2347081. * u_rand);\n}\n\n//bookofshaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    } else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\n//plot function\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nfloat plot2(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.x) -\n           smoothstep(p, p + 0.075, vUv.x);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.;\n    float y = sin(plot(vUv, u_time * u_rand)) * 500.;\n    y*= cir(vUv, vec2(1.), 1.);\n    float x = sin(plot2(vUv, u_time * u_rand)) * 500.;\n    x*= cir(vUv, vec2(1.), 1.);\n    color = (1.0 - y) * color + y * vec3(0.0, 1.0, 0.0);\n    color += (1.0 - x) * color + x * vec3(0.0, 1.0, 0.0);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    uniform float u_rand;\n    float Cir(vec2 vUv, float size){\n        return 1. - smoothstep( size, size + 0.01, distance(vUv, vec2(vUv.x * u_rand+ sin(u_time), vUv.y * u_rand+ cos(u_time))));\n    }\n    \n    float Cir2(vec2 vUv, float size){\n        return 1. - smoothstep( size, size + 0.01, distance(vUv, vec2(vUv.x * u_rand +cos(u_time), vUv.y * u_rand+ sin(u_time))));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 10. - 5.;\n        vec3 color = vec3(0.);\n        float c1 = Cir(vUv, 0.5);\n        float c2 = Cir2(vUv, 0.5);\n        color = vec3(c1 + c2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//book of shaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    }else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, - vUv.y);\n    }\n    return vUv;\n}\n\n//sinc curve iquilezles.org\nfloat sinc(float x,float k){\n    float a=PI*((k*x)-1.);\n    return sin(a)/a ;\n}\n\n//plot function bookofshaders\nfloat plot(vec2 st, float pct){\n  \n  return  smoothstep( pct-0.2, pct, st.x ) -\n          smoothstep( pct, pct+0.2, st.x );\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 5.0;\n    vec3 color = vec3(0.);\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand2(ipos)); \n    float x = (sinc((vUv.y), sin(u_time) * 0.5)) * 0.45;\n    float pct = plot(tile - 0.5, x);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//bookofshaders\nfloat pattern(vec2 vUv, vec2 v, float t){\n    vec2 p = floor(vUv + v);\n    float y = smoothstep(t, t+0.01, rand2(100.+p * 0.00001) + rand2(p.x)*0.5);\n    return distance(vUv *y, v * y);\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.001), vUv);\n    b *= smoothstep(size, size + vec2(0.001), 1. - vUv);\n    float b1 = b.x * b.y;\n    vec2 bb = smoothstep(size-0.05, (size-0.05) + vec2(0.01), vUv);\n    bb *= smoothstep(size-0.05, (size-0.05) + vec2(0.01), 1. - vUv);\n    float b2 = bb.x * bb.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float x = Box(vUv, vec2(.125));\n    vec2 grid = vec2(25., 50.);\n    vec2 grid2 = vec2(5., 5.);\n    vUv *= grid;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 vel = vec2(u_time * 0.25 * max(grid.x, grid.y));\n    vel *= vec2(-1., 0.0) * rand2(1.0 + ipos.y);\n    vec2 vel2 = vec2(u_time * 1. * max(grid2.x, grid2.y));\n    vel2 *= vec2(0.0, -1.0) * rand2(1.0 + ipos.x);\n    float y = pattern(vUv, vel, 0.95);\n    float z = pattern(1. - vUv, vel2, 0.95);\n    color = vec3(y + z);\n    color += 1. - x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n//book of shaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * (u_time * 0.25));\n    if(i > 0.75){\n        vUv = vec2(1.) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1. - vUv.x, vUv.y) ;\n    } else if (i > 0.25){\n        vUv = 1. - vec2(1. - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color = vec3(0.);\n    vUv *= 10.;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand2(ipos));\n    float y = step(tile.x, tile.y);\n    float z = smoothstep(tile.x - 0.1, tile.x, tile.y) - \n              smoothstep(tile.x, tile.x + 0.1, tile.y);\n    color = vec3(z);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(38.67392, 98.376482))) * 46783.2347982);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile(vec2 vUv,float zoom,float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 newUv = vUv;\n        vUv *= 10.0;\n        newUv = Tile(newUv, 10., 0.5);\n        float z=1. - Cir(newUv,vec2(.5),.25);\n        vec3 color = vec3(0.);\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        float y = 1. - rand(ipos * (u_time * sin(0.00000001)));\n        color = vec3(y * z);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KU(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JU,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $U=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //bookofshaders\nfloat plot(vec2 vUv, float x){\n    return smoothstep(x - 2000000.5, x, vUv.y) -\n           smoothstep(x, x + 0.05, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4. - 1.;\n    vec3 color = vec3(0.);\n    float y = fract(sin(vUv.x) * u_time * u_time);\n    float p = plot(vUv, y);\n    color = vec3(p);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$U,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ew=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(83.8237492, 12.3874298))) *  2349236.8732947);\n    }\n    \n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i-0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0-vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 20.;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand2(ipos ));\n        float y = BoxBorder(tile, vec2(0.15 * abs(sin(u_time * 0.25))));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ew,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ow=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(83.8237492, 12.3874298))) *  2349236.8732947);\n    }\n    \n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i-0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0-vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.25,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.05,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 10.;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand2(ipos ));\n        float y = BoxBorder(tile, vec2(0.15 * (sin(u_time * 0.15))));\n        float x = CirOutline(tile, vec2(0.5 * abs(sin(u_time * 0.15)), 0.5 * abs(cos(u_time * 0.15))), 0.5);\n        color = vec3(x);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ow,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(83.8237492, 12.3874298))) *  2349236.8732947);\n    // }\n    \n    // vec2 Rot(vec2 vUv, float angle){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(angle), -sin(angle),\n    //                sin(angle), cos(angle)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i-0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0-vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        vUv *= 5.;\n        \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand(ipos ));\n        tile = Rot(tile, u_time * 0.25);\n        float y = BoxBorder(tile, vec2(0.2 * abs(sin(u_time * 0.0525))));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand(float x){\n        return fract(sin(x)* 1e4);\n    }\n    \n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct - 0.02, pct, vUv.y) - \n               smoothstep(pct, pct + 0.02, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 10. - 5.;\n        vUv.y -= 2.;\n        vUv.x += u_time;\n        vec3 color = vec3(0.);\n        float i = floor(vUv.x);\n        float f = fract(vUv.x);\n        float y = rand(i);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y = mix(rand(i), rand(i + 1.0), smoothstep(0., 1., f));\n        float x = sin(u_time);\n        float pct = plot(vUv, y);\n        color = vec3(pct);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand(float x){\n        return fract(sin(x)* 1e4);\n    }\n    \n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct - 0.02, pct, vUv.y) - \n               smoothstep(pct, pct + .75, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 10. - 5.;\n        vUv.y -= 2.;\n        vUv.x += u_time;\n        vec3 color = vec3(0.);\n        float i = floor(vUv.x * 1.);\n        float f = fract(vUv.x * 1.);\n    \n        float i2 = floor(vUv.x * 1.5);\n        float f2 = fract(vUv.x * 1.5);\n    \n        float i3 = floor(vUv.x * 2.);\n        float f3 = fract(vUv.x * 2.);\n    \n        float i4 = floor(vUv.x * 2.5);\n        float f4 = fract(vUv.x * 2.5);\n    \n        float i5 = floor(vUv.x * 3.);\n        float f5 = fract(vUv.x * 3.);\n    \n    \n        float y = rand(i);\n        float y2 = rand(i2);\n        float y3 = rand(i3);\n        float y4 = rand(i2);\n        float y5 = rand(i3);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y = mix(rand(i), rand(i + 1.0), smoothstep(0., 1., f));\n        y2 = mix(rand(i2), rand(i2 + 1.0), smoothstep(0., 1., f2));\n        y3 = mix(rand(i3), rand(i3 + 1.0), smoothstep(0., 1., f3));\n        y4 = mix(rand(i4), rand(i4 + 1.0), smoothstep(0., 1., f4));\n        y5 = mix(rand(i5), rand(i5 + 1.0), smoothstep(0., 1., f5));\n    \n        float pct = plot(vUv, y);\n        float pct2 = plot(vUv, y2);\n        float pct3 = plot(vUv, y3);\n        float pct4 = plot(vUv, y4);\n        float pct5 = plot(vUv, y5);\n    \n        color.r = pct;\n        color.g = pct2;\n        color.b = pct3;\n        // color.r = pct4;\n        // color.g = pct5;\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand(float x){\n        return fract(sin(x)*1e5);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.02,pct,vUv.y)-\n        smoothstep(pct,pct+.02,vUv.y);\n    }\n    \n    float noise(vec2 vUv){\n        float i=floor(vUv.x);\n        float f=fract(vUv.x);\n        float y=rand(i);\n        y=mix(rand(i),rand(i+1.),smoothstep(0.,1.,f));\n        return y;\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        float x = 1.-smoothstep(size,size+.01,distance(vUv,pos));\n        float y = 1.-smoothstep(size + 0.02, size + 0.02+0.01, distance(vUv, pos));\n        return y - x;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv*=10.-5.;\n        //vUv.y-=2.; \n        //vUv.x+=u_time;\n        vec3 color=vec3(0.);\n        float y = noise(vUv);\n        float x1=cir(vUv,vec2(2.5),1.25+y*cos(u_time));\n        float x2=cir(vUv,vec2(2.5),1.5+y*sin(u_time));\n        float x3=cir(vUv,vec2(2.5),1.+y*cos(u_time));\n        float x4=cir(vUv,vec2(2.5),1.75+y*sin(u_time));\n        float x5=cir(vUv,vec2(2.5),.75+y*cos(u_time));\n        float pct=plot(vUv,y);\n    \n        color=vec3(x1 + x2 + x3 + x4 + x5);\n        //color=vec3(pct + x1);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // float rand(float x){\n    //     return fract(sin(x)* 1e4);\n    // }\n    \n    // //2D random\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872 + rand(u_time * 0.00001));\n    // }\n    \n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = rand(i);\n        float b = rand(i + vec2(1.0, 0.0));\n        float c = rand(i + vec2(0.0, 1.0));\n        float d = rand(i + vec2(1.0, 1.0));\n    \n        // Smooth Interpolation\n    \n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n    \n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 pos = vec2(vUv * 5.0);\n        float n = noise(pos);\n        vec3 color = vec3(0.);\n        color.r =1. - n - 0.5;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     //2D random\n// float rand(vec2 vUv){\n//     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n// }\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    vUv = vec2(0.5) - vUv;\n    float f = size * 1.5;\n    float r = length(vUv) * 2.0;\n    float a = atan(vUv.y, vUv.x);\n    float m = abs(mod(a + u_time * 2., 3.14 * 2.) - 3.14)/3.6;\n    m += noise(vUv + u_time * 0.1) * .5;\n    f += sin(a * 40.) * noise(vUv + u_time * .2) * 0.1;\n    f += sin(a * 10.) * .1 * pow(m, 2.);\n    float x = 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    float y = 1.-smoothstep(size + 0.02, size + 0.02+0.01, distance(vUv, pos));\n    return smoothstep(f, f + 0.01, r) + (x - y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = cir(vUv, vec2(0.0), 0.4);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //2D random\n// float rand(vec2 vUv){\n//     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n// }\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat lines(vec2 vUv, float b){\n    float s = 10.0;\n    vUv *= s;\n    return smoothstep(0., .5+b * .5, abs((sin(vUv.x * 3.1415) + b * 2.0)) * .5);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= 0.25;\n    vec3 color = vec3(0.);\n    vUv = vUv.yx * vec2(3., 3.);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = noise(vUv) * vUv + u_time * 0.25;\n    float p = vUv.x;\n    p = lines(vUv, .5);\n    color = vec3(p);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise2(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vec3 color = vec3(0.);\n    vUv += noise2(vUv * 2.5) * 5.0 + sin(u_time * 0.25);\n    float y = smoothstep(.19, .2, noise2(vUv ));\n    y += smoothstep(.1, .2, noise2(vUv * 10.));\n    y -= smoothstep(.3, .4, noise2(vUv * 10.));\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _w=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise2(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vec3 color = vec3(0.);\n    vUv += noise2(vUv * 2.5) * 1.0 + cos(u_time * 0.15);\n    float y = smoothstep(.19, .2, noise2(vUv ));\n    y += smoothstep(.1, .2, noise2(vUv * 10.));\n    y -= smoothstep(.3, .4, noise2(vUv * 10.));\n    y -= smoothstep(.4, .6, noise2(vUv * 20.));\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_w,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ww=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //2D random\n// float rand(vec2 vUv){\n//     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n// }\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    vUv = vec2(0.5) - vUv;\n    float f = size * 1.5;\n    float r = length(vUv) * 2.0;\n    float a = atan(vUv.y, vUv.x);\n    float m = abs(mod(a + u_time * 2., 3.14 * 2.) - 3.14)/3.6;\n    m += noise(vUv + u_time * 0.1) * .5;\n    f += sin(a * 20.) * noise(vUv + u_time * .02) * 0.1;\n    f -= sin(a * 10.) * .1 * pow(m, 2.);\n    float x = 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    float y = 1.-smoothstep(size + 0.05, size + 0.02+0.01, distance(vUv, pos));\n    return smoothstep(f, f + 0.007, r);\n}\n\nfloat boarder(vec2 vUv, float size, float w){\n    return cir(vUv, vec2(0.0), size ) - cir(vUv, vec2(0.0), size + w); \n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = boarder(vUv, 0.5, 0.04);\n    float y2 = boarder(vUv, 0.3, 0.04);\n    float y3 = boarder(vUv, 0.1, 0.04);\n    color = vec3(y + y2 + y3);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Sw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ww,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Mw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand(float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.2,pct,vUv.y)-\n        smoothstep(pct,pct+.02,vUv.y);\n    }\n    \n    //2D random\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(23.74927,89.23476)))*64827.27364872);\n    }\n    \n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise(in vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        // Four corners in 2D of a tile\n        float a=rand(i);\n        float b=rand(i+vec2(1.,0.));\n        float c=rand(i+vec2(0.,1.));\n        float d=rand(i+vec2(1.,1.));\n        \n        // Smooth Interpolation\n        \n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u=f*f*(3.-2.*f);\n        // u = smoothstep(0.,1.,f);\n        \n        // Mix 4 coorners percentages\n        return mix(a,b,u.x)+\n        (c-a)*u.y*(1.-u.x)+\n        (d-b)*u.x*u.y;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv*=10.-5.;\n        vUv.y-=2.5;\n        vUv.x+=u_time;\n        vec3 color=vec3(0.);\n        float i=floor(vUv.x);\n        float f=fract(vUv.x);\n        float y=rand(i);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y=mix(rand(i),rand(i+1.),smoothstep(0.,1.,f));\n        // float x=sin(u_time);\n        float pct=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y+ 0.8),y);\n        float pct2=plot(noise(vUv+u_time) + vUv,y);\n        float pct3=plot(noise(vUv+u_time)+vec2(vUv.x, vUv.y - 0.8),y);\n        float pct4=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y+ 1.6),y);\n        float pct5=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y-1.6),y);\n        color=vec3(pct + pct2 + pct3 + pct4 + pct5);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Mw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float rand(float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.2,pct,vUv.y)-\n        smoothstep(pct,pct+.02,vUv.y);\n    }\n    \n    //2D random\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(23.74927,89.23476)))*64827.27364872);\n    }\n    \n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise(in vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        // Four corners in 2D of a tile\n        float a=rand(i);\n        float b=rand(i+vec2(1.,0.));\n        float c=rand(i+vec2(0.,1.));\n        float d=rand(i+vec2(1.,1.));\n        \n        // Smooth Interpolation\n        \n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u=f*f*(3.-2.*f);\n        // u = smoothstep(0.,1.,f);\n        \n        // Mix 4 coorners percentages\n        return mix(a,b,u.x)+\n        (c-a)*u.y*(1.-u.x)+\n        (d-b)*u.x*u.y;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv = noise(Rot(vUv, u_time * 0.2)) * vUv;\n        vUv*=20.-10.;\n        vUv.y-=.0;\n        vUv.x+=u_time;\n        vec3 color=vec3(0.);\n        float i=floor(vUv.x);\n        float f=fract(vUv.x);\n        float y=rand(i);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y=mix(rand(i),rand(i+1.),smoothstep(0.,1.,f));\n        // float x=sin(u_time);\n        float pct=plot(vUv,y);\n        float pct2=plot(noise(vUv+u_time) + vUv,y);\n        float pct3=plot(noise(vUv+u_time)+vec2(vUv.x, vUv.y - 0.2),y);\n        float pct4=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y+ 0.4),y);\n        float pct5=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y-0.4),y);\n        color=vec3(pct + pct2 + pct3 + pct4 + pct5);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Cw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //2D random\n// float rand(vec2 vUv){\n//     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n// }\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat lines(vec2 vUv, float b){\n    float s = 10.0;\n    vUv *= s;\n    return smoothstep(0.45, .45+b * .451, abs((sin(vUv.x * 3.1415) + b * 1.)) * .5);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= .25;\n    vUv.x += sin(u_time) * 0.2;\n    vec3 color = vec3(0.);\n    vUv = vUv.yx * vec2(3., 3.);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = noise(vUv) * vUv + u_time * 0.025;\n    vUv.x = noise(vUv) * vUv.x;\n    vUv.y = noise(vUv) * vUv.y;\n    float p = vUv.x;\n    p = lines(vUv, .5);\n    color = vec3(p);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Rw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Tw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 2.);\n    pos = Rot(pos, u_time);\n    float y = noise(pos + sin(u_time));\n    float d = length( max(abs(vUv)-(.13 * sin(u_time * 0.25) * 2.),0.));\n    color = vec3(y * (fract(d * 10.0)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Pw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Dw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Fw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n    \n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n    \n    float lines(in vec2 pos, float b){\n        float scale = 10.0/2.;\n        pos *= scale;\n        return smoothstep(0.001,\n                        .05+b*.251,\n                        abs((sin(pos.x*3.1415)+b*2.0))*.0251);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        float scale  = 1.;\n        pos *= scale;\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        //vUv -= 0.5;\n        vec3 color = vec3(0.);\n        vec2 pos = vUv.yx*vec2(10.,3.);\n        pos -= vec2(5., 1.5);\n        float p = pos.x;\n        pos = rotate2d(noise2(pos + u_time)) * pos;\n        //p = Cir(pos, vec2(0.75), 0.45);\n        p += lines(pos, .5);\n        float r = smoothstep(0.4, 0.6, vUv.y * p);\n        float b = smoothstep(0.4, 0.6, 1. - vUv.y * p);\n        color.b = p * 0.025 * b;\n        color.b += 1. * r + p * 2. ;\n        //color.b = 1.0 * r;\n        //color.rg = vec2(p * b);\n        color.rg += (.8 - p * 1.23);\n        //color.rg += (.9 - p * 1.23);\n        //color.g = step(0.5, 1.);\n        //color.rg = vec2(1., 1.);\n        //color.b -= sin(u_time * 0.25);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Fw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Iw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n    \n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 10. - 5.;\n        //vUv.x += u_time * 0.2;\n        vec2 newUv = vUv;\n        newUv.x += 1. - noise2(newUv) * newUv.x + u_time;\n        newUv.y += 1. - noise2(newUv) * newUv.y + u_time;\n        \n        newUv = noise2(newUv) * newUv + sin(u_time);\n        color = vec3(newUv, 0.); \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ew(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Iw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ow=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n    \n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n    \n    float Tri(vec2 vUv, float size){\n        vUv = vUv * 5. - 2.5;\n        float a  = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.;\n        float d = cos(floor(.05 * a/r) * r-a) * length(vUv);\n        return 1. - smoothstep(size, size+0.01, d);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 triUv = vUv;\n        triUv = noise2(triUv + (u_time * 0.5)) + triUv;\n        vec3 color = vec3(0.);\n        float tri = Tri(triUv, 0.5);\n        color = vec3(tri);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ow,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Aw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    vec2 rotate2d(vec2 vUv, float angle){\n        vUv -= vec2(0.5);\n        vUv = (cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * vUv ;\n        vUv += vec2(0.5);\n        return vUv;\n    }\n    \n    float Tri(vec2 vUv,float size){\n        vUv=vUv*5.-2.5;\n        float a=atan(vUv.x,vUv.y)+PI;\n        float r=TWO_PI/3.;\n        float d=cos(floor(.05*a/r)*r-a)*length(vUv);\n        return 1.-smoothstep(size,size+.01,d);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-8. - abs(cos(u_time * 0.75)),pct,(vUv.y * (noise2(vUv + u_time))))-\n        smoothstep(pct,pct+8. + abs(sin(u_time * 0.75)),(vUv.y*(noise2(vUv + u_time))));\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 15. - 7.5;\n        //vUv = rotate2d(vUv, sin(u_time));\n        //vUv.x -= 0.5;\n        vUv.x = noise2(vUv * sin(u_time * 0.5)) + vUv.x;\n        vUv.y = noise2(vUv * sin(u_time * 0.5)) + vUv.y;\n        vec3 color = vec3(0.);\n        float y = noise2(vUv) + vUv.x;\n        float pct=plot(vUv, y);\n        color = vec3(pct);\n        gl_FragColor = vec4(color, 0.5);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Gw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Aw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Nw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    vec2 rotate2d(vec2 vUv,float angle){\n        vUv-=vec2(.5);\n        vUv=(cos(angle),-sin(angle),\n        sin(angle),cos(angle))*vUv;\n        vUv+=vec2(.5);\n        return vUv;\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-0.01-abs(sin(u_time*.75 )+7.5),pct,(vUv.y*(noise2(vUv+u_time + 2.0))))-\n        smoothstep(pct,pct+0.01+abs(sin(u_time*.75 )+2.0),(vUv.y*(noise2(vUv+u_time + 2.0))));\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv=vUv*15.-7.5;\n        vUv.y += 4.5;\n        //vUv = rotate2d(vUv, sin(u_time));\n        //vUv.x -= 0.5;\n        vUv.x=noise2(vUv)+vUv.x;\n        vUv.y=noise2(vUv)+vUv.y;\n        vec2 newUv = vUv;\n        newUv.y += 7.0;\n        vec3 color=vec3(0.);\n        float y=noise2(vUv)+vUv.y;\n        //float y2=noise2(vec2(newUv))+vUv.y - 7.5;\n        float pct=plot(vUv,y);\n        //float pct2=plot(vUv,y2);\n        float gradient = pow(1.0 - vUv.y, 2.0) * 0.5;\n        float final = pct * gradient;\n        color = final * vec3(pct, pct*pct, pct*pct*pct*pct*pct);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Bw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Nw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    vec2 rotate2d(vec2 vUv,float angle){\n        vUv-=vec2(.5);\n        vUv=(cos(angle),-sin(angle),\n        sin(angle),cos(angle))*vUv;\n        vUv+=vec2(.5);\n        return vUv;\n    }\n    \n    float plot(vec2 vUv,float p){\n        return smoothstep(p + 4.5, p, vUv.y) -\n               smoothstep(p, p - 0.0005, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. - 2.;\n        vUv.y += 2.5;\n        //vUv = vUv * sin(u_time * 0.5)/2.0;\n        vec3 color = vec3(.5, .8, .9);\n        float y1 = noise2(vUv + u_time);\n        float y2 = noise2(vUv + u_time);\n        float y3 = noise2(vUv + u_time);\n        float y4 = noise2(vUv + u_time);\n        float y5 = noise2(vUv + u_time);\n        float pct1 = plot(vec2(vUv.x + 0.0, vUv.y), y1);\n        float pct2 = plot(vec2(vUv.x + 0.5, vUv.y), y2);\n        float pct3 = plot(vec2(vUv.x + 1.0, vUv.y), y3);\n        float pct4 = plot(vec2(vUv.x - 0.5, vUv.y), y4);\n        float pct5 = plot(vec2(vUv.x - 1.0, vUv.y), y5);\n        color *= vec3(pct1 * pct2 * pct3 * pct4 * pct5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Vw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ww=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p + vUv.x * 1.5, p, vUv.y) -\n               smoothstep(p, p - vUv.x * 1.5, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 5.;\n        vUv.x -= 1.5;\n        vUv.y += 1.2;\n        vUv = Rot(vUv, PI * 0.5);\n        //vUv = vUv * sin(u_time * 0.5)/2.0;\n        vec3 color = vec3(0.);\n        float y1 = noise2(vUv - u_time * 0.2);\n        float y2 = noise2(vUv - u_time * 1.0);\n        float y3 = noise2(vUv - u_time * 1.5);\n        float y4 = noise2(vUv - u_time * 1.5);\n        float y5 = noise2(vUv - u_time * 0.5);\n        float pct1 = plot(vec2(vUv.x + 0.0, vUv.y), y1);\n        float pct2 = plot(vec2(vUv.x + 0.5, vUv.y), y2);\n        float pct3 = plot(vec2(vUv.x + 1.0, vUv.y), y3);\n        float pct4 = plot(vec2(vUv.x - 0.5, vUv.y), y4);\n        float pct5 = plot(vec2(vUv.x - 1.0, vUv.y), y5);\n        color = vec3(pct1 * pct2 * pct3 * pct4 * pct5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Hw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ww,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     //vUv *= 2.0;\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p + vUv.x * 1.5, p, vUv.y) -\n               smoothstep(p, p - vUv.x * 1.5, vUv.y);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        //vUv = vUv * 3. - 0.5;\n        //vUv.x -= 1.5;\n        //vUv.y += 1.2;\n        //vUv *= 2.0;\n        vUv = Rot(vUv, PI * u_time * 0.25);\n        vUv = vUv * 2. - 1.;\n        //vUv = vUv * sin(u_time * 0.5)/2.0;\n        vec3 color = vec3(.5, .8, .9);\n        float y1 = noise2(vUv - u_time * 0.2);\n        float y2 = noise2(vUv - u_time * 1.0);\n        float y3 = noise2(vUv - u_time * 1.5);\n        float y4 = noise2(vUv - u_time * 1.5);\n        float y5 = noise2(vUv - u_time * 0.5);\n        float pct1 = plot(vec2(vUv.x + 0.0, vUv.y), y1);\n        float pct2 = plot(vec2(vUv.x + 0.5, vUv.y), y2);\n        float pct3 = plot(vec2(vUv.x + 1.0, vUv.y), y3);\n        float pct4 = plot(vec2(vUv.x - 0.5, vUv.y), y4);\n        float pct5 = plot(vec2(vUv.x - 1.0, vUv.y), y5);\n        color *= vec3(pct1 * pct2 * pct3 * pct4 * pct5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Yw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Xw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Zw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     //vUv *= 2.0;\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p + vUv.x * 1.5, p, vUv.y) -\n               smoothstep(p, p - vUv.x * 1.5, vUv.y);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        //vUv = noise2(vUv + u_time) + vUv;\n        float t = u_time * speed;\n        if(fract(t) > .5 ){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n                vUv.x = noise2(vUv + u_time) + vUv.x;\n            }else{\n                vUv.x-= fract(t) * 2.;\n                vUv.x = noise2(vUv - u_time) - vUv.x;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;\n                vUv.y = noise2(vUv + u_time) + vUv.y;\n            } else {\n                vUv.y -= fract(t) * 2.;\n                vUv.y = noise2(vUv - u_time) - vUv.y;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Tri(vec2 vUv, float size){\n        vUv -= 0.5;\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.0;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return 1.0 - smoothstep(size, size+0.01, d);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 10.0, 0.25);\n        float c1 = cir(vUv, vec2(0.5), 0.25);\n    \n        vec2 newUv = vUv;\n        newUv = Rot(vUv, sin(u_time + 2.0) * PI);\n        float t1 = Tri(newUv, 0.1);\n        \n        color = vec3(c1 - t1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Qw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Zw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Jw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     //vUv *= 2.0;\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p +0.15, p, vUv.y) -\n               smoothstep(p, p - 0.15, vUv.y);\n    }\n    \n    float plot2(vec2 vUv,float p){\n        p *= vUv.y;\n        return smoothstep(p +0.15, p, vUv.x) -\n               smoothstep(p, p - 0.15, vUv.x);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 15. - 7.5;\n        vec3 color = vec3(0.);\n        vUv = noise2(vUv+u_time) * vUv;\n        float y = plot(vUv, 50.);\n        float y2 = plot2(vUv, cos(u_time+ TWO_PI));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Kw(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Jw,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $w=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1. - (smoothstep(size,size+.01,distance(vUv,pos)) - \n                     smoothstep(size-0.025, size-0.025+0.1,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2.6 - 1.3;\n        vec3 color = vec3(0.);\n        vec2 translate = noise2(vUv + u_time) * vUv;\n    \n        float c1=cir(vUv,vec2(.50 * translate.x , 0.50 * translate.y),.25);\n        float c2=cir(vUv,vec2(.25 * translate.x +sin(u_time), 0.50 * translate.y),.25);\n        float c3=cir(vUv,vec2(.75 * translate.x, 0.50 * translate.y +sin(u_time)),.25);\n        float c4=cir(vUv,vec2(.50 * translate.x -sin(u_time), 0.25 * translate.y),.25);\n        float c5=cir(vUv,vec2(.50 * translate.x, 0.75 * translate.y -sin(u_time)),.25);\n        color = 1. - vec3(c1*c2*c3*c4*c5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$w,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.1,distance(vUv,pos)));\n    }\n    \n    float sqr(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.03),vUv);\n        b*=smoothstep(size,size+vec2(.03),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.03),(size-vec2(.03))+vec2(.03),vUv);\n        b2*=smoothstep(size-vec2(.03),(size-vec2(.03))+vec2(.03),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv=vUv*3.-1.;\n        \n        vec2 newUv1= vUv;\n        newUv1.x += 1.0;\n        vec2 newUv2 = vUv;\n        newUv2.x -= 2.0;\n        vec3 color=vec3(0.);\n        vec2 translate1=noise2(newUv1+u_time)*newUv1;\n        vec2 translate2=noise2(newUv2+u_time)*newUv2;\n        //vUv = noise2(vUv+u_time ) + vUv;\n        float s1=sqr(vec2(newUv1.x,newUv1.y),vec2(.005+translate1.x,.05));\n        float s2=sqr(vec2(newUv1.x,newUv1.y+1.),vec2(.005-translate1.x,.005));\n        float s3=sqr(vec2(newUv1.x,newUv1.y-1.),vec2(.0005-translate1.x,.005));\n    \n        float s4=sqr(vec2(newUv2.x+1.,newUv2.y),vec2(.005+translate2.x,.05));\n        float s5=sqr(vec2(newUv2.x+1.,newUv2.y+1.),vec2(.005+translate2.x,.005));\n        float s6=sqr(vec2(newUv2.x+1.,newUv2.y-1.),vec2(.0005-translate2.x,.005));\n    \n        color = vec3(s1 + s2 + s3 + s4 + s5 + s6);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.1,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n        vUv += noise2(vUv + u_time) * vUv;\n        float c1 = cir(vUv, vec2(0.5,0.0), 0.25);\n        float c2 = cir(vUv, vec2(0.0,0.0), 0.25);\n        float c3 = cir(vUv, vec2(1.0,0.0), 0.25);\n    \n        float c4 = cir(vUv, vec2(0.5,0.5), 0.25);\n        float c5 = cir(vUv, vec2(0.0,0.5), 0.25);\n        float c6 = cir(vUv, vec2(1.0,0.5), 0.25);\n    \n        float c7 = cir(vUv, vec2(0.5,1.0), 0.25);\n        float c8 = cir(vUv, vec2(0.0,1.0), 0.25);\n        float c9 = cir(vUv, vec2(1.0,1.0), 0.25);\n        color = vec3(c1 * c2 * c3 * c4 *c5 * c6 * c7 * c8 * c9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.5,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 3. - 1.;\n        vec2 newUv = vUv;\n        vec2 translate = vec2(noise2(newUv+u_time) + newUv.x, sin(noise2(newUv+u_time)) * newUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = Rot(vUv, u_time * 0.25);\n    \n        vec2 pos = vec2(0.5);\n        pos.x = translate.x * pos.x + 0.25;\n        pos.y = translate.y * pos.y + 0.75;\n        float c1 = cir(vUv, pos, 0.5);\n    \n        vec2 pos2 = vec2(0.5);\n        pos2.x = translate.x * pos2.x + 0.25;\n        pos2.y = translate.y * pos2.y + 0.5;\n        float c2 = cir(vUv, pos2, 0.5);\n    \n        vec2 pos3 = vec2(0.5);\n        pos3.x = translate.x * pos3.x + 0.25;\n        pos3.y = translate.y * pos3.y + 0.25;\n        float c3 = cir(vUv, pos3, 0.5);\n    \n        vec2 pos4 = vec2(0.5);\n        pos4.x = translate.x * pos4.x + 0.25;\n        pos4.y = translate.y * pos4.y + 1.0;\n        float c4 = cir(vUv, pos4, 0.5);\n    \n        vec2 pos5 = vec2(0.5);\n        pos5.x = translate.x * pos5.x + 0.25;\n        pos5.y = translate.y * pos5.y + 1.25;\n        float c5 = cir(vUv, pos5, 0.5);\n    \n        vec2 pos6 = vec2(0.5);\n        pos6.x = translate.x * pos6.x + 0.25;\n        pos6.y = translate.y * pos6.y + 0.0;\n        float c6 = cir(vUv, pos6, 0.5);\n    \n        color = vec3(c1 * c2 * c3 * c4 * c5 * c6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.015,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.5,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vUv = noise2(vUv + u_time) + vUv;\n        vec3 color = vec3(0.);\n        float p1 = vUv.y;\n        float p2 = vUv.y - 0.5;\n        float p3 = vUv.y - 1.0;\n        float p4 = vUv.x;\n        float p5 = vUv.x - 0.5;\n        float p6 = vUv.x - 1.0;\n        float pct1 = plot(vUv, p1);\n        float pct2 = plot(vUv, p2);\n        float pct3 = plot(vUv, p3);\n        float pct4 = plot(vUv, p4);\n        float pct5 = plot(vUv, p5);\n        float pct6 = plot(vUv, p6);\n        color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.015,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float plot2(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.015,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.5,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 5. - 2.5;\n        vec3 color = vec3(0.);\n        vUv *= noise2(vUv+u_time) * vUv;\n        float y = plot(vUv, abs(sin(u_time+ TWO_PI)));\n        float y2 = plot2(vUv,  abs(sin(u_time+ TWO_PI)));\n        color = vec3(y2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, sin(u_time * 0.25));\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 5.);\n    vec2 vel = vec2(u_time * 0.1);\n    float y = snoise(pos + vel) * 0.25 + 0.25;\n    float a = snoise(pos * vec2(cos(u_time * 0.15), sin(u_time * 0.1)) * 0.1) * PI;\n    vel = vec2(cos(a), sin(a));\n    y += snoise(pos + vel) * 0.25 + 0.25;\n    color = vec3(smoothstep(0.7, 0.75, fract(y)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, sin(u_time * 0.25));\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 2.);\n    vec2 vel = vec2(u_time * 0.1);\n    float y = snoise(pos) * 2.75 + 0.75;\n    float a = snoise(pos * vec2(cos(u_time * 0.25), sin(u_time * 0.2)) * 0.1) * PI;\n    vel = vec2(cos(a), sin(a));\n    y += snoise(pos + vel) * 0.25 + 0.25;\n    color = 1. - vec3(smoothstep(0.7, 0.75, fract(y)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    p*=vUv.x;\n    return smoothstep(p+.015,p,vUv.y)-\n    smoothstep(p,p-.15,vUv.y);\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n    smoothstep(size+.292,size+.295,distance(vUv,pos)));\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, (u_time * 0.25));\n    vUv = vUv * 5.0 - 2.5;\n    vec3 color = vec3(0.);\n    vUv = snoise(vUv) * vUv;\n    vec2 pos = vec2(0.5);\n    pos = snoise(pos) * pos;\n    float c1 = cir(vUv, pos, 0.25 + snoise(vUv + (u_time * 0.1)));\n    color = vec3(c1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    p*=vUv.x;\n    return smoothstep(p+.015,p,vUv.y)-\n    smoothstep(p,p-.15,vUv.y);\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    float x = 1.-(smoothstep(size,size+.1,distance(vUv,pos)));\n    float y = 1.-(smoothstep(size * 1.5, size * 1.5 + 0.1, distance(vUv, pos)));\n    return y - x;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, (u_time * 0.25));\n    //vUv.x += u_time * 0.25;\n    vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n    //vUv += snoise(vUv) * vUv;\n    vec2 pos = vec2(0.5);\n    vUv = snoise(vUv) * vec2 (0.5);\n    float size = 0.25;\n    size = snoise(vUv * 5.0 + sin(u_time * 0.25)) + size;\n    float x = 1.-(smoothstep(size,size+.5,distance(vUv,pos)));\n    float y = 1.-(smoothstep(size * 1.25, size * 1.75 + 0.5, distance(vUv, pos)));\n    float c1 = y - x;\n    color = vec3(c1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x = snoise(vUv + u_time * 0.1);\n    p += x;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1. - 2.;\n    vec3 color = vec3(0.);\n    float x = vUv.x;\n    float y1 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct1 = plot(vec2(vUv.x - 2.5, vUv.y), y1);\n    float y2 =  x*x*(3.0-2.0*x);\n    float pct2 = plot(vec2(vUv.x - 2.0, vUv.y), y2);\n    float y3 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct3 = plot(vec2(vUv.x - 1.5, vUv.y), y3);\n    float y4 =  x*x*(3.0-2.0*x);\n    float pct4 = plot(vec2(vUv.x -1.0, vUv.y), y4);\n    float y5 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct5 = plot(vec2(vUv.x , vUv.y), y5);\n    float y6 =  x*x*(3.0-2.0*x);\n    float pct6 = plot(vec2(vUv.x + 1.0, vUv.y), y6);\n    float y7 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct7 = plot(vec2(vUv.x + 1.5, vUv.y), y7);\n    float y8 =  x*x*(3.0-2.0*x);\n    float pct8 = plot(vec2(vUv.x + 2.0, vUv.y), y8);\n    float y9 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct9 = plot(vec2(vUv.x + 2.5, vUv.y), y9);\n    float y10 =  x*x*(3.0-2.0*x);\n    float pct10 = plot(vec2(vUv.x + 3.5, vUv.y), y10);\n    color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6 + pct7 + pct8 + pct9 + pct10);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _S=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x = snoise(vUv + u_time * 0.1);\n    p += x;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 2.;\n    vUv.x += 1.0;\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv + u_time);\n    float x = vUv.x;\n    float y1 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct1 = plot(vec2(vUv.x - 2.5, vUv.y), y1);\n    float y2 =  x*x*(3.0-2.0*x);\n    float pct2 = plot(vec2(vUv.x - 2.0, vUv.y), y2);\n    float y3 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct3 = plot(vec2(vUv.x - 1.5, vUv.y), y3);\n    float y4 =  x*x*(3.0-2.0*x);\n    float pct4 = plot(vec2(vUv.x -1.0, vUv.y), y4);\n    float y5 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct5 = plot(vec2(vUv.x , vUv.y), y5);\n    float y6 =  x*x*(3.0-2.0*x);\n    float pct6 = plot(vec2(vUv.x + 1.0, vUv.y), y6);\n    float y7 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct7 = plot(vec2(vUv.x + 1.5, vUv.y), y7);\n    float y8 =  x*x*(3.0-2.0*x);\n    float pct8 = plot(vec2(vUv.x + 2.0, vUv.y), y8);\n    float y9 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct9 = plot(vec2(vUv.x + 2.5, vUv.y), y9);\n    float y10 =  x*x*(3.0-2.0*x);\n    float pct10 = plot(vec2(vUv.x + 3.5, vUv.y), y10);\n    color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6 + pct7 + pct8 + pct9 + pct10);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function US(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_S,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x = snoise(vUv + u_time * 0.1);\n    p += x;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    float x = 1.-(smoothstep(size,size+.01,distance(vUv,pos)));\n    float y = 1.-(smoothstep(size * 1.25, size * 1.25 + 0.01, distance(vUv, pos)));\n    return y - x;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 0.75;\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv + u_time);\n    float c1 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.15);\n    float c2 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.35);\n    float c3 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.55);\n    float c4 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.75);\n    float c5 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.95);\n    color = vec3(c1 + c2 + c3 + c4 + c5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat sqr(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.013),vUv);\n    b*=smoothstep(size,size+vec2(.013),1.-vUv);\n    float box1=b.x*b.y;\n    vec2 b2=smoothstep(size-vec2(.013),(size-vec2(.031))+vec2(.031),vUv);\n    b2*=smoothstep(size-vec2(.013),(size-vec2(.031))+vec2(.031),1.-vUv);\n    float box2=b2.x*b2.y;\n    return box2-box1;\n}\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    _st *= _zoom;\n    float time = u_time*_speed;\n    if( fract(time)>0.5 ){\n        if (fract( _st.y * 0.5) > 0.5){\n            _st.x += fract(time)*2.0;\n        } else {\n            _st.x -= fract(time)*2.0;\n        }\n    } else {\n        if (fract( _st.x * 0.5) > 0.5){\n            _st.y += fract(time)*2.0;\n        } else {\n            _st.y -= fract(time)*2.0;\n        }\n    }\n    return fract(_st);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv.y -= 2.5;\n    float noise = snoise(vUv + (u_time * 0.5));\n    vUv = movingTiles(vec2(sin(vUv.x) + noise * 0.01, cos(vUv.y) + noise * 0.01), 4., 0.15);\n    vec3 color = vec3(0.);\n    vec2 vUv2 = Rot(vUv, PI * 0.25);\n    vUv = Rot(vUv, u_time * 0.25 );\n    //vUv2 = Rot(vUv2, -u_time * 0.25  );\n    float y1 = sqr(vUv + (noise * 0.05), vec2(0.25));\n    float y2 = sqr(vUv2 + (noise * 0.05), vec2(0.2));\n    float y3 = sqr(vUv + (noise * 0.05), vec2(0.25 * 1.75));\n    float y4 = sqr(vUv2 + (noise * 0.05), vec2(0.2 * 1.75));\n    float y5 = sqr(vUv + (noise * 0.05), vec2(0.25 * 2.));\n    float y6 = sqr(vUv2 + (noise * 0.05), vec2(0.2 * 2.));\n    float y7 = sqr(vUv + (noise * 0.05), vec2(0.25 * 1.5));\n    float y8 = sqr(vUv2 + (noise * 0.05), vec2(0.2 * 1.5));\n    color = vec3(y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.1);\n    // p+=x * 0.15;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nfloat cir(vec2 vUv, float size){\n    vUv=vec2(.5)-vUv;\n    float r=length(vUv)*2.;\n    float a=atan(vUv.y,vUv.x);\n    float m=abs(mod(a+u_time*1.,3.14*2.)-3.14)/3.6;\n    float f=size;\n    m+=snoise(vUv+u_time*.1)*.01;\n    // a *= 1.+abs(atan(u_time*0.2))*.1;\n    // a *= 1.+noise(st+u_time*0.1)*0.1;\n    f+=sin(a*12.)*snoise(vUv*u_time*.2)*.01;\n    f+=(sin(a*10.)*.1*pow(m,1.));\n    return 1.-smoothstep(f,f+.007,r);\n}\n\nfloat cirOutline(vec2 vUv, float size, float width){\n    return cir(vUv, size) - cir(vUv, size - width);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n    float y1=cirOutline(vUv,0.9,.025);\n    float y2=cirOutline(vUv,.8,.025);\n    float y3=cirOutline(vUv,0.7,.025);\n    float y4=cirOutline(vUv,.6,.025);\n    float y5=cirOutline(vUv,.5,.025);\n    color = vec3(y1 + y2 + y3 + y4 + y5);\n    gl_FragColor = vec4(color, 1.);\n}\n\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.1);\n    // p+=x * 0.15;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.2 - 1.1;\n    vUv /= u_time * 0.15;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time);\n    y *= snoise(sin(vUv*(u_time))) * 0.5 ;\n    float pct = plot(vec2(vUv.x,vUv.y), y);\n    float pct2= plot(vec2(vUv.x,vUv.y + 0.25),y);\n    float pct3=plot(vec2(vUv.x,vUv.y-.25),y);\n    float pct4=plot(vec2(vUv.x,vUv.y+.50),y);\n    float pct5=plot(vec2(vUv.x,vUv.y-.50),y);\n    color = vec3(pct + pct2 + pct3 + pct4 + pct5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.15;\n    return smoothstep(p+(.05),p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time * 0.5);\n    float sn = snoise(vUv + u_time);\n    float pct = plot(vUv * sn, y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.15;\n    return smoothstep(p+(.15),p,vUv.y)-\n    smoothstep(p,p-(2.5),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv.y -= 0.5;\n    vec3 color = vec3(0.);\n    vec2 translate = (vec2(snoise(vUv + (u_time * 0.5)) + vUv.x, snoise(vUv + (u_time * 0.5)) + vUv.y));\n    float x = vUv.x;\n    float y = x * x * ( 3. - 2. * x);\n    float pct = plot(vUv + translate, y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.75;\n    return smoothstep(p+(.5),p,vUv.y)-\n    smoothstep(p,p-(2.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv = Rot(vUv, u_time * 0.15);\n    vec3 color = vec3(0.);\n    float n = snoise((vUv + u_time));\n    float y = sin(vUv.x + u_time) * n;\n    float pct = plot(vUv + sin(n + u_time * 0.25), y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ES(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.5 ;\n    return smoothstep(p+(0.25),p,vUv.y)-\n    smoothstep(p,p-(1.0),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv);\n    float c1 = cir(vUv, vec2(0.5), 0.25);\n    color = vec3(c1);\n    float x = vUv.x;\n    float y = x*x*x*(x*(x*6.-15.)+10.) + noise;\n    float p1 = plot(vec2(vUv.x * (noise + sin(u_time)), vUv.y - 0.5 + (noise + cos(u_time))), y);\n    color *= p1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.5 ;\n    return smoothstep(p+(0.25),p,vUv.y)-\n    smoothstep(p,p-(1.0),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv + (u_time * 0.5)) * 0.1;\n    float c1 = cir(vUv, vec2(0.5 + sin(noise), 0.5), 0.35 + noise);\n    float c2 = cir(vUv, vec2(0.5 + sin(noise), 0.5), 0.325 + noise);\n    float b1 = Box(vUv, vec2(0.25) + noise);\n    float b2 = Box(vUv, vec2(0.225) + noise);\n    color = vec3(c1 - c2);\n    color += (b2 - b1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.01),p,vUv.y)-\n    smoothstep(p,p-(0.01),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.5;\n    vec3 color = vec3(0.);\n    float noise=snoise((vUv)+(u_time*.15))*.51;\n    vUv = vUv * sin(noise +u_time * 0.5);\n    float x=vUv.x;\n    float y=x*x*x*(x*(x*6.-15.)+10.)*noise;\n    float pct1=plot(vec2(vUv.x,vUv.y-.0),y);\n    float pct2=plot(vec2(vUv.x,vUv.y-.1),y);\n    float pct3=plot(vec2(vUv.x,vUv.y-.2),y);\n    float pct4=plot(vec2(vUv.x,vUv.y-.3),y);\n    float pct5=plot(vec2(vUv.x,vUv.y-.4),y);\n    float pct6=plot(vec2(vUv.x,vUv.y+.0),y);\n    float pct7=plot(vec2(vUv.x,vUv.y+.1),y);\n    float pct8=plot(vec2(vUv.x,vUv.y+.2),y);\n    float pct9=plot(vec2(vUv.x,vUv.y+.3),y);\n    float pct10=plot(vec2(vUv.x,vUv.y+.4),y);\n    color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6 + pct7 + pct8 + pct9 + pct10);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+(0.5),p,vUv.y)-\n    smoothstep(p,p-(0.025),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    vUv.x += 1.5;\n    float noise = snoise(vUv) * (sin(u_time)) * 0.5;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + (u_time) + noise);\n    float pct1=plot(vec2(vUv.x,vUv.y-0.25),y);\n    float pct2=plot(vec2(vUv.x,vUv.y),y);\n    float pct3=plot(vec2(vUv.x,vUv.y-0.5),y);\n    float pct4=plot(vec2(vUv.x,vUv.y-.75),y);\n    color = vec3(pct1 + pct2 + pct3 + pct4);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(.75),p,vUv.y)-\n    smoothstep(p,p-(.01),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv);\n    float y1 = sin(vUv.x *noise+ u_time);\n    float pct1 = plot(vUv , y1);\n    vec2 newUv = vUv;\n    newUv = Rot(newUv, TWO_PI);\n    float y2=sin(newUv.x*noise+u_time);\n    float pct2=plot(newUv,y2);\n    vec2 newUv2=newUv;\n    newUv2=Rot(newUv2,TWO_PI);\n    float y3=sin(newUv2.x*noise+u_time);\n    float pct3=plot(newUv2,y3);\n    color = vec3(pct1 + pct2 + pct3);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.25);\n    p=x * 0.75 ;\n    return smoothstep(p+(2.75),p,vUv.y * p)-\n    smoothstep(p,p-(2.75),vUv.y * p);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    \n    vUv = vUv * 5. - 2.5;\n    \n    float noise = snoise(vUv + sin(u_time * 0.25) ) * (22.0);\n    vUv = vUv * (noise);\n    \n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time);\n    float pct = plot(Rot(vUv, u_time * 5.0), y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(1.75),p,vUv.y * p)-\n    smoothstep(p,p-(1.75),vUv.y * p);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    \n    float n = snoise(vUv);\n    vec2 vUv = vec2(vUv.x + n, vUv.y - n);\n    \n    vUv = vUv * 5. - 2.5;\n    vUv = Rot(vUv, u_time * 0.25);\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x * n * 2.5);\n    float pct = plot(vUv, y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.25),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float c1 = cir(vUv, vec2(0.5), 0.25);\n    float y = snoise(vUv) + sin(c1);\n    float pct = plot(vec2(vUv.x, vUv.y + 0.5), y + (sin(u_time+ 15.0)) );\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KS(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JS,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $S=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.525),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 newUv = vUv;\n    newUv = Rot(vUv, u_time * 0.5);\n    float c1 = cir(vUv, vec2(0.5), 0.25);\n    float s1 = Box(newUv, vec2(0.25));\n    float y = snoise(vUv) + sin(s1);\n    float pct = plot(vec2(vUv.x, vUv.y + 0.5) + snoise(vUv + u_time * 0.25), y + (sin(u_time+ 15.0)) );\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$S,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.525),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float n = snoise(vUv + u_time) * 0.05;\n    vec2 newUv = vUv;\n    newUv = Rot(vUv, u_time * 0.5);\n    float c1 = cir(vUv + n, vec2(0.5), 0.25);\n    float s1 = Box(newUv * n, vec2(0.25));\n    float y = snoise(vUv) + sin(s1);\n    float pct = plot(vUv, s1 - c1);\n    color = 1. - vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.525),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.21, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.011), vUv);\n    b *= smoothstep(size, size + vec2(0.011), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float n = snoise(vUv * (u_time)) * 0.15;\n    vec2 newUv = vUv;\n    newUv = Rot(vUv, u_time * 0.5);\n    float c1 = cir(vUv * n, vec2(0.5), 0.25);\n    float s1 = Box(newUv + (n), vec2(0.15));\n    float y = snoise(vUv) + sin(s1);\n    float pct = plot(vUv, s1);\n    color = 1. - vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.25);\n    p=x * .95 ;\n    return smoothstep(p + 0.25,p,vUv.y)-\n    smoothstep(p,p-(0.25),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.25);\n    vUv = vUv * 8. - 4.;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vUv3 = Rot(vUv3, PI * 0.75);\n    vUv4 = Rot(vUv4,-PI * 0.75);\n    float pct1 = plot(vUv1, y);\n    float pct2 = plot(vUv2, y);\n    float pct3 = plot(vUv3, y);\n    float pct4 = plot(vUv4, y);\n    color = vec3(pct1 + pct2 + pct3 + pct4);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * .05 ;\n    return smoothstep(p + 0.25,p,vUv.y)-\n    smoothstep(p,p-(0.25),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    float n = snoise((vUv) + (u_time * 0.25)) * .19;\n    float y0 = 1. - smoothstep(size - (0.15 * n) + n, size - (0.15 * n) + n + .01, distance(vUv + n, pos));\n    float y1 = 1. - smoothstep(size + n, (size + .01) + n, distance(vUv + n, pos));\n    float y2 = 1. - smoothstep(size + (0.15 * n) + n, size + (0.15 * n)  + n+ .01, distance(vUv + n, pos));\n    return y2 - y1 + y0;\n}\n\nvec2 tile(vec2 vUv, float zoom){\n    float n = snoise(vUv + u_time) * 0.2;\n    vUv *= zoom;\n    float time = u_time * 0.1 ;\n    if (fract(time) > 0.5){\n        if(fract(vUv.y * 0.5) > 0.5){\n            vUv.x += fract(time) * 2.0;\n        } else {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5){\n            vUv.y += fract(time) * 2.0;\n        } else {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv = tile(vUv, 1.);\n    vec3 color = vec3(0.);\n    float c1 = cir(vUv, vec2(0.5), 0.125);\n    color = vec3(c1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * .05 ;\n    return smoothstep(p + 0.015,p,vUv.y)-\n    smoothstep(p,p-(0.015),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float n = snoise(vUv + u_time) * 1.0;\n    float y = sin((vUv.x * n) + u_time) / 10.0;\n    float p1 = plot(vec2(vUv.x, vUv.y + 0.1), y);\n    float p2 = plot(vec2(vUv.x, vUv.y + 0.2), y);\n    float p3 = plot(vec2(vUv.x, vUv.y + 0.3), y);\n    float p4 = plot(vec2(vUv.x, vUv.y + 0.4), y);\n    float p5 = plot(vec2(vUv.x, vUv.y + 0.5), y);\n    float p6 = plot(vec2(vUv.x, vUv.y - 0.0), y);\n    float p7 = plot(vec2(vUv.x, vUv.y - 0.1), y);\n    float p8 = plot(vec2(vUv.x, vUv.y - 0.2), y);\n    float p9 = plot(vec2(vUv.x, vUv.y - 0.3), y);\n    float p10 =plot(vec2(vUv.x, vUv.y - 0.4), y);\n    float p11 =plot(vec2(vUv.x, vUv.y - 0.5), y);\n    float p12 =plot(vec2(vUv.x, vUv.y + 0.6), y);\n    float p13 =plot(vec2(vUv.x, vUv.y + 0.7), y);\n    float p14 =plot(vec2(vUv.x, vUv.y + 0.8), y);\n    float p15 =plot(vec2(vUv.x, vUv.y + 0.9), y);\n    float p16 =plot(vec2(vUv.x, vUv.y + 1.0), y);\n    float p17 =plot(vec2(vUv.x, vUv.y - 0.6), y);\n    float p18 =plot(vec2(vUv.x, vUv.y - 0.7), y);\n    float p19 =plot(vec2(vUv.x, vUv.y - 0.8), y);\n    float p20 =plot(vec2(vUv.x, vUv.y - 0.9), y);\n    float p21 =plot(vec2(vUv.x, vUv.y - 1.0), y);\n    float p22 =plot(vec2(vUv.x, vUv.y - 1.1), y);\n    float p23 =plot(vec2(vUv.x, vUv.y + 1.1), y);\n    color = vec3(p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + p10 + p11\n                 + p11 + p12 + p13 + p14 + p15 + p16 + p17 + p18 + p19 + p20 + p21 + p22 + p23);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 1.5 - 0.25;\n        vec3 color = vec3(0.);\n        //cellular noise loops\n        vec2 point[6];\n        point[0] = vec2(0.83 + sin(u_time * 0.25), 0.75);\n        point[1] = vec2(0.60 - cos(u_time * 0.25), 0.1);\n        point[2] = vec2(0.28 , 0.64 + sin(u_time * 0.25) );\n        point[3] = vec2(0.31 , 0.26 - cos(u_time * 0.25));\n        point[4] = vec2(0.50 + sin(u_time * 0.25), 0.50 + cos(u_time * 0.25) );\n        point[5] = vec2(0.5, 0.5);\n        float m_dist = 1.;\n    \n        for(int i = 0; i < 6; i++){\n            float dist = distance(vUv, point[i]);\n            m_dist = min(m_dist, dist);\n        }\n        color = vec3(smoothstep(.345, .511, abs(sin(50. * m_dist + cos(u_time * 2.)))));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    //cellular noise loops\n   //scale\n   vUv *= 3.;\n\n   //tile the space\n   vec2 vUvI = floor(vUv);\n   vec2 vUvF = fract(vUv);\n   float m_dist = 1.; //min distance\n\n    //double loop\n    for (int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x++){\n            //neighbor grid\n            vec2 neighbor = vec2(float(x), float(y));\n            //random position from current and neighbor place in grid\n            vec2 point = random2(vUvI + neighbor);\n            //animate points\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff = neighbor + point - vUvF;\n            //distance to the point\n            float dist = length(diff);\n            //closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    color += m_dist;\n    //center cell\n    color += 1. - step(0.02, m_dist);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.25);\n    vUv = vUv * 2. - 1.;\n\n    vec3 color = vec3(0.);\n    //cellular noise loops\n   //scale\n   vUv *= 3.;\n\n   //tile the space\n   vec2 vUvI = floor(vUv);\n   vec2 vUvF = fract(vUv);\n   float m_dist = 1.; //min distance\n   vec2 m_point;//min position\n    //double loop\n    for (int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x++){\n            //neighbor grid\n            vec2 neighbor = vec2(float(x), float(y));\n            //random position from current and neighbor place in grid\n            vec2 point = random2(vUvI + neighbor);\n            //animate points\n            point = 0.25 + 0.35 * sin(u_time * TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff = neighbor + (point * sin(u_time - 20.)) - vUvF;\n            //distance to the point\n            float dist = length(diff);\n            //closer distance\n            m_dist = min(m_dist, dist);\n            m_point = point;\n        }\n    }\n\n    color = vec3(m_dist);\n    //color = vec3(abs(cos(100. * m_dist))*0.07);\n    color *= m_dist * 1.025 + abs(sin(u_time * 0.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    //center cell\n    //color += 1. - step(0.02, m_dist);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+1.15,p,vUv.y)-\n    smoothstep(p,p-(1.151),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.25);\n    vUv=vUv*2.-1.;\n    \n    vec3 color=vec3(0.);\n    //cellular noise loops\n    //scale\n    vUv*=3.;\n    \n    //tile the space\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;//min distance\n    vec2 m_point;//min position\n    //double loop\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            //neighbor grid\n            vec2 neighbor=vec2(float(x),float(y));\n            //random position from current and neighbor place in grid\n            vec2 point=random2(vUvI+neighbor);\n            //animate points\n            // point.x=.15+.15*sin(u_time*TWO_PI*point.x);\n            // point.y=.25+.35*cos(u_time*TWO_PI*point.y);\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff=neighbor+point-vUvF;\n            //distance to the point\n            float dist=length(diff);\n            //closer distance\n            m_dist=min(m_dist,m_dist * dist);\n            m_point=point;\n        }\n    }\n    \n    color=1. - vec3(m_dist) - .9;\n    color += smoothstep(0.04, 0.41, m_dist);\n    // //color = vec3(abs(cos(100. * m_dist))*0.07);\n    // //color*=m_dist*1.025+abs(sin(u_time*.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    // //center cell\n    //color += 1. - step(.2, m_dist);\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+1.15,p,vUv.y)-\n    smoothstep(p,p-(1.151),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.25);\n    vUv=vUv*2.-1.;\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //cellular noise loops\n    //scale\n    vUv*=3.;\n    \n    //tile the space\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;//min distance\n    vec2 m_point;//min position\n    //double loop\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            //neighbor grid\n            vec2 neighbor=vec2(float(x),float(y));\n            //random position from current and neighbor place in grid\n            vec2 point=random2(vUvI+neighbor);\n            //animate points\n            // point.x=.15+.15*sin(u_time*TWO_PI*point.x);\n            // point.y=.25+.35*cos(u_time*TWO_PI*point.y);\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff=neighbor+point-vUvF;\n            //distance to the point\n            float dist=length(diff);\n            //closer distance\n            m_dist=min(m_dist,m_dist * dist);\n            m_point=point;\n        }\n    }\n    color = vec3(m_dist);\n    //color += smoothstep(0.04, 0.41, m_dist);\n    // //color = vec3(abs(cos(100. * m_dist))*0.07);\n    // //color*=m_dist*1.025+abs(sin(u_time*.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    // //center cell\n    //color += 1. - step(.2, m_dist);\n    color -= smoothstep(.017, .171, abs(sin(12.0*m_dist))) * 0.25;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _M=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453) + (u_time * 0.25);\n}\n\n//return min distance\n// float cellular(vec2 vUv, float scale, vec2 vUvI, vec2 vUvF, float minDist){\n//     vUv *= scale;\n//     for(int y=-1; y<=1; y++){\n//         for(int x=-1; x<=1; x++){\n//             vec2 neighbor = vec2(float(x), float(y));\n//             vec2 point = random2(vUvI + neighbor);\n//             point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n//             vec2 diff = neighbor + point - vUvF;\n//             float dist = length(diff);\n//             minDist = min(minDist,dist);\n//             //return minDist;\n//         }\n//     }\n    \n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color=vec3(0.);\n    vUv *= 8.;\n    vUv.x +=  u_time;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    //vUv*=scale;\n    float minDist = 1.;\n    for(int y=-2;y<=2;y++){\n        for(int x=-2;x<=2;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor );\n            point=.5+.5*sin(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            minDist=min(minDist,dist + u_mouse.x + u_mouse.y);\n        }\n    }\n    color += minDist;\n    //float c1 = cellular(vUv, 4.0, vUvI, vUvF, 12.0);\n    //color += c1;\n    //color.r += step(.98, f_st.x) + step(.98, f_st.y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_M,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453) + (u_time * 0.25);\n}\n\n//simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color=vec3(0.);\n    vUv *= 5.;\n    vUv.x +=  u_time;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float n = snoise(vUv + u_time) * 0.1;\n    //vUv*=scale;\n    float minDist = 1.;\n    for(int y=-2;y<=2;y++){\n        for(int x=-2;x<=2;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor ) + n;\n            point=.5+.5*sin(u_time+TWO_PI*point);\n            // point.x = point.x + n;\n            // point.y = point.y + n;\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff + n);\n            minDist=min(minDist,dist);\n        }\n    }\n    color += minDist;\n    //color += 1. - step(0.1, minDist);\n    //color.r += step(.98, vUvF.x) + step(.98, vUvF.y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+1.15,p,vUv.y)-\n    smoothstep(p,p-(1.151),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.25);\n    vUv=vUv*2.-1.;\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //cellular noise loops\n    //scale\n    vUv*=3.;\n    \n    //tile the space\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=10.;//min distance\n    vec2 m_point;//min position\n    //double loop\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            //neighbor grid\n            vec2 neighbor=vec2(float(x),float(y));\n            //random position from current and neighbor place in grid\n            vec2 point=random2(vUvI+neighbor);\n            //animate points\n            // point.x=.15+.15*sin(u_time*TWO_PI*point.x);\n            // point.y=.25+.35*cos(u_time*TWO_PI*point.y);\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff=neighbor+point-vUvF;\n            //distance to the point\n            float dist=length(diff);\n            //closer distance\n            m_dist=min(m_dist,m_dist * dist);\n            m_point=point;\n        }\n    }\n    color = 1. - vec3(m_dist);\n    //color += smoothstep(0.04, 0.41, m_dist);\n    // //color = vec3(abs(cos(100. * m_dist))*0.07);\n    // //color*=m_dist*1.025+abs(sin(u_time*.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    // //center cell\n    //color += 1. - step(.2, m_dist);\n    color -= smoothstep(.017, .171, abs(sin(12.0*m_dist))) * 0.25;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.;\n    vec2 vUvI = floor(vUv);\n    vec2 vUvF = fract(vUv);\n    float m_dist = 0.5 * sin(u_time) + 2.0;\n    for(int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x ++){\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = random2(vUvI + neighbor);\n            point = 0.5 + 0.5 * cos(u_time + TWO_PI * point);\n            vec2 diff = neighbor + point - vUvF;\n            float dist = length(diff) ;\n            m_dist = min(m_dist, dist);\n            \n        }\n    }\n    color.rg += m_dist;\n    color.rg += 1.- smoothstep(0.01, 0.011, m_dist);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    vUv.x+=u_time*.025;\n    vUv*=5.;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.05+.2*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    color +=m_dist;\n    color +=1.-smoothstep(.01,.011,m_dist);\n    color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.025,p,vUv.y)-\n    smoothstep(p,p-(0.025),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.025;\n    vUv*=5.;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 0.25;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.5+.5*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n            float y =dist-m_dist;\n            float pct = plot(point, y);\n            color = vec3(pct);\n        }\n    }\n    \n    //color +=m_dist;\n    color +=1.-smoothstep(.01,.011,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.025,p,vUv.y)-\n    smoothstep(p,p-(0.25),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.025;\n    vUv*=5.;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 0.25;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.5+.25*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n            float y =m_dist;\n            float pct = plot(vUvF, y);\n            color = vec3(pct);\n            \n            \n        }\n    }\n    \n    //color +=m_dist;\n    color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.025,p,vUv.y)-\n    smoothstep(p,p-(0.025),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=8.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 4.;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.5+.5*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist = dot(diff, diff);\n            dist -= 0.65;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist * 3.;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    for(int y=-5;y<=5;y++){\n        for(int x=-5; x<=5;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.75+.75*sin(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.75));\n            dist1=plot(diff, vUvF.y);\n            float dist = dot(diff / dist1, diff/ dist1);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist * 3.;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-5;y<=5;y++){\n        for(int x=-5; x<=5;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=2.35+1.25*sin(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.5));\n            dist1=plot(diff, vUv.y - 2.5);\n            float dist = dot(diff / dist1 / 15., diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist * 3.;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=10.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-5;y<=5;y++){\n        for(int x=-5; x<=5;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=2.35+0.95*abs(sin(u_time+TWO_PI*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.5));\n            dist1=plot(diff, vUv.y - 2.5);\n            float dist = dot(diff / dist1 / 15., diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=12.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) * 0.5;\n            point= .8*abs(sin(u_time+TWO_PI+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff / dist1 / 25., diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    \n    color = vec3(0., 0.25, 0.5);\n    color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=12.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.5;\n            point=4.-abs(sin(u_time+TWO_PI+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.15));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff/m_dist,diff/m_dist);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    color=vec3(0.,.25,.5);\n    color=vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.5;\n            point=(sin(u_time+TWO_PI*2.*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.005));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff/m_dist/m_dist,diff/m_dist/m_dist);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    color=vec3(0.,.25,.5);\n    color+=vec3(m_dist) * 0.9;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=5.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.25;\n            point=0.5 + 1.5 * (sin(u_time+TWO_PI + TWO_PI* 2.75*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.05));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff/m_dist,diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    //color=vec3(0.,.25,.5);\n    color+=vec3(m_dist) * 2.0;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=12.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) * 0.5;\n            point= .8*abs(sin(u_time+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15 * sin(u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            float y = plot(point, m_dist);\n            color = vec3(y);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color = vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KM(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JM,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $M=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= 0.5 + .8*abs(sin(u_time+TWO_PI*2.75*point) + 12.0);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            float y = plot2(vUv, m_dist, m_dist);\n            color = vec3(y);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color = vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$M,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ez=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa - ba*h);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= .8*abs(sin(u_time+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(vUvF + m_dist, point, neighbor);\n            color = vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color = vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ez,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float m) {\n    float thickness = 2.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b * m);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 3.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= .9*abs(sin(u_time+TWO_PI*1.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.25 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(vUvF, point, neighbor, m_dist);\n            color = vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var az=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.5;\n            point=1. + 1.8*abs(sin(u_time+TWO_PI+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.15));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff,diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    color=vec3(1.,.25,.5);\n    color*=1. - vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:az,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float m) {\n    float thickness = 2.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b * m);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 8.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= .7*abs(sin(u_time+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.25 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(neighbor, point/m_dist, point * m_dist, 0.15);\n            color = 1. - vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.5,p,vUv.y * m)-\n    smoothstep(p,p-(0.5),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float m) {\n    float thickness = 5.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b * m);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv -= 0.25;\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= 0.5 + .35*abs(cos(u_time+PI*20.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.25 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff/m_dist, diff/m_dist);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(vUvF, point, neighbor, m_dist);\n            color = vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n    float md = 8.0;\n\n    for (int i = -1; i <=1; i++){\n        for(int j = -1; j<= 1; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md){\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    md = 8.0;\n    for (int i = -3; i <=3; i++){\n        for(int j = -3; j<= 3; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            if (dot(mr -r, mr -r) > 0.00001){\n                md = min(md, dot(0.5 * (mr + r), normalize(r -mr)));\n\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, u_time * 0.25);\n    vUv *= 3.;\n    vec3 c = voronoi(vUv);\n    float dd = length( c.yz );\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.02, c.x * c ) );\n    //color += vec3(1.) * (1. - smoothstep(0.0, 0.04, dd));\n    //color = c;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n    float md = 8.0;\n\n    for (int i = -1; i <=1; i++){\n        for(int j = -1; j<= 1; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md){\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    md = 8.0;\n    for (int i = -2; i <=2; i++){\n        for(int j = -2; j<= 2; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            if (dot(mr -r, mr -r) > 0.00001){\n                md = min(md, dot(0.5 * (mr + r), normalize(r -mr)));\n\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv = vUv * 2. - 1.;\n    vUv *= 2.5 + sin(u_time * 0.5);\n    vec3 c = voronoi(vUv);\n    float dd = length( c.yz );\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.04, c.x) );\n    //color += vec3(1.) * (1. - smoothstep(0.0, 0.04, dd));\n    color *= c * 20.;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\n//simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec3 voronoi(vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n    float md = 8.0;\n\n    for (int i = -1; i <=1; i++){\n        for(int j = -1; j<= 1; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md){\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    md = 8.0;\n    for (int i = -2; i <=2; i++){\n        for(int j = -2; j<= 2; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            if (dot(mr -r, mr -r) > 0.00001){\n                md = min(md, dot(0.5 * (mr + r), normalize(r -mr)));\n\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    float n = snoise(vUv + (u_time * 0.25)) * 0.4;\n    vUv = vUv * 2. - 1.;\n    vUv *= 2.5 + sin(u_time * 0.5);\n    vec3 c = voronoi(vUv + u_time);\n    float dd = length( c.yz );\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.011, c.x * c.y * c.z) );\n    //color += vec3(1.) * (1. - smoothstep(0.0, 0.04, dd));\n    //color *= c * 20.;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=0.1;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi(vUv);\n    float dd=length(c.yz);\n    color=1. - mix(vec3(1.),color,smoothstep(.01,.04,c.x));\n    color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n//book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=.1;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md,mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x+=u_time*.15;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    float n = snoise(vUv + u_time) * 0.05;\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x+=u_time*.25;\n    vec3 c=voronoi(vUv);\n    vec3 c2=voronoi(vec2(vUv.x+n+0.25,vUv.y+n+0.25));\n    vec3 c3=voronoi(vec2(vUv.x-n-0.25,vUv.y-n-0.25));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.01,.04,c.x));\n    color+=mix(vec3(1.),color,smoothstep(.01,.04,c2.x));\n    color+=mix(vec3(1.),color,smoothstep(.01,.04,c3.x));\n    //color-=vec3(1.)*(1.-smoothstep(.1,.11,dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _z=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=3.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi(vUv);\n    float dd=length(c.yz);\n    color=1. - mix(vec3(1.),color,smoothstep(.01,.04,c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_z,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=3.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=3.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi(vUv);\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.01 + c.x,.08,c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Sz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Mz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=3.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=3.5;\n    vUv.x += u_time * 0.125;\n    vec3 c1=voronoi(vec2(vUv.x, vUv.y + sin(u_time)));\n    vec3 c2=voronoi(vec2(vUv.x, vUv.y + 0.25 + sin(u_time)));\n    vec3 c3=voronoi(vec2(vUv.x, vUv.y - 0.25 + sin(u_time)));\n    float dd=length(c1.yz);\n    color=mix(vec3(1.),color,smoothstep(.05,.051,c1.x));\n    color=mix(vec3(1.),color,smoothstep(.045,.0451,c2.x));\n    color=mix(vec3(1.),color,smoothstep(.035,.0351,c3.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Mz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.2,.21,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Cz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz)/2.;\n    color=1. - mix(vec3(1.),color,smoothstep(.2,.21,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Rz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Tz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    // float c1 = cir(vec2 vUv, vec2(0.5), 0.25);\n    float dd=length(c.yz);\n    color=1. - mix(vec3(1.),color,smoothstep(.05,.1,c.x));\n    color /= vec3(1.) * (1. - smoothstep(0.01, 0.91, dd ));\n    color*=c.z * c.y / c.x * 50.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Pz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Dz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Fz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    float x = smoothstep(size + 0.05, size + 0.06, distance(vUv, pos));\n    float y = smoothstep(size, size + 0.01, distance(vUv, pos));\n    return x * y;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vec2 newUv = vUv;\n    //vUv.x += u_time * 0.25;\n    \n    float c1 = cir(newUv, vec2(0.5), 0.45);\n    vec3 color=vec3(0.);\n    color = vec3(c1); \n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5 * sin(u_time * 0.5) + 5.0;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    \n    float dd=length(c.yz);\n    \n    color=1. - mix(vec3(1.),color,smoothstep(.05,.04,c.x));\n    //color /= vec3(1.) * (1. - smoothstep(0.01, 0.91, dd ));\n    color*=c.x * 50.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Fz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Iz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.125;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.5,.51,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color+=c.x*50.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ez(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Iz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Oz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.125;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*4.-2.;\n    vUv*=1.;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.45,.751,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color/=c.x * 70.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Oz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Az=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.025*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, vec2(mr.x, mr.y/md/(200.0 - sin(u_time))));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.125;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*4.-2.;\n    vUv*=2.;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.45,.751,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color/=c.x;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Gz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Az,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Nz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    float plot(vec2 vUv,float p){\n        return smoothstep(p + 0.09,p,vUv.y)-\n        smoothstep(p,p-(0.02),vUv.y);\n    }\n    \n    float fbm(vec2 vUv, int octaves){\n        //inital values\n        float value = 0.0;\n        float amplitude = 0.5 ;\n        float frequency = 0. ;\n        //loop of octaves\n        for (int i = 0; i < octaves; i++){\n            //vUv += 2.;\n            value += amplitude * (noise(vUv + u_time));\n            //vUv = vUv * 2. - 1.;\n            vUv *= 2.;\n            // vUv.x += u_time * 0.5;\n            amplitude *= 0.5 ;\n        }\n        return value; \n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = fbm(vUv, 6);\n        // float pct = plot(vec2(vUv), y);\n        // color = vec3(pct);\n        color += y;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Bz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Nz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0, amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color += y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Vz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = 0.6;\n    vec2 shift = vec2(100.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.05);\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 1.5;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv + 0.2 * u_time);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + r);\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.066667,0.666667,0.498039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,0.5,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f * f * f + 0.6 * f * f + 0.5 * f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Hz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Wz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .9;\n    vec2 shift = vec2(1000.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 1.5;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv + 0.2 * u_time);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.066667,0.666667,0.498039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,0.5,0.164706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.666667,1.,1),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Yz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Xz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Zz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 4.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,.8,0.94706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.166667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Qz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Zz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Jz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = .0;\n    float a = .55;\n    vec2 shift = vec2(1.5);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.25);\n        a *= 1.05 * noise(vUv);\n    }\n    return v;\n}\n\n//  \n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.01);\n    vUv *= 2.;\n    vUv.x += u_time * 0.24;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.3, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(9.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((f),0.4,1.0));\n\n    color = mix(color,\n                vec3(0.15,.78,0.94706),\n                clamp(length(q),.2,1.0));\n\n    color = mix(color,\n                vec3(0.66667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = 1. - f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Kz(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Jz,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $z=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 0.5 ;\n    float offset = 1. + snoise(p + (u_time * 0.25));\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 5.;\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum += n*amp;\n        sum += n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$z,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ek=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 0.5 ;\n    float offset = 1. + snoise(p + (u_time * 0.25));\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 5.;\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum += n*amp;\n        sum += n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv + snoise(vUv + (u_time * 0.1)));\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2 + sin(u_time)),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ek,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ok=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 1.5 ;\n    float offset = 1.25 + snoise(p + (u_time * 0.5));\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 5.;\n        float n = 1. - ridge(snoise(p*freq + (u_time * 0.5)), offset);\n        sum += n*amp;\n        sum += 1. - n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 5.;\n    float y = ridgedMF(vUv + snoise(vUv + (u_time * 0.1)));\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2 + sin(u_time)),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ok,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ak=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h ;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 1.5 ;\n    float offset = 1.1;\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 3.;\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum = n*amp;\n        sum += n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 23.;\n    float y = ridgedMF(vUv);\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ik(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ak,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0 ;\n    float gain = 0.25 ;\n    float offset = .9;\n\n    float sum = .0;\n    float freq = 1.0; \n    float amp = 0.75;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        //p *= 3.;\n        p.x += u_time * 0.2;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev * snoise(vUv + u_time * 0.5);  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv * 3.0);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ck(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0 ;\n    float gain = 0.25 ;\n    float offset = .9;\n\n    float sum = .0;\n    float freq = 1.0; \n    float amp = 0.75;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        //p *= 1.5;\n        p.x += u_time * 0.2;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev - snoise(p + u_time * 0.25);  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv * 3.0);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * PI * 0.25 * vUv * 3. + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 5.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667 + sin(u_time)),\n                vec3(0.966667,0.666667,0.098039 + sin(u_time)),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,.8,0.94706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.166667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f * f2 + f + f2;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .95;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv + u_time);\n        //vUv = rot * PI * 0.25 *vUv * 3. + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 10.;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    // q.x = fbm(vUv * vec2(8.));\n    // q.y = fbm(vUv * vec2(8.));\n\n    vec2 r = vec2(0.);\n    // r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    // r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667 + sin(u_time)),\n                vec3(0.966667,0.666667,0.098039 + sin(u_time)),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,.8,0.94706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.166667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f * f2 * f * f2;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.1;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st + (u_time * 0.5));\n            st *= 6.;\n            //st.x += u_time * 0.25;\n            amplitude *= .25;\n        }\n        return value;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float x = fbm(vUv * 1.0 + fbm(vUv * 3.0 + fbm(vUv * 5.0 + fbm(vUv * 7.0 + fbm(vUv * 11.0)))));\n    \n        vec2 q = vec2(0.);\n        q.x = fbm( vUv + 0.00*u_time);\n        q.y = fbm( vUv + vec2(1.0));\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.015*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.0126*u_time);\n        //x += x * sin(u_time * 0.15);\n        //color += x;\n        //color.x += sin(u_time * 0.05);\n        color = mix(color,\n                    vec3(0,0,0.164706),\n                    clamp(length(x),0.0,1.0));\n    \n        color = mix(color,\n                    vec3(0.966667,0,0),\n                    clamp(length(x),0.0,1.0));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f) ;\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.1;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st + (u_time * 0.5));\n            st *= 5.;\n            //st.x += u_time * 0.25;\n            amplitude *= .25;\n        }\n        return value;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2.75;\n        vec3 color = vec3(0.);\n        float x = fbm(vUv * 1.0 + fbm(vUv * 2.0 + fbm(vUv * 3. + fbm(vUv * 4. + fbm(vUv * 5.)))));\n        x += x - noise(vUv + u_time * 0.1);\n        vec2 q = vec2(0.);\n        q.x = fbm( vUv);\n        q.y = fbm( vUv);\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n        //x += x * sin(u_time * 0.15);\n        //color += x;\n        //color.x += sin(u_time * 0.05);\n        color = mix(color,\n                    vec3(0.2,0.4,0.64706),\n                    clamp(length(x),0.0,1.0));\n    \n        color = mix(color,\n                    vec3(0.166667,0.9,0.6),\n                    clamp(length(x),0.0,1.0));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.1;\n    float lacunarity = 2.0;\n    float prev = 1.0;\n    float offset = 0.9;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.25)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5.75;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + fbm(vUv * 5. + fbm(vUv * 10.)));\n    color += x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    // color = mix(color,\n    //             vec3(0.2,0.4,0.64706),\n    //             clamp(length(r),0.0,0.5));\n\n    // color = mix(color,\n    //             vec3(0.166667,0.5,0.7),\n    //             clamp(length(q),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _k=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.1;\n    float lacunarity = 2.0;\n    float prev = 1.0;\n    float offset = 0.9;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.25)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    // vUv = vUv * 1.75;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + snoise(vUv + u_time * 0.01) - fbm(vUv * 5. - fbm(vUv * 10. + fbm(vUv ))));\n    color += 1. - x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.0125*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.0126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    // color = mix(color,\n    //             vec3(0.2,0.4,0.64706),\n    //             clamp(length(r),0.0,0.5));\n\n    color = mix(color,\n                vec3(0.966667,0.,0.),\n                clamp(length(x),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_k,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.125;\n    float lacunarity = 2.;\n    float prev = 0.25;\n    float offset = 1.;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.125)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5.;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + fbm(vUv * 1.1 + fbm(vUv * 1.2 + fbm(vUv * 1.3 ))));\n    color += x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.125*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.0126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    // color = mix(color,\n    //             vec3(0.2,0.4,0.64706),\n    //             clamp(length(r),0.0,0.5));\n\n    color = mix(color,\n                vec3(0.066667,0.9,0.),\n                clamp(length(x),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Sk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Mk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f) ;\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.1;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st + (u_time * 0.5));\n            st *= 5.;\n            //st.x += u_time * 0.25;\n            amplitude *= .125;\n        }\n        return value;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2.75;\n        vUv.x += u_time * 0.25;\n        vec3 color = vec3(0.);\n        float x = fbm(vUv * 1.0 + fbm(vUv * 2.0 + fbm(vUv * 3. + fbm(vUv * 4. + fbm(vUv * 5.)))));\n        x += x - noise(vUv + u_time * 0.1);\n        vec2 q = vec2(0.);\n        q.x = fbm( vUv);\n        q.y = fbm( vUv);\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n        //x += x * sin(u_time * 0.15);\n        //color += x;\n        //color.x += sin(u_time * 0.05);\n        color = mix(color,\n                    vec3(0.0,0.,0.54706),\n                    clamp(length(x - r),0.0,1.0));\n    \n        color = mix(color,\n                    vec3(0.96667,0.2,.0),\n                    clamp(length(x - q),0.0,1.0));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Mk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a / noise(vUv - u_time * 0.2);\n        vUv = rot * PI * 0.25 * vUv * 3. + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return 1. -  v / 4.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 2.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv * 1.2 + fbm(vUv * 1.2 + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color *= mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f2*f2)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,.8,0.94706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.166667,.1,0.2),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f + f2 + noise(vUv + u_time);\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ck(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.1;\n    float lacunarity = 2.0;\n    float prev = 1.0;\n    float offset = 0.9;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.25)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.75;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + fbm(vUv * 5. + fbm(vUv * 10.)));\n    color += x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    color = mix(color,\n                vec3(0.1,0.9,0.64706),\n                clamp(length(r- x),0.0,0.5));\n\n    color = mix(color,\n                vec3(0.166667,0.5,0.7),\n                clamp(length(q - x),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Rk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Tk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h + h ;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .01 ;\n    float gain = 0.25 ;\n    float offset = .1;\n\n    float sum = .25;\n    float freq = 4.15; \n    float amp = 3.25;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        //p *= 1.5;\n        p.x += u_time * 0.2;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev - snoise(p + u_time * 0.15);  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain * 0.01;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv * 1.0);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Pk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Dk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Fk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h * h * h * (abs(sin(u_time)) + 0.75);      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 112.0;\n    float gain = 0.0125;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time * 0.5));\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color.g += y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Fk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ik=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h * h * h * (abs(sin(u_time)) + 0.75);      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .25 + snoise(p + u_time)* 0.015;\n    float gain = 1.25;\n    float offset = 0.6;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.025;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time * 0.5));\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color.br += y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ek(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ik,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ok=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset + h; // invert so creases are at top\n    h = h * h * h * h * h * h + snoise(vUv + u_time) * 0.1;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .25 + snoise(1. - p + u_time)* 0.0115;\n    float gain = 1.25;\n    float offset = 0.96;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.0025;\n    float prev = 12.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.05;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time) * 1.25);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    //color.br += y;\n    color.b += y;\n    color.bg += y * abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ok,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ak=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset + h; // invert so creases are at top\n    h = h * h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .25;\n    float gain = 1.25;\n    float offset = 0.01 + snoise(vUv + u_time * 0.25);\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.0025;\n    float prev = 12.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 4.0;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv.x += u_time * 0.25;\n    float y = ridgedMF(vUv);\n    //color.br += y;\n    color.rb += y;\n    color.bg += y * abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Gk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ak,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Nk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 1.25;\n    float gain = 0.5;\n    float offset = 0.9 + snoise(vUv + u_time * 0.25);\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.25;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv.x += u_time * 0.05;\n    float y = ridgedMF(vUv);\n    //color.br += y;\n    color.rb += y;\n    color.bg += y * abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Bk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Nk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.65;\n        vec2 shift = vec2(100.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a * noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 2.25 + shift;\n             a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 2.0;\n    \n        vec2 q = vec2(0.);\n        q.x = fbm( vUv + 0.05*u_time);\n        q.y = fbm( vUv + vec2(1.0));\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    \n        float f = fbm(vUv + fbm(vUv + fbm(vUv + fbm(vUv + fbm(vUv + fbm(vUv))))));\n        color = vec3(f * f * f * f);\n    \n        // color = mix(vec3(0.101961,0.619608,0.666667),\n        //             vec3(0.666667,0.666667,0.498039),\n        //             clamp((f*f)*4.0,0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0,0,0.164706),\n        //             clamp(length(q),0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0.666667,1,1),\n        //             clamp(length(r.x),0.0,1.0));\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Vk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.65;\n        vec2 shift = vec2(100.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a * noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 2.25 + shift;\n             a *= 0.53;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 2.0;\n    \n        float f = fbm(vUv + fbm(vUv / fbm(vUv)));\n        color = vec3(f * f * f * f);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Hk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Wk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.65;\n        vec2 shift = vec2(100.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a * noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 2.25 + shift;\n             a *= 0.83;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 0.5;\n    \n        float f = fbm(vUv / u_time + fbm(vUv * fbm(vUv)));\n        color = 1. - vec3(f * f * f * f);\n    \n        // vec2 q = vec2(0.);\n        // q.x = fbm( vUv + 0.05*u_time);\n        // q.y = fbm( vUv + vec2(1.0));\n    \n        // vec2 r = vec2(0.);\n        // r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        // r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    \n        // color = mix(vec3(0.101961,0.619608,0.666667),\n        //             vec3(0.666667,0.666667,0.498039),\n        //             clamp((f-f)*.0,0.,1.0));\n    \n        // color = mix(color,\n        //             vec3(0,0,0.164706),\n        //             clamp(length(q),0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0.666667,1,1),\n        //             clamp(length(r.x),0.0,1.0));\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Yk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Xk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Zk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.25;\n        vec2 shift = vec2(1.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a / noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 1. + shift;\n             a *= 0.65;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 5.25;\n        vUv.x += u_time * 0.25;\n        float f = fbm(vUv + u_time + fbm(vUv / fbm(vUv)));\n        color = vec3(f / f / f / f);\n    \n        // vec2 q = vec2(0.);\n        // q.x = fbm( vUv + 0.05*u_time);\n        // q.y = fbm( vUv + vec2(1.0));\n    \n        // vec2 r = vec2(0.);\n        // r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        // r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    \n        // color = mix(vec3(0.101961,0.619608,0.666667),\n        //             vec3(0.666667,0.666667,0.498039),\n        //             clamp((f-f)*.0,0.,1.0));\n    \n        // color = mix(color,\n        //             vec3(0,0,0.164706),\n        //             clamp(length(q),0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0.666667,1,1),\n        //             clamp(length(r.x),0.0,1.0));\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Qk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Zk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Jk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a / noise(vUv - u_time * 0.2);\n        vUv = rot * PI * 0.25 * vUv * 3. + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return 1. -  v / 4.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 2.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv * 1.2 + fbm(vUv * 1.2 + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color *= mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f2*f2)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,.8,0.94706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.166667,.1,0.2),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f + f2 + noise(vUv + u_time);\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Kk(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Jk,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $k=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = 1.55;\n    vec2 shift = vec2(0.1);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a ;\n        vUv = rot * PI * 0.15 * vUv * 4. + (u_time * 0.25);\n        a *= .95 * noise(vUv + u_time);\n    }\n    return 1. -  v / 4.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 2.;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv * fbm(vUv))));\n    float f2 = fbm(vUv * 1.2 + fbm(vUv * 1.2 + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color *= mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f2*f2)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,.8,0.94706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.166667,.1,0.2),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f + f2 + noise(vUv + u_time);\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$k,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h  * (abs(sin(u_time)) + 0.95);      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 152.0;\n    float gain = 0.0125;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time * 0.25));\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color.g += y + y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float amp = 0.5;\n        float freq = 0.1;\n    \n        for( int i = 0; i < OCTAVES; i++){\n            v += amp * noise(vUv + u_time * 0.25);\n            vUv *= 2.;\n            amp *= .5;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv.x += u_time * 0.1;\n        float y = fbm(vUv * 5. * fbm(vUv * 5. * fbm(vUv * 5.)));\n        color.x = 1. - y;\n        \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 0.1;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.15)));\n        vUv *= 2.;\n        amp *= .5;\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 0.125;\n    vUv.x += u_time * 0.01;\n    float y = fbm(vUv * 10.) + fbm (vUv * 20.) + fbm(vUv * 10.);\n    color.b = 1. - y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.1);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.;\n    vUv.x += u_time * 0.1;\n    float y = fbm(vUv + fbm(vUv));\n    color += y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.1);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .5;\n    vUv.x += u_time * 0.05;\n    float y = fbm(vUv + fbm(vUv));\n    color.r += y + y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .5;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv) + snoise(vUv * (u_time * 0.015)));\n    color.br += y * y;\n    color.gr += y * y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 1.45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        v *= freq;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .5;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv) + snoise(vUv * (u_time * 0.015)));\n    color.br += y * y;\n    color.gr += y * y * y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 1.45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        v /= freq;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv) + snoise(vUv + (u_time * 0.015)) + fbm(vUv + fbm(vUv)));\n    color.br *= y * y ;\n    color.gr *= y * y * y;\n    color += y + fbm(vUv + fbm(vUv));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 1.45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        v /= freq;\n        amp *= .85 + snoise(vUv + u_time * 0.1);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .125;\n    vUv.x += u_time * 0.00125 + 5.;\n    float y = fbm(vUv + fbm(vUv));\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += 1. - y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = .25;\n    float freq = .45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 1.5;\n        v *= freq;\n        amp *= 1. + snoise(vUv + u_time * 0.1);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .125;\n    vUv.x += u_time * 0.00125 + 5.;\n    float y = fbm(vUv - fbm(vUv));\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += 1. - y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _C=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.15;\n    float offset = 0.9;\n    float amp = 0.5;\n    float sum = 0.0;\n    float freq = 1.0; \n    float prev = 1.0;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq), offset * sin(snoise(vUv + u_time * 0.25)));\n        sum += v *amp;\n        sum += v * amp * prev;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*3.0);\n    float x = fbm(vUv*6.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_C,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.25;\n    float offset = 0.9;\n    float amp = 0.5;\n    float sum = 0.0;\n    float freq = 1.0; \n    float prev = 1.0;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq + (u_time * 0.025)), offset * sin(snoise(vUv + (u_time * 0.025))));\n        sum += v *amp;\n        sum += v * amp * prev;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*3.0 * fbm(vUv));\n    float x = fbm(vUv*6.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.125;\n    float offset = 0.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = .75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq + (u_time * 0.125)), offset);\n        sum += v *amp;\n        sum += v * amp * prev ;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*.5);\n    float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y / x;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.125;\n    float offset = 0.99;\n    float amp = 10.125;\n    float sum = 0.;\n    float freq = .75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq + (u_time * 0.125)), offset );\n        sum += v *amp;\n        sum += v * amp * prev ;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*4.0);\n    float x = fbm(vUv*3.5);\n    //color = vec3(y);\n    color.br += y ;\n    color.gr /= x;\n    //color.gr += y * y * y;\n    //color += y / x;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.125;\n    float offset = 0.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = .75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq * (snoise(vUv + (u_time * 0.125))) ), offset);\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 0.75;\n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*0.05);\n    float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color +=1. -  x / y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 1.1;\n    float gain = 0.5;\n    float offset = 1.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.75;\n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv);\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 1.1;\n    float gain = 0.95125;\n    float offset = 1.95;\n    float amp = .50;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .25;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.75;\n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv);\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv + snoise(vUv + (u_time * 0.05))) + snoise(vUv + (u_time * 0.015)));\n    color.br -= y * y * y;\n    color.gr += y * y * y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 1.9;\n    float gain = 0.5;\n    float offset = 1.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.75;\n    vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv - fbm(vUv));\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color.gr += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 12.9;\n    float gain = 0.25;\n    float offset = .19;\n    float amp = .5;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .95;\n    vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv + fbm(vUv));\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color.g += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 5.9;\n    float gain = 0.25 ;\n    float offset = .19 ;\n    float amp = .5 ;\n    float sum = 0. ;\n    float freq = 1.35 * (snoise(vUv + (u_time * 0.1))); \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp  ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.25;\n    vUv.x += 5.;\n    float y = fbm(vUv) * fbm(vUv) ;\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    color.br += y  ;\n    color.gr += y * y;\n    //color.g += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h + h * h + h ;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = .9;\n    float gain = 0.05 ;\n    float offset = .39 ;\n    float amp = .75 ;\n    float sum = 0. ;\n    float freq = 1.5 * (snoise(vUv + (u_time * 0.1))); \n    float prev = .25;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq), offset * (snoise(vUv + (u_time * 0.005))) );\n        sum += v *amp  ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.;\n    vUv.x += 5.;\n    float y = fbm(vUv) * fbm(vUv) + fbm(vUv) * 0.75 ;\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    color.r += y * y * y * y ;\n    color.b += y + y;\n    //color.g += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot(vec2 st){\n        return smoothstep(0.5, 0.0, abs(st.y - st.x));\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv*=2.;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv *= 4. - 3.;\n        vec2 vUv1 = vUv;\n        vec2 vUv2 = vUv;\n        vec2 vUv3 = vUv;\n        vUv3 = Rot(vUv, -(u_time * 4.5));\n        vUv2 = Rot(vUv, -(u_time * 3.0));\n        vUv1 = Rot(vUv, -(u_time * 2.5));\n        vec3 color = vec3(0.);\n        float y = vUv.x;\n        float x = 1. -  vUv.x;\n        float pct = plot(vUv1);\n        float pct2 = plot(vUv2);\n        float pct3 = plot(vUv3);\n        color = vec3(y * x);\n        color += vec3(pct) * vec3(1.0, .0, .0);\n        color += vec3(pct2) * vec3(.0, 1.0, .0);\n        color += vec3(pct3) * vec3(.0, .0, 1.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot(vec2 st, float pct){\n        return smoothstep(pct-0.1, pct, st.y) -\n               smoothstep(pct, pct+0.1, st.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 5. - 2.;\n        //vUv.y += 1.5;\n        \n        vec3 color = vec3(0.);\n        \n        //power function\n        //returns the value of x raised to the power of y\n        float y1 = pow(vUv.x, 5.0);\n        float pct1 = plot(vUv, y1);\n    \n        //exponentiation function\n        //returns the natural exponentiation of x\n        float y2 = exp(vUv.x);\n        float pct2 = plot(vUv, y2);\n    \n        //logarithm function\n        //returns the natural logarithm of x\n        float y3 = log(vUv.x);\n        float pct3 = plot(vUv, y3);\n    \n        //square root function\n        //returns the square root of x\n        float y4 = sqrt(vUv.x);\n        float pct4 = plot(vUv, y4);\n    \n        color += pct1*vec3(0.0,1.0,0.0);\n        color += pct2*vec3(1.0,0.0,0.0);\n        color += pct3*vec3(0.0,0.0,1.0);\n        color += pct4*vec3(1.0,1.0,.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    float plot(vec2 st, float pct){\n        return smoothstep(pct-0.35, pct, st.y) -\n               smoothstep(pct, pct+0.35, st.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        //rainbow\n        //red\n        float y1 = sqrt(vUv.x);\n        float pct1 = plot(vec2(vUv.x, vUv.y - 0.45 * sin(u_time)), y1);\n    \n        //orange\n        float y2 = sqrt(vUv.x);\n        float pct2 = plot(vec2(vUv.x, vUv.y - 0.30 * sin(u_time)), y2);\n    \n        //yellow\n        float y3 = sqrt(vUv.x);\n        float pct3 = plot(vec2(vUv.x, vUv.y - 0.25 * sin(u_time)), y3);\n    \n        //green\n        float y4 = sqrt(vUv.x);\n        float pct4 = plot(vec2(vUv.x, vUv.y - 0.10 * sin(u_time)), y4);\n    \n        //blue\n        float y5 = sqrt(vUv.x);\n        float pct5 = plot(vec2(vUv.x, vUv.y + 0.25 * sin(u_time)), y5);\n    \n        //indigo\n        float y6 = sqrt(vUv.x);\n        float pct6 = plot(vec2(vUv.x, vUv.y + 0.35 * sin(u_time)), y6);\n    \n        //violet\n        float y7 = sqrt(vUv.x);\n        float pct7 = plot(vec2(vUv.x, vUv.y + 0.55 * sin(u_time)), y7);\n    \n    \n        color += pct1*vec3(1.0,0.0,0.0);\n        color += pct2*vec3(1.0,0.6,0.0);\n        color += pct3*vec3(1.0,1.0,0.0);\n        color += pct4*vec3(0.0,0.5,0.0);\n        color += pct5*vec3(0.0,0.0,1.0);\n        color += pct6*vec3(0.29,0.0,0.5);\n        color += pct7*vec3(0.9,0.5,0.9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4. - 2.;\n    vec3 color = vec3(0.);\n\n    float y6 = log(vUv.x - 4. + sin(u_time));\n    float pct6 = plot(vec2(vUv.x, vUv.y), y6);\n    color += pct6;\n\n    float y5 = log(vUv.x - 2. + sin(u_time));\n    float pct5 = plot(vec2(vUv.x, vUv.y), y5);\n    color += pct5;\n\n    float y1 = log(vUv.x + sin(u_time));\n    float pct1 = plot(vUv, y1);\n    color += pct1;\n\n    float y2 = log(vUv.x + 2. + sin(u_time));\n    float pct2 = plot(vec2(vUv.x, vUv.y), y2);\n    color += pct2;\n\n    float y3 = log(vUv.x + 4. + sin(u_time));\n    float pct3 = plot(vec2(vUv.x, vUv.y), y3);\n    color += pct3;\n\n    float y4 = log(vUv.x + 6. + sin(u_time));\n    float pct4 = plot(vec2(vUv.x, vUv.y), y4);\n    color += pct4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KC(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JC,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $C=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    //step function\n    float y1 = 1. - step(0.142 * 1., vUv.x);\n    float y2 = 1. - step(0.142 * 2., vUv.x);\n    //float y2 = step(0.142 * 5.,1. - vUv.x);\n    float y3 = 1. - step(0.142 * 3., vUv.x);\n    float y4 = 1. - step(0.142 * 4., vUv.x);\n    float y5 = 1. - step(0.142 * 5., vUv.x);\n    float y6 = 1. - step(0.142 * 6., vUv.x);\n    float y7 = 1. - step(0.144 * 7., vUv.x);\n    \n    color.r += y1 + sin(u_time - 0.5);\n    color.g += y2 - sin(u_time + 1.0);\n    color.b += y3 + sin(u_time - 1.5);\n    color.r += y4 - sin(u_time + 2.0);\n    color.g += y5 + sin(u_time - 2.5);\n    color.b += y6 - sin(u_time + 3.0);\n    color.r += y7 + sin(u_time - 3.5);\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$C,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 6. - 3.;\n    vec3 color = vec3(0.);\n    //smoothstep line\n    float y1 = (sin(vUv.x + u_time * PI) + 2.0) * sin(u_time * 1.2);\n    float y2 = (sin(vUv.x + u_time * PI) + 1.0) * sin(u_time * 0.9);\n    float y3 = (sin(vUv.x + u_time * PI) - 1.0) * sin(u_time * 0.5);\n    float y4 = (sin(vUv.x + u_time * PI) - 2.0) * sin(u_time * 1.5);\n    float y5 = (sin(vUv.x + u_time * PI) + 0.0) * sin(u_time * 1.0);\n    //y += floor(y);\n    // float y = smoothstep(0.2, 0.5, vUv.x) - smoothstep(0.5, 0.8, vUv.x);\n    float pct1 = plot(vUv, y1);\n    float pct2 = plot(vUv, y2);\n    float pct3 = plot(vUv, y3);\n    float pct4 = plot(vUv, y4);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 + pct2 + pct3 + pct4 + pct5;\n    color -= smoothstep(0., 0.1, vUv.x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 6. - 3.;\n    vec3 color = vec3(0.);\n    \n    float y1 = fract(sin(vUv.x + u_time * 0.25 * PI) + 2.0) * sin(u_time * 1.2);\n    float y2 = fract(sin(vUv.x + u_time * 0.25 * PI) + 1.0) * sin(u_time * 0.9);\n    float y3 = fract(sin(vUv.x + u_time * 0.25 * PI) - 1.0) * sin(u_time * 0.5);\n    float y4 = fract(sin(vUv.x + u_time * 0.25 * PI) - 2.0) * sin(u_time * 1.5);\n    float y5 = fract(sin(vUv.x + u_time * 0.25 * PI) + 0.0) * sin(u_time * 1.0);\n    //y += floor(y);\n    // float y = smoothstep(0.2, 0.5, vUv.x) - smoothstep(0.5, 0.8, vUv.x);\n    float pct1 = plot(vUv, y1);\n    float pct2 = plot(vUv, y2);\n    float pct3 = plot(vUv, y3);\n    float pct4 = plot(vUv, y4);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 + pct2 + pct3 + pct4 + pct5;\n   \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.01, pct, st.y) -\n           smoothstep(pct, pct+0.01, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n//m is threshold (value above m stays unchanged)\n//n is the value given when signal is zero\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    \n    float y = almostIdentity(vUv.x, 0.5, 0.2);\n    float pct = plot(vUv, y);\n\n    color = vec3(y);\n    color = (1.0 - pct) * color + pct * vec3(0., 1., 0.);\n   \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv.y += 1.0;\n    vec3 color = vec3(0.);\n    \n    float y = almostIdentity(vUv.x, 0.5, 0.2);\n    float y2 = almostIdentity2(vUv.x, 0. + cos(u_time));\n    float y3 = almostIdentity2(vUv.x, 0.3 + sin(u_time));\n    float y4 = almostIdentity2(vUv.x, 0.6 + cos(u_time));\n    float y5 = almostIdentity2(vUv.x, 0.9 + sin(u_time));\n    float y6 = almostIdentity2(vUv.x, 1.2 + cos(u_time));\n    float y7 = almostIdentity2(vUv.x, 1.5 + sin(u_time));\n    float pct2 = plot(vUv, y2);\n    float pct3 = plot(vUv, y3);\n    float pct4 = plot(vUv, y4);\n    float pct5 = plot(vUv, y5);\n    float pct6 = plot(vUv, y6);\n    float pct7 = plot(vUv, y7);\n\n    //color = vec3(y2);\n    color = pct2 * vec3(0., 1., 0.);\n    color += pct3 * vec3(0., 1., 0.);\n    color += pct4 * vec3(0., 1., 0.);\n    color += pct5 * vec3(0., 1., 0.);\n    color += pct6 * vec3(0., 1., 0.);\n    color += pct7 * vec3(0., 1., 0.);\n   \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float y = almostUnitIdentity(vUv.x + cos(u_time));\n    float y2 = almostUnitIdentity(1. - vUv.x + sin(u_time));\n    float pct = plot(vUv, y);\n    float pct2 = plot(vUv, y2);\n    color += pct * vec3(0., 1., 0.);\n    color += pct2 * vec3(0., 1., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float y = integralSmoothstep(vUv.x, 1.0 + sin(u_time));\n    float pct = plot(vUv, y);\n    color += pct * vec3(0., 1., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4.;\n    vec3 color = vec3(0.);\n    float y1 = expImpulse(vUv.x, 0.);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = expImpulse(vUv.x, 0.5 + abs(sin(u_time * 0.25)));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = expImpulse(vUv.x, 1.0);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = expImpulse(vUv.x, 1.5);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = expImpulse(vUv.x, 2.0);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 2.0 * sqrt(k) * x/(.25 + k * x * x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4.;\n    vec3 color = vec3(0.);\n    float y1 = quaImpulse(vUv.x, 0.);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = quaImpulse(vUv.x, 0.5 + abs(sin(u_time * 0.5)));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = quaImpulse(vUv.x, 1.0);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = quaImpulse(vUv.x, 1.5);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = quaImpulse(vUv.x, 2.0);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.;\n    vec3 color = vec3(0.);\n    float y1 = polyImpulse(vUv.x, 0.0, 4.);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = polyImpulse(vUv.x, 0.5, 4. + sin(u_time));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = polyImpulse(vUv.x, 1.0, 4. + cos(u_time));\n    float pct3 = plot(vUv, y3);\n\n    float y4 = polyImpulse(vUv.x, 1.5, 4.);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = polyImpulse(vUv.x, 2.0, 4.);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv *3.;\n    vec3 color = vec3(0.);\n    float y1 = expSustainedImpulse(vUv.x, 2.0, 0.25);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = expSustainedImpulse(vUv.x, 1.25 + abs(sin(u_time * 0.25)), 0.25 + abs(cos(u_time * 0.25)));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = expSustainedImpulse(vUv.x, 1.5 + abs(sin(u_time * 0.25)), 0.5 );\n    float pct3 = plot(vUv, y3);\n\n    float y4 = expSustainedImpulse(vUv.x, 1.75, 0.25 + abs(sin(u_time * 0.25)));\n    float pct4 = plot(vUv, y4);\n\n    float y5 = expSustainedImpulse(vUv.x, 2.0, 0.5);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _T=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv *3.;\n    vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = cubicPulse(0.35, 2.00, vUv.x);\n    float pct1 = plot(vUv, y1);\n\n    \n\n    float y2 = cubicPulse(0.35, 1.25, vUv.x);\n    float pct2 = plot(vUv, y2);\n\n    float y3 = cubicPulse(0.35, 1.5, vUv.x);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = cubicPulse(0.35, 1.75, vUv.x);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = cubicPulse(0.35, 1.00, vUv.x);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_T,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 1.5;\n    vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = expStep(vUv.x, 1.0, 1.0);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = expStep(vUv.x, 1.5, 2.0);\n    float pct2 = plot(vUv, y2);\n\n    float y3 = expStep(vUv.x, 2.0, 3.0 + sin(u_time));\n    float pct3 = plot(vUv, y3);\n\n    float y4 = expStep(vUv.x, 2.0, 4.0);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = expStep(vUv.x, 3.0, 5.0);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ST(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1.5;\n    //vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = gain(vUv.x, 1.0);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = gain(vUv.x, 2.25 + sin(u_time * 0.5));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = gain(vUv.x, 0.5);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = gain(vUv.x, 5.5);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = gain(vUv.x, 0.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\n//11. Parabola\n//remap the 0 to 1 interval into 0 to 1 where the corners are mapped to 0 and the center is mapped to 1\nfloat parabola(float x, float k)\n{\n    return pow(4.0*x*(1.0 - x), k);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1.5;\n    //vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = parabola(vUv.x, 1.0);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = parabola(vUv.x, 2.25 + sin(u_time));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = parabola(vUv.x, 0.75);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = parabola(vUv.x, 1.75);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = parabola(vUv.x, 1.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\n//11. Parabola\n//remap the 0 to 1 interval into 0 to 1 where the corners are mapped to 0 and the center is mapped to 1\nfloat parabola(float x, float k)\n{\n    return pow(4.0*x*(1.0 - x), k);\n}\n\n//12. Power Curve\n//generalized parabola that can be control the shape on either side of the curve\n//useful for creating curved shaped\nfloat pcurve(float x, float a, float b)\n{\n    float k = pow(a + b, a + b)/(pow(a, a) * pow(b, b));\n    return k * pow(x, a)*pow(1. - x, b);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1.5;\n    //vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = pcurve(vUv.x, 0.65, 1.5);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = pcurve(vUv.x, 2.0, 2.25 + sin(u_time));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = pcurve(vUv.x, 2.5, 1.75);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = pcurve(vUv.x, 2.75, 1.75 + cos(u_time));\n    float pct4 = plot(vUv, y4);\n\n    float y5 = pcurve(vUv.x, 3.0, 1.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\n//11. Parabola\n//remap the 0 to 1 interval into 0 to 1 where the corners are mapped to 0 and the center is mapped to 1\nfloat parabola(float x, float k)\n{\n    return pow(4.0*x*(1.0 - x), k);\n}\n\n//12. Power Curve\n//generalized parabola that can be control the shape on either side of the curve\n//useful for creating curved shaped\nfloat pcurve(float x, float a, float b)\n{\n    float k = pow(a + b, a + b)/(pow(a, a) * pow(b, b));\n    return k * pow(x, a)*pow(1. - x, b);\n}\n\n//13. Sinc curve\n//bouncing behavior\n//k - number for bounces\nfloat sinc(float x, float k)\n{\n    float a = PI *(k * x - 1.0);\n    return sin(a)/a;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 0.5;\n    //vUv.y -= 0.25;\n    vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = sinc(vUv.x, 1.5);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = sinc(vUv.x, 2.25);\n    float pct2 = plot(vUv, y2);\n\n    float y3 = sinc(vUv.x, 1.75);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = sinc(vUv.x, 1.4);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = sinc(vUv.x, 1.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 1.25;\n    //vUv.y -= 0.25;\n    //vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdCircle(vUv, .15 + abs(sin(u_time)));\n\n    float y2 = sdCircle(vUv, 0.5 + (cos(u_time)));\n\n    float y3 = sdCircle(vUv, 0.25 + (sin(u_time)));\n\n    float y4 = sdCircle(vUv, 0.35 + abs(cos(u_time)));\n\n    float y5 = sdCircle(vUv, 0.45 + (sin(u_time)));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n//circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n//box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 1.25;\n    //vUv.y -= 0.25;\n    //vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdBox(vUv, vec2(2.5 * abs(cos(u_time))));\n\n    float y2 = sdBox(vUv, vec2(2.0 * abs(sin(u_time))));\n\n    float y3 = sdBox(vUv, vec2(1.5 * (cos(u_time))));\n\n    float y4 = sdBox(vUv, vec2(1.0 * (sin(u_time))));\n\n    float y5 = sdBox(vUv, vec2(0.5 * abs(cos(u_time))));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ET(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n//circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2.5 - 1.25;\n    //vUv.y -= 0.25;\n    //vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdSegment(vUv, vec2(0.5), vec2(2.5 * (cos(u_time))));\n\n    float y2 = sdSegment(vUv, vec2(0.5), vec2(.05 * (sin(u_time))));\n\n    float y3 = sdSegment(vUv, vec2(0.5), vec2(1.5 * (cos(u_time))));\n\n    float y4 = sdSegment(vUv, vec2(0.5), vec2(1.0 * (sin(u_time))));\n\n    float y5 = sdSegment(vUv, vec2(0.25), vec2(0.5 * (cos(u_time))));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 6. - 3.;\n    //vUv.y -= 0.25;\n    vUv.y += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdEqTriangle(vUv * abs(sin(u_time) * 0.1));\n    float y2 = sdEqTriangle(vUv * abs(sin(u_time) * 0.2));\n    float y3 = sdEqTriangle(vUv * abs(sin(u_time) * 0.3));\n    float y4 = sdEqTriangle(vUv * abs(sin(u_time) * 0.4));\n    float y5 = sdEqTriangle(vUv * abs(sin(u_time) * 1.5));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 6. - 3.;\n    //vUv.y -= 0.25;\n    vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 = 1. -  sdEqTriangle(vUv * 5.5 * abs(sin(u_time * 0.5) + 1.5)) * 2.;\n    float x = smoothstep(2.5, 2.51, y1);\n    // float y2 = sdEqTriangle(vUv * abs(sin(u_time) * 0.2));\n    // float y3 = sdEqTriangle(vUv * abs(sin(u_time) * 0.3));\n    // float y4 = sdEqTriangle(vUv * abs(sin(u_time) * 0.4));\n    // float y5 = sdEqTriangle(vUv * abs(sin(u_time) * 1.5));\n\n    //color = vec3(y1);\n\n    color += x * vec3(1., 1., 0.); //yellow\n    // color += y2 * vec3(0., 1., 1.); //teal\n    // color += y3 * vec3(0.5, 1., .5); //green\n    // color += y4 * vec3(1., 0., 0.); //red\n    // color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 6. - 3.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 =1. - sdHexagon(vUv, 18.25);\n    float y2 =1. - sdHexagon(vUv, 20.25);\n    float y3 =1. - sdHexagon(vUv, 21.25);\n    float y4 =1. - sdHexagon(vUv, 22.25);\n    float y5 =1. - sdHexagon(vUv, 23.25);\n\n    color = vec3(y1);\n\n    color += y1 * vec3(1., 0., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 40. - 20.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 = 1. - sdCircle(vUv * abs(sin(u_time + 4.0 * 0.25)) , 1.9);\n    float y2 = 1. - sdCircle(vUv * abs(sin(u_time + 4.0 * 0.5)), 3.5);\n    float y3 = sdCircle(vUv * cos(u_time + 4.0 * 0.5), 2.5);\n    float y4 = 1. - sdCircle(vUv * sin(u_time + 4.0 * 0.25), 3.5);\n    float y5 = sdCircle(vUv * sin(u_time + 4.0 * 0.25), 3.0);\n\n    color = vec3(y1);\n\n    color += y1 * vec3(1., 0., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// //hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 60. - 30.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 = 1. - sdHexagram(vUv * abs(sin(u_time + 4.0 * 0.25)) , 1.9);\n    float y2 = 1. - sdHexagram(vUv * abs(sin(u_time + 4.0 * 0.5)), 3.5);\n    float y3 = sdHexagram(vUv * cos(u_time + 4.0 * 0.5), 2.5);\n    float y4 = 1. - sdHexagram(vUv * sin(u_time + 4.0 * 0.25), 3.5);\n    float y5 = sdHexagram(vUv * sin(u_time + 4.0 * 0.25), 3.0);\n\n    color = vec3(y1);\n\n    color += y1 * vec3(1., 0., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 4. - 2.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.5 + 0.5 * sin(u_time * 0.5 + 2.0));\n    float b = 0.25 *(0.75 + 0.75);\n    float y1 = sdArc(vUv, vec2(a * 2.50, a * 2.50), 1.0, b * 1.0);\n    float y2 = sdArc(vUv, vec2(a * 2.25, a * 2.25), 1.0, b * 0.8);\n    float y3 = sdArc(vUv, vec2(a * 2.15, a * 2.15), 1.0, b * 0.6);\n    float y4 = sdArc(vUv, vec2(a * 2.45, a * 2.45), 1.0, b * 0.4);\n    float y5 = sdArc(vUv, vec2(a * 2.35, a * 2.35), 1.0, b * 0.2);\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 3. - 1.5;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.5 + 0.5);\n    float b = 0.25 *(0.75 + 0.75);\n    float y1 = sdPie(vUv, vec2(a * 2.50, a * 2.50), b * 1.0 + abs(sin(u_time)));\n    float y2 = sdPie(vUv, vec2(a * 2.25, a * 2.25), b * 0.8 + abs(sin(u_time)));\n    float y3 = sdPie(vUv, vec2(a * 2.15, a * 2.15), b * 0.6 + abs(sin(u_time)));\n    float y4 = sdPie(vUv, vec2(a * 2.45, a * 2.45), b * 0.4 + abs(sin(u_time)));\n    float y5 = sdPie(vUv, vec2(a * 2.35, a * 2.35), b * 0.2 + abs(sin(u_time)));\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KT(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JT,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $T=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 3. - 1.5;\n    //vUv.y -= 0.25;\n    vUv.y += 1.0;\n    \n    vec3 color = vec3(0.);\n    float y1 = sdHeart(vUv * 0.12 * abs(sin(u_time) - 5.5));\n    float y2 = sdHeart(vUv * 0.14 * abs(sin(u_time) - 5.5));\n    float y3 = sdHeart(vUv * 0.16 * abs(sin(u_time) - 5.5));\n    float y4 = sdHeart(vUv * 0.1 * abs(sin(u_time) - 5.5));\n    float y5 = sdHeart(vUv * 0.11 * abs(sin(u_time) - 5.));\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$T,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// //hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    vec2 s = 0.6 + 0.3*cos(u_time + vec2(0.0, 1.57));\n    if (s.x < s.y){\n        s = s.yx;\n    }\n    vec3 color = vec3(0.);\n    float y1 = sdCross(vUv, s, 0.25);\n    float y2 = sdCross(vUv, s, 0.15);\n    float y3 = sdCross(vUv, s, 0.35);\n    float y4 = sdCross(vUv, s, 0.45);\n    float y5 = sdCross(vUv, s, 0.50);\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    vec2 s = 0.6 + 0.3*cos(u_time + vec2(0.0, 1.57));\n    if (s.x < s.y){\n        s = s.yx;\n    }\n    vec3 color = vec3(0.);\n    float y1 = sdRoundedX(vUv, 0.5, 0.25 * sin(u_time * 0.5));\n    float y2 = sdRoundedX(vUv, 0.5, 0.15 * abs(cos(u_time * 0.5)));\n    float y3 = sdRoundedX(vUv, 0.5, 0.35 * abs(sin(u_time * 0.5)));\n    float y4 = sdRoundedX(vUv, 0.5, 0.45 / sin(u_time * 0.5));\n    float y5 = sdRoundedX(vUv, 0.5, 0.50 * cos(u_time * 0.5));\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\n// float sdHexagon(vec2 p, float r)\n// {\n//     vec3 k = vec3(-0.866025404,0.5,0.577350269);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n//     return length(p) * sin(p.y);\n// }\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 4;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.25 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.35 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v2 = 0.5 * cos(0.45 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.55 * u_time + vec2(0., 2.5) + 4.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3);\n\n    float d = sdPolygon(vUv, polygon);\n    vec3 color = vec3(0.);\n    color += 1.0 - exp(-6.0*abs(d));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, d) * vec3(0., 1., 1.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vUv = Rot(vUv,   u_time * 0.4 * 2.);\n    vUv2 = Rot(vUv2, u_time * 0.6 * 2.);\n    vUv3 = Rot(vUv3, u_time * 0.8 * 2.);\n    vUv4 = Rot(vUv3, u_time * 0.2 * 2.);\n    vUv = vUv * 4. - 2.;\n    vUv2 = vUv2 * 4. - 2.;\n    vUv3 = vUv3 * 4. - 2.;\n    vUv4 = vUv4 * 4. - 2.;\n\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.5 + 0.5);\n    float b = 0.25 *(0.75 + 0.75);\n    float y1 = sdArc(vUv4 * 0.65, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y2 = sdArc(vUv, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y21 = sdArc(vUv2 / 0.65, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y211 = sdArc(vUv3 / 0.4, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    \n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1); //yellow\n    color *= smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color *= smoothstep(0.0, 0.015, y21) * vec3(0.5, 1., .5); //green\n    color *= smoothstep(0.0, 0.015, y211); //red\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vec2 vUv5 = vUv;\n\n    vUv = Rot(vUv,   u_time * 0.4 * 4.);\n    vUv2 = Rot(vUv2, u_time * 0.6 * 4.);\n    vUv3 = Rot(vUv3, u_time * 0.8 * 4.);\n    vUv4 = Rot(vUv4, u_time * 1.0 * 4.);\n    vUv5 = Rot(vUv5, u_time * 0.2 * 4.);\n\n    vUv = vUv * 4. - 2.;\n    vUv2 = vUv2 * 4. - 2.;\n    vUv3 = vUv3 * 4. - 2.;\n    vUv4 = vUv4 * 4. - 2.;\n    vUv5 = vUv5 * 4. - 2.;\n\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.25 + 0.25);\n    float b = 0.025 *(0.5 + 0.5);\n    float y1 = sdArc(vUv4 * 0.65, vec2(a * 2.5, a * 2.5), 1.0 , b * 0.4 );\n    float y2 = sdArc(vUv, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y21 = sdArc(vUv2 / 0.65, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y211 = sdArc(vUv3 / 0.4, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y2111 = sdArc(vUv5 /0.225, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    \n\n    color = vec3(y1);\n\n    y1 = smoothstep(0.0, 0.015, y1); //yellow\n    y2 = smoothstep(0.0, 0.015, y2); //teal\n    y21 = smoothstep(0.0, 0.015, y21); //green\n    y211 = smoothstep(0.0, 0.015, y211); //red\n    y2111 = smoothstep(0.0, 0.015, y2111); //red\n\n    color += y1;\n    color *= y2;\n    color *= y21;\n    color *= y211;\n    color *= y2111;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vec2 vUv5 = vUv;\n\n    vUv = Rot(vUv,   u_time * 0.15);\n\n    vUv = vUv * (100. *sin(u_time * 0.5) + 25.) - (50. * sin(u_time * 0.5) + 12.5);    \n    vec3 color = vec3(0.);\n    \n    float y1 = sdHexagram(vUv, 1.5);\n    float y2 = sdHexagram(vUv, 1.2);\n    float y21 = sdHexagram(vUv, 1.0);\n    float y211 = sdHexagram(vUv, 0.8);\n    float y2111 = sdHexagram(vUv, 0.5);\n\n    y1 = smoothstep(0.0, 0.015, y1); //yellow\n    y2 = smoothstep(0.0, 0.015, y2); //teal\n    y21 = smoothstep(0.0, 0.015, y21); //green\n    y211 = smoothstep(0.0, 0.015, y211); //red\n    y2111 = smoothstep(0.0, 0.015, y2111); //red\n\n    color += y1;\n    color += y2 ;\n    color *= y21 ;\n    color *= y211;\n    color *= y2111;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 8;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.25 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.35 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v2 = 0.5 * cos(0.45 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.55 * u_time + vec2(0., 2.5) + 4.0);\n    vec2 v4 = 0.5 * cos(0.65 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.75 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.85 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.95 * u_time + vec2(0., 2.5) + 4.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3,v4, v5, v6, v7);\n\n    float d = sdPolygon(vUv, polygon);\n    vec3 color = vec3(0.);\n    color += 1.0 - exp(-6.0*abs(d));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, d) * vec3(0., 1., 1.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\n// float sdHexagon(vec2 p, float r)\n// {\n//     vec3 k = vec3(-0.866025404,0.5,0.577350269);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n//     return length(p) * sin(p.y);\n// }\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 3;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.25 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.55 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v2 = 0.5 * cos(0.95 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.55 * u_time + vec2(0., 2.5) + 4.0);\n    vec2 v4 = 0.5 * cos(0.65 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.75 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.85 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.95 * u_time + vec2(0., 2.5) + 4.0);\n    vec2 v8 = 0.5 * cos(1.25 * u_time + vec2(0., 3.5) + 4.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2);\n    vec2[] polygon2 = vec2[](v3, v4, v5);\n    vec2[] polygon3 = vec2[](v6, v7, v8);\n\n    float d = sdPolygon(vUv, polygon);\n    float d2 = sdPolygon(vUv, polygon2);\n    float d3 = sdPolygon(vUv, polygon3);\n    vec3 color = vec3(0.);\n    color += exp(-16.0*abs(d));\n    color += exp(-16.0*abs(d2));\n    color += exp(-16.0*abs(d3));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(0.2, 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, d2) * vec3(0., 0.2, 0.); //teal\n    color += smoothstep(0.0, 0.015, d3) * vec3(0.3, 0., 0.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 4;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.15 * u_time + vec2(10., 0.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.15 * u_time + vec2(0., 1.0) + 2.0);\n    vec2 v2 = 0.5 * cos(0.15 * u_time + vec2(1.0, 0.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.15 * u_time + vec2(1.0, 1.0) + 4.0);\n    vec2 v4 = 0.5 * cos(0.15 * u_time + vec2(1.5, 0.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.15 * u_time + vec2(1.5, 2.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.15 * u_time + vec2(3.0, 0.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.15 * u_time + vec2(3.0, 2.5) + 1.0);\n    vec2 v8 = 0.5 * cos(1.15 * u_time + vec2(0., 3.5) + 2.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3);\n    vec2[] polygon2 = vec2[](v4, v5, v6, v7);\n    vec2[] polygon3 = vec2[](v6, v7, v8);\n\n    float d = sdPolygon(vUv, polygon);\n    float d2 = sdPolygon(vUv, polygon2);\n    //float d3 = sdPolygon(vUv, polygon3);\n    vec3 color = vec3(0.);\n    color += exp(-32.0*abs(d));\n    color += exp(-32.0*abs(d2));\n    //color += exp(-32.0*abs(d3));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(0.2, 0., 0.2); //yellow\n    color += smoothstep(0.0, 0.015, d2) * vec3(0., 0.2, 0.); //teal\n    //color += smoothstep(0.0, 0.015, d3) * vec3(0.1, 0., 0.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n//circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 4;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.15 * u_time + vec2(0.0, 0.0) + 1.5);\n    vec2 v1 = 0.5 * cos(0.15 * u_time + vec2(0.0, 4.0) + 2.3);\n    vec2 v2 = 0.5 * cos(0.15 * u_time + vec2(4.0, 2.0) + 3.5);\n    vec2 v3 = 0.5 * cos(0.15 * u_time + vec2(2.0, 0.0) + 4.1);\n    vec2 v4 = 0.5 * cos(0.15 * u_time + vec2(1.5, 0.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.15 * u_time + vec2(1.5, 2.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.15 * u_time + vec2(3.0, 0.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.15 * u_time + vec2(3.0, 2.5) + 1.0);\n    vec2 v8 = 0.5 * cos(1.15 * u_time + vec2(0., 3.5) + 2.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3);\n    vec2[] polygon2 = vec2[](v4, v5, v6, v7);\n    // vec2[] polygon3 = vec2[](v6, v7, v8);\n\n    float d = sdPolygon(vUv, polygon);\n    float d2 = sdPolygon(vUv, polygon2);\n    //float d3 = sdPolygon(vUv, polygon3);\n    vec3 color = vec3(0.);\n    color += exp(-16.0*abs(d));\n    color += exp(-32.0*abs(d2));\n    //color += exp(-32.0*abs(d3));\n\n    color += smoothstep(0.0, 0.015, d * d2) * vec3(0.2, 0., 0.2); //yellow\n    //color += smoothstep(0.0, 0.015, d2) * vec3(0., 0.2, 0.); //teal\n    //color += smoothstep(0.0, 0.015, d3) * vec3(0.1, 0., 0.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _R=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = step(((1.0 - width)/ 2.0), vUv.x);\n//     float right = step(((1.0 - width)/2.0), 1. - vUv.x);\n//     float top = step(((1.0 - height)/2.0), 1. - vUv.y);\n//     float bottom = step(((1.0 - height)/2.0), vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, u_time * 0.75);\n    float rectangle1 = rect(vUv, 0.25, 0.25);\n    float rectangle2 = rect(vUv, 0.025, 0.5);\n    float rectangle3 = rect(vUv, 0.5, 0.025);\n    color = vec3(rectangle1 + rectangle2 + rectangle3);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_R,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, u_time * 0.75);\n    float rectangle1 = rect(vec2(vUv.x-0.25,vUv.y), 0.25, 0.25);\n    float rectangle2 = rect(vec2(vUv.x-0.25,vUv.y), 0.025, 0.5);\n    float rectangle3 = rect(vec2(vUv.x-0.25,vUv.y), 0.5, 0.025);\n    float rectangle4 = rect(vec2(vUv.x,vUv.y), 0.25, 0.25);\n    float rectangle5 = rect(vec2(vUv.x,vUv.y), 0.025, 0.5);\n    float rectangle6 = rect(vec2(vUv.x,vUv.y), 0.5, 0.025);\n    float rectangle7 = rect(vec2(vUv.x+0.25,vUv.y), 0.25, 0.25);\n    float rectangle8 = rect(vec2(vUv.x+0.25,vUv.y), 0.025, 0.5);\n    float rectangle9 = rect(vec2(vUv.x+0.25,vUv.y), 0.5, 0.025);\n    color = vec3(rectangle1 - rectangle2 + rectangle3);\n    color += vec3(rectangle4 - rectangle5 + rectangle6);\n    color += vec3(rectangle7 - rectangle8 + rectangle9);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1  - 366\n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float b1 = rect(vec2(vUv.x - 0.5, vUv.y - 0.225), 0.2, 0.2);\n    float b2 = rect(vec2(vUv.x - 0.5, vUv.y - 0.45), 0.2, 0.2);\n    float b3 = rect(vec2(vUv.x -0.125, vUv.y - 0.45), 0.65, 0.5);\n    float b4 = rect(vec2(vUv.x -0.125, vUv.y + 0.125 ), 0.45, 0.5);\n    float b5 = rect(vec2(vUv.x -0.125, vUv.y + 0.45 ), 0.15, 0.5);\n    float b6 = rect(vec2(vUv.x -0.5, vUv.y + 0.125 ), 0.45, 0.2);\n    float b7 = rect(vec2(vUv.x -0.5, vUv.y + 0.45 ), 0.15, 0.2);\n    float b8 = rect(vec2(vUv.x + 0.5, vUv.y + 0.45 ), 0.15, 0.2);\n    float b9 = rect(vec2(vUv.x + 0.5, vUv.y - 0.225 ), 0.75, 0.695);\n    float b10 = rect(vec2(vUv.x +0.5, vUv.y + 0.265), 0.175, 0.695);\n    float b11 = rect(vec2(vUv.x + 0.265, vUv.y + 0.445 ), 0.14, 0.22);\n\n    color.r = b1 * (sin(u_time * 0.1));\n    color.b += b2 * (sin(u_time * 0.2));\n    color.rgb += b3 * (sin(u_time * 0.3));\n    color.rg += b4 * (sin(u_time * 0.4));\n    color.b += b5 * (sin(u_time * 0.5));\n    color.rgb += b6 * (sin(u_time * 0.6));\n    color.r += b7 * (sin(u_time * 0.7));\n    color.rg += b8 * (sin(u_time * 0.8));\n    color.rg += b9 * (sin(u_time * 0.9));\n    color.rgb += b10 * (sin(u_time * 0.11));\n    color.r += b11 * (sin(u_time * 0.12));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec3 color = vec3(0.);\n\n    vUv1 = Rot(vUv1, u_time * 0.5 * 1.5);\n    vUv2 = Rot(vUv2, u_time * 0.25 * 1.5);\n    vUv3 = Rot(vUv3, u_time * 0.75 * 1.5);\n\n    float c1 = circle(vUv, 0.5);\n    color = vec3(c1);\n    float r1 = rect(vUv1, 0.55, 0.55);\n    color -= r1;\n\n    float c2 = circle(vUv, 0.25);\n    color += c2;\n    float r2 = rect(vUv2, 0.4, 0.4);\n    color -= r2;\n    \n    float c3 = circle(vUv, 0.125);\n    color += c3;\n    //float r3 = rect(vUv, 0.35, 0.035);\n    //color -= c3;\n\n    float c4 = circle(vUv, 0.75);\n    color += c4;\n    float r4 = rect(vUv3, 0.75, 0.75);\n    color -= r4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.25);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec3 color = vec3(0.);\n\n    vUv1 = Rot(vUv, PI * 0.25);\n    vUv2 = Rot(vUv, -PI * 0.25);\n    float c1 = circle(vUv, 0.25);\n    float c2 = circle(vUv, 0.35);\n\n    float c3 = circle(vUv, 0.15);\n    float c4 = circle(vUv, 0.1);\n    float r1 = rect(vUv, 0.05, 0.65);\n    float r2 = rect(vUv, 0.65, 0.05);\n    float r3 = rect(vUv1, 0.65, 0.05);\n    float r4 = rect(vUv2, 0.65, 0.05);\n\n    color += c2;\n    color -= c1;\n    color += c3;\n    color -= c4;\n\n    color -= r1;\n    color -= r2;\n    color -= r3;\n    color -= r4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv, u_time);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.3, 0.75);\n    float c1 = circle(vUv, 0.35);\n    \n    float r2 = rect(vUv1, 0.75, 0.3);\n    float c2 = circle(vUv, 0.025);\n\n    float r3 = rect(vUv2, 0.3, 0.3);\n    \n    \n    color += r1;\n    color += r2;\n    color -= c1;\n    color += c2;\n    color -= r3;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv, u_time);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.3, 0.75);\n    float c1 = circle(vUv, 0.35);\n    \n    float r2 = rect(vUv1, 0.75, 0.3);\n    float c2 = circle(vUv, 0.025);\n\n    float r3 = rect(vUv2, 0.3, 0.3);\n    \n    \n    color -= r1;\n    color -= r2;\n    color += c1;\n    color -= c2;\n    color += r3;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.6);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv1, PI);\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.5, 0.5);\n    float r2 = 1. - rect(vUv1, 0.25, 0.5);\n    float r3 = rect(vUv1, 0.1, 0.7);\n    \n\n    float r4 = rect(vUv2, 0.5, 0.5);\n    float r5 = 1. - rect(vUv2, 0.25, 0.5);\n    float r6 = rect(vUv2, 0.1, 0.7);\n    \n    color += r1;\n    color -= r2;\n    color -= r3;\n    color += r4;\n    color -= r5;\n    color -= r6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ER(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 1.6);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv1, PI);\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.5, 0.5);\n    float r2 = 1. - rect(vUv1, 0.35, 0.75);\n    float r3 = rect(vUv1, 0.2, 0.7);\n    \n\n    float r4 = rect(vUv2, 0.25, 0.25);\n    float r5 = 1. - rect(vUv2, 0.55, 0.55);\n    float r6 = rect(vUv2, 0.1, 0.1);\n    \n    color += r1;\n    color -= r2;\n    color -= r3;\n    color += r4;\n    color -= r5;\n    color -= r6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 1.6);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv1, PI);\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.5, 0.5);\n    float r2 = 1. - rect(vUv1, 0.35, 0.75);\n    float r3 = rect(vUv1, 0.2, 0.7);\n    \n\n    float r4 = rect(vUv2, 0.15, 0.45);\n    float r5 = 1. - rect(vUv2, 0.55, 0.55);\n    float r6 = rect(vUv2, 0.82, 0.1);\n    \n    color += r1;\n    color -= r2;\n    color -= r3;\n    color -= r4;\n    color -= r5;\n    color += r6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float c1 = circle(vUv, 0.5 * abs(sin(u_time)));\n    float c2 = circle(vUv, 0.51 * abs(sin(u_time)));\n    float c3 = smoothstep(0.1, 0.2, c2 - c1);\n    color += c3;\n\n    float r1 = rect(vUv, 0.6 * abs(cos(u_time)), 0.6 * abs(cos(u_time)));\n    float r2 = rect(vUv, 0.61 * abs(cos(u_time)), 0.61 * abs(cos(u_time)));\n    float r3 = smoothstep(0.1, 0.2, r2 - r1);\n    color += r3;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float c1 = cirOutline(vUv, 0.50 * abs(sin(u_time * 0.95)) + .15);\n    float c2 = cirOutline(vUv, 0.45 * abs(sin(u_time * 0.85)) + .15);\n    float c3 = cirOutline(vUv, 0.40 * abs(sin(u_time * 0.75)) + .15);\n    float c4 = cirOutline(vUv, 0.35 * abs(sin(u_time * 0.65)) + .15);\n    float c5 = cirOutline(vUv, 0.30 * abs(sin(u_time * 0.56)) + .15);\n    float c6 = cirOutline(vUv, 0.25 * abs(sin(u_time * 0.45)) + .15);\n    float c7 = cirOutline(vUv, 0.20 * abs(sin(u_time * 0.35)) + .15);\n    float c8 = cirOutline(vUv, 0.15 * abs(sin(u_time * 0.25)) + .15);\n    float c9 = cirOutline(vUv, 0.10 * abs(sin(u_time * 0.15)) + .15);\n    float c10 = cirOutline(vUv, 0.05 *abs(sin(u_time * 0.05)) + .15);\n    color += c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8 + c9 + c10;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float r1 = rectOutline(vUv, 0.3 - (0.04 * 6.5) * sin(u_time), 0.3 - (0.04 * 6.5) * cos(u_time));\n    float r2 = rectOutline(vUv, 0.3 - (0.03 * 6.5) * sin(u_time), 0.3 - (0.03 * 6.5) * cos(u_time));\n    float r3 = rectOutline(vUv, 0.3 - (0.02 * 6.5) * sin(u_time), 0.3 - (0.02 * 6.5) * cos(u_time));\n    float r4 = rectOutline(vUv, 0.3 - (0.01 * 6.5) * sin(u_time), 0.3 - (0.01 * 6.5) * cos(u_time));\n    float r5 = rectOutline(vUv, 0.3 + (0.00 * 6.5) * sin(u_time), 0.3 + (0.00 * 6.5) * cos(u_time));\n    float r6 = rectOutline(vUv, 0.3 + (0.01 * 6.5) * sin(u_time), 0.3 + (0.01 * 6.5) * cos(u_time));\n    float r7 = rectOutline(vUv, 0.3 + (0.02 * 6.5) * sin(u_time), 0.3 + (0.02 * 6.5) * cos(u_time));\n    float r8 = rectOutline(vUv, 0.3 + (0.03 * 6.5) * sin(u_time), 0.3 + (0.03 * 6.5) * cos(u_time));\n    float r9 = rectOutline(vUv, 0.3 + (0.04 * 6.5) * sin(u_time), 0.3 + (0.04 * 6.5) * cos(u_time));\n\n    color += r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float r1 = rectOutline(vUv, 0.3 - (0.04 * 6.5) * cos(u_time + 1.5), 0.3 - (0.04 * 6.5) * cos(u_time * 0.5));\n    float r2 = rectOutline(vUv, 0.3 - (0.03 * 6.5) * cos(u_time + 1.5), 0.3 - (0.03 * 6.5) * cos(u_time * 0.5));\n    float r3 = rectOutline(vUv, 0.3 - (0.02 * 6.5) * cos(u_time + 1.5), 0.3 - (0.02 * 6.5) * cos(u_time * 0.5));\n    float r4 = rectOutline(vUv, 0.3 - (0.01 * 6.5) * cos(u_time + 1.5), 0.3 - (0.01 * 6.5) * cos(u_time * 0.5));\n    float r5 = rectOutline(vUv, 0.3 + (0.00 * 6.5) * cos(u_time + 1.5), 0.3 + (0.00 * 6.5) * cos(u_time * 0.5));\n    float r6 = rectOutline(vUv, 0.3 + (0.01 * 6.5) * cos(u_time + 1.5), 0.3 + (0.01 * 6.5) * cos(u_time * 0.5));\n    float r7 = rectOutline(vUv, 0.3 + (0.02 * 6.5) * cos(u_time + 1.5), 0.3 + (0.02 * 6.5) * cos(u_time * 0.5));\n    float r8 = rectOutline(vUv, 0.3 + (0.03 * 6.5) * cos(u_time + 1.5), 0.3 + (0.03 * 6.5) * cos(u_time * 0.5));\n    float r9 = rectOutline(vUv, 0.3 + (0.04 * 6.5) * cos(u_time + 1.5), 0.3 + (0.04 * 6.5) * cos(u_time * 0.5));\n\n    color += r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 2. - 0.5;\n\n    vec2 vUv1 = vUv;\n    vUv1.x += sin(u_time * 0.25);\n    float c1 = cirOutline(vUv1, 0.05);\n\n    vec2 vUv2 = vUv;\n    vUv2.x -= sin(u_time * 0.5);\n    float c2 = cirOutline(vUv2, 0.05);\n\n    vec2 vUv3 = vUv;\n    vUv3.x += sin(u_time * 0.2);\n    float c3 = cirOutline(vUv3, 0.05);\n\n    vec2 vUv4 = vUv;\n    vUv4.x += sin(u_time * 1.9);\n    float c4 = cirOutline(vUv4, 0.05);\n\n    vec2 vUv5 = vUv;\n    vUv5.x -= sin(u_time * 1.15);\n    float c5 = cirOutline(vUv5, 0.05);\n\n    vec2 vUv6 = vUv;\n    vUv6.x += sin(u_time * 0.85);\n    vUv6.y -= 0.25;\n    float c6 = cirOutline(vUv6, 0.05);\n\n    vec2 vUv7 = vUv;\n    vUv7.x -= sin(u_time * 0.55);\n    vUv7.y -= 0.25;\n    float c7 = cirOutline(vUv7, 0.05);\n\n    vec2 vUv8 = vUv;\n    vUv8.x += sin(u_time * 0.35);\n    vUv8.y -= 0.25;\n    float c8 = cirOutline(vUv8, 0.05);\n\n    vec2 vUv9 = vUv;\n    vUv9.x += sin(u_time * 1.24);\n    vUv9.y -= 0.25;\n    float c9 = cirOutline(vUv9, 0.05);\n\n    vec2 vUv10 = vUv;\n    vUv10.x -= sin(u_time * .25);\n    vUv10.y -= 0.25;\n    float c10 = cirOutline(vUv10, 0.05);\n\n    vec2 vUv11 = vUv;\n    vUv11.x -= sin(u_time * .25);\n    vUv11.y += 0.25;\n    float c11 = cirOutline(vUv11, 0.05);\n\n    vec2 vUv12 = vUv;\n    vUv12.x -= sin(u_time * .25);\n    vUv12.y += 0.25;\n    float c12 = cirOutline(vUv12, 0.05);\n\n    vec2 vUv13 = vUv;\n    vUv13.x -= sin(u_time * .45);\n    vUv13.y += 0.25;\n    float c13 = cirOutline(vUv13, 0.05);\n\n    vec2 vUv14 = vUv;\n    vUv14.x -= sin(u_time * .75);\n    vUv14.y += 0.25;\n    float c14 = cirOutline(vUv14, 0.05);\n\n    vec2 vUv15 = vUv;\n    vUv15.x -= sin(u_time * 1.35);\n    vUv15.y += 0.25;\n    float c15 = cirOutline(vUv15, 0.05);\n\n    color += c1 + c2 + c3 + c4 + c5;\n    color += c6 + c7 + c8 + c9 + c10;\n    color += c11 + c12 + c13 + c14 + c15;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = vUv * 2. - 0.5;\n\n    float r1 = rect(vUv, 0.5, 0.5);\n    float c1 = circle(vUv, 0.15);\n    float c2 = cirOutline(vUv, 0.045 + abs(sin(u_time) / 16.));\n    float r2 = rectOutline(vUv, 0.45 + abs(sin(u_time) / 32.), 0.45 + abs(sin(u_time) / 32.) );\n    color += r1;\n    color -= c1;\n    color += c2;\n    color -= r2;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KR(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JR,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $R=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 4. - 2.;\n\n    float d = 1. - length(max(abs(vUv) - .3, 0.));\n\n    d = fract((d * 2. + (u_time * 0.75)));\n    d = smoothstep(0.3, 0.4, d) * smoothstep(0.6, 0.5, d);\n    color += d;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$R,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = Rot(vUv, (u_time * 0.25));\n    vUv = vUv * 4. - 2.;\n    \n    float d = 1. - length(max(abs(vUv) - .3, 0.));\n\n    d = fract((d + d * d * d * 2. - (u_time * 0.75)));\n    d /= smoothstep(0.3, 0.31, d) * smoothstep(0.4, 0.41, d);\n    color += 1. - d;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, (u_time * 0.25));\n    vUv = vUv * 4. - 2.;\n    \n    float d = 1. - length(max(abs(vUv) - .3, 0.));\n    d += length( min(abs(vUv)-.3,0.) );\n\n    d = fract((d * d + d + d + 2. - (u_time * 0.25)));\n    d =  step(.3,d );\n    d /= smoothstep(0.3, 0.31, d) * smoothstep(0.4, 0.41, d);\n    color += 1. - d;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vUv1 = Rot(vUv1, (u_time * 5.));\n    vUv *= 2. - 1.;\n    vec2 pos = vec2(0.5) - vUv1;\n\n    float r = length(pos) * 5.0;\n    float a = atan(pos.y, pos.x);\n\n    float f = cos(a * 3.);\n\n    float i = smoothstep(f, f + 0.1, r);\n    float r1 = 1. - rect(vec2(vUv.x, vUv.y + 0.27), 0.56, 0.025);\n    color = vec3(i);\n    color *= r1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vUv1 = Rot(vUv1, (u_time * 0.5));\n    float i1 = flower(vUv1, 6., 4.0 * cos(u_time * 0.5));\n    float i2 = flower(vUv1, 6., 4.25 * cos(u_time * 0.5));\n    float i3 = flower(vUv1, 6., 2.0 * sin(u_time * 0.25));\n    float i4 = flower(vUv1, 6., 2.25 * sin(u_time * 0.25));\n    float i5 = flower(vUv1, 6., 8.0 * cos(u_time * 0.75));\n    float i6 = flower(vUv1, 6., 8.125 * cos(u_time * 0.75));\n    float i7 = flower(vUv1, 6., 6.0 * sin(u_time * 1.0));\n    float i8 = flower(vUv1, 6., 6.125 * sin(u_time * 1.0));\n    float x1 = i2 - i1;\n    float x2 = i4 - i3;\n    float x3 = i6 - i5;\n    float x4 = i8 - i7;\n    color += x1 + x1;\n    color += x2 + x2;\n    color += x3 + x3;\n    color += x4 + x4;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n\n    vUv1 = Rot(vUv1, u_time * 0.50);\n    vUv2 = Rot(vUv2, u_time * 0.75);\n    vUv3 = Rot(vUv3, u_time * 0.25);\n    vUv4 = Rot(vUv4, u_time * 1.00);\n    \n    float f1 = flower(vUv1, 4., 4.);\n    color.rg += f1 * sin(u_time);\n\n    float f2 = flower(vUv2, 4., 3.5);\n    color.g += f2 * 0.5 * abs(cos(u_time));\n\n    float f3 = flower(vUv3, 4., 3.);\n    color.r += f3 * 0.25 * abs(sin(u_time));\n\n    float f4 = flower(vUv4, 4., 2.5);\n    color.b += f4 * cos(u_time) * 0.25;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1.0 - smoothstep(size, size + 0.01, d);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 0.25);\n\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.75);\n\n    vec2 vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.95);\n\n    vec2 vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.50);\n    \n    float p1 = polygon(vUv1, 6, 0.5);\n    float p2 = polygon(vUv2, 8, 0.5);\n    float p3 = polygon(vUv3, 7, 0.5);\n    float p4 = polygon(vUv4, 9, 0.5);\n\n    color += p1;\n    color.g -= p2;\n    color.b -= p3;\n    color.r -= p4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return smoothstep(size, size + 0.01, d);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 0.25);\n\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.75);\n\n    vec2 vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.95);\n\n    vec2 vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.50);\n    \n    float p1 = polygon(vUv1, 6, 0.15);\n    float p2 = polygon(vUv2, 8, 0.25);\n    float p3 = polygon(vUv3, 7, 0.35);\n    float p4 = polygon(vUv4, 9, 0.45);\n\n    color -= p1 * cos(u_time);\n    color.g += p2 + cos(u_time);\n    color.b += p3 + sin(u_time);\n    color.r -= p4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.01 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 1.0);\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.9);\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.8);\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.7);\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time * 0.6);\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time * 0.5);\n\n    float s1 = polygonOutline(vUv1, 6, 0.50);\n    float s2 = polygonOutline(vUv2, 6, 0.45);\n    float s3 = polygonOutline(vUv3, 6, 0.40);\n    float s4 = polygonOutline(vUv4, 6, 0.35);\n    float s5 = polygonOutline(vUv5, 6, 0.30);\n    float s6 = polygonOutline(vUv6, 6, 0.25);\n\n    color += s1 + s2 + s3 + s4 + s5 + s6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    //vUv = vUv * 2. - 0.5;\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 1.0);\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.9);\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.8);\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.7);\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time * 0.6);\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time * 0.5);\n\n    float s1 = polygonOutline(vUv1, 8, 0.5);\n    float s2 = polygonOutline(vUv2, 8, 0.4);\n    float s3 = polygonOutline(vUv3, 8, 0.3);\n    float s4 = polygonOutline(vUv4, 8, 0.2);\n    float s5 = polygonOutline(vUv5, 8, 0.1);\n    float s6 = polygonOutline(vUv6, 8, 0.025);\n\n    color += s1 + s2 + s3 + s4 + s5 + s6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.0125, size + 0.125 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n\n    //vUv = vUv / 2. + 0.25;\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time + 1.0 * (2. * sin(u_time)));\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time + 0.9 * (2. * sin(u_time)));\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time + 0.8 * (2. * sin(u_time)));\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time + 0.7 * (2. * sin(u_time)));\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time + 0.6 * (2. * sin(u_time)));\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time + 0.5 * (2. * sin(u_time)));\n\n    \n\n    float s1 = polygonOutline(vUv1, 3, 0.5);\n    float s2 = polygonOutline(vUv2, 3, 0.4);\n    float s3 = polygonOutline(vUv3, 3, 0.3);\n    float s4 = polygonOutline(vUv4, 3, 0.2);\n    float s5 = polygonOutline(vUv5, 3, 0.1);\n    float s6 = polygonOutline(vUv6, 3, 0.025);\n\n    color.r += s1 + s2 + s3 + s4 + s5 + s6 - 0.6 * (sin(u_time)/15.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _D=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.000005, size + 0.225 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n\n    //vUv = vUv / 2. + 0.25;\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time + 1.0 * (2. * sin(u_time)));\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time + 0.9 * (2. * sin(u_time)));\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time + 0.8 * (2. * sin(u_time)));\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time + 0.7 * (2. * sin(u_time)));\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time + 0.6 * (2. * sin(u_time)));\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time + 0.5 * (2. * sin(u_time)));\n\n    \n\n    float s1 = polygonOutline(vUv1, 4, 0.5);\n    float s2 = polygonOutline(vUv2, 4, 0.4);\n    float s3 = polygonOutline(vUv3, 4, 0.3);\n    float s4 = polygonOutline(vUv4, 4, 0.2);\n    float s5 = polygonOutline(vUv5, 4, 0.1);\n    float s6 = polygonOutline(vUv6, 4, 0.025);\n\n    color.b += s1 + s2 + s3 + s4 + s5 + s6 - 0.6 * (sin(u_time)/15.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_D,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.000005, size + 0.225 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv / 2. + 0.25;\n    vec3 color = vec3(0.);\n\n    float x = blobOutline(vUv, 8., 0.5);\n    float y = blob(vUv, 8., 0.5);\n    color = vec3(x + y);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.000005, size + 0.225 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1, vUv2, vUv3, vUv4;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 0.75);\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 1.00);\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.50);\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 1.25);\n\n    float y = spike(vUv1, 5, 0.5);\n    float x = spike(vUv2, 5, 0.25);\n    float z = spike(vUv3, 5, 0.75);\n    float a = spike(vUv4, 5, 0.05);\n    color += y + x + z + a;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// // float circle(vec2 vUv, float radius)\n// // {\n// //     vec2 dist = vUv - vec2(0.5);\n// //     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// // }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.521 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nvec2 scale(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 1.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale2(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 2.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale3(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 3.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale4(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 4.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale5(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 0.6) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vec2 vUv5 = vUv;\n    //vUv1 = Rot(vUv1, u_time * 0.5);\n    vUv2, vUv3, vUv4, vUv5 = vUv1;\n    vUv1 = scale(vUv1);\n    vUv2 = scale2(vUv2);\n    vUv3 = scale3(vUv3);\n    vUv4 = scale4(vUv4);\n    vUv5 = scale5(vUv5);\n    vec2 translate = vec2(cos(u_time), sin(u_time));\n    //vUv1 += translate * 0.25;\n\n    float s1 = polygonOutline(vUv1, 4, 0.15);\n\n    float s2 = polygonOutline(vUv2, 4, 0.25);\n\n    float s3 = polygonOutline(vUv3, 4, 0.35);\n\n    float s4 = polygonOutline(vUv4, 4, 0.45);\n\n    float s5 = polygonOutline(vUv5, 4, 0.55);\n\n    color += s1 + s2 + s3 + s4 + s5;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.521 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/3.);\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/3.);\n    float r2 = rect(vUv, size/3., size);\n    float r = r1 + r2;\n    float ra = rect(vUv, size + 0.01, size + 0.01/3.);\n    float rb = rect(vUv, size + 0.01, size + 0.02/3.);\n    float rn = ra + rb;\n    return rn - r;\n}\n\nvec2 scale(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 1.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5 = vUv;\n    vUv1 = vec2(vUv.x, vUv.y);\n    vUv2 = vec2(vUv.x, vUv.y);\n    vUv3 = vec2(vUv.x, vUv.y);\n    vUv4 = vec2(vUv.x, vUv.y);\n    vUv5 = vec2(vUv.x, vUv.y);\n\n    vUv1 = Rot(vUv1, u_time * 0.50);\n    vUv2 = Rot(vUv2, u_time * 0.45);\n    vUv3 = Rot(vUv2, u_time * 0.35);\n    vUv4 = Rot(vUv2, u_time * 0.25);\n    vUv5 = Rot(vUv2, u_time * 0.15);\n    vec2 translate = (vec2(cos(u_time), sin(u_time)));\n    vUv2 += translate *0.25;\n    vUv3 += translate *0.25;\n    vUv4 += translate *0.25;\n    vUv5 += translate *0.25;\n\n    float s1 = crossSDF(vUv1, 0.15);\n    float s2 = crossSDF(vUv2, 0.15);\n    float s3 = crossSDF(vUv3, 0.15);\n    float s4 = crossSDF(vUv4, 0.15);\n    float s5 = crossSDF(vUv5, 0.15);\n\n    color += s1 + s2 + s3 + s4 + s5;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.521 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6, vUv7;\n\n    vUv1 = vUv;\n    vUv2 = vUv;\n    vUv3 = vUv;\n    vUv4 = vUv;\n    vUv5 = vUv;\n    vUv6 = vUv;\n    vUv7 = vUv;\n\n    vUv1 = scale(vUv1, sin(u_time * 0.5));\n    vUv2 = scale(vUv2, sin(u_time * 0.6));\n    vUv3 = scale(vUv3, sin(u_time * 0.7));\n    vUv4 = scale(vUv4, sin(u_time * 0.8));\n    vUv5 = scale(vUv5, sin(u_time * 0.9));\n    vUv6 = scale(vUv6, sin(u_time * 1.0));\n    vUv7 = scale(vUv7, sin(u_time * 1.1));\n\n    float c1 = crossSDFOutline(vUv1, 0.5 * 0.1);\n    float c2 = crossSDFOutline(vUv2, 0.5 * 0.2);\n    float c3 = crossSDFOutline(vUv3, 0.5 * 0.3);\n    float c4 = crossSDFOutline(vUv4, 0.5 * 0.4);\n    float c5 = crossSDFOutline(vUv5, 0.5 * 0.5);\n    float c6 = crossSDFOutline(vUv6, 0.5 * 0.6);\n    float c7 = crossSDFOutline(vUv7, 0.5 * 0.7);\n\n    color += c1 + c2 + c3 + c4 + c5 + c6 + c7;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// // float circle(vec2 vUv, float radius)\n// // {\n// //     vec2 dist = vUv - vec2(0.5);\n// //     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// // }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.02, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.15 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 5.);\n\n    float s1 = polygonOutline(vUv, 6, 1.);\n    float s2 = polygon(vUv, 6, 0.8);\n\n    color += s1 + s2;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ID=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// // float circle(vec2 vUv, float radius)\n// // {\n// //     vec2 dist = vUv - vec2(0.5);\n// //     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// // }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.02, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.15 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 5.);\n\n    float s1 = polygonOutline(vUv, 6, 1.);\n    float s2 = polygon(vUv, 6, 0.28);\n\n    color.r += 1. - s2;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ED(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ID,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.15 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 5.);\n\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n\n    vUv1 = Rot(vUv1, u_time * 0.25);\n    vUv2 = Rot(vUv2, -u_time * 0.95);\n\n    float s1 = polygonOutline(vUv1, 4, 0.75);\n    float s2 = polygon(vUv2, 4, 0.5);\n\n    color.r += s1 + s2 * vUv.x * vUv.y * 2.;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 1.);\n\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    \n    vUv2 = tile(vUv2, 3.);\n\n    vUv1 = Rot(vUv1, u_time * 0.25);\n    vUv2 = Rot(vUv2, -u_time * 0.5);\n\n    float s1 = blobOutline(vUv1, 0.15, 0.36);\n    float s2 = blobOutline(vUv2, 1.15, 1.);\n\n    color += s1 * vUv.x * vUv.y * 2.;\n    color += s2;\n\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ND=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.1, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    return vec3(str * shape );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float s1 = circle(vUv, 0.25);\n    vec3 mat = matrix(vUv, s1);\n\n    color = vec3(mat.x * 0.5 * abs(sin(u_time)), mat.y * 0.25 * abs(cos(u_time + 0.5)), mat.z * 0.1 );\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ND,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = Rot(vUv, u_time * 0.25);\n\n    float c1 = crossSDF(vUv, 0.6);\n    float s1 = circle(vUv, 0.25);\n    vec3 mat = matrix(vUv, c1);\n\n    color = vec3(mat);\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 3.);\n\n    vUv = Rot(vUv, u_time * 0.25);\n\n    float c1 = crossSDF(vUv, 0.61);\n    float s1 = circle(vUv, 0.25);\n    vec3 mat = matrix(vUv, c1);\n\n    color = vec3(mat.x * cos(u_time), mat.y, mat.z * sin(u_time));\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = vUv * 2. - 1.;\n\n    float y = sdRoundedBox(vUv, vec2(0.5, 0.7), vec4(0.5, 0.0, 0.5, 0.0));\n    color += y;\n\n    float t1 =  polygon((vec2(vUv.x+0.86, vUv.y + 1.1)), 3, 0.3);\n\n    float t2 =  polygon((vec2(vUv.x+0.51, vUv.y + 1.1)), 3, 0.3);\n\n    float t3 =  polygon((vec2(vUv.x+0.16, vUv.y + 1.1)), 3, 0.3);\n\n    \n\n    color -= vec3(t1, 0.5, 0.5);\n    color -= vec3(t2, 0.5, 0.5);\n    color -= vec3(t3, 0.5, 0.5);\n\n    float c1 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.2), 0.065);\n    float c2 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.225), 0.065);\n\n    float c3 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.2), 0.065);\n    float c4 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.225), 0.065);\n\n    float c5 = circle(vec2(vUv.x+ 0.725 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n    float c6 = circle(vec2(vUv.x+ 0.425 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n\n    color += vec3(c1 + c2) * 2.;\n    color += vec3(c3 + c4) * 2.;\n\n    color *= 1. - vec3(c5 + c6);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = vUv * 2. - 1.;\n\n    float y = sdRoundedBox(vUv, vec2(0.5, 0.7), vec4(0.5, 0.0, 0.5, 0.0));\n    \n\n    float t1 =  polygon((vec2(vUv.x+0.86 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t1 = smoothstep(0.01, 0.021, t1);\n    float t2 =  polygon((vec2(vUv.x+0.51 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t2 = smoothstep(0.01, 0.021, t2);\n    float t3 =  polygon((vec2(vUv.x+0.16 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t3 = smoothstep(0.01, 0.021, t3);\n    float t4 =  polygon((vec2(vUv.x-0.18 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t4 = smoothstep(0.01, 0.021, t4);\n    float t5 =  polygon((vec2(vUv.x+1.2 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t5 = smoothstep(0.01, 0.021, t5);\n    float t6 =  polygon((vec2(vUv.x+1.55 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t6 = smoothstep(0.01, 0.021, t6);\n    float t7 =  polygon((vec2(vUv.x-0.53 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t7 = smoothstep(0.01, 0.021, t7);\n    \n\n    \n\n    float c1 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.2), 0.065);\n    float c2 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.225), 0.065);\n    c1 = smoothstep(0.01, 0.03, c1);\n    c2 = smoothstep(0.01, 0.03, c2);\n    float c3 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.2), 0.065);\n    float c4 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.225), 0.065);\n    c3 = smoothstep(0.01, 0.03, c3);\n    c4 = smoothstep(0.01, 0.03, c4);\n    float c5 = circle(vec2(vUv.x+ 0.725 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n    float c6 = circle(vec2(vUv.x+ 0.425 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n    c5 = smoothstep(0.01, 0.03, c5);\n    c6 = smoothstep(0.01, 0.03, c6);\n    \n    \n    color = vec3(y, y * 0.75, 0.);\n    color += vec3(c1 + c2) * 2.;\n    color += vec3(c3 + c4) * 2.;\n    color *= 1. - vec3(c5 + c6);\n\n    color -= vec3(t1);\n    color -= vec3(t2);\n    color -= vec3(t3);\n    color -= vec3(t4);\n    color -= vec3(t5);\n    color -= vec3(t6);\n    color -= vec3(t7);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvec2 rotatedTilepattern(vec2 st)\n{\n    st *= 2.0;\n    float index = 0.0;\n    index += step(1., mod(st.x, 2.0));\n    index += step(1., mod(st.y, 2.0)) * 2.0;\n    st = fract(st);\n    if(index == 1.0){\n        st = Rot(st, PI * 0.5);\n    } else if (index == 2.0){\n        st = Rot(st, PI * -0.5);\n    } else if (index == 3.0){\n        st = Rot(st, PI);\n    }\n    return st;\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 3.);\n\n    vUv = rotatedTilepattern(vUv * 1.);\n\n    vUv = Rot(vUv, PI * u_time * 0.25);\n\n    float x = smoothstep(vUv.x, vUv.y, 0.01);\n    x = smoothstep(0.01, 0.04, x);\n\n    color = vec3(x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KD(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JD,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $D=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvec2 rotatedTilepattern(vec2 st)\n{\n    st *= 4.0;\n    float index = 0.0;\n    index += step(1., mod(st.x, 2.0));\n    index += step(1., mod(st.y, 2.0)) * 2.0;\n    st = fract(st);\n    if(index == 1.0){\n        st = Rot(st, PI * 0.5);\n    } else if (index == 2.0){\n        st = Rot(st, PI * -0.5);\n    } else if (index == 3.0){\n        st = Rot(st, PI);\n    }\n    return st;\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 1.);\n\n    vUv = rotatedTilepattern(vUv);\n\n    vUv = Rot(vUv, PI * u_time * 0.25);\n\n    float x = polygonOutline(vUv, 4, 0.35);\n    x = smoothstep(0.01, 0.02, x);\n\n    color = vec3(x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$D,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvec2 rotatedTilepattern(vec2 st)\n{\n    st *= 4.0;\n    float index = 0.0;\n    index += step(1., mod(st.x, 2.0));\n    index += step(1., mod(st.y, 2.0)) * 2.0;\n    st = fract(st);\n    if(index == 1.0){\n        st = Rot(st, PI * 0.5);\n    } else if (index == 2.0){\n        st = Rot(st, PI * -0.5);\n    } else if (index == 3.0){\n        st = Rot(st, PI);\n    }\n    return st;\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float val1 = (sin(u_time * 0.5)/2.);\n    float val2 = (sin(u_time * 1.0)/3.);\n    float val3 = (sin(u_time * 1.5)/4.);\n    float val4 = (sin(u_time * 2.0)/5.);\n\n    float x = sdRoundedBox(vUv, vec2(0.5, 0.5), vec4(0.0 + val1, 0.0 + val2, 0.0 + val3, 0.0 + val4));\n\n    color = vec3(x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float val1 = (sin(u_time * 0.5)/2.);\n    float val2 = (sin(u_time * 1.0)/3.);\n    float val3 = (sin(u_time * 1.5)/4.);\n    float val4 = (sin(u_time * 2.0)/5.);\n\n    float x = sdRoundedBox(vec2(vUv.x, vUv.y + 0.125), vec2(0.2, 0.125), vec4(0.0, 0.14, 0.0, 0.14));\n    float x1 = sdRoundedBox(vec2(vUv.x, vUv.y + 0.125), vec2(0.15 * (sin(u_time)/5. + 1.), 0.08), vec4(0.0, 0.08, 0.0, 0.08));\n    float y = sdRoundedBoxOutline(vUv, vec2(0.4, 0.45), vec4(0.1, 0.25, 0.1, 0.25), 0.02);\n    float z = sdCircle(vec2(vUv.x - 0.1, vUv.y - 0.1), 0.1);\n    float z1 = sdCircle(vec2(vUv.x - 0.1, vUv.y - 0.1), 0.05);\n    float a = sdCircle(vec2(vUv.x + 0.1, vUv.y - 0.1), 0.1);\n    float a1 = sdCircle(vec2(vUv.x + 0.1, vUv.y - 0.1), 0.05);\n\n    color = vec3(x + y + z + a);\n    color -= z1 + a1 + x1;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, PI * 0.5 );\n    vec3 color = vec3(0.);\n    float y =1. - smoothstep(0.01, 0.014, sdSegment(vec2(vUv.x, vUv.y), vec2(0.75 + (sin(u_time)/3.)), vec2(-0.75 + (cos(u_time)/3.))));\n    float x = sdSegment(vec2(vUv.x, vUv.y), vec2(0.75 + (sin(u_time)/3.)), vec2(-0.75 + (cos(u_time)/3.)));\n    float y1 =1. - smoothstep(0.01, 0.014, sdSegment(vec2(vUv2.x, vUv2.y), vec2(0.75 + (cos(u_time)/3.)), vec2(-0.75 + (cos(u_time)/3.))));\n    float x1 = sdSegment(vec2(vUv2.x, vUv2.y), vec2(0.75 + (sin(u_time)/4.)), vec2(-0.75 + (cos(u_time)/4.)));\n    color.g += y;\n    color.r += y1;\n    color.g += x;\n    color.r += x1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\n// float ndot(vec2 a, vec2 b)\n// {\n//     return a.x * b.x - a.y * b.y;\n// }\n\n// float sdRhombus(vec2 p, vec2 b)\n// {\n//     p = abs(p);\n//     float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n//     float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n//     return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, PI * 0.5 );\n    float x = sdRhombus(vUv, vec2(0.5 * (sin(u_time)/4. + 1.), 0.75 * (sin(u_time)/4. + 1.)));\n    float x1 = sdRhombus(vUv, vec2(0.5 * (sin(u_time)/4. + 1.), 0.75 * (sin(u_time)/4. + 1.)));\n    float y = sdRhombus(vec2(vUv.x, vUv.y - 0.05), vec2(0.5 * (sin(u_time)/4. + 1.), 0.25 * (sin(u_time)/4. + 1.)));\n    float y1 = sdRhombus(vec2(vUv.x, vUv.y), vec2(0.5 * (sin(u_time)/4. + 1.), 0.25 * (sin(u_time)/4. + 1.)));\n    color.g = 1. -  smoothstep(0.01, 0.014, x);\n    color.b -= 1. - smoothstep(0.01, 0.014, y);\n    color.br += x1;\n    color.rgb += 1. - smoothstep(0.01, 0.014, y1);\n    \n    color -= step(0., vUv.x) * 0.1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\n// float ndot(vec2 a, vec2 b)\n// {\n//     return a.x * b.x - a.y * b.y;\n// }\n\n// float sdRhombus(vec2 p, vec2 b)\n// {\n//     p = abs(p);\n//     float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n//     float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n//     return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n// }\n\n// float dot2(vec2 a)\n// {\n//     return dot(a.x, a.y);\n// }\n\n// float trapezoid(vec2 p, float r1, float r2, float he)\n// {\n//     vec2 k1 = vec2(r2, he);\n//     vec2 k2 = vec2(r2-r1, 2.0 * he);\n//     p.x = abs(p.x);\n//     vec2 ca = vec2(p.x-min(p.x, (p.y<0.)?r1:r2), abs(p.y)-he);\n//     vec2 cb = p - k1 + k2 * clamp(dot(k1-p,k2)/dot2(k2), 0., 1.);\n//     float s = (cb.x < 0. && ca.y<0.)? -1.: 1.;\n//     return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 15. - 7.5;\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, (u_time));\n    float x =1. - trapezoid(vUv, 0.8, 0.2, 2. + sin(u_time));\n    x = smoothstep(0.01, 0.081, x);\n    color += x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\n// float ndot(vec2 a, vec2 b)\n// {\n//     return a.x * b.x - a.y * b.y;\n// }\n\n// float sdRhombus(vec2 p, vec2 b)\n// {\n//     p = abs(p);\n//     float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n//     float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n//     return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n// }\n\n// float dot2(vec2 a)\n// {\n//     return dot(a.x, a.y);\n// }\n\n// float trapezoid(vec2 p, float r1, float r2, float he)\n// {\n//     vec2 k1 = vec2(r2, he);\n//     vec2 k2 = vec2(r2-r1, 2.0 * he);\n//     p.x = abs(p.x);\n//     vec2 ca = vec2(p.x-min(p.x, (p.y<0.)?r1:r2), abs(p.y)-he);\n//     vec2 cb = p - k1 + k2 * clamp(dot(k1-p,k2)/dot2(k2), 0., 1.);\n//     float s = (cb.x < 0. && ca.y<0.)? -1.: 1.;\n//     return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n// }\n\n// float sdEqTriangle(vec2 p, float size)\n// {\n//     p = p / size;\n//     float k = sqrt(3.);\n//     p.x = abs(p.x) - 1.;\n//     p.y = p.y + 1.0/k;\n//     if(p.x+k*p.y > 0.)\n//     {\n//         p = vec2(p.x-k*p.y, -k*p.x-p.y)/2.0; \n//     }\n//     p.x -= clamp(p.x, -2., 0.);\n//     return -length(p) * sign(p.y);\n// }\n\n// float sdEqTriangleOutline(vec2 p, float size)\n// {\n//     float x = 1. - sdEqTriangle(p, size);\n//     float y = 1. - sdEqTriangle(p, size + 0.025);\n//     x = smoothstep(0.01, 0.021, x);\n//     y = smoothstep(0.01, 0.021, y);\n//     return y - x;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vUv1 = Rot(vUv1, (u_time));\n    vUv2 = Rot(vUv2, (u_time));\n    vUv3 = Rot(vUv3, (u_time));\n    // vUv = Rot(vUv, (u_time));\n    float x = sdEqTriangleOutline(vUv1, 0.4);\n    float y = sdEqTriangleOutline(vUv2, 0.25);\n    float z = sdEqTriangleOutline(vUv3, 0.125);\n    //x = smoothstep(0.01, 0.021, x);\n    color += x + y + z ;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n        void main()\n        {\n            vec2 vUv = vec2(vUv.x, vUv.y);\n            vUv = vUv * 2.;\n            //vUv.y -= 0.25;\n            vec2 vUv2 = vUv;\n            vUv2 -= 1.;\n            vUv2 = Rot(vUv2, PI);\n            vec3 color = vec3(0.);\n            float y = sdTriIsosceles(vUv, vec2(0.25 +(sin(u_time)/4.), 0.5 +(cos(u_time)/4.)));\n            float x = sdTriIsosceles(vUv2, vec2(0.25 +(cos(u_time)/4.), 0.5 +(sin(u_time)/4.)));\n            y = 1. - smoothstep(0.01, 0.021, y);\n            x = 1. - smoothstep(0.01, 0.021, x);\n            color += y;\n            color += x;\n            gl_FragColor = vec4(color, 1.);\n        }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 2.;\n    \n    //vUv.y -= 0.25;\n    vec2 vUv2 = vUv;\n    vUv2 -= 1.;\n    vec2 vUv3 = vUv;\n    vUv3 -= 1.;\n    vUv3.y += 1.;\n    vec2 vUv4 = vUv;\n    vUv4 -= 1.;\n    vUv4.x += 1.;\n    vUv2 = Rot(vUv2, PI);\n    vUv3 = Rot(vUv3, PI * 0.5);\n    \n    vUv4 = Rot(vUv4, PI * -0.5);\n    vec3 color = vec3(0.);\n    float y = sdTriIsosceles(vUv, vec2(0.25 +(sin(u_time)/4.), 0.5 +(cos(u_time)/4.)));\n    float x = sdTriIsosceles(vUv2, vec2(0.25 +(cos(u_time)/4.), 0.5 +(sin(u_time)/4.)));\n    float y2 = sdTriIsosceles(vUv3, vec2(0.25 +(cos(u_time)/4.), 0.5 +(sin(u_time)/4.)));\n    float x2 = sdTriIsosceles(vUv4, vec2(0.25 +(sin(u_time)/4.), 0.5 +(cos(u_time)/4.)));\n    y = 1. - smoothstep(0.01, 0.021, y);\n    x = 1. - smoothstep(0.01, 0.021, x);\n    y2 = 1. - smoothstep(0.01, 0.021, y2);\n    x2 = 1. - smoothstep(0.01, 0.021, x2);\n    color.g += y + y2;\n    color.r += x + x2;\n    gl_FragColor = vec4(color, 1.);\n}\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 onevUv = vUv;\n    vec2 vUvy2 = vUv;\n    vUv = vUv * 2. - 0.5;\n    vec2 twovUv = vUv;\n    twovUv = twovUv * 2. - 1.;\n    twovUv.x -= 0.5;\n    \n    onevUv = Rot(onevUv, PI * -0.25);\n    float one = sdRoundedBox(vec2(vUv.x + 0.275, vUv.y), vec2(0.17, 0.85), vec4(0.1, 0.1, 0.1, 0.1));\n    float oneP = sdRoundedBox(vec2(onevUv.x + 0.24, onevUv.y + 0.05), vec2(0.07, 0.2), vec4(0.1, 0.075, 0.1, 0.075));\n    \n    // color += one;\n    float a = PI * (0.5 + 0.25);\n    float b = 0.2 *(0.5 + 0.5);\n    twovUv = Rot(twovUv, PI * 1.85);\n    float y1 = sdArc(vec2(twovUv.x - 0.1, twovUv.y - 0.15), vec2(a * 0.8, a * 0.8), .35, b * 0.84 );\n    y1 = smoothstep(0.0, 0.015, y1); //yellow\n    vUvy2 = Rot(vUvy2, PI * -0.22);\n    float y2 = sdRoundedBox(vec2(vUvy2.x - 0.122, vUvy2.y - 0.05), vec2(0.075, 0.35), vec4(0.2, 0.1, 0.1, 0.1));\n    float y3 = sdRoundedBox(vec2(vUv.x - 0.25, vUv.y + 0.335), vec2(0.5, 0.155), vec4(0.1, 0.1, 0.1, 0.1));\n    color += y1;\n    color -= one;\n    color -= y2;\n    color -= y3; \n    color -= oneP;\n    gl_FragColor = vec4(color, 1.);\n}\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        // vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x + 0.35, vUv.y));\n        // color += one;\n        float two = sdTwo(vec2(vUv.x + 0.05, vUv.y));\n        // color += two;\n        float three = sdThree(vec2(vUv.x, vUv.y));\n        color += three;\n        // color += one;\n        // color += two;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _P=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x + 0.5 * sin(u_time), vUv.y - 0.5 * cos(u_time)));\n        color += one;\n        float two = sdTwo(vec2(vUv.x + 0.5 * sin(u_time), vUv.y + 0.5 * cos(u_time)));\n        color += two;\n        float three = sdThree(vec2(vUv.x - 0.5 * cos(u_time), vUv.y - 0.5 * sin(u_time)));\n        color += three;\n        float four = sdFour(vec2(vUv.x - 0.5 * cos(u_time), vUv.y + 0.5 * sin(u_time)));\n        color += four;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_P,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x + 0.5 * sin(u_time), vUv.y - 0.5 * cos(u_time)));\n        color += one;\n        float two = sdTwo(vec2(vUv.x + 0.5 * sin(u_time), vUv.y + 0.5 * cos(u_time)));\n        color += two;\n        float three = sdThree(vec2(vUv.x - 0.5 * cos(u_time), vUv.y - 0.5 * sin(u_time)));\n        color += three;\n        float four = sdFour(vec2(vUv.x - 0.5 * cos(u_time), vUv.y + 0.5 * sin(u_time)));\n        color += four;\n        float five = sdFive(vec2(vUv.x + (sin(u_time)*0.5), vUv.y));\n        color += five;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 15.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float one = sdOne(b);\n        float zero = sdZero(b);\n        float shape;\n        if(str > .5 )\n        {\n            shape = smoothstep(0.01, 0.011, one);\n        } else {\n            shape = smoothstep(0.01, 0.011, zero);\n        }\n        \n        return vec3(shape * str );\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        // vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x , vUv.y ));\n        // color += one;\n        float zero = sdZero(vUv);\n        // color += zero;\n        // float two = sdTwo(vec2(vUv.x + 0.5 * sin(u_time), vUv.y + 0.5 * cos(u_time)));\n        // color += two;\n        // float three = sdThree(vec2(vUv.x - 0.5 * cos(u_time), vUv.y - 0.5 * sin(u_time)));\n        // color += three;\n        // float four = sdFour(vec2(vUv.x - 0.5 * cos(u_time), vUv.y + 0.5 * sin(u_time)));\n        // color += four;\n        // float five = sdFive(vec2(vUv.x + (sin(u_time)*0.5), vUv.y));\n        // color += five;\n        vec3 m = matrix(vUv);\n        color.g += m.x * 1.5;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 8.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float shape;\n        float zero = sdZero(b);\n        float one = sdOne(b);\n        float two = sdTwo(b);\n        float three = sdThree(b);\n        float four = sdFour(b);\n        float five = sdFive(b);\n        float six = sdSix(b);\n         if(str > 0.0 && str < 0.1 ){\n            shape = smoothstep(0.01, 0.011, zero);\n        }if(str > 0.1 && str < 0.2 ) {\n            shape = smoothstep(0.01, 0.011, one);\n        }if(str > 0.2 && str < 0.3 ) {\n            shape = smoothstep(0.01, 0.011, two);\n        }if(str > 0.3 && str < 0.4 ) {\n            shape = smoothstep(0.01, 0.011, three);\n        }if(str > 0.4 && str < 0.5 ) {\n            shape = smoothstep(0.01, 0.011, four);\n        }if(str > 0.5 && str < 0.6 ) {\n            shape = smoothstep(0.01, 0.011, five);\n        }if(str > 0.6 && str < 0.7 ) {\n            shape = smoothstep(0.01, 0.011, six);\n        }if(str > 0.7 && str < 0.8 ) {\n            shape = smoothstep(0.01, 0.011, two);\n        }if(str > 0.8 && str < 0.9 ) {\n            shape = smoothstep(0.01, 0.011, three);\n        }if(str > 0.9 && str < 1.0 ) {\n            shape = smoothstep(0.01, 0.011, four);\n        }\n        \n        return vec3(shape * str );\n    }\n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec3 m = matrix(vUv);\n        m.x *= sin(u_time * 0.25);\n        m.y *= cos(u_time * 0.25);\n        color = m * 2.5;\n       \n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 15.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1., floor(u_time * 6. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float shape;\n        float zero = sdZero(b);\n        float one = sdOne(b);\n        float two = sdTwo(b);\n        float three = sdThree(b);\n        float four = sdFour(b);\n        float five = sdFive(b);\n        float six = sdSix(b);\n        float seven = sdSeven(b);\n        float eight = sdEight(b);\n        float nine = sdNine(b);\n         if(str >= 0.0 && str < 0.1 ){\n            shape = zero;\n        }if(str >= 0.1 && str < 0.2 ) {\n            shape = one;\n        }if(str >= 0.2 && str < 0.3 ) {\n            shape = two;\n        }if(str >= 0.3 && str < 0.4 ) {\n            shape = three;\n        }if(str >= 0.4 && str < 0.5 ) {\n            shape = four;\n        }if(str >= 0.5 && str < 0.6 ) {\n            shape = five;\n        }if(str >= 0.6 && str < 0.7 ) {\n            shape = six;\n        }if(str >= 0.7 && str < 0.8 ) {\n            shape = seven;\n        }if(str >= 0.8 && str < 0.9 ) {\n            shape = eight;\n        }if(str >= 0.9 && str < 1.0 ) {\n            shape = nine;\n        }\n        return vec3(shape);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec3 m = matrix(vUv);\n        // m.x *= sin(u_time * 0.25) + 2.;\n        // m.y *= cos(u_time * 0.25) ;\n        color = m;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Vh+Wh+qh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdFive(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float hexagramOutline(vec2 p, float size)\n    {\n        float x = sdHexagram(p, size);\n        x = 1. - smoothstep(0.01, 0.02, x);\n        float y = sdHexagram(p, size * 0.95);\n        y = 1. - smoothstep(0.01, 0.02, y);\n        return x - y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time);\n        newUv = newUv * 2. - 1.;\n        vec2 uv2 = newUv;\n        uv2 *= ((sin(u_time) / 1.25) - 2.);\n        float hexagram = sdHexagram(newUv, 0.25);\n        hexagram = 1. - smoothstep(0.01, 0.02, hexagram);\n        color += hexagram;\n        float hexOutline = hexagramOutline(newUv, 0.28);\n        color += hexOutline;\n        float hexOutline2 = hexagramOutline(uv2, 0.2);\n        color -= hexOutline2;\n        float shaderLabel = label(vUv);\n        color += shaderLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdSix(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 vUv2 = vUv;\n        float s1 = sdSegment(vUv, vec2(0.5 + (sin(u_time)/2.5),0.5 + (cos(u_time) / 2.5)), vec2(0.5, 0.5));\n        float s2 = sdSegment(vUv2, vec2(0.5 + (sin(u_time * 0.5)/5.), 0.5 + (cos(u_time * 0.5) / 5.)), vec2(0.5, 0.5));\n        s1 = 1. - smoothstep(0.01, 0.012, s1);\n        s2 = 1. - smoothstep(0.01, 0.012, s2);\n        color.r += s1;\n        color.g += s2;\n        float shaderLabel = label(vUv);\n        color += shaderLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdSeven(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 evUv = vUv;\n        evUv = evUv * 2. - 1.;\n        float e1 = sdEgg(evUv, 0.5, 0.25);\n        e1 = 1. - smoothstep(0.01, 0.02, e1);\n        color += e1;\n\n        float s1 = sdSegment(vUv, vec2(0.45, 0.5), vec2(0.45, 0.1));\n        float s2 = sdSegment(vUv, vec2(0.55, 0.5), vec2(0.55, 0.1));\n        s1 = 1. - smoothstep(0.01, 0.015, s1);\n        s2 = 1. - smoothstep(0.01, 0.015, s2);\n        color += s1 + s2;\n\n        float numberLabel = label(vUv);\n        color += numberLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdEight(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 5. - 2.5;\n        p.y -= 1.25;\n        p.x += 0.5;\n        float c;\n        float steps = 15.;\n        for(float i = 1.; i < steps; i++)\n        {\n            c += sdCircle(vec2(p.x  + i/ 4. * (sin(u_time * i * 0.25)), p.y + i / 4. ), a);\n        }\n        \n        return c;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float x = newfunc(vUv, 0.25);\n        color += x;\n        float num = label(vUv);\n        color += num;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdNine(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 4.;\n        //p.y -= 1.25;\n        p.x += 0.5;\n        p.y += 0.5;\n        float c;\n        float steps = 25.;\n        for(float i = 1.; i < steps; i++)\n        {\n            c += sdCircle(vec2(p.x  + i/ 4. * (sin(u_time * i * 0.25)), p.y + i / 12. * (cos(u_time * i * 0.25)) ), a);\n        }\n        return c;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        float y = newfunc(vUv, 0.25);\n        color += y;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdZero(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n    float sdCircleHighlight(vec2 p, float r)\n    {\n        p = p * 2.0 - 1.;\n        float x = length(p) - r;\n        return 1. - smoothstep(0.01, 1.5, x);\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 4.;\n        //p.y -= 1.25;\n        p.x += 0.5;\n        p.y += 0.5;\n        float c;\n        float d;\n        float e;\n        float f;\n        float steps = 25.;\n        for(float i = 1.; i < steps; i++)\n        {\n            c += sdCircle(vec2(p.x  + i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y + i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            d += sdCircle(vec2(p.x  - i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y - i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            e += sdCircleHighlight(vec2(p.x  + i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y + i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            f += sdCircleHighlight(vec2(p.x  - i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y - i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n        }\n        e *= 0.25;\n        f *= 0.25;\n        return c + d + e + f ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdOne(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n    \n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 4.;\n        // //p.y -= 1.25;\n        p.x += 0.5;\n        p.y += 0.5;\n        p*= 0.5;\n        // float c;\n        // float d;\n        // float steps = 25.;\n        // for(float i = 1.; i < steps; i++)\n        // {\n        //     c += sdCircle(vec2(p.x  + i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y + i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n        //     d += sdCircle(vec2(p.x  - i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y - i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            \n        // }\n        // return c + d;\n        float b;\n        float steps = 30.;\n        for(float i = 1.; i<steps; i++)\n        {\n            b += sdSegment(vec2(p.x, p.y), vec2(0.25 + i/20. * (cos(u_time * i * 0.015)) , 0.25 + i/20. * (sin(u_time * i * 0.05)) ), vec2(0.75 + i/20. * (cos(u_time * i * 0.025)), 0.75 + i/20. * (sin(u_time * i * 0.05)) ));\n            \n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 12. - 6.;\n        // //p.y -= 1.25;\n        // p.x += 0.5;\n        // p.y += 0.5;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            b += sdEqTriangleOutline(vec2(p.x + i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n            b += sdEqTriangleOutline(vec2(p.x - i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 12. - 6.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            b += sdCircleOutline(vec2(p.x + i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n            b += sdCircleOutline(vec2(p.x - i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n            b += sdCircleOutline(vec2(p.x + i / 10. * cos(u_time + i / 5. ), p.y + i / 10. * sin(u_time + i / 10.)), a);\n            b += sdCircleOutline(vec2(p.x - i / 10. * cos(u_time + i / 5. ), p.y + i / 10. * sin(u_time + i / 10.)), a);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdFour(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 100. - 50.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, sin(u_time * i/1.));\n            b += 1. - sdBox(vec2(p.x + i + sin(u_time * i), p.y + sin(u_time * i)), vec2(1.5, 0.5));\n            b += 1. - sdBox(vec2(p.x - i + cos(u_time * i), p.y + sin(u_time * i)), vec2(1.5, 0.5));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i), p.y + i + cos(u_time * i)), vec2(0.5, 1.5));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i) , p.y - i + sin(u_time * i)), vec2(0.5, 1.5));\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdFive(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 100. - 50.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, cos(u_time * i/25.));\n            b += 1. - sdBox(vec2(p.x + i + sin(u_time * i / 50.), p.y + sin(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n            b += 1. - sdBox(vec2(p.x - i + cos(u_time * i / 50.), p.y + sin(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i / 50.), p.y + i + cos(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i / 50.) , p.y - i + sin(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KP(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JP,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $P=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdSix(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 100. - 50.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 30.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/10.)));\n            b += sdCircle(vec2(p.x + i /1.75 + sin(u_time * i / 150.), p.y + sin(u_time * i / 150.)),  2.5 * i/50.);\n            b += sdCircle(vec2(p.x - i/1.75 + cos(u_time * i / 150.), p.y + sin(u_time * i / 150.)),  2.5 * i/50.);\n            b += sdCircle(vec2(p.x + sin(u_time * i / 150.), p.y + i/1.75 + cos(u_time * i / 150.)),  2.5 * i/50.);\n            b += sdCircle(vec2(p.x + sin(u_time * i / 150.) , p.y - i/1.75 + sin(u_time * i / 150.)),  2.5 * i/50.);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$P,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdSeven(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 10. - 5.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 30.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/15.)));\n            b += sdSegment(p, vec2(0.25 * i + ((sin(u_time) * 2.) - 12.5), 0.25 ), vec2(2.75 * i, 2.75));\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdEight(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 2.;\n\n        // //p.y -= 1.25;\n        // p.x += 1.;\n        // p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 15.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/15.)));\n            b += rectOutline(vec2(p.x, p.y), 0.5 * i / 15., 0.5 * i / 15.);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdNine(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 3.;\n        p*= 0.5;\n        float b;\n        float steps = 15.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/15.)));\n            b += cirOutline(vec2(p.x + sin(u_time * i/15. + i), p.y + cos(u_time * i/15. + i)), 0.5 * (i + sin(u_time)) * 0.25);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdZero(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 3.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            // if(i < 12.)\n            // {\n            //     p = Rot(p, (cos(u_time * i/50.)));\n            // } else \n            // {\n            //     p = Rot(p, (sin(u_time * i/50.)));\n            // }\n\n            p = Rot(p, (sin(u_time * i/50.)));\n            b += cirOutline(vec2(p.x + 0.75, p.y + sin(u_time * i/25. + 5.)), 0.5);\n            b += cirOutline(vec2(p.x - 0.75, p.y + sin(u_time * i/25. + 5.)), 0.5);\n\n           \n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdOne(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        // vUv = vUv * 4. - 2.;\n        float x = random(vUv);\n        float y = sin(vUv.x);\n        vec2 cp = vec2(cos(u_time), sin(u_time  )) * 0.45 + 0.5;\n        y = quadraticBezier(y, cp);\n        // y += mod(vUv.x, 0.5);\n        float line = plot(vec2(vUv.x, vUv.y) , y, 0.01);\n        float line2 = plot(vec2(vUv.x, vUv.y) , y / x, 0.1);\n        float line3 = plot(vec2(vUv.x, vUv.y), y * x, 0.001);\n        color += line + line2 + line3;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // vec3 sdgBox(vec2 p, vec2 b)\n    // {\n    //     vec2 w = abs(p) - b;\n    //     vec2 s = vec2(p.y < 0. ? -1. : 1., p.x < 0. ? -1. : 1.);\n    //     float g = max(w.x, w.y);\n    //     vec2 q = max(w, 0.0);\n    //     float l = length(q);\n    //     vec3 x = vec3((g > 0.0) ? l : g, s * ((g > 0.0) ? q /l : ((w.x > w.y) ? vec2(1., 0.) : vec2(0., 1.))));\n    //     return smoothstep(0.01, 0.02, x);\n    // }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        \n        vUv = Rot(vUv, u_time);\n        vUv = vUv * 6. - 3.;\n        \n        float ra = 0.5;\n        vec3 cir = 1. - sdgCircle(vUv, ra);\n        float d = cir.x;\n        vec2 g = cir.yz;\n        \n        color += (d > 0.) ? vec3(1.) : vec3(0.0);\n        color *= 1.0 + vec3(0.5 * g, 0.0);\n        color *= 1.0 - 0.5 * exp(-16.0 * abs(d));\n        color *= 0.5 + 0.1 * cos(150.0 * d);\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    vec3 sdgBox(vec2 p, vec2 b)\n    {\n        vec2 w = abs(p) - b;\n        vec2 s = vec2(p.y < 0. ? -1. : 1., p.x < 0. ? -1. : 1.);\n        float g = max(w.x, w.y);\n        vec2 q = max(w, 0.0);\n        float l = length(q);\n        vec3 x = vec3((g > 0.0) ? l : g, s * ((g > 0.0) ? q /l : ((w.x > w.y) ? vec2(1., 0.) : vec2(0., 1.))));\n        return x;\n    }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        \n        vUv = Rot(vUv, u_time);\n        vUv = vUv * 6. - 3.;\n        \n        float ra = 0.5;\n        vec3 cir = 1. - sdgCircle(vUv, ra);\n        vec3 box = 1. - sdgBox(vUv, vec2(0.5, 0.5));\n        float d = cir.x;\n        vec2 g = cir.yz;\n\n        d = box.x;\n        g = box.yz;\n        \n        color += (d > 0.) ? vec3(1.) : vec3(0.0);\n        color *= 1.0 + vec3(0.5 * g, 0.0);\n        color *= 1.0 - 0.5 * exp(-16.0 * abs(d));\n        color *= 0.5 + 0.1 * cos(150.0 * d);\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    vec3 sdgBox(vec2 p, vec2 b)\n    {\n        vec2 w = abs(p) - b;\n        vec2 s = vec2(p.y < 0. ? -1. : 1., p.x < 0. ? -1. : 1.);\n        float g = max(w.x, w.y);\n        vec2 q = max(w, 0.0);\n        float l = length(q);\n        vec3 x = vec3((g > 0.0) ? l : g, s * ((g > 0.0) ? q /l : ((w.x > w.y) ? vec2(1., 0.) : vec2(0., 1.))));\n        return x;\n    }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        \n        vUv = Rot(vUv, u_time);\n        vUv = vUv * 4. - 2.;\n        \n        float ra = 0.5;\n        vec3 cir = 1. - sdgCircle(vUv, ra);\n        vec3 box = 1. - sdgBox(vUv, vec2(0.5, 0.5));\n        float d = cir.x;\n        vec2 g = cir.yz;\n\n        d = box.x;\n        g = box.yz;\n        \n        color += (d > 0.) ? vec3(1.) : vec3(0.0);\n        // color *= 1.0 + vec3(0.5 * g, 0.0);\n        color *= 1.0 - 0.5 * exp(-16.0 * abs(d));\n        color *= 0.1 + 0.5 * cos(20.0 * d * (sin(u_time * 0.5) * 2.) + 5. );\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdFive(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n\n        vUv = vUv * 2. - 1.;\n        float k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\n        float spiral = sdSpiral(vUv, 1.0, k);\n        color += 1. - smoothstep(0.01, 0.02, spiral);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdSix(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = Rot(p , u_time);\n        p = p * 2. - 1.;\n        // //p.y -= 1.25;\n        // p.x += 1.;\n        // p.y += 1.;\n        // p*= 0.5;\n        float b;\n        float steps = 15.;\n        \n        for(float i = 1.; i<steps; i++)\n        {\n            // p = Rot(p, u_time * 0.25);\n            // p = p * 2. - 1.;\n            float k = 1. + i * (0.25 - 0.25 * cos(u_time * i * 0.025));\n            b += sdSpiral(p , a  * i, k + i * 0.2);\n        }\n        return b;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n\n        // vUv = vUv * 2. - 1.;\n        float k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\n        float spiral = sdSpiral(vUv, 1.0, k);\n        // color += spiral;\n        float func = newfunc(vUv, 1.0);\n        // color.g += func * 0.25;\n        color.r += func * 0.25 - abs(cos(u_time * 0.5));\n        color.b += func * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _F=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdSeven(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = Rot(p , u_time);\n        p = p * 2. - 1.;\n        // //p.y -= 1.25;\n        // p.x += 1.;\n        // p.y += 1.;\n        // p*= 0.5;\n        float b;\n        float steps = 15.;\n        \n        for(float i = 1.; i<steps; i++)\n        {\n            // p = Rot(p, u_time * 0.25);\n            // p = p * 2. - 1.;\n            p = p * i / (3. + sin(u_time * 0.5));\n            float k = 1. + i * (0.25 - 0.25 * cos(u_time * i * 0.025));\n            b += sdSpiral(p , a  * i, k + i * 0.2);\n        }\n        return b;\n    }\n\n    \n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n\n        // vUv = vUv * 2. - 1.;\n        float k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\n        float spiral = sdSpiral(vUv, 1.0, k);\n        // color += spiral;\n        float func = newfunc(vUv, 1.0);\n        // color.g += func * 0.25;\n        color.r += func * 0.25 - abs(cos(u_time * 0.5));\n        color.b += func * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\n        color += numLabel + numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_F,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\nfloat label(vec2 p)\n{\n    p *= 10.;\n    p.x -= 0.25;\n    float left = sdFour(vec2(p.x + 0.3, p.y));\n    float center = sdFour(vec2(p.x -0.05, p.y));\n    float right = sdEight(vec2(p.x - 0.38, p.y));\n    return left + center + right;\n}\n\nfloat newfunc(vec2 p, float a)\n{\np = Rot(p , u_time);\np = p * 2. - 1.;\n// //p.y -= 1.25;\n// p.x += 1.;\n// p.y += 1.;\n// p*= 0.5;\nfloat b;\nfloat steps = 15.;\n\nfor(float i = 1.; i<steps; i++)\n{\n    // p = Rot(p, u_time * 0.25);\n    // p = p * 2. - 1.;\n    p = p * i / (3.);\n    float k = 1. + i * (0.25 - 0.25 * cos(u_time * i * 0.025));\n    b += sdSpiral(p * i, a  * i, k + i * 0.2);\n    b += sdSegment(p * i , vec2(0.0), vec2(0.25));\n}\nreturn b;\n}\n\nvoid main()\n{\nvec2 vUv = vec2(vUv.x, vUv.y);\nvec3 color = vec3(0.);\nfloat numLabel = label(vUv);\nvec2 newUv = vUv;\n// vUv = vUv * 2. - 1.;\nfloat k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\nfloat spiral = sdSpiral(vUv, 1.0, k);\n// color += spiral;\nvUv = Rot(vUv, u_time);\nnewUv = Rot(newUv, PI * 0.25);\nfloat func = newfunc(vUv, 1.0);\nfloat func2 = newfunc(newUv, 1.0);\n// color.g += func * 0.25;\ncolor.r += func * 0.25 - abs(cos(u_time * 0.5));\ncolor.r += func2 * 0.25 - abs(cos(u_time * 0.5));\ncolor.b += func * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\ncolor.b += func2 * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\ncolor += numLabel + numLabel + numLabel;\ngl_FragColor = vec4(color, 1.);\n}\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdNine(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n\n        float y = (sin(noiseUv.x + u_time) )  / 2. ;\n        float line = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y, 0.01);\n        float line2 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n, 0.01);\n        float line3 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n * n, 0.01);\n        color += line;\n        color += line2;\n        color += line3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = newUv / 1.25 + 0.1;\n        float box = sdRoundedBoxOutline(newUv, vec2(0.5), vec4(\n            0.25 * n + (sin(u_time * (sin(n + u_time/5.))/50.) / 10.) + 0.2, \n            0.25 * n + (sin(u_time * (sin(n + u_time/5.))/50.) / 10.) + 0.2, \n            0.25 * n + (sin(u_time * (cos(n + u_time/5.))/50.) / 10.) + 0.2, \n            0.25 * n + (sin(u_time * (cos(n + u_time/5.))/50.) / 10.) + 0.2), \n            0.025);\n        float y = (sin(noiseUv.x + u_time) )  / 2. ;\n        float line = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y, 0.01);\n        float line2 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n, 0.01);\n        float line3 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n * n, 0.01);\n        // color += line;\n        // color += line2;\n        // color += line3;\n        color += box;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = newUv / 1.25 + 0.1;\n        float box = sdRoundedBox(newUv, vec2(0.5), vec4(\n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2, \n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2, \n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2, \n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2));\n        float y = (sin(noiseUv.x + u_time) )  / 2. ;\n        float line = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y, 0.01);\n        float line2 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n, 0.01);\n        float line3 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n * n, 0.01);\n        // color += line;\n        // color += line2;\n        // color += line3;\n        color += box;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n       \n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        color += spiral;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        newUv = newUv * 2. - 1.;\n        vec2 newUv2 = vUv;\n        newUv2 = Rot(newUv2, u_time * 0.5);\n        newUv2 = newUv2 * 2. - 1.;\n        float tri = sdEqTriangleOutline(newUv, 0.35 + (n * 0.05 * sin(u_time)));\n        float tri2 = sdEqTriangleOutline(newUv2, 0.15 + (n * 0.05 * sin(u_time)));\n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        // color += spiral;\n        color += tri;\n        color += tri2;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        // newUv = newUv * 2. - 1.;\n        vec2 newUv2 = vUv;\n        newUv2 = Rot(newUv2, u_time * 0.5);\n        // newUv2 = newUv2 * 2. - 1.;\n        float c1 = cirOutline(newUv, 0.35 + (n * 0.05 * sin(u_time)));\n        float c2 = cirOutline(newUv2, 0.15 + (n * 0.05 * sin(u_time)));\n        float c3 = cirOutline(newUv, 0.5 + (n * 0.05 * sin(u_time)));\n        float c4 = cirOutline(newUv2, 0.25 + (n * 0.035 * sin(u_time)));\n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        // color += spiral;\n        color += c1;\n        color += c2 + c3 + c4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/25.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = newUv * 4. - 2.;\n        float y = sin(vUv.x + u_time + n);\n        float x = sin(vUv.y + u_time + n);\n        float line = plot(newUv, y, 0.5);\n        float line2 = plot(newUv, x, 0.25);\n        color += line;\n        color += line2;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 220. * 1.2)/10.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n       \n        float shape = rectOutline(vUv, 0.5 + n/5., 0.25);\n        color += shape;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 82. * 1.2)/15.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n       \n        float shape = rectOutline(vUv, 0.5 + n/5. * sin(u_time), 0.5 + n/5. * cos(u_time));\n        color += shape;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 82. * 1.2)/15.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        float shape = rectOutline(newUv, 0.5 + n/5. * sin(u_time), 0.5 + n/5. * cos(u_time));\n        float shape2 = cirOutline(vUv, 0.5 + n/5. * sin(u_time));\n        color += shape;\n        color += shape2;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 1580. * 1.2)/35.);\n        vec2 vUv2, vUv3, vUv4, vUv5;\n        vUv2 = vUv;\n        vUv2 = vUv2 * 2. - 0.5;\n        vUv2.x += 0.56;\n        vUv3 = vUv;\n        vUv3 = vUv3 * 2. - 0.5;\n        vUv3.x += 0.2;\n        vUv4 = vUv;\n        vUv4 = vUv4 * 2. - 0.5;\n        vUv4.x -= 0.05;\n        vUv5 = vUv;\n        vUv5 = vUv5 * 2. - 0.5;\n        vUv5.x -= 0.4;\n\n        float two = sdTwo(vUv2 * abs(sin(n + u_time)+ 25.)/25.);\n        float zero = sdZero(vUv3 * abs(cos(n + u_time) + 25.)/25.);\n        float two1 = sdTwo(vUv4 * abs(sin(n + u_time)+ 25.)/25.);\n        float three = sdThree(vUv5 * abs(cos(n + u_time)+ 25.)/25.);\n        color += two;\n        color += zero;\n        color += two1;\n        color += three;\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 82. * 1.2)/15.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        float shape = rect(newUv, 0.5 + n/5. * sin(u_time), 0.5 + n/5. * cos(u_time));\n        float shape2 = circle(vUv * 2. - 0.5, 0.5 + n/5. * sin(u_time));\n        float shape3 = circle(vUv * 2.5 - 0.75, 0.5 + n/5. * sin(u_time));        color += shape;\n        color += shape2;\n        color -= shape3;\n        float shape4 = rect(newUv, 0.45 + n/5. * sin(u_time), 0.45 + n/5. * cos(u_time));\n        color -= shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * ((u_time) / 5.) + 65.);\n        vec2 newUv = vUv;\n        float y = vUv.x * n;\n\n        float line = plot(vUv, y, 0.01);\n        // newUv = newUv * 2.;\n        float cir = cirOutline(newUv, 0.25); \n        // color += line;\n        color += cir;\n        color += line;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    \n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv + u_time);\n        // vUv.x += u_time;\n        float y = sin(vUv.x * n * u_time);\n\n        float line = plot(vUv, y, 0.5 + n);\n        color += line;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KF(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JF,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $F=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        // newUv = newUv * 2. - 1.;\n        vec2 newUv2 = vUv;\n        newUv2 = Rot(newUv2, u_time * 0.5);\n        // newUv2 = newUv2 * 2. - 1.;\n        float c1 = circle(newUv, 0.35 + (n * 0.07 * sin(u_time)));\n        float c2 = circle(newUv2, 0.15 + (n * 0.05 * cos(u_time)));\n        float c3 = circle(newUv, 0.5 + (n * 0.04 * sin(u_time)));\n        float c4 = circle(newUv2, 0.25 + (n * 0.035 * cos(u_time)));\n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        // color += spiral;\n        \n        color += c2;\n        color -= c1;\n        color += c3;\n        // color -= c3;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$F,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ej=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        // float shape1 = sdPolygonOutline(vUv, 7.0 + sin(u_time), 0.1);\n        // float shape2 = sdPolygonOutline(vUv, 6.0 + sin(u_time), 0.2);\n        // float shape3 = sdPolygonOutline(vUv, 5.0 + sin(u_time), 0.3);\n        // float shape4 = sdPolygonOutline(vUv, 4.0 + sin(u_time), 0.4);\n        //float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        //color += shape1 + shape2 + shape3 + shape4;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ej,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        for (int i=4; i<=15; i++)\n        {\n            shape1 += sdPolygonOutline(vUv, i, float(i) * 0.1 + (sin(u_time)/2.) - 0.95);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 0.5;\n        newvUv = Rot(newvUv, u_time * 0.25);\n        for (int i=4; i<=15; i++)\n        {\n            shape1 += sdPolygonOutline(vec2(newvUv.x, newvUv.y + sin(float(i)/2.)), i, float(i) * 0.1 + (sin(u_time)/4.) - 0.95);\n            shape2 += sdPolygonOutline(vec2(newvUv.x + cos(float(i)/2.), newvUv.y ), i, float(i) * 0.1 + (cos(u_time)/4.) - 0.95);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color += shape2;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ij(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 0.5;\n        newvUv = Rot(newvUv, u_time * 0.25);\n        for (int i=3; i<=7; i++)\n        {\n            shape1 += sdPolygonOutline(vec2(newvUv.x, newvUv.y + sin(float(i)/1.)), i, float(i) * 0.1 + (sin(u_time * float(i) * 0.5)/1.) - 0.95);\n            shape2 += sdPolygonOutline(vec2(newvUv.x + cos(float(i)/1.), newvUv.y ), i, float(i) * 0.1 + (cos(u_time * float(i) * 0.5)/1.) - 0.95);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color += shape2;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 1.;\n        // newvUv = Rot(newvUv, u_time * 0.25);\n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=3; i<=7; i++)\n        {\n            shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            shape2 += sdSpiral(newvUv, 0.5* float(i), 5./k );\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color *= shape2;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 4. - 1.5;\n        // newvUv = Rot(newvUv, u_time * 0.25);\n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=3; i<=7; i++)\n        {\n            // shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            // shape2 += sdSpiral(newvUv, 0.5* float(i), 20./k );\n            // shape3 += sdSpiral(newvUv, 0.5* float(i), 100./k );\n            shape1 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.75), 0.5* float(i)), vec4(float(i)), 0.1);\n            shape2 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.25), 0.5* float(i)), vec4(float(i)), 0.1);\n            shape3 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.5), 0.5* float(i)), vec4(float(i)), 0.2);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color *= shape2;\n        color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 4. - 1.5;\n        newvUv = Rot(newvUv, u_time * 0.5);\n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=0; i<=10; i++)\n        {\n            // shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            // shape2 += sdSpiral(newvUv, 0.5* float(i), 20./k );\n            // shape3 += sdSpiral(newvUv, 0.5* float(i), 100./k );\n            shape1 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.35), 0.25* float(i)), vec4(float(i)), 0.1);\n            shape2 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.25), 0.5* float(i)), vec4(float(i)), 0.1);\n            shape3 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.35), 0.5* float(i)), vec4(float(i)), 0.1);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color *= shape2;\n        color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * 0.5);\n        newvUv = newvUv * 4. - 2.;\n        \n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=0; i<=10; i++)\n        {\n            // shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            // shape2 += sdSpiral(newvUv, 0.5* float(i), 20./k );\n            // shape3 += sdSpiral(newvUv, 0.5* float(i), 100./k );\n            shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            // shape2 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.25), 0.5* float(i)), vec4(float(i)), 0.1);\n            // shape3 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.35), 0.5* float(i)), vec4(float(i)), 0.1);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        // color *= shape2;\n        // color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 3. - 1.;\n        newvUv = Rot(newvUv, u_time * 0.25);\n        \n        for (int i=4; i<=10; i++)\n        {\n            // shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            shape2 += sdPolygonOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.0725), newvUv.y + sin(float(i) * u_time * 0.0725)), 4, 0.1 * (float(i) - 0.125));\n            shape3 += sdPolygonOutline(vec2(newvUv.x - sin(float(i) * u_time * 0.0725), newvUv.y - sin(float(i) * u_time * 0.0725)), 4, 0.1 * (float(i) - 0.125));\n            \n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        // color += shape1;\n        color += shape2;\n        color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 3. - 1.;\n        // newvUv = Rot(newvUv, u_time * 0.25);\n        \n        for (int i=4; i<=8; i++)\n        {\n            // shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            shape2 += sdPolygonOutline(vec2(newvUv.x - sin(float(i) * u_time * 0.25), newvUv.y + sin(float(i) * u_time * 0.125)), 4, 0.05 * (float(i) - 0.125));\n            shape3 += sdPolygonOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + sin(float(i) * u_time * 0.125)), 4, 0.05 * (float(i) - 0.125));\n            \n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        // color += shape1;\n        color += shape2;\n        color += shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _j=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 0.5;\n        \n        \n        for (int i=4; i<=15; i++)\n        {\n            newvUv = Rot(newvUv, u_time * 0.125);\n            // shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            shape2 += sdPolygonOutline(vec2(newvUv), 3, 0.0525 * (float(i) - 0.125));\n            shape3 += sdPolygonOutline(vec2(newvUv.x + cos(float(i) * u_time * 0.125), newvUv.y + sin(float(i) * u_time * 0.125)), 3, 0.025 * (float(i) - 0.125));\n            \n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        // color += shape1;\n        color += shape2;\n        // color += shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_j,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * 4.);\n        newvUv = newvUv / 2. - 0.25;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=4; i<=15; i++)\n        {\n            shape1 += sdSpiral(vec2(newvUv), 0.45, k);\n        }\n        \n        color += shape1;\n        shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2;\n        color += shape3;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Sj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Mj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * .25);\n        // newvUv = newvUv / 2. - 0.25;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=0; i<=10; i++)\n        {\n            shape1 += rectOutline(vec2(newvUv.x + (float(i) * (sin(u_time) / 2.)/ 20.), newvUv.y), 0.25, 0.25);\n            shape2 += rectOutline(vec2(newvUv.x , newvUv.y + (float(i) * (sin(u_time) / 2.)/ 20.)), 0.25, 0.25);\n            // shape3 += rectOutline(vec2(newvUv.x + (float(i) * (cos(u_time) / 2.)/ 20.), newvUv.y), 0.25, 0.25);\n            // shape4 += rectOutline(vec2(newvUv.x , newvUv.y + (float(i) * (cos(u_time) / 2.)/ 20.)), 0.25, 0.25);\n        }\n        \n        color += shape1;\n        // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2;\n        // color += shape3;\n        // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Mj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * .25);\n        // newvUv = newvUv / 2. +0.125;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=5; i<=15; i++)\n        {\n            shape1 += rectOutline(vec2(newvUv) , 0.0725 * float(i) * cos(u_time * float(i) * 0.01), 0.0725 * float(i) * sin(u_time * float(i) * 0.05));\n        //     shape2 += rectOutline(vec2(newvUv.x , newvUv.y), 0.025 * float(i), 0.25);\n        //     shape3 += rectOutline(vec2(newvUv.x , newvUv.y), 0.025 * float(i), 0.25);\n        //     shape4 += rectOutline(vec2(newvUv.x , newvUv.y), 0.025 * float(i), 0.25);\n        }\n        \n        color += shape1;\n        // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2;\n        color += shape3;\n        color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Cj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        // newvUv = Rot(newvUv, u_time * .25);\n        newvUv = newvUv * 4. - 1.5;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=0; i<=13; i++)\n        {\n            shape1 += circle(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5), newvUv.y +  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n            shape2 += circle(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5) , newvUv.y -  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n            shape3 += cirOutline(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5), newvUv.y +  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n            shape4 += cirOutline(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5) , newvUv.y -  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n        }\n        \n        color += shape1 * shape3;\n        // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2 * shape4;\n        // color *= shape3;\n        // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Rj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Tj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        // newvUv = Rot(newvUv, u_time * .25);\n        newvUv = newvUv * 3. - 1.5;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=1; i<=15; i++)\n        {\n            shape1 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.5 * (sin(u_time * float(i) * 0.1)), 0.75 * (cos(u_time * float(i) * 0.21))));\n            shape2 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.5 * (sin(u_time * float(i) * 0.1)), 0.75 * (cos(u_time * float(i) * 0.21))));\n            shape3 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.75 * (cos(u_time * float(i) * 0.21)), 0.75 * (sin(u_time * float(i) * 0.21))));\n            shape4 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.75 * (cos(u_time * float(i) * 0.21)), 0.75 * (sin(u_time * float(i) * 0.21))));\n        }\n        \n        // color += shape1;\n        color += shape1 * shape3;\n        color += shape2 * shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Pj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Dj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Fj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        // newvUv = Rot(newvUv, u_time * .25);\n        newvUv = newvUv * 3. - 1.5;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=1; i<=15; i++)\n        {\n            shape1 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.25 * (sin(u_time * float(i) * 0.1)), 0.25 * (cos(u_time * float(i) * 0.1))));\n            shape2 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.15 + (sin(u_time * float(i) * 0.1)), 0.15 + (cos(u_time * float(i) * 0.1))));\n            shape3 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.15 + (sin(u_time * float(i) * 0.1)), -0.15 + (cos(u_time * float(i) * 0.1))));\n            shape4 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(-0.15 + (sin(u_time * float(i) * 0.1)), 0.15 + (cos(u_time * float(i) * 0.1))));\n        }\n        \n        // color += shape1;\n        color += shape1; \n        color += shape3;\n        color += shape2;\n        color += shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Fj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ij=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        \n        newvUv = newvUv * 2. - 0.5;\n        newvUv.y -= 0.7;\n        newvUv = Rot(newvUv, PI * 0.25);\n        float k = 1. + 20. * (0.25 - 0.125);\n        vec2 uv2 = newvUv;\n        \n        uv2.x += 1.;\n        uv2.y -0.2;\n        uv2 = Rot(uv2, PI * 0.5);\n        \n        for (int i=1; i<=15; i++)\n        {\n            shape1 += sdSegment(vec2(newvUv.x + sin(float(i) * u_time * 0.1), newvUv.y + cos(float(i) * u_time * 0.1)), vec2(0. + sin(u_time * float(i) * (0.1))), vec2(0.0 + cos(u_time * float(i) * 0.1)));\n            \n        }\n        \n        // color += shape1;\n        color += shape1; \n        color += shape3;\n        color += shape2;\n        color += shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ej(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Ij,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Oj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        vec2 uv2 = newvUv;\n        newvUv = Rot(newvUv, PI * 0.5);\n        uv2 = Rot(uv2, PI *0.5);\n        newvUv = newvUv * 2. - 0.5;\n        newvUv.y -= 0.7;\n        newvUv = Rot(newvUv, PI * 0.25);\n        uv2 = uv2 * 2. - 0.5;\n        uv2.y -= 0.7;\n        \n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        \n        for (int i=1; i<=15; i++)\n        {\n            uv2 = Rot(uv2, PI * 0.25 + u_time * 0.1);\n            shape1 += sdSegment(vec2(newvUv.x + cos(float(i) * u_time * 0.01), newvUv.y + sin(float(i) * u_time * 0.1)), vec2(0. + cos(u_time * float(i) * (0.1))), vec2(0.0 + sin(u_time * float(i) * 0.1)));\n            shape2 += sdSegment(vec2(uv2.x + cos(float(i) * u_time * 0.01), uv2.y + sin(float(i) * u_time * 0.1)), vec2(0. + cos(u_time * float(i) * (0.1))), vec2(0.0 + sin(u_time * float(i) * 0.0)));\n            \n        }\n        \n        // color += shape1;\n        color += shape1; \n        color += shape3;\n        color += shape2;\n        color += shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Oj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Aj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=15; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += sdSegment(vec2(uv2.x + float(i) /10. - 0.25, uv2.y + float(i) /10. - 0.25), vec2(0.0), vec2(0.25));\n            \n        }\n        \n        color += shape1; \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Gj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Aj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Nj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.25;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=15; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += sdSegment(vec2(uv2.x + (float(i) * sin(u_time) /10. ) , uv2.y + (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            shape2 += sdSegment(vec2(uv2.x - (float(i) * sin(u_time) /10. ) , uv2.y - (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            shape3 += sdSegment(vec2(uv2.x + (float(i) * sin(u_time) /10. ) , uv2.y - (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            shape4 += sdSegment(vec2(uv2.x - (float(i) * sin(u_time) /10. ) , uv2.y + (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Bj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Nj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=0; i<=20; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += circle(vec2(uv2.x + float(i) / 10. + sin(u_time*(float(i)/15.)), uv2.y - float(i) / 150. + cos(u_time*(float(i)/10.))), 0.25);\n            shape2 += cirOutline(vec2(uv2.x + float(i) / 10. + sin(u_time*(float(i)/15.)), uv2.y - float(i) / 150. + cos(u_time*(float(i)/10.))), 0.25);\n            \n        }\n        \n        color += shape1; \n        color *= shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Vj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += circle(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * cos(u_time)), 0.005);\n            shape2 += circle(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * sin(u_time)), 0.005);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Hj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Wj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, u_time * 0.0000005 * float(i));\n            shape1 += circle(vec2(uv2.x + sin(u_time*(float(i)/25.)) - sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) + cos(u_time)), 0.005);\n            shape2 += circle(vec2(uv2.x + cos(u_time*(float(i)/25.)) - cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) + sin(u_time)), 0.005);\n            shape3 += circle(vec2(uv2.x + sin(u_time*(float(i)/12.5)) + sin(u_time), uv2.y - cos(u_time*(float(i)/12.5)) - cos(u_time)), 0.005);\n            shape4 += circle(vec2(uv2.x - cos(u_time*(float(i)/12.5)) + cos(u_time), uv2.y + sin(u_time*(float(i)/12.5)) - sin(u_time)), 0.005);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Yj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Xj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Zj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=45; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.0000005 * float(i));\n            shape1 += circle(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) + sin(u_time)), 0.005);\n            shape2 += circle(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) + sin(u_time)), 0.005);\n            shape3 += circle(vec2(uv2.x + sin(u_time*(float(i)/12.5)) * cos(u_time), uv2.y - cos(u_time*(float(i)/12.5)) - cos(u_time)), 0.005);\n            shape4 += circle(vec2(uv2.x + cos(u_time*(float(i)/12.5)) * sin(u_time), uv2.y + sin(u_time*(float(i)/12.5)) - sin(u_time)), 0.005);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Qj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Zj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Jj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=50; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.0000005 * float(i));\n            shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape2 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape3 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * cos(u_time)), 0.25, 0.25);\n            shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * sin(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Kj(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:Jj,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $j=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=40; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, ((u_time * 0.5) * float(i/25))/200825.);\n            // shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape2 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5)), uv2.y + sin(u_time*(float(i)/5.)) * abs(sin(u_time * 0.5))), 0.0525, 0.0525);\n            shape3 += rectOutline(vec2(uv2.x + (sin(u_time*(float(i)/5.))) * (sin(u_time * 0.5)), uv2.y + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5))), 0.0525, 0.0525);\n            // shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * cos(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$j,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=40; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, ((u_time * 0.5) * float(i/25))/200825.);\n            // shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape2 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/5.)) + abs(cos(u_time * 0.5)), uv2.y + sin(u_time*(float(i)/5.)) * abs(sin(u_time * 0.5))), 0.0525, 0.0525);\n            shape3 += rectOutline(vec2(uv2.x + (sin(u_time*(float(i)/5.))) - (sin(u_time * 0.5)), uv2.y + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5))), 0.0525, 0.0525);\n            // shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * cos(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=40; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, ((u_time * 0.5) * float(i/25))/200825.);\n            shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) + sin(u_time), uv2.y + cos(u_time*(float(i)/15.)) - cos(u_time * float(i/10))), 0.25, 0.25);\n            // shape2 += rectOutline(vec2(uv2.x / cos(u_time*(float(i)/5.)) + abs(cos(u_time * 0.5)), uv2.y + sin(u_time*(float(i)/5.)) * abs(sin(u_time * 0.5))), 0.0525, 0.0525);\n            // shape3 += rectOutline(vec2(uv2.x * (sin(u_time*(float(i)/5.))) - (sin(u_time * 0.5)), uv2.y + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5))), 0.0525, 0.0525);\n            // shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * cos(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=0; i<=10; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            \n            shape1 += circle(vec2(uv2.x + sin(float(i) + u_time) * 2. , uv2.y), 0.0525);\n            shape2 += circle(vec2(uv2.x  , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=5; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.15));\n            shape1 += circle(vec2(uv2.x + cos(float(i) + u_time) * 2. , uv2.y), 0.0525);\n            shape2 += circle(vec2(uv2.x  , uv2.y - sin(float(i) + u_time) * 2.), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=5; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, sin(u_time * 0.15 * (float(i))));\n            shape1 += circle(vec2(uv2.x + cos(float(i) + u_time) - float(i)/10. , uv2.y + sin(float(i) + u_time) + float(i)/10.), 0.0525);\n            shape2 += circle(vec2(uv2.x + cos(float(i) + u_time) + float(i)/10.  , uv2.y - sin(float(i) + u_time) - float(i)/10.), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) + u_time) + float(i)/10. , uv2.y + cos(float(i) + u_time) - float(i)/10.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) + u_time) + float(i)/10. , uv2.y + cos(float(i) + u_time) - float(i)/10.), 0.0525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=5; i<=150; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.0125 * (float(i))));\n            shape1 += circle(vec2(uv2.x + cos(float(i) + u_time) - float(i)/50. , uv2.y ), 0.0525);\n            shape2 += circle(vec2(uv2.x + cos(float(i) + u_time) + float(i)/50. , uv2.y ), 0.0525);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=0; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, sin(u_time * 0.0125));\n            shape1 += cirOutline(vec2(uv2.x + sin(float(i) * u_time/12.) - float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10.), 0.0525);\n            shape2 += cirOutline(vec2(uv2.x - sin(float(i) * u_time/12.) + float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10. ), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) * u_time/12.) - float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) * u_time/12.) + float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10. ), 0.0525);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color -= shape3; \n        color -= shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=0; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.25));\n            shape1 += cirOutline(vec2(uv2.x + (float(i)/4.) + cos(u_time * 0.5 + (float(i))), uv2.y+ sin(float(i)/4.) + sin(u_time * 0.5 + (float(i)))), 0.0525);\n            shape2 += cirOutline(vec2(uv2.x + (float(i)/4.) + cos(u_time + (float(i)) ), uv2.y+ sin(float(i)/4.) + sin(u_time * 0.5 + (float(i)))), 0.0525);\n            shape3 += cirOutline(vec2(uv2.x + (float(i)/4.) + sin(u_time * 0.5 + (float(i))), uv2.y+ sin(float(i)/4.) + cos(u_time)), 0.0525);\n            shape4 += cirOutline(vec2(uv2.x + (float(i)/4.) + sin(u_time + (float(i))), uv2.y+ sin(float(i)/4.) + cos(u_time)), 0.0525);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=0; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.25));\n            float y = sin(u_time + uv2.x + (float(i) * sin(u_time + 25.) * 0.1));\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)), uv2.y), y, 0.05 );\n        }\n        \n        color += shape1; \n        color += shape2;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=0; i<=20; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.125) + 2.5);\n            float y = abs(sin(u_time + uv2.x + (float(i) * cos(u_time + 025.) * 0.00161)) + 1.5);\n            float x = abs(cos(u_time + uv2.x + (float(i) * sin(u_time + 025.) * 0.00161)) + 1.5);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)), uv2.y), x / y, 0.0375 );\n        }\n        \n        color += shape1; \n        color += shape2;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _I=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=0; i<=20; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.125) + 2.5);\n            float y = abs(sin(u_time + uv2.x + (float(i) * cos(u_time + 025.) * 0.00161)) + .05);\n            float x = abs(cos(u_time + uv2.x + (float(i) * sin(u_time + 025.) * 0.00161)) + .05);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i) * u_time), uv2.y), x, 0.04575 );\n        }\n        \n        color += shape1; \n        color += shape2;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_I,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=8; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.25) + 10.5);\n            float y = (sin(u_time + uv2.x + (float(i) * cos(u_time * 25.) * 0.00161)) + .05);\n            float x = (cos(u_time + uv2.x + (float(i) * sin(u_time * 25.) * 0.00161)) + .05);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), x, 0.04575 );\n        }\n\n        float z = circle(uv2, 10.5);\n        \n        color += shape1; \n        color += shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=8; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, cos(u_time * 0.025) + 10.5 / 1.);\n            float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05);\n            float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), x * y, 0.04575 );\n        }\n\n        float z = circle(uv2, 10.5);\n        \n        color += shape1; \n        color += shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=5; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, cos(u_time * 0.025) + 10.5 / 1.);\n            float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            float z = (cos(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            float a = (cos(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), y * x, 0.075 );\n            shape2 += plot(vec2(uv2.x + cos(u_time + float(i)/100. * u_time), uv2.y), z * a, 0.075 );\n        }\n\n        float z = circle(uv2, 10.5);\n        \n        color += shape1; \n        color *= shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *15. - 15.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=10; i++)\n        {\n            for(int j=1; j<=10; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), sin(u_time + 0.075 * float(j + i))*4.);\n                float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(1.));\n                \n                shape1 += line;\n            }\n            // uv2 = uv2 * 1.1 - 0.1;\n            \n            // float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // float z = (cos(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float a = (cos(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), y * x, 0.075 );\n            // shape2 += plot(vec2(uv2.x + cos(u_time + float(i)/100. * u_time), uv2.y), z * a, 0.075 );\n        }\n\n        float z = circle(uv3, 0.75);\n        \n        color += shape1; \n        // color *= shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *25. - 25.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=20; i++)\n        {\n            for(int j=1; j<=20; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), sin(u_time + 0.075 * float(j * i)/4.)*4.);\n                float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                \n                shape1 += line;\n            }\n            // uv2 = uv2 * 1.1 - 0.1;\n            \n            // float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // float z = (cos(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float a = (cos(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), y * x, 0.075 );\n            // shape2 += plot(vec2(uv2.x + cos(u_time + float(i)/100. * u_time), uv2.y), z * a, 0.075 );\n        }\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color *= shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *25. - 24.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=15; i++)\n        {\n            for(int j=1; j<=15; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), cos(u_time + 0.08 * float(j * i)/5.) + 0.53*1.9);\n                float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                float r = rect(vec2(newUv), 0.45, 3.);\n                shape1 += r;\n            }\n        }\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color *= shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var II=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *15. - 15.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=15; i++)\n        {\n            for(int j=1; j<=15; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), cos(u_time + 0.08 * float(j * i)/5.) + 0.53*1.9);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                shape1 += c;\n            }\n        }\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color *= shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:II,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - 0.5;\n        // uv2.x -= 1.;\n        vec2 uv3 = uv2;\n        uv2 = Rot(uv2, u_time * 0.75);\n        uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<=5; i++)\n        {\n            for(int j=1; j<=15; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 0.085, newUv.y + float(i) * .085), (u_time + 0.08 * float(j * i)/5.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                shape1 += rectOutline(vec2(newUv), 0.5, 0.5);\n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *1.5 - 0.5;\n        uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<=13; i++)\n        {\n            for(int j=1; j<=10; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<=5; i++)\n        {\n            for(int j=1; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, (u_time * float(i * j) * 0.025)/11. + 100.);\n                shape1 += circle(vec2(uv2.x + sin(float(i) + u_time)  , uv2.y), 0.00525);\n                shape2 += circle(vec2(uv2.x  , uv2.y + sin(float(i) + u_time)), 0.00525);\n                shape3 += circle(vec2(uv2.x + sin(float(i) + u_time), uv2.y + sin(float(i) + u_time)), 0.00525);\n                shape4 += circle(vec2(uv2.x - sin(float(i) + u_time), uv2.y + sin(float(i) + u_time)), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<7; i++)\n        {\n            for(int j=1; j<=7; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, sin(u_time * 0.000115));\n                shape1 += circle(vec2(uv2.x + sin(float(i * j) + (u_time * 0.5))  , uv2.y), 0.00525);\n                shape2 += circle(vec2(uv2.x  , uv2.y + cos(float(i - j) + (u_time * 0.5))), 0.00525);\n                shape3 += circle(vec2(uv2.x + sin(float(j -i  ) + (u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n                shape4 += circle(vec2(uv2.x - sin(float(j * i) +(u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<15; i++)\n        {\n            for(int j=1; j<=10; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, sin(u_time * 0.00115 * float(i)));\n                shape1 += circle(vec2(uv2.x + sin(float(i - j)/30. + (u_time * 0.25)) * 2. , uv2.y), 0.00525);\n                shape2 += circle(vec2(uv2.x  , uv2.y + cos(float(i - j) + (u_time * 0.5))), 0.00525);\n                shape3 += circle(vec2(uv2.x + sin(float(j -i  ) + (u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n                shape4 += circle(vec2(uv2.x - sin(float(j * i) +(u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<15; i++)\n        {\n            for(int j=1; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, (sin(u_time * 0.0525)));\n                // shape1 += circle(vec2(uv2.x + sin(float(i * j)/30. + (u_time * 0.25)) * 1. , uv2.y), 0.00525);\n                shape1 += sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.) * sin(float(i + j)));\n                // shape2 += circle(vec2(uv2.x  , uv2.y + cos(float(i - j) + (u_time * 0.5))), 0.00525);\n                // shape3 += circle(vec2(uv2.x + sin(float(j ) + (u_time * 0.5)), uv2.y + cos(float(j) + (u_time * 0.5))), 0.00525);\n                // shape4 += circle(vec2(uv2.x - sin(float(j) +(u_time * 0.5)), uv2.y + cos(float(j ) + (u_time * 0.5))), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<15; i++)\n        {\n            for(int j=1; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, ((u_time * 0.01525) + 10.));\n                uv2 = noise(uv2) * 0.08 + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y ), vec2(0.0), vec2(2.));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - .5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=2; i<5; i++)\n        {\n            for(int j=2; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, (sin(u_time * 1.525)/5. - 10.2));\n                // uv2 = (noise(uv2) * 0.15) + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0 + noise(uv2) * (cos(u_time)/1. + 2.) * 0.2, 0.0 + noise(uv2) * (sin(u_time)/1. + 2.)), vec2(0.0 + noise(uv2) * (cos(u_time)/1. + 2.), 0.0 + noise(uv2) * (sin(u_time)/1. + 2.)));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        // float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KI(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JI,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $I=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - .5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<14; i++)\n        {\n            for(int j=1; j<=4; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, (sin(u_time * .175)/4. + 11.0));\n                uv2 = (noise(uv2) * 0.15) + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.01 * float(i + j), 0.01 * float(i +j)));\n                shape2 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.015 * float(j + i), 0.015 * float(j + i)));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        // float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$I,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - .5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<5; i++)\n        {\n            for(int j=1; j<=4; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, (sin(u_time * .175)/6. + 11.0));\n                uv2 = (noise(uv2) * 0.15) + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.05 * float(i) + cos(u_time), 0.05 / float(i) + cos(u_time)));\n                shape2 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.05 * float(i) + sin(u_time), 0.05 / float(i) + sin(u_time)));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 2.);\n        \n        color += shape1; \n        color += shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float semi (vec2 p, float n)\n    {\n        float c = circle(vec2(p), n);\n        float c2 = circle(vec2(p), n + n * 0.05);\n        float r = rect(vec2(p.x, p.y- n * 0.45), n - n * 0.1, n + n * 0.5);\n        float r2= rect(vec2(p.x, p.y -0.2), n, n * 0.3);\n        float shape = r * c * 2.;\n        float shape2 = r2 * c2* 2.;\n        return shape;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        uv2 = uv2 *2. - .5;\n\n        for(int i = 1; i < 20; i++)\n        {\n            uv2 = Rot(uv2, ((u_time * .175)/1. + 1.0));\n            vec2 newUv = uv2;\n            shape1 += semi(newUv, float(i)/10. + 0.5);\n            shape2 -= semi(newUv, float(i)/10. + 0.45);\n        }\n        \n        \n        color += shape1; \n        color += shape2;\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float semi (vec2 p, float n)\n    {\n        float c = circle(vec2(p), n);\n        float c2 = circle(vec2(p), n + n * 0.05);\n        float r = rect(vec2(p.x, p.y- n * 0.45), n - n * 0.1, n + n * 0.5);\n        float r2= rect(vec2(p.x, p.y -0.2), n, n * 0.3);\n        float shape = r * c * 2.;\n        float shape2 = r2 * c2* 2.;\n        return shape;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        uv2 = uv2 *2. - .5;\n\n        for(int i = 0; i < 20; i++)\n        {\n            uv2 = Rot(uv2, ((u_time * .275)));\n            vec2 newUv = uv2;\n            float n = noise(newUv) + u_time;\n            \n            shape1 += semi(newUv, float(i)/5. + 0.5);\n            shape2 -= semi(newUv, float(i)/5. + 0.45);\n            shape3 += semi(newUv, float(i)/10. + 0.52);\n            shape4 -= semi(newUv, float(i)/10. + 0.45);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color *= shape3 * 1.5; \n        color += shape4;\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float semi (vec2 p, float n)\n    {\n        float c = circle(vec2(p), n);\n        float c2 = circle(vec2(p), n + n * 0.05);\n        float r = rect(vec2(p.x, p.y- n * 0.45), n - n * 0.1, n + n * 0.5);\n        float r2= rect(vec2(p.x, p.y -0.2), n, n * 0.3);\n        float shape = r * c * 2.;\n        float shape2 = r2 * c2* 2.;\n        return shape;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        uv2 = uv2 *3. - 1.;\n\n        for(int i = 1; i < 80; i++)\n        {\n            uv2 = Rot(uv2, ((u_time * .275 )));\n            // uv2 *= 2. - 1.;\n            vec2 newUv = uv2;\n            // float n = noise(newUv) * u_time;\n            // newUv += n * 0.0005;\n            shape1 += semi(newUv, float(i)/5. + 0.5);\n            shape2 -= semi(newUv, float(i)/5. + 0.45);\n            shape3 += semi(newUv, float(i)/10. + 0.52);\n            shape4 -= semi(newUv, float(i)/10. + 0.45);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color *= shape3 * 2.5; \n        color += shape4;\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 4.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 1.;\n        float seg;\n        float shape;\n\n        for(int y = -2; y <=2; y++){\n            for(int x = -2; x <=2; x++){\n                vec2 n = vec2(float(x), float(y));\n                vec2 p = random2(iUv + n);\n                p = 0.5 + 0.5 * sin(u_time + TWO_PI * p);\n                vec2 dif = n + p - fUv;\n                float dist = length(dif);\n                m_dist = min(m_dist, dist);\n                shape = min(m_dist, dist);\n                // m_dist = smoothstep(0.05, 0.051, m_dist);\n                \n                // seg = sdSegment(fUv, dif, dif * dis);\n            }\n        }\n        color += seg;\n        color += shape;\n        // color += smoothstep(0.9, 0.11, shape);\n        // color += 1. - m_dist;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n    \n        vec2 mg,mr;\n        float md=1.;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.75)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=0.5;\n        for(int i=-5;i<=5;i++){\n            for(int j=-5;j<=5;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.75)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.001){\n                    md=min(md,dot(.25*(mr+r),normalize(r-mr)));\n                    \n                }\n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 5.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float seg;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        float dd = length(s.yz);\n\n        color+=mix(vec3(1.), color, smoothstep(0.002, 0.05, dd * s.x));\n        // color += 1. - smoothstep(0.01, 0.012, s.x);\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n    \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 10.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float seg;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        float dd = length(s.yz) + 0.;\n\n        color+=mix(vec3(1.), color, smoothstep(0.09, 0.061, dd * s.x));\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float seg;\n        vec2 uv2 = vUv;\n\n        uv2 *= 5.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/4., uv2.y  + cos(u_time)/4.));\n        float dd = length(s.yz) + 0.;\n        seg = sdSegment(fUv, vec2(s2.yz), vec2(s.yz));\n        color+=mix(vec3(1.), color, smoothstep(0.01, 0.021, s.x));\n        color+= mix(vec3(1.), color,smoothstep(0.01, 0.021, s2.x));\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n        // color += seg;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float seg;\n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.1);\n        uv2 *= 10.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        float dd = length(s.yz) + 0.;\n        seg = sdSegment(fUv, vec2(s2.yz), vec2(s.yz));\n        color.r+= 1. - smoothstep(0.01 * 2., 0.021 * 2., s.x);\n        color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 4., s2.x);\n        color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 4., s3.x);\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n        // color += seg;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float seg;\n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.1);\n        uv2 *= 5.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        float dd = length(s.yz) + 0.;\n        seg = sdSegment(fUv, vec2(s2.yz), vec2(s.yz));\n        color.r+= 1. - smoothstep(0.01 * 2., 0.021 * 2.,  dd);\n        color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 4., dd);\n        color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 4., s3.x / dd);\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n        // color += seg;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _E=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 4.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 1.;\n        float seg;\n        float shape;\n\n        for(int y = -2; y <=2; y++){\n            for(int x = -2; x <=2; x++){\n                vec2 n = vec2(float(x), float(y));\n                vec2 p = random2(iUv + n);\n                p = 0.25 + 0.25 * sin(u_time + TWO_PI * p );\n                vec2 dif = n + p - fUv;\n                float dist = length(dif);\n                m_dist = min(m_dist, dist);\n                shape = min(m_dist, dist);\n                // m_dist = smoothstep(0.05, 0.051, m_dist);\n                \n                seg = sdSegment(p, vec2(m_dist /dist), vec2(m_dist));\n                color += seg;\n            }\n        }\n        \n        // color += shape;\n        // color += smoothstep(0.9, 0.11, shape);\n        // color += 1. - m_dist;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_E,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        m *= S(1.0, .5, length(a -b));\n        return m;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n        \n        // float d = DistLine(uv2, vec2(0.), vec2(1.));\n        float m = 0.;\n        \n        uv2 *= 8.;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+p[i].x * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        vec3 col = vec3(m);\n        // col.rg = gv;\n\n        // color.rg = col.rg;\n\n        // color += m;\n        // if(gv.x > .48 || gv.y > .48) col = vec3(1., 0, 0);\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ME=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        return m;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.1);\n        uv2 -= 0.5;\n        \n        // float d = DistLine(uv2, vec2(0.), vec2(1.));\n        float m = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(20., .1, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            m += Layer(uv2 * size + i * 20.) * fade;\n        }\n        \n\n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = m * base;\n        col += uv2.y * base * 0.2;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ME,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float GetDist(vec3 p)\n    {\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p.y;\n\n        float d = min(sphereDist, planeDist);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(u_time), cos(u_time)) * 2.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 1, 0);//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p.y;\n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, .5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(-3, .75, 6), vec3(.5));\n        float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, 1, 6), 0.2);\n\n        // float d = min(sphereDist, planeDist);\n        float d = min(cd, planeDist);\n        d = min(d, td);\n        d = min(d, bd);\n        d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(u_time), cos(u_time)) * 2.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(sin(u_time), 3, -2.-cos(u_time));//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p.y;\n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0, 2.75, 6.+ sin(u_time) * 2.), vec3(.5));\n        float bd2 = sdBox(p - vec3(0, 2.75+ cos(u_time * 2.) * 2., 6.), vec3(.5));\n        float bd3 = sdBox(p - vec3(0. + cos(u_time * 2.) * 2., 0.75, 6.), vec3(.5));\n        float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, 1, 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd, d);\n        d = min(bd3, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 5, -2.-cos(u_time));//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 2.75, 6.+ sin(u_time) * 2.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(0, 2.75+ cos(u_time * 2.) * 2., 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3(0. + cos(u_time * 2.) * 2., 0.75, 6.), vec3(.5));\n        float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, 1, 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd, d);\n        d = min(bd3, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5, -6.);//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 2.75 + sin(u_time), 6.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(-2. + sin(u_time), 2.75, 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3(2. + sin(u_time), 2.75, 6.), vec3(.5));\n        float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(cyld, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5., -6.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 4.75 - sin(u_time), 6.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(-2. + sin(u_time), 2.75, 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3(2. - sin(u_time), 2.75, 6.), vec3(.5));\n        float bd4 = sdBox(p2 - vec3(0. , 1.75 + sin(u_time), 6.), vec3(.5));\n        float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(bd4, d);\n        // d = min(cyld, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5., -6.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 4.75 - sin(u_time), 6.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float shape;\n        for(int i =0; i<= 5; i++)\n        {\n            // shape = sdBox(p2 - vec3(0., 0.+ (float(i)), 5.), vec3(.5));\n            // float d = min(shape, planeDist);\n            float d = min(sdBox(p2 - vec3(0. , 0. + 2., 6.), vec3(.5)), planeDist);\n            // d = min(bd, d);\n            d = min(bd2, d);\n            d = min(bd3, d);\n            d = min(bd4, d);\n        // d = min(cyld, d);\n        // d = min(d, cyld);\n            return d;\n            // return d;\n        }\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5., -6.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0, 3. , 6.), vec3(.5));\n        float bd2 = sdBox2(p - vec3(0, 4.5 , 6.), vec3(.5));\n        float bd3 = sdBox3(p - vec3(0, 1.5 , 6.), vec3(.5));\n        float bd4 = sdBox3(p - vec3(-1.5, 3. , 6.), vec3(.5));\n        float bd5 = sdBox(p - vec3(-1.5, 4.5 , 6.), vec3(.5));\n        float bd6 = sdBox2(p - vec3(-1.5, 1.5 , 6.), vec3(.5));\n        float bd7 = sdBox2(p - vec3(1.5, 3. , 6.), vec3(.5));\n        float bd8 = sdBox3(p - vec3(1.5, 4.5 , 6.), vec3(.5));\n        float bd9 = sdBox(p - vec3(1.5, 1.5 , 6.), vec3(.5));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(bd, planeDist);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(bd4, d);\n        d = min(bd5, d);\n        d = min(bd6, d);\n        d = min(bd7, d);\n        d = min(bd8, d);\n        d = min(bd9, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0. + sin(u_time), 3. + cos(u_time), 6.), vec3(.5));\n        float bd2 = sdBox2(p - vec3(0. + cos(u_time), 4.5 + cos(u_time) , 6.), vec3(.5));\n        float bd3 = sdBox3(p - vec3(0. + sin(u_time), 1.5 + cos(u_time), 6.), vec3(.5));\n        float bd4 = sdBox3(p - vec3(-1.5 + sin(u_time), 3. + cos(u_time) , 6.), vec3(.5));\n        float bd5 = sdBox(p - vec3(-1.5, 4.5 , 6.), vec3(.5));\n        float bd6 = sdBox2(p - vec3(-1.5, 1.5 , 6.), vec3(.5));\n        float bd7 = sdBox2(p - vec3(1.5 + sin(u_time), 3. + sin(u_time) , 6.), vec3(.5));\n        float bd8 = sdBox3(p - vec3(1.5, 4.5 , 6.), vec3(.5));\n        float bd9 = sdBox(p - vec3(1.5, 1.5 , 6.), vec3(.5));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(bd, planeDist);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(bd4, d);\n        // d = min(bd5, d);\n        // d = min(bd6, d);\n        d = min(bd7, d);\n        // d = min(bd8, d);\n        // d = min(bd9, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus2(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 3., 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0., 3., 6.), vec3(.5));\n        float td2 = sdTorus2(p-vec3(0, 3., 6), vec2(.4, 0.2));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(td, planeDist);\n\n        d = min(td2, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus2(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus3(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateZ(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus4(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time *2.));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 3., 6), vec2(1., 0.2));\n        float bd = sdBox(p - vec3(0., 3., 6.), vec3(.5));\n        float td2 = sdTorus2(p-vec3(0, 3., 6), vec2(.4, 0.1));\n        float td3 = sdTorus3(p-vec3(0, 3., 6), vec2(1.5, 0.1));\n        float td4 = sdTorus4(p-vec3(0, 3., 6), vec2(2.0, 0.2));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(td, planeDist);\n\n        d = min(td2, d);\n        d = min(td3, d);\n        d = min(td4, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus2(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus3(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateZ(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus4(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time *2.));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n        float n = cnoise(p + u_time) * 0.15;\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 3., 6) + n, vec2(1., 0.2));\n        float bd = sdBox(p - vec3(0., 3., 6.) + n, vec3(.5));\n        float td2 = sdTorus2(p-vec3(0, 3., 6), vec2(.4, 0.1));\n        float td3 = sdTorus3(p-vec3(0, 3., 6), vec2(1.5, 0.1));\n        float td4 = sdTorus4(p-vec3(0, 3., 6) + n, vec2(2.0, 0.2));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(bd, planeDist);\n\n        // d = min(td2, d);\n        // d = min(td3, d);\n        d = min(td4, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        float d = max(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 unionSDF(vec4 a, vec4 b) {\n        float d = min(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        float d = max(a.w, -b.w);\n        return d == a.w ? a : vec4(b.rgb,-b.w);\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,1.05));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0);\n     \n    csg0 = differenceSDF(b0,s0); // Intersect box with sphere creating a CSG object.\n\n    \n     \n    // csg1 = unionSDF(c0,c1); // Unite cylinders\n    // csg1 = unionSDF(csg1,c2);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg0, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(5.*sin(u_time),5.,5.*cos(u_time));// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.5,-3.5); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KE(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JE,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $E=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        float d = max(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 unionSDF(vec4 a, vec4 b) {\n        float d = min(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        float d = max(a.w, -b.w);\n        return d == a.w ? a : vec4(b.rgb,-b.w);\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.85,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .2);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .2);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,1.05));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0);\n     \n    csg0 = differenceSDF(b0, b1); // Intersect box with sphere creating a CSG object.\n\n    \n     \n    csg1 = differenceSDF(csg0,b2);\n\n    // csg1 = unionSDF(csg1,c2);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg1, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.5,-3.5); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$E,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.85,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .2);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .2);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,0.5,1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, s0, 0.15 + sin(u_time * 1.5)/8.);\n     \n    csg2 = smoothDifferenceSDF(csg1, s1, 0.15 + cos(u_time * 1.5)/8.);\n\n    csg3 = smoothDifferenceSDF(csg2, b2, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(1,0,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .4);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,0.5,1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n     \n    csg0 = smoothUnionSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s0, 0.25);\n     \n    // csg2 = smoothDifferenceSDF(csg1, s1, 0.15 + cos(u_time * 1.5)/8.);\n\n    csg3 = smoothUnionSDF(csg1, b2, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(1,0,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .4);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2. - sin(u_time),1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,2. + sin(u_time),1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s1, 0.25);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.25);\n\n    csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg5, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(1,0,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.0175,1.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2. - sin(u_time),1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0. + sin(u_time),2. ,1.);\n    s1p=p-s1p;\n    s1p.xz *=Rotate(0.1);\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, p0, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s1, 0.25);\n     \n    // csg2 = smoothUnionSDF(csg1, s1, 0.25);\n\n    // csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg1, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.0175,1.75,1.5); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + sin(u_time));\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(2.,2. - sin(u_time),2.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0. + sin(u_time) * 2.,2. ,.5);\n    s1p=p-s1p;\n    s1p.xz *=Rotate(0.1);\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, p0, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s1, 0.25);\n     \n    // csg2 = smoothUnionSDF(csg1, s1, 0.25);\n\n    // csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg1, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(2.,2. - sin(u_time),2.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, p0, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b2, 0.25);\n     \n    csg2 = smoothDifferenceSDF(csg1, b1, 0.25);\n\n    // csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg0, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(1.25,.5,.75);\n    vec3 b3p = vec3(0., 1.5, 1.);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2. - sin(u_time),0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothUnionSDF(b1, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b2, 0.125);\n     \n    csg2 = unionSDF(csg1, b3);\n\n    csg3 = smoothUnionSDF(csg2, s0, 0.125);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,0.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.0,0.75);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p,1.5 + sin(u_time)/2. - 0.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, s1, 0.125); // Intersect box with sphere creating a CSG object.\n\n    // csg1 = smoothDifferenceSDF(csg0, s1, 0.125);\n     \n    // csg2 = unionSDF(csg1, b3);\n\n    // csg3 = smoothUnionSDF(csg2, s0, 0.125);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothUnionSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg0, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,0.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.0,0.75);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p,1.5 + sin(u_time)/2. - 0.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, s1, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, b1, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, b2, 0.125);\n\n    // csg3 = smoothUnionSDF(csg2, s0, 0.125);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothUnionSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg2, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdFour(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.65,2.5,-0.45);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.65,2.5,-0.45);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.1);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b0, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg6, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _O=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdFive(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,2.,-0.65 ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.65,2.5,-0.45);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.65,2.5,-0.45);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.1);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg6, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_O,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdSix(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,0.6,-0.7 - sin(u_time)/15. ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI * 2.);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.65,2.24,-0.45);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.65,2.24,-0.6);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.24,-0.1);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.125));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.24,-0.1);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.125));\n\n      vec4 s6 = vec4(vec3(0, 0, 0), sphereSDF(s5p, 0.125));\n      vec4 s7 = vec4(vec3(0, 0, 0), sphereSDF(s4p, 0.125));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0), csg7 = vec4(0), csg8 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n\n    csg7 = smoothUnionSDF(csg6, s6, 0.15);\n\n    csg8 = smoothUnionSDF(csg7, s7, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg8, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 t = vUv;\n        vUv -= 0.5;\n        // t *= 0.5;\n\n        for(int i = 0; i < 20; i++) {\n            float t = 2.0 * PI * float(i) / 30.0 * u_time * 0.5;\n            float x = cos(0.0*t);\n\t\t    float y = sin(2.0*t);\n            vec2 o = 0.40 * vec2(x + sin(u_time) - 1., y);\n            float r = fract(x);\n            float g = 1.0 - r;\n            color += 0.003 / (length(vUv - o)) * vec3(r, g, 0.9);\n        }\n        for(int i = 0; i < 20; i++) {\n            float t = 2.0 * PI * float(i) / 30.0 * u_time * 0.5;\n            float x = cos(2.0*t);\n\t\t    float y = sin(0.0*t);\n            vec2 o = 0.40 * vec2(x , y - sin(u_time) );\n            float r = fract(x);\n            float g = 1.0 - r;\n            color += 0.003 / (length(vUv - o)) * vec3(r, g, 0.9);\n        }\n        for(int i = 0; i < 20; i++) {\n            float t = 2.0 * PI * float(i) / 30.0 * u_time * 0.5;\n            float x = cos(2.0*t);\n\t\t    float y = sin(2.0*t);\n            vec2 o = 0.40 * vec2(x , y );\n            float r = fract(x);\n            float g = 1.0 - r;\n            color += 0.003 / (length(vUv - o)) * vec3(r, g, 0.9);\n        }\n\n        float numLabel = label(t);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:MO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdEight(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    // Octahedron - exact\n    float octahedronSDF(vec3 p,float s) {\n    p=abs(p);\n    float m=p.x+p.y+p.z-s;\n    vec3 q;\n    if(3.*p.x<m)q=p.xyz;\n    else if(3.*p.y<m)q=p.yzx;\n    else if(3.*p.z<m)q=p.zxy;\n    else return m*.57735027;\n \n    float k=clamp(.5*(q.z-q.y+s),0.,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\n    vec4 GetDist(vec3 p)\n    {\n        //octahedron\n\n        vec3 op = vec3(0, 2.5, 0);\n        op = p - op;\n        op.xy *= Rotate(-u_time);\n        op.xz *= Rotate(-u_time);\n\n        float r = fract(BoxColor.b);\n        float g = 1.0 - r;\n        vec4 o = vec4(BoxColor.rgb + vec3(r * cos(u_time), g * sin(u_time), 0.9 * sin(u_time)), octahedronSDF(op, 1.));\n\n        vec4 scene = vec4(0);\n\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n        scene = unionSDF(p0, o);\n        \n        \n    \n        return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdNine(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    // float sdNumHorizontal(vec2 p)\n    // {\n    //     vec2 newUv = p;\n    //     newUv.x += 0.125;\n    //     newUv.y -= 0.25;\n    //     vec2 uv1 = newUv;\n    //     vec2 uv2 = newUv;\n    //     uv1 = Rot(uv1, PI * 0.5);\n    //     uv1 /= .5;\n    //     uv1 -= 1.;\n\n    //     uv2 = Rot(uv2, -PI* .5);\n    //     uv2 /= .5;\n    //     uv2 -= 1.;\n    //     float shape1 = sdEqTriangle(uv1, 0.15);\n    //     shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n    //     float shape2 = sdBox(vec2(uv1.x + 0.5, uv1.y+0.75), vec2(0.33, 0.2815));\n    //     shape2 = 1. - smoothstep(0.1, 0.11, shape2);\n\n    //     float shape3 = sdEqTriangle(vec2(uv2.x, uv2.y-0.5), 0.15);\n    //     shape3 = 1. - smoothstep(0.1, 0.11, shape3);\n\n    //     return shape1 + shape2 + shape3;\n    // }\n\n    // float sdNumVertical(vec2 p){\n    //     vec2 newUv = p;\n    //     newUv.x += 0.125;\n    //     newUv.y -= 0.25;\n    //     vec2 uv1 = newUv;\n    //     vec2 uv3 = newUv;\n    //     vec2 uv4 = newUv;\n    //     uv1 = Rot(uv1, PI * 0.5);\n    //     uv1 /= .5;\n    //     uv1 -= 1.;\n\n    //     uv3 = Rot(uv3, PI * 1.5);\n    //     uv3 /= .5;\n    //     uv3 -= 1.;\n    //     uv3.x -= 0.2;\n    //     uv3.y += 0.1;\n\n    //     uv4 = Rot(uv4, PI * 1.5);\n    //     uv4 /= .5;\n    //     uv4 -= 1.;\n    //     uv4.y += 0.1;\n    //     uv4.x -= 0.52;\n\n    //     float shape1 = sdEqTriangle(vec2(uv1.x + 0.36125, uv1.y-0.01), 0.125);\n    //     shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n    //     float shape4 = sdEqTriangle(vec2(uv3.x, uv3.y), 0.14);\n    //     shape4 = 1. - smoothstep(0.1, 0.11, shape4);\n\n    //     float shape5 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.35, 0.325));\n    //     shape5 = 1. - smoothstep(0.1, 0.11, shape5);\n\n    //     float shape6 = sdEqTriangle(vec2(uv4), 0.14);\n    //     shape6 = 1. - smoothstep(0.1, 0.11, shape6);\n\n    //     float tri = ((shape4 + shape6 + shape1 ) );\n    //     float sq = sdBox(vec2(uv1.x + 0.859, uv1.y +0.442), vec2(0.3));\n    //     sq = 1. - smoothstep(0.1, 0.11, sq);\n    //     float shape7 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.3));\n    //     shape7 = 1. - smoothstep(0.1, 0.11, shape7);\n\n    //     return tri ;\n    // }\n\n   \n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float z = sdZero(vUv);\n        // color += z;\n\n        float zero = numZero(vUv);\n        // color += zero;\n        \n        float one = numOne(vUv);\n        color += one;\n\n        float two = numTwo(vUv);\n        // color += two;\n\n        float three = numThree(vUv);\n        // color += three;\n\n        float four = numFour(vUv);\n        // color += four;\n\n        float five = numFive(vUv);\n        // color += five;\n\n        float six = numSix(vUv);\n        // color += six;\n\n        float seven = numSeven(vUv);\n        // color += seven;\n\n        float eight = numEight(vUv);\n        // color += eight;\n        \n        float nine = numNine(vUv);\n        // color += nine;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n  \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float zero = numZero(vUv);\n        float one = numOne(vUv);\n        float two = numTwo(vUv);\n        float three = numThree(vUv);\n        float four = numFour(vUv);\n        float five = numFive(vUv);\n        float six = numSix(vUv);\n        float seven = numSeven(vUv);\n        float eight = numEight(vUv);\n        float nine = numNine(vUv);\n        // color += zero;\n\n        \n        // color += one;\n\n        float t = u_time;\n        t = t * 0.5;\n\n        if(fract(t) < 0.1)\n        {\n            color += zero;\n        }\n        if(fract(t) <= 0.2)\n        {\n            if(fract(t) > 0.1)\n            {\n                color += one;\n            }\n            \n        }\n        if(fract(t) <= 0.3)\n        {\n            if(fract(t) > 0.2)\n            {\n                color += two;\n            }\n        }\n        if(fract(t) <= 0.4)\n        {\n            if(fract(t) > 0.3)\n            {\n                color += three;\n            }\n        }\n        if(fract(t) <= 0.5)\n        {\n            if(fract(t) > 0.4)\n            {\n                color += four;\n            }\n        }\n        if(fract(t) <= 0.6)\n        {\n            if(fract(t) > 0.5)\n            {\n                color += five;\n            }\n        }\n        if(fract(t) <= 0.7)\n        {\n            if(fract(t) > 0.6)\n            {\n                color += six;\n            }\n        }\n        if(fract(t) <= 0.8)\n        {\n            if(fract(t) > 0.7)\n            {\n                color += seven;\n            }\n        }\n        if(fract(t) <= 0.9)\n        {\n            if(fract(t) > 0.8)\n            {\n                color += eight;\n            }\n        }\n        if(fract(t) <= 1.)\n        {\n            if(fract(t) > 0.9)\n            {\n                color += nine;\n            }\n        }\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    float tile(vec2 uv, float zoom)\n    {\n        uv *= zoom;\n\n        float index = 0.;\n        index += step(1., mod(uv.x, 3.));\n        index += step(1., mod(uv.y, 3.)) * 2.;\n        \n        uv = fract(uv);\n        float c;\n        float zero = numZero(uv);\n        float one = numOne(uv);\n        float two = numTwo(uv);\n        float three = numThree(uv);\n        float four = numFour(uv);\n        float five = numFive(uv);\n        float six = numSix(uv);\n        float seven = numSeven(uv);\n        float eight = numEight(uv);\n        float nine = numNine(uv);\n\n        float t = u_time;\n        t = t / 2.;\n\n        if(index == 0.)\n        {\n            c = zero;\n        } else if (index == 1.){\n            if(fract(t) < 0.1)\n            {\n                c += zero;\n            }\n            if(fract(t) <= 0.2)\n            {\n                if(fract(t) > 0.1)\n                {\n                    c += one;\n                }\n                \n            }\n            if(fract(t) <= 0.3)\n            {\n                if(fract(t) > 0.2)\n                {\n                    c += two;\n                }\n            }\n            if(fract(t) <= 0.4)\n            {\n                if(fract(t) > 0.3)\n                {\n                    c += three;\n                }\n            }\n            if(fract(t) <= 0.5)\n            {\n                if(fract(t) > 0.4)\n                {\n                    c += four;\n                }\n            }\n            if(fract(t) <= 0.6)\n            {\n                if(fract(t) > 0.5)\n                {\n                    c += five;\n                }\n            }\n            if(fract(t) <= 0.7)\n            {\n                if(fract(t) > 0.6)\n                {\n                    c += six;\n                }\n            }\n            if(fract(t) <= 0.8)\n            {\n                if(fract(t) > 0.7)\n                {\n                    c += seven;\n                }\n            }\n            if(fract(t) <= 0.9)\n            {\n                if(fract(t) > 0.8)\n                {\n                    c += eight;\n                }\n            }\n            if(fract(t) <= 1.)\n            {\n                if(fract(t) > 0.9)\n                {\n                    c += nine;\n                }\n            }\n        } else if (index == 2.){\n            c = two;\n        } else if (index == 3.){\n            c = three;\n        } else if (index == 4.){\n            c = four;\n        }else if (index == 5.){\n            c = five;\n        } else if (index == 6.){\n            c = six;\n        }\n\n        return c;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        float x = tile(uv2, 3.);\n        color += x;\n\n        float count = numZero(vec2(uv2.x + 0.2, uv2.y)) + numZero(vec2(uv2.x-0.2, uv2.y));\n\n        // color += count;\n        \n        // float zero = numZero(uv2);\n        // float one = numOne(uv2);\n        // float two = numTwo(uv2);\n        // float three = numThree(uv2);\n        // float four = numFour(uv2);\n        // float five = numFive(uv2);\n        // float six = numSix(uv2);\n        // float seven = numSeven(uv2);\n        // float eight = numEight(uv2);\n        // float nine = numNine(uv2);\n        // color += zero;\n\n        \n        // color += one;\n\n        // float t = u_time;\n        // t = t / 2.;\n\n        // if(fract(t) < 0.1)\n        // {\n        //     color += zero;\n        // }\n        // if(fract(t) <= 0.2)\n        // {\n        //     if(fract(t) > 0.1)\n        //     {\n        //         color += one;\n        //     }\n            \n        // }\n        // if(fract(t) <= 0.3)\n        // {\n        //     if(fract(t) > 0.2)\n        //     {\n        //         color += two;\n        //     }\n        // }\n        // if(fract(t) <= 0.4)\n        // {\n        //     if(fract(t) > 0.3)\n        //     {\n        //         color += three;\n        //     }\n        // }\n        // if(fract(t) <= 0.5)\n        // {\n        //     if(fract(t) > 0.4)\n        //     {\n        //         color += four;\n        //     }\n        // }\n        // if(fract(t) <= 0.6)\n        // {\n        //     if(fract(t) > 0.5)\n        //     {\n        //         color += five;\n        //     }\n        // }\n        // if(fract(t) <= 0.7)\n        // {\n        //     if(fract(t) > 0.6)\n        //     {\n        //         color += six;\n        //     }\n        // }\n        // if(fract(t) <= 0.8)\n        // {\n        //     if(fract(t) > 0.7)\n        //     {\n        //         color += seven;\n        //     }\n        // }\n        // if(fract(t) <= 0.9)\n        // {\n        //     if(fract(t) > 0.8)\n        //     {\n        //         color += eight;\n        //     }\n        // }\n        // if(fract(t) <= 1.)\n        // {\n        //     if(fract(t) > 0.9)\n        //     {\n        //         color += nine;\n        //     }\n        // }\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,2.,-0.65 ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.5,2.5,-0.5);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.5,2.5,-0.5);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.15);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n\n      // Sphere.\n      vec3 s6p=vec3(-0.15,2.,-0.75);\n      s6p=p-s6p;\n      vec4 s6 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s6p, 0.012525));\n\n      vec3 s7p=vec3(0.15,2.,-0.75);\n      s7p=p-s7p;\n      vec4 s7 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s7p, 0.012525));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0), csg7 = vec4(0), csg8 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n\n    csg7 = smoothDifferenceSDF(csg6, s6, 0.15);\n\n    csg8 = smoothDifferenceSDF(csg7, s7, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg8, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,2.,-0.65 ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.5,2.5,-0.5);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.5,2.5,-0.5);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.15);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n\n      // Sphere.\n      vec3 s6p=vec3(-0.15,2.,-0.75);\n      s6p=p-s6p;\n      vec4 s6 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s6p, 0.012525));\n\n      vec3 s7p=vec3(0.15,2.,-0.75);\n      s7p=p-s7p;\n      vec4 s7 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s7p, 0.012525));\n\n      // Sphere.\n      vec3 s8p=vec3(0.65,2.5,-0.35);\n      s8p=p-s8p;\n      vec4 s8 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s8p, 0.125));\n\n      vec3 s9p=vec3(-0.65,2.5,-0.35);\n      s9p=p-s9p;\n      vec4 s9 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s9p, 0.125));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0), csg7 = vec4(0), csg8 = vec4(0), csg9 = vec4(0), csg10 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n\n    csg7 = smoothDifferenceSDF(csg6, s6, 0.15);\n\n    csg8 = smoothDifferenceSDF(csg7, s7, 0.15);\n     \n    csg9 = smoothDifferenceSDF(csg8, s8, 0.15);\n    csg10 = smoothDifferenceSDF(csg9, s9, 0.15);\n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg10, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    float displacement =  sin(2.0 * p.x + (u_time)/1.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/1.) * 0.37525;\n    s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 1.));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect \n\n    scene = smoothUnionSDF(s0, p0, 0.15);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    float displacement =  sin(2.0 * p.x + (u_time)/1.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/1.) * 0.37525;\n    s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 1.));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5, 1.0,0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n\n    float b1 = boxSDF(p - vec3(-1.5,1.5,0), vec3(1));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    //shell\n    box = abs(box)-.1 + (sin(u_time * 0.5)/6.)-0.15;\n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect \n\n    scene = smoothIntersectSDF(box, plane, 0.15);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3 );\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    float displacement =  sin(2.0 * p.x + (u_time)/1.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/1.) * 0.37525;\n    s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 1.));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-1.5,1.5,0);\n    // b1p.yz *= Rotate((u_time));\n    float b1 = boxSDF(p - b1p, vec3(1));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    //shell\n    box = abs(box)-.1;\n    // box.xy *= Rotate(sin(u_time)); \n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0);\n     \n    csg0 = smoothIntersectSDF(box, plane, 0.125); // Intersect \n\n    scene = unionSDF(csg0, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(-1.5,1.5,0);\n    float displacement =  sin(2.0 * p.x + (u_time)/2.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/2.) * 0.37525;\n    // s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 0.15));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-1.5,1.5,0);\n    // b1p.yz *= Rotate((u_time));\n    float b1 = boxSDF(p - b1p + displacement, vec3(1.25));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    //shell\n    box = abs(box)-.1;\n    // box.xy *= Rotate(sin(u_time)); \n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0);\n     \n    csg0 = smoothUnionSDF(box, p0, 0.125);\n    csg1 = smoothUnionSDF(csg0, s0, 0.125); \n\n    scene = smoothUnionSDF(box, p0, 0.25);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n        lightPos.zx *= Rotate(PI * 1.75);\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9 ,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(.0,1.5,0);\n    float displacement =  sin(3.0 * p.x + (u_time)/2.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/2.) * 0.137525;\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 0.05));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-.5,1.5,0);\n    b1p.xz *= Rotate((u_time));\n    \n    float s1 = sphereSDF(p - s0p + displacement, 1.75);\n    float s2 = sphereSDF(p - s0p + displacement, 0.5);\n    float b1 = boxSDF(p - b1p , vec3(1.25));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    \n    vec4 sphere = vec4(ColorRed.rgb, s1);\n    vec4 sphere2 = vec4(ColorRed.rgb, s2);\n    //shell\n    box = abs(box)-.1;\n    // box.xy *= Rotate(sin(u_time)); \n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0);\n     \n    csg0 = smoothUnionSDF(box, p0, 0.125);\n    csg1 = smoothDifferenceSDF(csg0, sphere, 0.125); \n    csg2 = smoothUnionSDF(csg1, sphere2, 0.125);\n    scene = smoothUnionSDF(csg2, p0, 0.25);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n        lightPos.zx *= Rotate(PI * 1.75);\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9 ,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(.0,1.5,0);\n    float displacement =  sin(3.0 * p.x + (u_time)/2.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/2.) * 0.137525;\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 0.05));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-0.5,1.5,0) ;\n    // b1p.xz *= Rotate((u_time));\n    float b1 = boxSDF(p - b1p * displacement , vec3(1.25 + sin(u_time * 0.25), .525 , 1.25 + cos(u_time * 0.25)));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0);\n     \n    csg0 = smoothUnionSDF(box, p0, 0.125);\n    scene = smoothUnionSDF(csg0, p0, 0.25);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n        lightPos.zx *= Rotate(PI * 1.75);\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9 ,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.263,0.416 * u_time,0.557);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time *0.25);\n        uv2 -= 0.5;\n        vec2 uv3 = uv2;\n\n        \n        float d;\n        vec3 c;\n\n        for (float i = 0.; i < 4.; i++)\n        {\n            uv2 = fract(uv2 * 1.) - 0.5;\n            d = length(uv3) * exp(-length(uv2));\n            c = palette(length(uv2) + i * .4 + u_time * .4);\n            d = sin(d * 20. + u_time) / 8.;\n            d = abs(d);\n            d = pow(0.01/d, 1.2);\n            color += c * d;\n        }\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KO(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JO,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $O=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        // uv2 = Rot(uv2, u_time * 0.25);\n        uv2 -= 0.5;\n        vec2 uv3 = uv2;\n\n        \n        float d;\n        vec3 c;\n\n        for (float i = 0.; i < 4.; i++)\n        {\n            uv2 = fract(uv2 * (1.5 + sin(u_time * 0.25)/15.)) - 0.5;\n            d = length(uv3) * (-length(uv2));\n            c = palette(length(uv2) + i * .4 + u_time * .4);\n            d = sin(d * 15. + sin(u_time)) / 5.;\n            d = abs(d);\n            d = pow(0.01/d, 1.);\n            color += c * d;\n        }\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$O,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.25);\n        uv2 -= 0.5;\n        vec2 uv3 = uv2;\n\n        \n        float d;\n        float d2;\n        vec3 c;\n\n        for (float i = 0.; i < 4.; i++)\n        {\n            uv2 = fract(uv2 * (1.5 + sin(u_time * 0.25)/15.)) - 0.5;\n            d = length(uv3) * (length(uv2));\n            c = palette(length(uv2) + i * .4 + u_time * .4);\n            d2 = d;\n            d = sin(d * 5. + (u_time * 0.5)) / 5.;\n            d2 = tan(d * 5. + (u_time * 0.5)) / 5.;\n            d = abs(d);\n            d2 = abs(d2);\n            d = pow(0.005/d, 1.);\n            d2 = pow(0.002/d2, 1.);\n            color += c * d + d2;\n        }\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    float variation(vec2 v1, vec2 v2, float strength, float speed) {\n        return sin(\n            dot(normalize(v1), normalize(v2)) * strength + u_time * speed\n        ) / 100.0;\n    }\n    \n    vec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n        \n        vec2 diff = center-uv;\n        float len = length(diff);\n    \n        len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n        len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);\n        \n        float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n\n        float segment = sdSegment(uv, vec2(0.), vec2(0.5));\n\n        return vec3(circle);\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        // uv2 = Rot(uv2, u_time * 0.25);\n        float m = 0.;\n        vec3 d;\n        uv2 -= 0.5;\n        float t = u_time * 0.05;\n        for(float i =0.; i <1.; i+= 1./2.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(.5, .05, z);\n            float fade = S(0.0, 0.5, z) * S(.0, 1., z) ;\n            \n            \n            vec3 cir = paintCircle(uv2 , vec2(0.0) ,  fade  + 0.15 * 1.25 , 0.01 );\n            vec3 cir2 = paintCircle(uv2, vec2(0.0) ,  fade + 0.15 * 1.25, 0.04 );\n\n            vec3 cir3 = paintCircle(uv2, vec2(0.0) ,  fade + 0.1 * 1.25, 0.01);\n            vec3 cir4 = paintCircle(uv2, vec2(0.0) ,  fade + 0.1 * 1.25, 0.04);\n\n            vec3 cir5 = paintCircle(uv2, vec2(0.0) ,  fade + 0.05 * 1.25, 0.01);\n            vec3 cir6 = paintCircle(uv2, vec2(0.0) ,  fade + 0.05 * 1.25, 0.04 );\n\n            vec3 cir7 = paintCircle(uv2, vec2(0.0) ,  fade - 0.0 * 1.25, 0.01);\n            vec3 cir8 = paintCircle(uv2, vec2(0.0) ,  fade - 0.0 * 1.25, 0.04);\n\n            vec3 cir9 = paintCircle(uv2, vec2(0.0) ,  fade - 0.05 * 1.25, 0.01);\n            vec3 cir10 = paintCircle(uv2, vec2(0.0) ,  fade - 0.05 * 1.25, 0.04);\n\n            vec3 cir11 = paintCircle(uv2, vec2(0.0) , fade - 0.1 * 1.25, 0.01);\n            vec3 cir12 = paintCircle(uv2, vec2(0.0) , fade - 0.1 * 1.25, 0.04);\n\n            vec3 cir13 = paintCircle(uv2, vec2(0.0) , fade - 0.15  * 1.25, 0.01 );\n            vec3 cir14 = paintCircle(uv2, vec2(0.0) ,  fade - 0.15 * 1.25, 0.04);\n\n            cir += cir2;\n            color += cir2 * vec3(0.9, 0., 0.);\n            // m += Layer(uv2 * size + i * 20.) * fade;\n\n            cir3 += cir4;\n            color += cir4 * vec3(0.9, 0.5, 0.0);\n\n            cir5 += cir6;\n            color += cir6 * vec3(1., 1., 0.0);\n\n            cir7 += cir8;\n            color += cir8 * vec3(0., 1., 0.0);\n\n            cir9 += cir10;\n            color += cir10 * vec3(0., 0., 1.0);\n\n            cir11 += cir12;\n            color += cir12 * vec3(0.29, 0., 0.51);\n\n            cir13 += cir14;\n            color += cir14 * vec3(0.93, 0.51, 0.93);\n        }\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:oL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n        uv2.y -= 0.065;\n\n        float one = 1. - sdBox(vec2(uv2.x, uv2.y + (1./7.)), vec2(2.5, 1./7.));\n        float two = 1. - sdBox(vec2(uv2.x, uv2.y + (2./7.)), vec2(2.5, 1./7.));\n        float three = 1. - sdBox(vec2(uv2.x, uv2.y + 3./7.), vec2(2.5, 1./7.));\n        float four = 1. - sdBox(vec2(uv2.x, uv2.y + 4./7.), vec2(2.5, 1./7.));\n        float five = 1. - sdBox(vec2(uv2.x, uv2.y + 5./7.), vec2(2.5, 1./7.));\n        float six = 1. - sdBox(vec2(uv2.x, uv2.y + 6./7.), vec2(2.5, 1./7.));\n        float seven = 1. - sdBox(vec2(uv2.x, uv2.y + 7./7.), vec2(2.5, 1./7.));\n\n        color += one * vec3(0.9, 0., 0.);\n        color += two * vec3(0.9, 0.5, 0.0);\n        color += three * vec3(1., 1., 0.0);\n        color += four * vec3(0., 1., 0.0);\n        color += five * vec3(0., 0., 1.0);\n        color += six * vec3(0.29, 0., 0.51);\n        color += seven * vec3(0.93, 0.51, 0.93);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:aL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, - uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (TWO_PI * 2.0) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), 4.0);\n    \n    return radialUv;\n    }\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        vec2 uv3 = uv2;\n        vec2 uv4 = vUv;\n        uv4 -= 0.5;\n        uv4 = getRadialUv(uv4);\n        uv2 -= .5;\n        uv3 = Rot(uv3, PI * 2.);\n        uv3 -= 0.5;\n        \n\n        float an = -u_time * 0.15;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2);\n        float a = atan(uv2.y, uv2.x);\n        uv2 = vec2(0.3/r1 + 0.5 * u_time , a);\n        float r2 = length(uv3);\n        float a2 = atan(uv3.y, uv3.x);\n        uv3 = vec2(0.3/r2 + 0.5 * u_time, a2);\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv4 + 0.00*u_time);\n        q.y = fbm( uv4 + vec2(1.0));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv4 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv4 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r);\n        float f2 = fbm(uv3+r);\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.101961,0.619608,0.666667),\n                    vec3(0.666667,0.666667,0.498039),\n                    clamp((f*f)*4.0,0.0,1.0));\n\n        c = mix(color,\n                    vec3(0,0,0.164706),\n                    clamp(length(q),0.0,1.0));\n\n        c = mix(color,\n                    vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n        c *= f*f*f+.6*f *f + .5 *f * c ;\n        // c *= f2*f2*f2+.6*f2 *f2 + .5 *f2 * c ;\n\n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:vL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    // radialUv.x = angle / (PI) + 0.5;\n    // radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) + 0.0005 * u_time, angle );\n    \n    return radialUv;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n        \n        \n\n        float an = -u_time * 0.15;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2) ;\n        r1 = abs(r1);\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a);\n        uv2 = vec2(0.3/r1 + .95 * u_time , a);\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.00*u_time);\n        q.y = fbm( uv2 + vec2(1.0));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.101961,0.619608,0.666667),\n                    vec3(0.666667,0.666667,0.498039),\n                    clamp((f*f)*4.0,0.0,1.0));\n\n        c = mix(color,\n                    vec3(0,0,0.164706),\n                    clamp(length(q),0.0,1.0));\n\n        c = mix(color,\n                    vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n        c *= f*f*f+.6*f *f + .25 *f * c* f * c ;\n\n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:lL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.15;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 0.5) ;\n        r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.3/r1 + .95 - u_time * 1.25 , a);\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + vec2(50.01));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.619608,0.666667),\n                    vec3(0.666667,0.666667,0.498039),\n                    clamp((f*f)*5.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.9,0,0.164706),\n                    clamp(length(q),0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.966667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n        c *= f*f*f+.6*f *f + .25 *f * c* f * f ;\n\n        float cir = sdCircle(vUv, 0.0525);\n        \n\n        color += c * 2. * 2. + c;\n        color *=  c - cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:uL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.15;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 0.5) ;\n        r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.3/r1 + .95 + u_time * 2.25 , a);\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + vec2(50.01));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.9666667,0.9666667,0.998039),\n                    clamp((f*f)*1.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.099,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,1),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color,\n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        c *= f ;\n\n        float cir = sdCircle(vUv, 0.125 * sin(1. /u_time));\n        \n\n        color += c * 2. * 2. + c;\n        color *=  c - cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:pL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1 + sin(u_time), a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color,\n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.125 ) * 0.65;\n        \n\n        color += c * 2. ;\n        color *=  c - cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:dL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1 + sin(u_time), a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color,\n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.125 );\n        \n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        color.rgb+= smoothstep(0.02 * 2., 0.031 * 2., s.x);\n        //color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        //color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:xL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1 + sin(u_time), a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.125 );\n        \n        vec3 s = voronoi(uv2 * 0.25);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        color.rgb+= smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f);\n        //color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        //color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:gL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _L=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1, a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.0125 );\n        \n        vec3 s = voronoi(uv2 * 0.25);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        color.rgb += smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f + s2.x);\n        color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:_L,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    vec2 tile(vec2 uv, float zoom, float speed){\n        uv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > 0.5)\n        {\n            if(fract(uv.y * 0.5) > 0.5){\n                uv.x += fract(t) * 2.;\n            } else {\n                uv.x -= fract(t) * 2.;\n            }\n        } else {\n            if(fract(uv.x * 0.5) > 0.5)\n            {\n                uv.y += fract(t) * 2.;\n            } else {\n                uv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(uv);\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1, a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        vec2 pattern = tile(uv2, 1., 0.5);\n        float x = numZero(pattern);\n        color.g += x;\n\n        float cir = sdCircle(vUv, 0.0125 );\n        \n        vec3 s = voronoi(uv2 );\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        // color.rgb += 1. - smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f + s.x);\n        // color.g+= smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        // color.b+= smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:wL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ML=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    vec2 tile(vec2 uv, float zoom, float speed){\n        uv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > 0.5)\n        {\n            if(fract(uv.y * 0.5) > 0.5){\n                uv.x += fract(t) * 2.;\n            } else {\n                uv.x -= fract(t) * 2.;\n            }\n        } else {\n            if(fract(uv.x * 0.5) > 0.5)\n            {\n                uv.y += fract(t) * 2.;\n            } else {\n                uv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(uv);\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1, a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        vec2 pattern = tile(uv2, 1., 0.5);\n        float x = numTwo(pattern);\n        color.r += x;\n\n        \n        float cir = sdCircle(vUv, 0.0125 );\n        vec3 s = voronoi(uv2 );\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        // color.rgb += 1. - smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f + s.x);\n        // color.g+= smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        // color.b+= smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ML,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv -= 0.5;\n\n        float x = sdSpiral(newUv, 0.525, 2.525 + sin(u_time));\n        color += x;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:kL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv *= 0.25 + 0.75;\n        newUv = Rot(newUv, u_time * 4.5 + sin(u_time));\n        newUv -= 0.5;\n\n        float x;\n        for(float i=0.; i<2.; i++){\n            newUv*= 0.165;\n\n            x = sdSpiral(newUv, 0.82, 3.525 + sin(u_time + i/2. ));\n            color += x;\n\n            vec3 c = palette(x * i);\n            color -= c.xyz;\n        }\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:TL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv *= 0.25 + 0.75;\n        newUv = Rot(newUv, u_time * 4.5 + sin(u_time));\n        newUv -= 0.5;\n\n        float x;\n        for(float i=0.; i<6.; i++){\n            newUv*= 0.165;\n\n            x = sdSpiral(vec2(newUv.x * 55.5 * i, newUv.y * 55.5 * i), i, 3.525 + sin(u_time + i/2. ));\n            color += x;\n\n            vec3 c = palette(x * i);\n            color -= c.xyz;\n        }\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:DL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        // newUv = Rot(newUv, u_time * 4.5 + sin(u_time));\n        // newUv -= 0.5;\n\n        float line = 0.;\n        // float x = plot(newUv, line, 0.02 );\n        float x = circle(newUv, 1.025);\n        float x1 = circle(vec2(newUv.x + sin(u_time)/4., newUv.y + cos(u_time)/4.), 0.275);\n        float x2 = circle(vec2(newUv.x + sin(u_time)/8., newUv.y + cos(u_time)/8.), 0.075);\n        float x3 = circle(vec2(newUv.x + sin(u_time)/16. , newUv.y + cos(u_time)/16.) , 0.022);\n        float x4 = circle(vec2(newUv.x + sin(u_time)/32. , newUv.y + cos(u_time)/32.) , 0.006);\n        float x5 = circle(vec2(newUv.x + sin(u_time)/64. , newUv.y + cos(u_time)/64.) , 0.002);\n\n        color.rgb += x;\n        color.rgb -= x1;\n        color.rgb += x2;\n        color.rgb -= x3;\n        color.rgb += x4;\n        color.rgb -= x5;\n        // color.rb -= x2;\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:FL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    float flower(vec2 vUv, float n, float zoom)\n    {\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * zoom;\n        float a = atan(pos.y, pos.x);\n        float f = cos(a * n );\n        return smoothstep(f, f + 0.25, r );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        vec2 newUv2 = newUv;\n        vec2 newUv3 = newUv;\n        newUv = Rot(newUv, u_time * 1.5 + sin(u_time));\n        newUv2 = Rot(newUv2, u_time * 1.5 + cos(u_time));\n        newUv3 = Rot(newUv2, u_time * 1. + cos(u_time));\n        // newUv -= 0.5;\n        // newUv2.x -= 0.2;\n\n        float line = 0.;\n        // float x = plot(newUv, line, 0.02 );\n        float x = flower(newUv, 5., 2.);\n        float x2 = flower(newUv2, 5., 2.);\n        float x3 = flower(newUv3, 5., 2.);\n        color += 1. - palette(x * 0.5);\n        color += 1. - palette(x2 * 0.25);\n        color += 1. - palette(x3 * 0.15);\n\n        // color.rb -= x2;\n\n        \n\n        float numLabel = label(vUv);\n        color *= 1. - numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:IL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 3.28318*(c*t+d) * abs(sin(u_time/8. )- 0.25));\n    }\n\n    float flower(vec2 vUv, float n, float zoom)\n    {\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * zoom;\n        float a = atan(pos.y, pos.x);\n        float f = cos(a * n );\n        return smoothstep(f, f + 0.25, r );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        vec2 newUv2 = newUv;\n        vec2 newUv3 = newUv;\n        vec2 newUv4 = newUv;\n        vec2 newUv5 = newUv;\n        vec2 newUv6 = newUv;\n        vec2 newUv7 = newUv;\n        vec2 newUv8 = newUv;\n\n        newUv = Rot(newUv, u_time * 2.25 + cos(u_time));\n        newUv2 = Rot(newUv2, u_time * 2.0 + cos(u_time));\n        newUv3 = Rot(newUv3, u_time * 1.75 + cos(u_time));\n        newUv4 = Rot(newUv4, u_time * 1.5 + cos(u_time));\n        newUv5 = Rot(newUv5, u_time * 1.25 + cos(u_time));\n        newUv6 = Rot(newUv6, u_time * 1. + cos(u_time));\n        newUv7 = Rot(newUv7, u_time * 0.75 + cos(u_time));\n        newUv8 = Rot(newUv8, u_time * 0.5 + cos(u_time));\n        // newUv -= 0.5;\n        // newUv2.x -= 0.2;\n\n        float x = sdPolygonOutline(newUv, 6, 0.8); \n        float x2 = sdPolygonOutline(newUv2, 6, 0.7);\n        float x3 = sdPolygonOutline(newUv3, 6, 0.6); \n        float x4 = sdPolygonOutline(newUv4, 6, 0.5); \n        float x5 = sdPolygonOutline(newUv5, 6, 0.4); \n        float x6 = sdPolygonOutline(newUv6, 6, 0.3);\n        float x7 = sdPolygonOutline(newUv7, 6, 0.2); \n        float x8 = sdPolygonOutline(newUv8, 6, 0.1);  \n        \n        color += 1. - palette(x * 0.59);\n        color += 1. - palette(x2 * 0.58);\n        color += 1. - palette(x3 * 0.57);\n        color += 1. - palette(x4 * 0.56);\n        color += 1. - palette(x5 * 0.55);\n        color += 1. - palette(x6 * 0.54);\n        color += 1. - palette(x7 * 0.53);\n        color += 1. - palette(x8 * 0.52);\n\n        color *= 2.;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:OL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 3.28318*(c*t+d) * abs(sin(u_time/8. )- 0.25));\n    }\n\n    float flower(vec2 vUv, float n, float zoom)\n    {\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * zoom;\n        float a = atan(pos.y, pos.x);\n        float f = cos(a * n );\n        return smoothstep(f, f + 0.25, r );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        vec2 newUv2 = newUv;\n        vec2 newUv3 = newUv;\n        vec2 newUv4 = newUv;\n        vec2 newUv5 = newUv;\n        vec2 newUv6 = newUv;\n        vec2 newUv7 = newUv;\n        vec2 newUv8 = newUv;\n\n        newUv = Rot(newUv,   u_time/4. * 2.25 + cos(u_time));\n        newUv2 = Rot(newUv2, u_time/4. * 2.00 + cos(u_time));\n        newUv3 = Rot(newUv3, u_time/4. * 1.75 + cos(u_time));\n        newUv4 = Rot(newUv4, u_time/4. * 1.50 + cos(u_time));\n        newUv5 = Rot(newUv5, u_time/4. * 1.25 + cos(u_time));\n        newUv6 = Rot(newUv6, u_time/4. * 1.00 + cos(u_time));\n        newUv7 = Rot(newUv7, u_time/4. * 0.75 + cos(u_time));\n        newUv8 = Rot(newUv8, u_time/4. * 0.50 + cos(u_time));\n        // newUv -= 0.5;\n        // newUv2.x -= 0.2;\n\n        float x = sdPolygonOutline(newUv,   4, 0.8); \n        float x2 = sdPolygonOutline(newUv2, 4, 0.7);\n        float x3 = sdPolygonOutline(newUv3, 4, 0.6); \n        float x4 = sdPolygonOutline(newUv4, 4, 0.5); \n        float x5 = sdPolygonOutline(newUv5, 4, 0.4); \n        float x6 = sdPolygonOutline(newUv6, 4, 0.3);\n        float x7 = sdPolygonOutline(newUv7, 4, 0.2); \n        float x8 = sdPolygonOutline(newUv8, 4, 0.1);  \n        \n        color += 1. - palette(x  * 0.59 * 2.2 * abs(sin(u_time) + 0.1));\n        color += 1. - palette(x2 * 0.58 * 2.2 * abs(cos(u_time) + 0.2));\n        color += 1. - palette(x3 * 0.57 * 2.2 * abs(sin(u_time) + 0.3));\n        color += 1. - palette(x4 * 0.56 * 2.2 * abs(cos(u_time) + 0.4));\n        color += 1. - palette(x5 * 0.55 * 2.2 * abs(sin(u_time) + 0.5));\n        color += 1. - palette(x6 * 0.54 * 2.2 * abs(cos(u_time) + 0.6));\n        color += 1. - palette(x7 * 0.53 * 2.2 * abs(sin(u_time) + 0.7));\n        color += 1. - palette(x8 * 0.52 * 2.2 * abs(cos(u_time) + 0.8));\n\n        // color *= 2.;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function GL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:AL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var NL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 15.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float one = sdOne(b);\n        float zero = sdZero(b);\n        float two = sdTwo(b);\n        float three = sdThree(b);\n        float four = sdFour(b);\n        float five = sdFive(b);\n        float six = sdSix(b);\n        float seven = sdSeven(b);\n        float eight = sdEight(b);\n        float nine = sdNine(b);\n        float shape;\n        if(str > .9 )\n        {\n            shape = smoothstep(0.01, 0.011, zero);\n        } else if(str > .8){\n            shape = smoothstep(0.01, 0.011, one);\n        } else if(str > .7){\n            shape = smoothstep(0.01, 0.011, two);\n        } else if(str > .6){\n            shape = smoothstep(0.01, 0.011, three);\n        } else if(str > .5){\n            shape = smoothstep(0.01, 0.011, four);\n        } else if(str > .4){\n            shape = smoothstep(0.01, 0.011, five);\n        } else if(str > .3){\n            shape = smoothstep(0.01, 0.011, six);\n        } else if(str > .2){\n            shape = smoothstep(0.01, 0.011, seven);\n        } else if(str > .1){\n            shape = smoothstep(0.01, 0.011, eight);\n        } else {\n            shape = smoothstep(0.01, 0.011, nine);\n        }\n        \n        return vec3(shape * str );\n    }\n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv -= 0.5;\n    \n        float an = -u_time * 0.5;\n        // newUv = mat2(cos(an),-sin(an),sin(an),cos(an)) * newUv;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(newUv) ;\n        // r1 = abs(r1 );\n        float a = -atan(newUv.x, newUv.y) * 0.425;\n        // a = abs(a * 0.85);\n        newUv = vec2(0.5/r1 + .95 + u_time * 0.25 + r1, a );\n\n        vec3 mat = matrix(vec2(newUv.y, newUv.x));\n\n        color.g += mat.g;\n\n        float cir = sdCircle(vUv, 0.125 );\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function BL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:NL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float cloudscale = 1.1;\n    float speed = 0.03;\n    float clouddark = 0.5;\n    float cloudlight = 0.3;\n    float cloudcover = 0.2;\n    float cloudalpha = 8.0;\n    float skytint = 0.5;\n    vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\n    vec3 skycolour2 = vec3(1.4, 0.7, 1.0);\n\n    const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\n    vec2 hash( vec2 p ) {\n        p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    }\n    \n    float noise( in vec2 p ) {\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\n        vec2 i = floor(p + (p.x+p.y)*K1);\t\n        vec2 a = p - i + (i.x+i.y)*K2;\n        vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n        vec2 b = a - o + K2;\n        vec2 c = a - 1.0 + 2.0*K2;\n        vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n        return dot(n, vec3(70.0));\t\n    }\n    \n    float fbm(vec2 n) {\n        float total = 0.0, amplitude = 0.1;\n        for (int i = 0; i < 7; i++) {\n            total += noise(n) * amplitude;\n            n = m * n;\n            amplitude *= 0.4;\n        }\n        return total;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv -= 0.5;\n        // newUv *= 20.5;\n        float t = u_time * speed;\n        float q = fbm(newUv * cloudscale * 0.5);\n\n        float r = 0.;\n        newUv *= cloudscale;\n        newUv -= q - t;\n        float weight = 0.8;\n        for(int i = 0; i < 8; i++){\n            r += abs(weight*noise(newUv));\n            newUv = m*newUv + t;\n            weight *= 0.7;\n        }\n        float f = 0.0;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv *= cloudscale;\n        newUv -= q - t;\n        weight = 0.7;\n        for (int i=0; i<8; i++){\n            f += weight*noise( newUv );\n            newUv = m*newUv + t;\n            weight *= 0.6;\n    }\n        f *= r + f;\n        float c = 0.0;\n        t = u_time * speed * 2.0;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv *= cloudscale*2.0;\n        newUv -= q - t;\n        weight = 0.4;\n        for (int i=0; i<7; i++){\n            c += weight*noise( newUv );\n            newUv = m*newUv + t;\n            weight *= 0.6;\n        }\n        float c1 = 0.0;\n        t = u_time * speed * 3.0;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv *= cloudscale*3.0;\n        newUv -= q - t;\n        weight = 0.4;\n        for (int i=0; i<7; i++){\n            c1 += abs(weight*noise( newUv ));\n            newUv = m*newUv + t;\n            weight *= 0.6;\n        }\n\n        c += c1;\n        \n        vec3 skycolour = mix(skycolour2, skycolour1, vUv.x);\n        vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n    \n        f = cloudcover + cloudalpha*f*r;\n\n        vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n        color += result;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function VL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:qL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.52;\n        uv2 *= 2.9;\n        uv2.x += u_time*0.1;\n        \n        vec2 q = vec2(0.);\n        q.y = fbm( uv2 + 0.2*u_time);\n        q.x = fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r ));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f),0.0,1.0));\n        color += c;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function HL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:WL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.52;\n        uv2 *= 3.9;\n        uv2.x += u_time*0.1;\n        uv2.y += u_time * 0.1;\n        \n        vec2 q = vec2(0.);\n        q.y = fbm( uv2 + 0.2*u_time);\n        q.x = fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function YL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:XL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ZL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(1.83/r1 + .95 + u_time * 0.025 + r1, a );\n        uv2 -= 0.52;\n        uv2 *= 2.9;\n        uv2.x -= u_time*0.1;\n        uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        uv3 *= 1.2;\n        uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        vec2 cp0 = vec2(-0.5, 1.95);\n        vec2 cp1 = vec2(0.75, 0.5);\n        vec2 cp3 = vec2(0.5, 0.5);\n        float l = cubicBezierNearlyThroughTwoPoints(uv3.x*0.25, cp0, cp1);\n        float l2 = cubicBezierNearlyThroughTwoPoints(uv4.y*0.25, cp0, cp3);\n        float px = 1. / vUv.y;\n\n        float t1 = uv3.x*7.-2.*u_time+uv3.y*3.;\n        uv3.y += sin(t1) * 0.05;\n        float x = .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        float y = fbm(uv4 + r2 * fbm(uv4 + r2));\n        // color *= .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        \n        color *= vec3( smoothstep(l, l+0.025, vUv.y+0.6));\n        color.g += (1. - smoothstep(l, l+0.025, vUv.y+0.6))* 0.72 * x* y;\n        \n        // color -= vec3(1. - smoothstep(l2, l2, vUv.y+0.5));\n\n        \n        \n        // color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function QL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:ZL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var JL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(1.83/r1 + .95 + u_time * 0.025 + r1, a );\n        uv2 -= 0.52;\n        uv2 *= 2.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        uv3 *= 1.2;\n        uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        vec2 cp0 = vec2(-0.5, 1.95);\n        vec2 cp1 = vec2(0.75, 0.5);\n        vec2 cp3 = vec2(0.5, 0.5);\n        float l = cubicBezierNearlyThroughTwoPoints(uv3.x*0.25, cp0, cp1);\n        float l2 = cubicBezierNearlyThroughTwoPoints(uv4.y*0.25, cp0, cp3);\n        float px = 1. / vUv.y;\n\n        float t1 = uv3.x*7.-2.*u_time+uv3.y*3.;\n        uv3.y += sin(t1) * 0.05;\n        float x = .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        float y = fbm(uv4 + r2 * fbm(uv4 + r2));\n        color *= .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        \n        color *= vec3( smoothstep(l, l+0.025, vUv.y+0.6));\n        color.g += (1. - smoothstep(l, l+0.025, vUv.y+0.6))* 0.72 * x* y;\n        \n        // color -= vec3(1. - smoothstep(l2, l2, vUv.y+0.5));\n\n        \n        \n        // color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function KL(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:JL,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $L=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_texture;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n        \n        // vec2 pic = texture2D(u_texture);\n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 2.5);\n        uv2 = vec2(1.83/r1 + .45 + -u_time * 0.125 + r1, a );\n        uv2 -= 0.52;\n        uv2 *= 1.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        uv3 *= 1.2;\n        uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        vec2 cp0 = vec2(-0.65, 1.95);\n        vec2 cp1 = vec2(0.85, 0.4);\n        vec2 cp3 = vec2(0.5, 0.5);\n        float l = cubicBezierNearlyThroughTwoPoints(uv3.x*0.25, cp0, cp1);\n        float l2 = cubicBezierNearlyThroughTwoPoints(uv4.y*0.25, cp0, cp3);\n        float px = 1. / vUv.y;\n\n        float t1 = uv3.x*7.-2.*u_time+uv3.y*3.;\n        uv3.y += sin(t1) * 0.05;\n        float x = .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        float y = fbm(uv4 + r2 * fbm(uv4 + r2));\n        // color *= .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        \n        color *= vec3( smoothstep(l, l+0.025, vUv.y+0.6));\n        // color.g += (1. - smoothstep(l, l+0.025, vUv.y+0.6))* 0.72 * x* y;\n        \n        // color -= vec3(1. - smoothstep(l2, l2, vUv.y+0.5));\n\n        \n        // color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        vec4 col = texture2D(u_texture, vec2(vUv.x, vUv.y + 0.305));\n        \n        col.xyz += color;\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_texture, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function nA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:$L,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n   \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n        uv2 -= 0.475;\n        // vec2 pic = texture2D(u_texture);\n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 2.75 +0.6) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(.000083/r1 + .45 + -u_time * 0.925 + r1, a );\n        // uv2.x -= 0.52;\n        // uv2 *= 1.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        // uv3 *= 1.2;\n        // uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * f * 0.8),0.0,1.0));\n\n        \n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_texture, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function tA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:eA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var oA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n   \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.5, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n        uv2 -= 0.475;\n        // vec2 pic = texture2D(u_texture);\n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 2.75 +0.6) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 8.5);\n        uv2 = vec2(.003/r1 + u_time * 0.925 + r1, a );\n        // uv2.x -= 0.52;\n        // uv2 *= 1.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        // uv3 *= 1.2;\n        // uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1 + cos(u_time * 0.3), skycolour2 + abs(sin(u_time * 0.1)/5.) - 0.5, clamp((f*f*f + f * f * 0.8),0.,.8));\n\n        \n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_texture, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function rA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:oA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.2,1.); // box position\n    b0p = p-b0p;\n    b0p.yz *=Rotate(u_time * .2);\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.85,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.2,1.); // box position\n    b1p = p-b1p;\n    b1p.yz *=Rotate(u_time * .2);\n    b1p.xz *=Rotate(u_time * .2);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.2,1.); // box position\n    b2p = p-b2p;\n    b2p.yz *=Rotate(u_time * .2);\n    b2p.xz *=Rotate(u_time * .2);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,0.5,1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, s0, 0.15 + sin(u_time * 1.5)/8.);\n     \n    csg2 = smoothDifferenceSDF(csg1, s1, 0.15 + cos(u_time * 1.5)/8.);\n\n    csg3 = smoothDifferenceSDF(csg0, b2, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.,-2.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:aA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    /////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n    // Primitives\n    ///////////////////////\n    \n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n        // Box0\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n        //Box1\n        vec3 b1s = vec3(.85,.5,.5); //box size\n        vec3 b1p = vec3(0.,1.2,1.); // box position\n        b1p = p-b1p;\n        b1p.yz *=Rotate(u_time * .2);\n        b1p.xz *=Rotate(u_time * .2);\n        vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n        //Box2\n        vec3 b2s = vec3(.5,.5,.85); //box size\n        vec3 b2p = vec3(0.,1.2,1.); // box position\n        b2p = p-b2p;\n        b2p.yz *=Rotate(u_time * 1.5);\n        b2p.xz *=Rotate(u_time * 1.5);\n        vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n        // p.xz *=Rotate(u_time * .2);\n    \n        // Sphere.\n        vec3 s0p=vec3(0.,2.,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n        vec3 s1p=vec3(0.,2.2,1.);\n        s1p=p-s1p;\n        s1p.yz *=Rotate(u_time * .2);\n        s1p.xz *=Rotate(u_time * .2);\n        vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.75));\n        \n        // Cylinders\n        float c0h = 1.,c0r = .55; // Cylinder height, radius.\n        vec3 c0p = p - vec3 (0,1,2.); // Position\n        vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n        \n        float c1h = 1.,c1r = .55; \n        vec3 c1p = p - vec3 (0,1,0); \n        c1p.xy *= Rotate(PI*.5);  // Rotate\n        vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n        \n        float c2h = 1.,c2r = .55; \n        vec3 c2p = p - vec3 (0,1,0);\n        c2p.xy *= Rotate(PI*.5);  \n        c2p.yz *= Rotate(PI*.5);  \n        vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n    \n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s1, 0.15); // Intersect box with sphere creating a CSG object.\n\n        scene = unionSDF(csg0, p0);\n    \n        return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:vA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    /////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n    // Primitives\n    ///////////////////////\n    \n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n        // Box0\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n        //Box1\n        vec3 b1s = vec3(.85,.5,.5); //box size\n        vec3 b1p = vec3(0.,2.2 + sin(u_time) * 2.,1.); // box position\n        b1p = p-b1p;\n        b1p.yz *=Rotate(u_time * 1.2);\n        b1p.xz *=Rotate(u_time * 1.2);\n        vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n        //Box2\n        vec3 b2s = vec3(.5,.5,.85); //box size\n        vec3 b2p = vec3(0.,1.2,1.); // box position\n        b2p = p-b2p;\n        b2p.yz *=Rotate(u_time * 1.5);\n        b2p.xz *=Rotate(u_time * 1.5);\n        vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n        // p.xz *=Rotate(u_time * .2);\n    \n        // Sphere.\n        vec3 s0p=vec3(0.,2.,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n        vec3 s1p=vec3(0.,2.2,1.);\n        s1p=p-s1p;\n        s1p.yz *=Rotate(u_time * .2);\n        s1p.xz *=Rotate(u_time * .2);\n        vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.75));\n        \n        // Cylinders\n        float c0h = 1.,c0r = .55; // Cylinder height, radius.\n        vec3 c0p = p - vec3 (0,1,2.); // Position\n        vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n        \n        float c1h = 1.,c1r = .55; \n        vec3 c1p = p - vec3 (0,1,0); \n        c1p.xy *= Rotate(PI*.5);  // Rotate\n        vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n        \n        float c2h = 1.,c2r = .55; \n        vec3 c2p = p - vec3 (0,1,0);\n        c2p.xy *= Rotate(PI*.5);  \n        c2p.yz *= Rotate(PI*.5);  \n        vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n    \n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s1, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15); //intersect\n\n        scene = unionSDF(csg1, p0);\n    \n        return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:lA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //Box2\n        vec3 b1s = vec3(0.25);\n        vec3 b1p = vec3(0., 2.2, 1.);\n        b1p = p - b1p;\n        b1p.yz *=Rotate(-u_time * 2.2);\n        b1p.xz *=Rotate(-u_time * 2.2);\n        vec4 b1 = vec4(BoxColor.rgb, boxSDF(b1p, b1s));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s0, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15);\n\n        scene = smoothUnionSDF(csg1, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function fA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:uA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //Box2\n        vec3 b1s = vec3(0.25);\n        vec3 b1p = vec3(0., 2. + sin(u_time * 1.5) + 0.75 * 1.5, 1.);\n        b1p = p - b1p;\n        b1p.yz *=Rotate(-u_time * 2.2);\n        b1p.xz *=Rotate(-u_time * 2.2);\n        vec4 b1 = vec4(BoxColor.rgb, boxSDF(b1p, b1s));\n\n        //Box3\n        vec3 b2s = vec3(0.25);\n        vec3 b2p = vec3(0. + cos(u_time * 1.5) * 2.25, 2. + sin(u_time * 1.5) * 0.5, 1.);\n        b2p = p - b2p;\n        b2p.yz *=Rotate(u_time * 2.2);\n        b2p.xz *=Rotate(u_time * 2.2);\n        vec4 b2 = vec4(BoxColor.rgb, boxSDF(b2p, b2s));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s0, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b2, 0.15);\n\n        scene = smoothUnionSDF(csg2, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        #ifdef ANTIALIASING\n        vec3 oh = vec3(0.0);\n        vec4 tmp = vec4(0.0);\n        #endif\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function mA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:pA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var dA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n        //Box2\n        vec3 b1s = vec3(0.25);\n        vec3 b1p = vec3(0. + sin(u_time * 1.5) * 2.25, 2. + cos(u_time * 1.5) * 0.5, 1.);\n        b1p = p - b1p;\n        b1p.yz *=Rotate(-u_time * 2.2);\n        b1p.xz *=Rotate(-u_time * 2.2);\n        vec4 b1 = vec4(BoxColor.rgb, boxSDF(b1p, b1s));\n\n        //Box3\n        vec3 b2s = vec3(0.25);\n        vec3 b2p = vec3(0. + cos(u_time * 1.5) * 2.25, 2. + sin(u_time * 1.5) * 0.5, 1.);\n        b2p = p - b2p;\n        b2p.yz *=Rotate(u_time * 2.2);\n        b2p.xz *=Rotate(u_time * 2.2);\n        vec4 b2 = vec4(BoxColor.rgb, boxSDF(b2p, b2s));\n        \n            \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        vec3 s1p=vec3(0. + sin(u_time * 1.5) * 2.25, 2. + cos(u_time * 1.5) * 0.5, 1.);\n        s1p=p-s1p;\n        vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.25));\n\n        vec3 s2p=vec3(0. + cos(u_time * 1.5) * 2.25, 2. + sin(u_time * 1.5) * 0.5, 1.);\n        s2p=p-s2p;\n        vec4 s2 = vec4(SphereColor.rgb,sphereSDF(s2p,.25));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s0, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b2, 0.15);\n\n        csg3 = smoothDifferenceSDF(csg2, s1, 0.15);\n\n        csg4 = smoothDifferenceSDF(csg3, s2, 0.15);\n\n        scene = smoothUnionSDF(csg4, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    vec4 fC(vec2 vUv){\n        vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-6.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        return vec4(color, 1.);\n    }\n\n    void main()\n    {\n        //https://www.shadertoy.com/view/wtjfRV\n        //anti-alias\n        gl_FragColor = vec4(0.);\n        float A = 4.;  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!  \n        float s = 1./A, x, y;\n        for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) gl_FragColor += min ( fC(vec2(vUv.x,vUv.y)), 1.0);\n        gl_FragColor /= A*A;\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function hA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:dA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(.75,.75,.75); //box size\n        vec3 bfp = vec3(0.,2.2,1.); // box position\n        bfp = p - bfp;\n        bfp.yz *=Rotate(u_time * 1.2);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.025));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        // csg0 = smoothDifferenceSDF(bf, s0, 0.15); \n\n        scene = smoothUnionSDF(bf, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        #ifdef ANTIALIASING\n        vec3 oh = vec3(0.0);\n        vec4 tmp = vec4(0.0);\n        #endif\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:xA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(1.5,1.5,1.5); //box size\n        vec3 bfp = vec3(0.,2.2,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time + 0.5) * 1.25);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.05));\n\n        //box frame\n        vec3 bfs2 = vec3(.75,.75,.75); //box size\n        vec3 bfp2 = vec3(0.,2.2,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time + 0.25) * 1.25);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.05));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time) * 1.25);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.05));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(bf, bf2, 0.15); \n\n        scene = smoothUnionSDF(csg0, bf3, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,4.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,5.,-8.0 + sin(u_time) + .45 * 15.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.3); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function bA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:gA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _A=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(1.5,1.5,1.5); //box size\n        vec3 bfp = vec3(0.,2.2,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.075));\n\n        //box frame\n        vec3 bfs2 = vec3(.75,.75,.75); //box size\n        vec3 bfp2 = vec3(0.,2.2,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.125) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.075));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(bf, bf2, 0.15); \n\n        csg1 = smoothUnionSDF(csg0, bf3, 0.15);\n\n        scene = smoothUnionSDF(csg1, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,6.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-4. + sin(u_time * 0.25 + 0.5)  * 5.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // rd.zy *= Rotate(PI*-.2); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:_A,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(bf, bf2, 0.15); \n\n        scene = smoothUnionSDF(csg0, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8.,-2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 2.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-5.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // rd.zy *= Rotate(PI*-.2); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function SA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:wA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var MA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(u_time * 1.2);\n        hexPrismPosition.xz *=Rotate(u_time * 1.2);\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        // csg0 = smoothUnionSDF(hexPrism, bf2, 0.15); \n\n        scene = smoothUnionSDF(hexPrism, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-5.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:MA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/2.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        //hex prism2\n        vec2 hexPrismSize2 = vec2(0.5, 0.9 + (sin(u_time)/2. )+ 0.75);\n        vec3 hexPrismPosition2 = vec3(0., 2., 0.);\n        hexPrismPosition2 = p - hexPrismPosition2;\n        hexPrismPosition2.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition2.xz *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism2 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition2, hexPrismSize2));\n\n        //hex prism3\n        vec2 hexPrismSize3 = vec2(0.5, 0.9 + (sin(u_time)/2. )+ 0.75);\n        vec3 hexPrismPosition3 = vec3(0., 2., 0.);\n        hexPrismPosition3 = p - hexPrismPosition3;\n        hexPrismPosition3.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition3.xy *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism3 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition3, hexPrismSize3));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(hexPrism, hexPrism2, 0.15); \n\n        csg1 = smoothUnionSDF(csg0, hexPrism3, 0.15);\n\n        scene = smoothUnionSDF(csg1, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-8.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function CA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:kA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.,0.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/4.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        //hex prism2\n        vec2 hexPrismSize2 = vec2(0.5, 0.9 + (sin(u_time)/4. )+ 0.75);\n        vec3 hexPrismPosition2 = vec3(0., 2., 0.);\n        hexPrismPosition2 = p - hexPrismPosition2;\n        hexPrismPosition2.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition2.xz *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism2 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition2, hexPrismSize2));\n\n        //hex prism3\n        vec2 hexPrismSize3 = vec2(0.5, 0.9 + (sin(u_time)/4. )+ 0.75);\n        vec3 hexPrismPosition3 = vec3(0., 2., 0.);\n        hexPrismPosition3 = p - hexPrismPosition3;\n        hexPrismPosition3.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition3.xy *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism3 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition3, hexPrismSize3));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(hexPrism, hexPrism2, 0.15); \n\n        csg1 = smoothUnionSDF(csg0, hexPrism3, 0.15);\n\n        csg2 = smoothDifferenceSDF(csg1, s0, 0.15);\n\n        scene = smoothUnionSDF(csg2, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-8.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function RA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:TA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.25); //box size\n        vec3 b0p = vec3(0.,2.0,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.,0.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/4.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(hexPrism, hexPrism, 0.15); \n\n        csg1 = smoothDifferenceSDF(csg0, s0, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b0, 0.15);\n\n        scene = smoothUnionSDF(csg2, csg2, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-8.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function PA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:DA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var FA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    float opOnion( in float sdf, in float thickness )\n    {\n        return abs(sdf)-thickness;\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        float n = cnoise(p + (u_time)) * 0.1;\n        p.x += n;\n        p.y += n * 2.;\n        p.z += n * 5.;\n        vec3 q = abs(p) - b;\n        \n        \n        return length(max(q ,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.25); //box size\n        vec3 b0p = vec3(0.,2.0,1.); // box position\n        // float n = cnoise(b0s) + sin(u_time);\n        // b0s += n;\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        float box = boxSDF(b0p, b0s);\n        vec4 b0 = vec4(BoxColor.rgb, box); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.,0.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/4.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(b0, p0, 0.15); \n\n        csg1 = smoothDifferenceSDF(csg0, s0, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b0, 0.15);\n\n        scene = smoothUnionSDF(csg0, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.,-2.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function jA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:FA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var IA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n    #define S smoothstep\n    #define T u_time\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float GetDist(vec3 p){\n        float d = sdBox(p, vec3(1.));\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.001, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy/u_resolution.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3);\n        ro.yz *= Rot(-T*PI + 1. * 0.125);\n        ro.xz *= Rot(-T*TWO_PI * 0.125);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        vec3 col = vec3(0.);\n\n        float d = RayMarch(ro, rd);\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d;\n            vec3 n = GetNormal(p);\n            vec3 r = reflect(rd, n);\n\n            float dif = dot(n , normalize(vec3(1., 2., 3.))) * .5 + .5;\n            col = vec3(dif);\n            color += col;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function EA(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),addEventListener("mousemove",(function(n){n.clientX,window.innerWidth,n.clientY,window.innerHeight})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:n,material:IA,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function OA(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float GetDist(vec3 p){\n        float d = sdBox(p, vec3(1.));\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.001, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3);\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 reflectDir = reflect(rd, n);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n\n            vec3 reflTex = texture(u_cubemap, rdOut).rgb;\n\n            col = vec3(reflTex);\n            color += col;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function LA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float GetDist(vec3 p){\n\n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        p = abs(p);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(0.);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function AA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        vec3 p1 = p;\n        vec3 p2 = p;\n        // p1.x -= 0.65;\n        p2.x += sin(u_time) * 1.5;\n\n        p2.xy *= Rot(u_time * .4);\n        p2.yz *= Rot(u_time * .4);\n        p2.xz *= Rot(u_time * .4);\n\n        p1.xy *= Rot(u_time * .4);\n        p1.yz *= Rot(u_time * .4);\n        p1.xz *= Rot(u_time * .4);\n\n        float d1 = sdTorus(p2, vec2(0.5, 0.2));\n\n        float d2 = sdBox(p1, vec3(0.5));\n\n        float d = opSmoothUnion(d1, d2, 0.15);\n\n        // float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        // vec3 n = vec3(-0.5, -c, s);\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.6);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function GA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        vec3 p1 = p;\n        vec3 p2 = p;\n        // p1.x -= 0.65;\n        // p2.x += sin(u_time) * 1.5;\n\n        p2.xy *= Rot(u_time * .4);\n        p2.yz *= Rot(u_time * .4);\n        p2.xz *= Rot(u_time * .4);\n\n        p1.xy *= Rot(u_time * .4);\n        p1.yz *= Rot(u_time * .4);\n        p1.xz *= Rot(u_time * .4);\n\n        float d1 = sdTorus(p2, vec2(0.5, 0.2));\n\n        float d2 = sdBox(p1, vec3(0.5));\n\n        float d = opSmoothSubtraction(d1, d2, 0.15);\n\n        \n\n        for(int i = 0; i < 4; i++){\n            float c = cos(PI/5.), s = sqrt(0.75-c*c);\n            vec3 n = vec3(-0.5, -c, s);\n            p1.xy = abs(p.xy);\n            p1 -= 2. * min(0., dot(p1, n)) * n;\n        }\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.6);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function NA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        vec3 p1 = p;\n        vec3 p2 = p;\n        // p1.x -= 0.65;\n        // p2.x += sin(u_time) * 1.5;\n\n        p2.xy *= Rot(u_time * .4);\n        p2.yz *= Rot(u_time * .4);\n        p2.xz *= Rot(u_time * .4);\n\n        p1.xy *= Rot(u_time * .4);\n        p1.yz *= Rot(u_time * .4);\n        p1.xz *= Rot(u_time * .4);\n\n        float d1 = sdTorus(p2, vec2(0.5, 0.2));\n\n        float d2 = sdBox(p1, vec3(0.5));\n\n        // float d = opSmoothUnion(d1, d2, 0.15);\n\n        float d = d1;\n        \n\n        for(int i = 0; i < 4; i++){\n            float c = cos(PI/5.), s = sqrt(0.75-c*c);\n            vec3 n = vec3(-0.5, -c, s);\n            p1.xy = abs(p.xy);\n            p1 -= 2. * min(0., dot(p1, n)) * n;\n        }\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.6);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function BA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        p = abs(p);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.5);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            // vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            // col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function qA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        p = abs(p);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.5);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            // vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            // col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n\n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function VA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.5);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            // vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            // col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.25 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif * col);\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function WA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xy *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p, vec2(0.5, 0.15));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d2;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.yx *= Rot(-m.x*PI + 1.);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif * col);\n        // float m = 0.;\n        float t = u_time;\n        for (float i = 0.; i <=1.; i+= 1./4.){\n            float z = fract(i + t);\n            float size = mix(10., .5, z);\n            ro.z *= size;\n            color += col;\n        }\n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function HA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xy *= Rot(u_time * .3);\n        p2.xy *= Rot(u_time * .5);\n        p3.xy *= Rot(u_time * .7);\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p2), vec2(0.25, 0.15));\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        return total;\n        \n\n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.yx *= Rot(-m.x*PI + 1.);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n        // float m = 0.;\n        // float t = u_time;\n        // for (float i = 0.; i <=1.; i+= 1./4.){\n        //     float z = fract(i + t);\n        //     float size = mix(10., .5, z);\n        //     ro.z *= size;\n        //     color += col;\n        // }\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function XA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=((new vf).load(o),new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xy *= Rot(u_time * 1.3);\n        p.yz *= Rot(u_time * 1.7);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        return total;\n        \n\n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        // ro.yx *= Rot(-m.x*PI + 1.);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n        // float m = 0.;\n        // float t = u_time;\n        // for (float i = 0.; i <=1.; i+= 1./4.){\n        //     float z = fract(i + t);\n        //     float size = mix(10., .5, z);\n        //     ro.z *= size;\n        //     color += col;\n        // }\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}})),a=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=a.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[a.current]),Bd((function(t){var o=t.clock;a.current.material.uniforms.u_time.value=o.elapsedTime,a.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:a,material:r,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function YA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=((new vf).load(o),new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.xy *= Rot(u_time * 1.3);\n        // p.yz *= Rot(u_time * 1.7);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        total = opSmoothUnion(total, plane, 0.15);\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,5.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        // ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n       \n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}})),a=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=a.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[a.current]),Bd((function(t){var o=t.clock;a.current.material.uniforms.u_time.value=o.elapsedTime,a.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:a,material:r,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function ZA(){var n,e,t=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xz *= Rot(PI * 0.5);\n        p1.xy *= Rot(u_time * 1.5);\n        p1.yz *= Rot(u_time * 1.5);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p1), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        total = opSmoothUnion(total, plane, 0.15);\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        // ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif + col);\n       \n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}}),o=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=o.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[o.current]),Bd((function(t){var r=t.clock;o.current.material.uniforms.u_time.value=r.elapsedTime,o.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:o,material:t,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function QA(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xz *= Rot(PI * 0.5);\n        p1.xy *= Rot(u_time * 1.5);\n        p1.yz *= Rot(u_time * 1.5);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p1), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        // total = opSmoothUnion(total, plane, 0.15);\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function JA(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n\n        p2.zy *= Rot(PI * 0.5);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float total = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 0.75);\n\n        total = opSmoothSubtraction(total, d2, 0.15);\n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function KA(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n\n        p2.zy *= Rot(PI * 0.5 + u_time);\n        p2.xy *= Rot(PI * 0.5 + u_time);\n        p2.zx *= Rot(PI * 0.5 + u_time);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 0.75);\n\n        float total = opSmoothSubtraction(d1, d2, 0.15);\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function $A(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n\n        p2.zy *= Rot(PI * 0.5 + u_time);\n        p2.xy *= Rot(PI * 0.5 + u_time);\n        p2.zx *= Rot(PI * 0.5 + u_time);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5 + sin(u_time)/4. + 0.2));\n\n        float d2 = sdSphere(p, 0.75 + sin(u_time)/4. + 0.2);\n\n        float total = opSmoothSubtraction(d1, d2, 0.15);\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(PI * 0.5);\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function nG(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.y += 1.;\n\n        \n        p2.zy *= Rot(PI * 0.5 + u_time);\n        p2.xy *= Rot(PI * 0.5 + u_time);\n        p2.zx *= Rot(PI * 0.5 + u_time);\n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 0.75 + sin(u_time)/4. + 0.2);\n\n        float total = d1;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(PI * 0.5);\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.8);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function eG(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.y += 1.;\n\n        \n        // p.zy *= Rot(PI * 0.5 + u_time);\n        p.xy *= Rot(PI * 0.5 + u_time);\n        p.zx *= Rot(PI * 0.5 + u_time);\n\n        p.xz *= Rot(PI * 0.5);\n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.8);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function tG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.y += 1.;\n\n        \n        // p.zy *= Rot(PI * 0.5 + u_time);\n        p.xy *= Rot(PI * 0.5 + u_time);\n        p.zx *= Rot(PI * 0.5 + u_time);\n\n        p.xz *= Rot(PI * 0.5);\n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function oG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        \n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        \n\n        vec3 ro = vec3 (0., 3., -4) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap,-rd).rgb;\n        // vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function rG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        \n        p += cnoise(p) * (0.2 * sin(u_time));\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        \n\n        vec3 ro = vec3 (0., 3., -4) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap,-rd).rgb;\n        // vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            // p += cnoise(p) * 0.1;\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r += cnoise(reflTex);\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function aG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        \n        p1 += (cnoise(p1 + sin(u_time)) * 0.1) * (sin(u_time) / 10. + 1.);\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p1, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        \n\n        vec3 ro = vec3 (0., 3., -4) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap,-rd).rgb;\n        // vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            // p += cnoise(p) * 0.1;\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            reflTex.r += cnoise(reflTex) * 0.5;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            reflTex.g += cnoise(reflTex) * 0.2;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            reflTex.b += cnoise(reflTex) * 0.2;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Bd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){o=n.changedTouches[0].clientX/window.innerWidth,r=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iG=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        return m;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        \n\n        float an = -u_time * 0.5;\n        float r1 = length(uv2 * 3.5) ;\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 * 1.25 + r1, a );\n\n        float m = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .1, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            m += Layer(uv2 * size + i * 20.) * fade;\n        }\n\n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = m * base;\n        // col += uv2.y * base * 0.2;\n        // col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vG(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:iG,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cG=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        return m;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        \n        uv2 *= 1.5;\n\n        float an = -u_time * 0.5;\n        float r1 = length(uv2 * 1.75) ;\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.25);\n        uv2 = vec2(0.053/r1 + .95 * .25 + r1, a * 0.15);\n\n        float m = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .1, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            m += Layer(uv2 * size + i * 20.) * fade;\n        }\n\n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = m * base;\n        // col += uv2.y * base * 0.2;\n        // col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function lG(){var n=(0,Lm.useRef)();return Bd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{ref:n,material:cG,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function sG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        vec2 m = u_mouse.xy;\n        vec2 uv2 = vUv;\n        uv2 -= .5;\n\n        vec3 col = vec3((sin(u_time)/2.) + 0.5, 0.5, 0.);\n\n        float d = length(vUv - abs(u_mouse.xy)) - 0.2;\n        color += (step(0., -d)) * col;\n\n        float glow = 0.005/ d;\n        glow = clamp(glow, 0., 1.);\n        glow = glow * 15. * (sin(u_time)/10. + 0.75);\n\n        color += col * glow ;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)(),v=new Oo,c=new Oo(-1,-1,0),l=new Oo(1,-1,0);new Oo(-1,1,0),new Oo(1,1,0);(0,Lm.useEffect)((function(){(new Go).setFromObject(i.current).getSize(v)}),[i.current]),Nd((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function uG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        vec2 m = u_mouse.xy;\n        vec2 uv2 = vUv;\n        uv2 += .5;\n\n        vec3 col = vec3((sin(u_time))/2. + 1., 0.3, 0.);\n\n        float n = noise2D(uv2 + u_time) * .5;\n        \n\n        float cir = circle(uv2 - abs(u_mouse.xy), 0.05) * n;\n        float d = length(vUv  - abs(u_mouse.xy) ) - 0.25 ;\n        color = (step(0., -d)) * col * n;\n        // color += cir * col;\n\n        \n\n        float glow = 0.001/ -d * n;\n        float glow2 = 0.01/ d * n;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        color += col * glow * 2.;\n        color += col * glow2 * 2.;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)(),v=new Oo,c=new Oo(-1,-1,0),l=new Oo(1,-1,0);new Oo(-1,1,0),new Oo(1,1,0);(0,Lm.useEffect)((function(){(new Go).setFromObject(i.current).getSize(v)}),[i.current]),Nd((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function fG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    // float rand(vec2 n) { \n    //     return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    // }\n    \n    // float noise2D(vec2 p){\n    //     vec2 ip = floor(p);\n    //     vec2 u = fract(p);\n    //     u = u*u*(3.0-2.0*u);\n        \n    //     float res = mix(\n    //         mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    //         mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    //     return res*res;\n    // }\n\n    float glow(vec2 uv2, vec2 m){\n        m = vec2(u_mouse.xy);\n        float n = noise2D(uv2 + u_time) * .5;\n        float d = length(vUv  - abs(u_mouse.xy) ) - 0.25 ;\n        //color = (step(0., -d)) * col * n;\n        //color += cir * col;\n\n        \n        float glow = 0.001/ -d * n;\n        float glow2 = 0.01/ d * n;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        return glow + glow2;\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n\n        vec3 colx = vec3((sin(u_time))/2. + 1., 0.3, 0.);\n\n        float x = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .5, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            x += glow(uv2 * size + i * 20., vec2(u_mouse.xy)) * fade;\n        }\n        \n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = x * base;\n        col += uv2.y * base * 0.2;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)(),v=new Oo,c=new Oo(-1,-1,0),l=new Oo(1,-1,0);new Oo(-1,1,0),new Oo(1,1,0);(0,Lm.useEffect)((function(){(new Go).setFromObject(i.current).getSize(v)}),[i.current]),Nd((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function pG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float glow(vec2 uv2, vec2 m){\n        m = vec2(u_mouse.xy);\n        float n = noise2D(uv2 + u_time) * .5;\n        float d = length(vUv  - abs(u_mouse.xy) ) - 0.25 ;\n        //color = (step(0., -d)) * col * n;\n        //color += cir * col;\n\n        \n        float glow = 0.001/ -d * n;\n        float glow2 = 0.0001/ d * n;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        return glow + glow2;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            // m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += glow(uv2, vec2(u_mouse.xy));\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        return m;\n    }\n\n    \n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n\n        vec3 colx = vec3((sin(u_time))/2. + 1., 0.3, 0.);\n\n        float x = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .5, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            x += Layer(uv2 * size + i * 20.) * fade;\n        }\n        \n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = x * base;\n        col += uv2.y * base * 0.2;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)(),v=new Oo,c=new Oo(-1,-1,0),l=new Oo(1,-1,0);new Oo(-1,1,0),new Oo(1,1,0);(0,Lm.useEffect)((function(){(new Go).setFromObject(i.current).getSize(v)}),[i.current]),Nd((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mG=["children","eps","style","className","prepend","center","fullscreen","portal","distanceFactor","sprite","transform","occlude","onOcclude","zIndexRange","calculatePosition","as","wrapperClass","pointerEvents"],dG=new Oo,hG=new Oo,xG=new Oo;function yG(n,e,t){var o=dG.setFromMatrixPosition(n.matrixWorld);o.project(e);var r=t.width/2,a=t.height/2;return[o.x*r+r,-o.y*a+a]}var gG=function(n){return Math.abs(n)<1e-10?0:n};function bG(n,e){for(var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",o="matrix3d(",r=0;16!==r;r++)o+=gG(e[r]*n.elements[r])+(15!==r?",":")");return t+o}var _G,UG=(_G=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],function(n){return bG(n,_G)}),wG=function(n,e){return bG(n,[1/(t=e),1/t,1/t,1,-1/t,-1/t,-1/t,-1,1/t,1/t,1/t,1,1,1,1,1],"translate(-50%,-50%)");var t},SG=Lm.forwardRef((function(n,e){var t=n.children,r=n.eps,a=void 0===r?.001:r,i=n.style,v=n.className,l=n.prepend,s=n.center,f=n.fullscreen,p=n.portal,m=n.distanceFactor,d=n.sprite,h=void 0!==d&&d,x=n.transform,y=void 0!==x&&x,g=n.occlude,b=n.onOcclude,_=n.zIndexRange,U=void 0===_?[16777271,0]:_,w=n.calculatePosition,S=void 0===w?yG:w,M=n.as,z=void 0===M?"div":M,k=n.wrapperClass,C=n.pointerEvents,T=void 0===C?"auto":C,R=o(n,mG),D=Nd(),P=D.gl,F=D.camera,j=D.scene,I=D.size,E=D.raycaster,O=D.events,L=c(Lm.useState((function(){return document.createElement(z)})),1)[0],A=Lm.useRef(),G=Lm.useRef(null),N=Lm.useRef(0),B=Lm.useRef([0,0]),q=Lm.useRef(null),V=Lm.useRef(null),W=(null==p?void 0:p.current)||O.connected||P.domElement.parentNode;Lm.useLayoutEffect((function(){if(G.current){var n=A.current=Ih.s(L);if(j.updateMatrixWorld(),y)L.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{var e=S(G.current,F,I);L.style.cssText="position:absolute;top:0;left:0;transform:translate3d(".concat(e[0],"px,").concat(e[1],"px,0);transform-origin:0 0;")}return W&&(l?W.prepend(L):W.appendChild(L)),function(){W&&W.removeChild(L),n.unmount()}}}),[W,y]),Lm.useLayoutEffect((function(){k&&(L.className=k)}),[k]);var H=Lm.useMemo((function(){return y?{position:"absolute",top:0,left:0,width:I.width,height:I.height,transformStyle:"preserve-3d",pointerEvents:"none"}:u(u({position:"absolute",transform:s?"translate3d(-50%,-50%,0)":"none"},f&&{top:-I.height/2,left:-I.width/2,width:I.width,height:I.height}),i)}),[i,s,f,I,y]),X=Lm.useMemo((function(){return{position:"absolute",pointerEvents:T}}),[T]);Lm.useLayoutEffect((function(){var n,o;y?null==(n=A.current)||n.render(Lm.createElement("div",{ref:q,style:H},Lm.createElement("div",{ref:V,style:X},Lm.createElement("div",{ref:e,className:v,style:i,children:t})))):null==(o=A.current)||o.render(Lm.createElement("div",{ref:e,style:H,className:v,children:t}))}));var Y=Lm.useRef(!0);return Bd((function(){if(G.current){F.updateMatrixWorld(),G.current.updateWorldMatrix(!0,!1);var n=y?B.current:S(G.current,F,I);if(y||Math.abs(N.current-F.zoom)>a||Math.abs(B.current[0]-n[0])>a||Math.abs(B.current[1]-n[1])>a){var e=function(n,e){var t=dG.setFromMatrixPosition(n.matrixWorld),o=hG.setFromMatrixPosition(e.matrixWorld),r=t.sub(o),a=e.getWorldDirection(xG);return r.angleTo(a)>Math.PI/2}(G.current,F),t=!1;"boolean"===typeof g?!0===g&&(t=[j]):Array.isArray(g)&&(t=g.map((function(n){return n.current})));var o=Y.current;if(t){var r=function(n,e,t,o){var r=dG.setFromMatrixPosition(n.matrixWorld),a=r.clone();a.project(e),t.setFromCamera(a,e);var i=t.intersectObjects(o,!0);if(i.length){var v=i[0].distance;return r.distanceTo(t.ray.origin)<v}return!0}(G.current,F,E,t);Y.current=r&&!e}else Y.current=!e;if(o!==Y.current&&(b?b(!Y.current):L.style.display=Y.current?"block":"none"),L.style.zIndex="".concat(function(n,e,t){if(e instanceof Wa||e instanceof di){var o=dG.setFromMatrixPosition(n.matrixWorld),r=hG.setFromMatrixPosition(e.matrixWorld),a=o.distanceTo(r),i=(t[1]-t[0])/(e.far-e.near),v=t[1]-i*e.far;return Math.round(i*a+v)}}(G.current,F,U)),y){var i=I.width/2,v=I.height/2,c=F.projectionMatrix.elements[5]*v,l=F.isOrthographicCamera,s=F.top,u=F.left,f=F.bottom,p=F.right,d=UG(F.matrixWorldInverse),x=l?"scale(".concat(c,")translate(").concat(gG(-(p+u)/2),"px,").concat(gG((s+f)/2),"px)"):"translateZ(".concat(c,"px)"),_=G.current.matrixWorld;h&&((_=F.matrixWorldInverse.clone().transpose().copyPosition(_).scale(G.current.scale)).elements[3]=_.elements[7]=_.elements[11]=0,_.elements[15]=1),L.style.width=I.width+"px",L.style.height=I.height+"px",L.style.perspective=l?"":"".concat(c,"px"),q.current&&V.current&&(q.current.style.transform="".concat(x).concat(d,"translate(").concat(i,"px,").concat(v,"px)"),V.current.style.transform=wG(_,1/((m||10)/400)))}else{var w=void 0===m?1:function(n,e){if(e instanceof di)return e.zoom;if(e instanceof Wa){var t=dG.setFromMatrixPosition(n.matrixWorld),o=hG.setFromMatrixPosition(e.matrixWorld),r=e.fov*Math.PI/180,a=t.distanceTo(o);return 1/(2*Math.tan(r/2)*a)}return 1}(G.current,F)*m;L.style.transform="translate3d(".concat(n[0],"px,").concat(n[1],"px,0) scale(").concat(w,")")}B.current=n,N.current=F.zoom}}})),Lm.createElement("group",rh({},R,{ref:G}))}));function MG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e),o=Bh((function(n){return n.currentShader}));console.log(o);var r=Bh((function(n){return n.setSongOn})),a=Bh((function(n){return n.startSong})),i=Bh((function(n){return n.setSongOff})),v=null,l=null;Nd((function(n){v=n.camera,l=n.gl}));var s=c((0,Lm.useState)(!1),2),u=s[0],f=s[1],p=l.capabilities.isWebGL2?he:fe,m=new Kf,d=(0,Lm.useRef)(),h=(0,Lm.useRef)(),x=(0,Lm.useRef)();x.current=new $f(m),v&&v.add(m);var y,g,b=new Af,_=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_audio;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(.0, 0., 0.);\n        vec3 bckgdcl = vec3(0.825, 0.5, 0.6);\n        vec2 uv2 = vUv;\n        // uv2 -= .5;\n\n        float f = texture2D(u_audio, vec2(vUv.x, 0.)).r;\n        f = clamp(f, 0.1, 0.9);\n        float i = step( uv2.y, f ) * step( f - 0.0125, uv2.y );\n        \n        vec3 col = mix(color, bckgdcl, i);\n\n        color += col.g * i;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t},u_audio:{value:h.current}}}),U=(0,Lm.useRef)();Bd((function(n){var e=n.clock;d.current&&d.current.getFrequencyData(),U.current.material.uniforms.u_time.value=e.elapsedTime,U.current.material.uniforms.u_mouse.value=new ao(y,g),U.current.material.uniforms.u_audio.value&&(U.current.material.uniforms.u_audio.value.needsUpdate=!0),m.needsUpdate=!0})),addEventListener("mousemove",(function(n){y=n.clientX/window.innerWidth,g=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){y=n.changedTouches[0].clientX/window.innerWidth,g=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1});return(0,Hh.jsxs)(Hh.Fragment,{children:[!u&&(0,Hh.jsx)(SG,{children:(0,Hh.jsx)("div",{className:"play",children:(0,Hh.jsx)("button",{onClick:function(){b.load("./Audio/new-adventure-matrika.ogg",(function(n){x.current.setBuffer(n),x.current.setLoop(!1),x.current.setVolume(.5),console.log(x.current),x.current.play(),d.current=new ap(x.current,128),h.current=new ml(d.current.data,64,1,p),x.current.isPlaying&&(console.log("playing"),f(!0),r(),a()),x.current.isPlaying||(console.log("ended"),f(!1),i())}))},style:{cursor:"pointer",color:"white",alignItems:"center",display:"inline-flex",justifyContent:"center",position:"absolute",left:"50%",top:"50%",transform:"translate(-50%, -50%)",backgroundColor:"#00000000",padding:"10px"},children:"Play"})})}),(0,Hh.jsx)("mesh",{dispose:null,ref:U,material:_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})]})}function zG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e),o=Bh((function(n){return n.currentShader}));console.log(o);var r=Bh((function(n){return n.setSongOn})),a=Bh((function(n){return n.startSong})),i=Bh((function(n){return n.setSongOff})),v=null,l=null;Nd((function(n){v=n.camera,l=n.gl}));var s=c((0,Lm.useState)(!1),2),u=s[0],f=s[1],p=l.capabilities.isWebGL2?he:fe,m=new Kf,d=(0,Lm.useRef)(),h=(0,Lm.useRef)(),x=(0,Lm.useRef)();x.current=new $f(m),v&&v.add(m);var y,g,b=new Af,_=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_audio;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float glow(vec2 uv2, vec2 m){\n        m = vec2(u_mouse.xy);\n        float f = texture2D(u_audio, m * 0.5).r;\n        float n = (noise2D(vUv + u_time) * .5 + f ) * 0.5;\n        float n2 = noise2D(vec2(uv2.x * f, uv2.y - f) ) * 0.125;\n        float d = length((vUv + n2) - abs(u_mouse.xy) ) - 0.25 ;\n        //color = (step(0., -d)) * col * n;\n        //color += cir * col;\n\n        \n        float glow = 0.002/ -d * n ;\n        float glow2 = 0.002/ d * n ;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        return glow + glow2;\n    }\n\n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(.0, 0., 0.);\n        vec3 bckgdcl = vec3(0.825, 0.5, 0.6);\n        vec2 uv2 = vUv;\n        // uv2 -= .5;\n\n        uv2 = Rot(uv2, u_time * 0.25);\n\n        float f = texture2D(u_audio, vec2(vUv.x* .75, 0.)).r;\n        // f = clamp(f, 0.1, 0.9);\n\n        float x = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .5, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            x += glow(uv2 * size + i * 20., vec2(u_mouse.xy)) * fade;\n        }\n        \n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = x * base;\n        col += uv2.y * base * 0.2 ;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        \n        float i = step( uv2.y, f ) * step( f - 0.0125, uv2.y );\n        \n        // vec3 col = mix(color, bckgdcl, i);\n\n        // color += col.g * i;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t},u_audio:{value:h.current}}}),U=(0,Lm.useRef)();Bd((function(n){var e=n.clock;d.current&&d.current.getFrequencyData(),U.current.material.uniforms.u_time.value=e.elapsedTime,U.current.material.uniforms.u_mouse.value=new ao(y,g),U.current.material.uniforms.u_audio.value&&(U.current.material.uniforms.u_audio.value.needsUpdate=!0),m.needsUpdate=!0})),addEventListener("mousemove",(function(n){y=n.clientX/window.innerWidth,g=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){y=n.changedTouches[0].clientX/window.innerWidth,g=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1});return(0,Hh.jsxs)(Hh.Fragment,{children:[!u&&(0,Hh.jsx)(SG,{children:(0,Hh.jsx)("div",{className:"play",children:(0,Hh.jsx)("button",{onClick:function(){b.load("./Audio/polaroid-arston.ogg",(function(n){x.current.setBuffer(n),x.current.setLoop(!1),x.current.setVolume(.5),console.log(x.current),x.current.play(),d.current=new ap(x.current,128),h.current=new ml(d.current.data,64,1,p),x.current.isPlaying&&(console.log("playing"),f(!0),r(),a()),x.current.isPlaying||(console.log("ended"),x.current.pause(),f(!1),i())}))},style:{cursor:"pointer",color:"white",alignItems:"center",display:"inline-flex",justifyContent:"center",position:"absolute",left:"50%",top:"50%",transform:"translate(-50%, -50%)",backgroundColor:"#00000000",padding:"10px"},children:"Play"})})}),(0,Hh.jsx)("mesh",{dispose:null,ref:U,material:_,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})]})}function kG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e),o=Bh((function(n){return n.currentShader}));console.log(o);var r=Bh((function(n){return n.setSongOn})),a=Bh((function(n){return n.startSong})),i=(Bh((function(n){return n.setSongOff})),null),v=null;Nd((function(n){i=n.camera,v=n.gl}));var l=c((0,Lm.useState)(!1),2),s=l[0],u=l[1],f=v.capabilities.isWebGL2?he:fe,p=new Kf,m=(0,Lm.useRef)(),d=(0,Lm.useRef)(),h=(0,Lm.useRef)();h.current=new $f(p),i&&i.add(p),(new Af).load("./Audio/new-adventure-matrika.ogg",(function(n){h.current.setBuffer(n),h.current.setLoop(!1),h.current.setVolume(.5)}));var x,y,g=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_audio;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float blob(vec2 vUv, float x, float y){\n        vec2 audioVal;\n        audioVal.x = texture2D(u_audio, vec2(vUv.x / 2., 0.)).r;\n        audioVal.y = texture2D(u_audio, vec2(vUv.y / 2., 0.)).r;\n        vUv *= y;\n        vec2 pos = vec2(y/2.) - vUv;\n        float r = length(pos) * 2.0;\n        float a = atan(pos.y, pos.x);\n        float f = abs(cos(a * 13. * audioVal.y) * sin(a * (x))) * .02  + .25 * audioVal.y;\n        return 1. - smoothstep(f, f+0.01, r);\n    }\n\n    float blobOutline(vec2 vUv, float x, float y){\n        vec2 audioVal;\n        audioVal.x = texture2D(u_audio, vec2(vUv.x / -2., 0.)).r;\n        audioVal.y = texture2D(u_audio, vec2(vUv.y / 2., 0.)).r;\n        vUv *= y;\n        float noise = (noise2D(vUv + audioVal)) * 15. * audioVal.x;\n        // x += noise;\n        vec2 pos = vec2(y/2.) - vUv;\n        float r = length(pos ) * 2.0;\n        float a = atan(pos.y , pos.x );\n        float f = abs(cos(a * 13. * audioVal.x ) * sin(a * (x))) * .02  + .25 * audioVal.x;\n        float m = 1. - smoothstep(f, f+0.01, r);\n        float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n        return n - m;\n    }\n\n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(.0, 0., 0.);\n        vec3 bckgdcl = vec3(0.825, 0.5, 0.6);\n        vec2 uv2 = vUv;\n        // uv2 -= .5;\n\n        float f = texture2D(u_audio, vec2(uv2.x * 0.5, 0.)).r;\n        // f = clamp(f * 2., 0.1, 1.1)* 2.;\n        // float noise = noise2D(uv2 * 0.5 * sin(u_time * f)) ;\n        float y = blob(uv2  , 10., 0.5);\n        float x = blobOutline(uv2, 10., 0.45);\n        color += vec3(y + x);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t},u_audio:{value:d.current}}}),b=(0,Lm.useRef)();Bd((function(n){var e=n.clock;m.current&&m.current.getFrequencyData(),b.current.material.uniforms.u_time.value=e.elapsedTime,b.current.material.uniforms.u_mouse.value=new ao(x,y),b.current.material.uniforms.u_audio.value&&(b.current.material.uniforms.u_audio.value.needsUpdate=!0),p.needsUpdate=!0})),addEventListener("mousemove",(function(n){x=n.clientX/window.innerWidth,y=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){x=n.changedTouches[0].clientX/window.innerWidth,y=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1});return(0,Hh.jsxs)(Hh.Fragment,{children:[!s&&(0,Hh.jsx)(SG,{children:(0,Hh.jsx)("div",{className:"play",children:(0,Hh.jsx)("button",{onClick:function(){h.current.play(),m.current=new ap(h.current,128),d.current=new ml(m.current.data,64,1,f),u(!0),r(),a()},style:{cursor:"pointer",color:"white",alignItems:"center",display:"inline-flex",justifyContent:"center",position:"absolute",left:"50%",top:"50%",transform:"translate(-50%, -50%)",backgroundColor:"#000000",padding:"10px"},children:"Play"})})}),(0,Hh.jsx)("mesh",{dispose:null,ref:b,material:g,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})]})}function CG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //simplex noise book of shaders\n    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n    vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n    vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n    \n    float snoise(vec2 v) {\n        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                            -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n        vec2 i  = floor(v + dot(v, C.yy) );\n        vec2 x0 = v -   i + dot(i, C.xx);\n        vec2 i1;\n        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n        i = mod289(i); // Avoid truncation effects in permutation\n        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n            + i.x + vec3(0.0, i1.x, 1.0 ));\n    \n        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n        m = m*m ;\n        m = m*m ;\n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 ox = floor(x + 0.5);\n        vec3 a0 = x - ox;\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n        vec3 g;\n        g.x  = a0.x  * x0.x  + h.x  * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n    }\n\n    float glow(vec2 uv2, float d){\n        float dist = 1.0/length(uv2);\n        dist *= 0.2;\n        dist = pow(dist, 0.8);\n        d *= dist;\n        return d;\n    }\n\n    float plot(vec2 vUv,float p){\n        // float x=snoise(vUv+u_time*.25);\n        // p=x * .05 ;\n        return smoothstep(p + 0.015,p,vUv.y)-\n        smoothstep(p,p-(0.015),vUv.y);\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 *= 2.;\n        uv2 -= 1.;\n\n        // float y = vUv.x;\n        vec2 m = u_mouse;\n        float n = snoise(uv2 - u_mouse) * 4.0 ;\n        float y = sin((uv2.x * n) + u_time) / 10.0;\n        float p1 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.1), y));\n        float p2 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.2), y));\n        float p3 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.3), y));\n        float p4 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.4), y));\n        float p5 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.5), y));\n        float p6 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.0), y));\n        float p7 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.1), y));\n        float p8 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.2), y));\n        float p9 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.3), y));\n        float p10 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.4), y));\n        float p11 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.5), y));\n        float p12 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.6), y));\n        float p13 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.7), y));\n        float p14 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.8), y));\n        float p15 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.9), y));\n        float p16 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 1.0), y));\n        float p17 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.6), y));\n        float p18 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.7), y));\n        float p19 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.8), y));\n        float p20 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.9), y));\n        float p21 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 1.0), y));\n        float p22 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 1.1), y));\n        float p23 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 1.1), y));\n        color += p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + p10 + p11 + p12 + p13 + p14 + p15 + p16 + p17 + p18 + p19 + p20 + p21 + p22 + p23;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)(),v=new Oo,c=new Oo(-1,-1,0),l=new Oo(1,-1,0);new Oo(-1,1,0),new Oo(1,1,0);(0,Lm.useEffect)((function(){(new Go).setFromObject(i.current).getSize(v)}),[i.current]),Nd((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function TG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define NUMBER_OF_STEPS 32;\n    #define MIN_HIT_DISTANCE 0.001;\n    #define MAX_TRACE_DISTANCE 1000;\n\n    float distance_from_sphere(vec3 point, vec3 center, float radius)\n    {\n        return length(point - center) - radius;\n    }\n\n    float draw_scene(vec3 p)\n    {\n\n        //distortion\n        float displacement = sin((5.0 + cos(u_time)) * p.x) * sin((5.0 + sin(u_time)) * p.y) * sin((5.0 + cos(u_time)) * p.z) * 0.25;\n\n        float sphere = distance_from_sphere(p, vec3(0.), 1.);\n        sphere += displacement;\n\n        float total_map;\n\n        total_map += sphere;\n\n        return total_map;\n    }\n\n    vec3 calculate_normal(vec3 p)\n    {\n        vec3 small_step = vec3(0.001, 0., 0.);\n\n        float gradient_x = draw_scene(p + small_step.xyy) - draw_scene(p - small_step.xyy);\n        float gradient_y = draw_scene(p + small_step.yxy) - draw_scene(p - small_step.yxy);\n        float gradient_z = draw_scene(p + small_step.yyx) - draw_scene(p - small_step.yyx);\n\n        vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ray_origin, vec3 ray_direction)\n    {\n        float total_distance_traveled = 0.;\n\n        for(int i = 0; i < 1000; ++i)\n        {\n            vec3 current_position = ray_origin + total_distance_traveled * ray_direction;\n\n            float distance_to_closest = draw_scene(current_position);\n\n            if(distance_to_closest < 0.001)\n            {\n                // return vec3(1., 0., 0.);\n                //normal range is between -1 to 1 needs to be remapped to be 0 to 1\n                vec3 normal = calculate_normal(current_position);\n                // return normal * 0.5 + 0.5;\n\n                //diffuse lighting\n                vec3 light_position = vec3(2., -5., 3.);\n                vec3 direction_to_light = normalize(current_position - light_position);\n                float diffuse_intesity = max(0., dot(normal, direction_to_light));\n\n                return vec3(1. + cos(u_time), 0.2 + sin(u_time), 0.4) * diffuse_intesity;\n            }\n\n            if(total_distance_traveled > 1000.)\n            {\n                break;\n            }\n\n            total_distance_traveled += distance_to_closest;\n        }\n\n        return vec3(0.);\n    }\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 camera_position = vec3(0., 0., -5.);\n        vec3 ray_origin = camera_position;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function RG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float smoothDifferenceSDF(float shape1, float shape2, float value) \n    {\n        float h = clamp(0.5 - 0.5 * (shape2 + shape1) / value, 0., 1.);\n        return mix(shape2, -shape1, h) + value * h * (1. - h);\n    }\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float sdf_sphere(vec3 point, float size)\n    {\n        return length(point) - size;\n    }\n\n    float sdf_box(vec3 point, vec3 box_size)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        vec3 q = abs(point) - box_size;\n        return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point));\n        float displacement = sin((noise + sin(u_time) * 3.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time)) * point.z) * 0.25;\n\n        float box = sdf_box(point, vec3(1.));\n        box += displacement;\n\n        float sphere = sdf_sphere(point, 1.2);\n        sphere += displacement;\n\n        float new_shape = smoothDifferenceSDF(sphere, box, 0.15);\n\n        float total_map;\n\n        total_map += new_shape;\n\n        return total_map;\n    }\n\n    vec3 calculate_normal(vec3 point)\n    {\n        vec3 small_step = vec3(0.0001, 0., 0.);\n        float gradient_x = draw_scene(point + small_step.xyy) - draw_scene(point - small_step.xyy);\n        float gradient_y = draw_scene(point + small_step.yxy) - draw_scene(point - small_step.yxy);\n        float gradient_z = draw_scene(point + small_step.yyx) - draw_scene(point - small_step.yyx);\n        vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ray_origin, vec3 ray_direction)\n    {\n        float total_distance = 0.;\n        for(int i = 0; i < 1000; ++i){\n            vec3 current_position = ray_origin + total_distance * ray_direction;\n            float distance_to_closest = draw_scene(current_position);\n\n            if(distance_to_closest < 0.0001)\n            {\n                //normal\n                vec3 normal = calculate_normal(current_position);\n                //return normal * 0.5 + 0.5;\n\n                //diffuse lighting\n                vec3 light_position = vec3(2., -5., 3.);\n                vec3 direction_to_light = normalize(current_position - light_position);\n                float diffuse_intesity = max(0., dot(normal, direction_to_light));\n\n                return vec3(1., 0.2, 0.5) * diffuse_intesity;\n            }\n\n            if(total_distance > 1000.)\n            {\n                break;\n            }\n\n            total_distance += distance_to_closest;\n        }\n\n        return vec3(0.);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 camera_position = vec3(0., 0., -5.);\n        vec3 ray_origin = camera_position;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function DG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float smoothDifferenceSDF(float shape1, float shape2, float value) \n    {\n        float h = clamp(0.5 - 0.5 * (shape2 + shape1) / value, 0., 1.);\n        return mix(shape2, -shape1, h) + value * h * (1. - h);\n    }\n\n    float smoothUnion( float shape1, float shape2, float value)\n    {\n        float h = clamp( 0.5 + 0.5 * (shape2 - shape1)/value, 0., 1.);\n        return mix(shape2, shape1, h) - value * h * (1. - h);\n    }\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float sdf_box(vec3 point, vec3 box_size)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        vec3 q = abs(point) - box_size;\n        return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n    }\n\n    float sdf_sphere(vec3 point, float radius)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        return length(point) - radius;\n    }\n\n    float sdf_cone(vec3 p, vec2 c, float h)\n    {\n        p.yz *= Rotate(PI * 0.5);\n        p.xy *= Rotate(u_time * 0.5);\n        p.yz *= Rotate(u_time * 0.5); \n        vec2 q = h*vec2(c.x/c.y,-1.0);\n        vec2 w = vec2( length(p.xz), p.y );\n        vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n        vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n        float k = sign( q.y );\n        float d = min(dot( a, a ),dot(b, b));\n        float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n        return sqrt(d)*sign(s);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point)) * 5.;\n        float displacement = sin((noise + sin(u_time) * 3.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time) * 5.) * point.z) * 0.25;\n\n        float sphere = sdf_sphere(point, 0.75);\n        // sphere += displacement;\n\n        float box = sdf_box(point, vec3(0.5));\n        // box += displacement;\n\n        float box2 = sdf_box(point , vec3(1.));\n\n        float cone = sdf_cone(point, vec2(0.05), .5);\n\n        float total_map = box;\n        total_map = smoothUnion(sphere, total_map, 0.15);\n        total_map += displacement;\n        // total_map = smoothUnion(cone, total_map, 0.15);\n\n        return total_map;\n    }\n\n    vec3 calculate_normal(vec3 point)\n    {\n        vec3 small_step = vec3(0.0001, 0., 0.);\n        float grad_x = draw_scene(point + small_step.xyy) - draw_scene(point - small_step.xyy);\n        float grad_y = draw_scene(point + small_step.yxy) - draw_scene(point - small_step.yxy);\n        float grad_z = draw_scene(point + small_step.yyx) - draw_scene(point - small_step.yyx);\n        vec3 normal = vec3(grad_x, grad_y, grad_z);\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ray_origin, vec3 ray_direction)\n    {\n        float total_distance = 0.;\n        for(int i = 0; i < 1000; ++i)\n        {\n            vec3 current_pos = ray_origin + total_distance * ray_direction;\n            float distance_to_closest = draw_scene(current_pos);\n\n            if(distance_to_closest < 0.0001)\n            {\n                //normal\n                vec3 normal = calculate_normal(current_pos);\n\n                //light\n                vec3 light_pos = vec3(2., -5., 3.);\n                vec3 dir_to_light = normalize(current_pos - light_pos);\n                float light_intensity = max(0., dot(normal, dir_to_light));\n\n                return vec3(1., 0.2 * sin(u_time), 0.5 * sin(u_time)) * light_intensity;\n            }\n\n            if(total_distance > 1000.)\n            {\n                break;\n            }\n\n            total_distance += distance_to_closest;\n        }\n\n        return vec3(0.);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -3.);\n        vec3 ray_origin = cam_pos;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function PG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float smoothDifferenceSDF(float shape1, float shape2, float value) \n    {\n        float h = clamp(0.5 - 0.5 * (shape2 + shape1) / value, 0., 1.);\n        return mix(shape2, -shape1, h) + value * h * (1. - h);\n    }\n\n    float smoothUnion( float shape1, float shape2, float value)\n    {\n        float h = clamp( 0.5 + 0.5 * (shape2 - shape1)/value, 0., 1.);\n        return mix(shape2, shape1, h) - value * h * (1. - h);\n    }\n\n    float smoothIntersection(float shape1, float shape2, float value)\n    {\n        float h = clamp(0.5 - 0.5 * (shape2 - shape1)/ value, 0., 1.);\n        return mix(shape2, shape1, h) + value * h * (1. - h);\n    }\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float sdf_box(vec3 point, vec3 box_size)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        vec3 q = abs(point) - box_size;\n        return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n    }\n\n    float sdf_sphere(vec3 point, float radius)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        return length(point) - radius;\n    }\n\n    float sdf_cone(vec3 p, vec2 c, float h)\n    {\n        p.yz *= Rotate(PI * 0.5);\n        p.xy *= Rotate(u_time * 0.5);\n        p.yz *= Rotate(u_time * 0.5); \n        vec2 q = h*vec2(c.x/c.y,-1.0);\n        vec2 w = vec2( length(p.xz), p.y );\n        vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n        vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n        float k = sign( q.y );\n        float d = min(dot( a, a ),dot(b, b));\n        float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n        return sqrt(d)*sign(s);\n    }\n\n    float infiniteRepetitionBox(vec3 point, vec3 spacing)\n    {\n        vec3 q = point - spacing * round(point/spacing);\n        return sdf_box(q, vec3(0.25));\n    }\n\n    float repeatedBox(vec3 point)\n    {\n        float noise = cnoise(vec3(point)) * 1.;\n        float displacement = sin((noise + sin(u_time) * 3.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time) * 5.) * point.z) * 0.25;\n\n        point.x = point.x - round(point.x);\n        point.y = point.y - round(point.y);\n        // point.z = point.z - round(point.z);\n        return sdf_box(point, vec3(0.25));\n    }\n\n    float draw_scene(vec3 point)\n    {\n        point.x = point.x - round(point.x);\n        point.y = point.y - round(point.y);\n        // point.z = point.z - round(point.z);\n        //distortion\n        float noise = cnoise(vec3(point)) * 5.;\n        float displacement = sin((noise + sin(u_time) * 3.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time) * 5.) * point.z) * 0.25;\n\n        float sphere = sdf_sphere(point, 0.25);\n        // sphere += displacement;\n\n        float box = sdf_box(point, vec3(0.25));\n        // box += displacement;\n\n        float box2 = sdf_box(point , vec3(0.5));\n\n        float cone = sdf_cone(point, vec2(0.05), .5);\n\n        float total_map;\n        float v1 = smoothIntersection(sphere, box, 0.15);\n        total_map += v1;\n        // total_map = repeatedBox(point);\n        // total_map += displacement;\n        // total_map = smoothDifferenceSDF(cone, total_map, 0.15);\n\n        return total_map;\n    }\n\n    vec3 calculate_normal(vec3 point)\n    {\n        vec3 small_step = vec3(0.0001, 0., 0.);\n        float grad_x = draw_scene(point + small_step.xyy) - draw_scene(point - small_step.xyy);\n        float grad_y = draw_scene(point + small_step.yxy) - draw_scene(point - small_step.yxy);\n        float grad_z = draw_scene(point + small_step.yyx) - draw_scene(point - small_step.yyx);\n        vec3 normal = vec3(grad_x, grad_y, grad_z);\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ray_origin, vec3 ray_direction)\n    {\n        float total_distance = 0.;\n        for(int i = 0; i < 1000; ++i)\n        {\n            ray_direction.xy *= Rotate(u_time * 0.5);\n            vec3 current_pos = ray_origin + total_distance * ray_direction;\n            float distance_to_closest = draw_scene(current_pos);\n\n            if(distance_to_closest < 0.0001)\n            {\n                //normal\n                vec3 normal = calculate_normal(current_pos);\n\n                //light\n                vec3 light_pos = vec3(2., -5., 3.);\n                vec3 dir_to_light = normalize(current_pos - light_pos);\n                float light_intensity = max(0., dot(normal, dir_to_light));\n\n                return vec3(1., 0.2 * sin(u_time), 0.5 * sin(u_time)) * light_intensity;\n            }\n\n            if(total_distance > 1000.)\n            {\n                break;\n            }\n\n            total_distance += distance_to_closest;\n        }\n\n        return vec3(0.);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -2. + sin(u_time));\n        vec3 ray_origin = cam_pos;\n        vec3 ray_direction = vec3(uv2, 1.);\n        // ray_direction.xy *= Rotate(u_time * 0.5);\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function FG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point)) * 2.;\n        float displacement = sin((noise + sin(u_time) * 1.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.125;\n\n        float sphere = Sphere_SDF(vec3(point.x , point.y - 1.75, point.z), 1.25) + displacement * 2. ;\n        float sphere2 = Sphere_SDF(vec3(point.x, point.y + 1.75, point.z), 1.75) + displacement * 2. ;\n        float sphere3 = Sphere_SDF(vec3(point.x + 1.5, point.y + 1.75, point.z), 1.75) + displacement * 2. ;\n        float plane = Plane_SDF(point, vec3(0.0, 1., 0.0), 0.25) + displacement * 2.;\n\n        float plane2 = Plane_SDF(point, vec3(0., 1., 0.), 0.25);\n\n        float total_map;\n\n        total_map += plane;\n\n        total_map = Smooth_Intersection_SDF(plane, plane2, 0.15);\n\n        total_map = Smooth_Union_SDF(total_map, sphere, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere2, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere3, 0.15);\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ro, vec3 rd)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos);\n\n            if(dist < 0.001)\n            {\n                //normal\n                vec3 normal = getNormal(pos);\n\n                //light\n                vec3 light_pos = vec3(2., -5., 3.);\n                vec3 dir = normalize(pos - light_pos);\n                float intensity = max(0., dot(normal, dir));\n\n                return vec3(.45, .58, .6) * intensity;\n            }\n\n            if(tot_dist > 1000.)\n            {\n                break;\n            }\n\n            tot_dist += dist;\n        }\n\n        return vec3(0.11, 0.16, 0.19);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -7);\n        vec3 ray_origin = cam_pos;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function jG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n\n        vec3 newpoint = point;\n        newpoint.xy *= Rotate(sin(u_time));\n        newpoint.zy *= Rotate(sin(u_time));\n        float sphere = Sphere_SDF(vec3(newpoint), 1.25) + displacement ;\n        float box = Box_SDF(newpoint, vec3(0.75) + displacement * 1.  );\n\n        float total_map;\n\n        total_map += sphere;\n\n        // total_map = Smooth_Difference_SDF(sphere, box, 0.15);\n        \n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -4.);\n        vec3 ray_origin = cam_pos;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        vec3 col = vec3(0.);\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            vec3 refOutside = vec3(1.);\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function IG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n\n        // point.xy *= Rotate(sin(u_time));\n        // point.zy *= Rotate(sin(u_time));\n\n        vec3 newpoint1 = point;\n        float sphere = Sphere_SDF(vec3(newpoint1), 1.) + displacement ;\n        \n        vec3 newpoint2 = point;\n        newpoint2.x += 0.35 + sin(u_time) * 1.25;\n        float sphere2 = Sphere_SDF(vec3(newpoint2), .25) + displacement ;\n\n        vec3 newpoint3 = point;\n        newpoint3.x -= 0.35 + sin(u_time) * 1.;\n        float sphere3 = Sphere_SDF(vec3(newpoint3), .25) + displacement ;\n\n        vec3 newpoint4 = point;\n        newpoint4.y -= 0.35 + sin(u_time) * 0.5;\n        float sphere4 = Sphere_SDF(vec3(newpoint4), .25) + displacement ;\n\n        vec3 newpoint5 = point;\n        newpoint5.y += 0.35 + sin(u_time) * 2.;\n        float sphere5 = Sphere_SDF(vec3(newpoint5), .25) + displacement ;\n\n        vec3 newpoint6 = point;\n        newpoint6.z -= 0.35 + sin(u_time) * 0.8;\n        float sphere6 = Sphere_SDF(vec3(newpoint6), .25) + displacement ;\n\n        vec3 newpoint7 = point;\n        newpoint7.z += 0.35 + sin(u_time) * 0.25;\n        float sphere7 = Sphere_SDF(vec3(newpoint7), .25) + displacement ;\n\n        vec3 newpoint8 = point;\n        newpoint8.y += 0.35 + sin(u_time) * 0.45;\n        newpoint8.z -= 0.35 + sin(u_time) * 1.25;\n        float sphere8 = Sphere_SDF(vec3(newpoint8), .25) + displacement ;\n\n        float total_map;\n\n        total_map += sphere;\n\n        total_map = Smooth_Union_SDF(sphere, sphere2, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere3, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere4, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere5, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere6, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere7, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere8, 0.15);\n        \n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -4.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function EG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n\n        // point.xy *= Rotate(sin(u_time));\n        // point.zy *= Rotate(sin(u_time));\n\n        vec3 newpoint1 = point;\n        float sphere = Sphere_SDF(vec3(newpoint1), 1.) + displacement ;\n        \n        vec3 newpoint2 = point;\n        newpoint2.x += 0.35 + sin(u_time) * 1.25;\n        float sphere2 = Sphere_SDF(vec3(newpoint2), .25) + displacement ;\n\n        vec3 newpoint3 = point;\n        newpoint3.x -= 0.35 + sin(u_time) * 1.;\n        float sphere3 = Sphere_SDF(vec3(newpoint3), .25) + displacement ;\n\n        vec3 newpoint4 = point;\n        newpoint4.y -= 0.35 + sin(u_time) * 0.5;\n        float sphere4 = Sphere_SDF(vec3(newpoint4), .25) + displacement ;\n\n        vec3 newpoint5 = point;\n        newpoint5.y += 0.35 + sin(u_time) * 2.;\n        float sphere5 = Sphere_SDF(vec3(newpoint5), .25) + displacement ;\n\n        vec3 newpoint6 = point;\n        newpoint6.z -= 0.35 + sin(u_time) * 0.8;\n        float sphere6 = Sphere_SDF(vec3(newpoint6), .25) + displacement ;\n\n        vec3 newpoint7 = point;\n        newpoint7.z += 0.35 + sin(u_time) * 0.25;\n        float sphere7 = Sphere_SDF(vec3(newpoint7), .25) + displacement ;\n\n        vec3 newpoint8 = point;\n        newpoint8.y += 0.35 + sin(u_time) * 0.45;\n        newpoint8.z -= 0.35 + sin(u_time) * 1.25;\n        float sphere8 = Sphere_SDF(vec3(newpoint8), .25) + displacement ;\n\n        float total_map;\n\n        total_map += sphere;\n\n        \n\n        // total_map = Smooth_Union_SDF(sphere, sphere2, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere3, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere4, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere5, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere6, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere7, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere8, 0.15);\n\n        for(int i = 0; i < 20; i++)\n        {\n            float noise = cnoise(vec3(point + u_time)) * 1.;\n            float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n            vec3 newPoint = point;\n            float x = Sphere_SDF(vec3(newPoint.x + float(i/5) + (sin(u_time + float(i)) * 2.), newPoint.y + float(i/5) + (cos(u_time + float(i)) * 2.), newPoint.z + float(i/5) + (sin(u_time + float(i)) * 2.)), 0.25) + displacement;\n            total_map = Smooth_Union_SDF(total_map, x, 0.5);\n        }\n        \n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -4.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function OG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n\n        vec3 newPoint1 = point;\n        newPoint1.x -= 2.5;\n        float sphere = Sphere_SDF(vec3(newPoint1), 1.) + displacement ;\n        float box = Box_SDF(vec3(newPoint1), vec3(1.));\n\n        vec3 newPoint2 = point;\n        float sphere2 = Sphere_SDF(vec3(newPoint2), 1.) + displacement ;\n        float box2 = Box_SDF(vec3(newPoint2), vec3(1.));\n\n        vec3 newPoint3 = point;\n        newPoint3.x += 2.5;\n        float sphere3 = Sphere_SDF(vec3(newPoint3), 1.) + displacement ;\n        float box3 = Box_SDF(vec3(newPoint3), vec3(1.));\n\n        float total_map;\n\n        // total_map += box;\n        float map1 = Smooth_Intersection_SDF(sphere, box, 0.15);\n\n        float map2 = Smooth_Union_SDF(sphere2, box2, 0.15);\n\n        float map3 = Smooth_Difference_SDF(sphere3, box3, 0.15);\n\n        float map = Smooth_Union_SDF(map1, map2, 0.15);\n\n        map = Smooth_Union_SDF(map, map3, 0.15);\n        \n        total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -7.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function LG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.5;\n\n        vec3 newPoint1 = point;\n        // newPoint1.x -= 0.;\n        float sphere = Sphere_SDF(vec3(newPoint1), 0.5) + displacement ;\n        float box = Box_SDF(vec3(newPoint1), vec3(0.5)) + displacement;\n\n        vec3 newPoint2 = point;\n        float sphere2 = Sphere_SDF(vec3(newPoint2), 1.) + displacement ;\n        float box2 = Box_SDF(vec3(newPoint2), vec3(1.));\n\n        vec3 newPoint3 = point;\n        // newPoint3.x += 2.5;\n        float sphere3 = Sphere_SDF(vec3(newPoint3), 1.1) + displacement ;\n        float box3 = Box_SDF(vec3(newPoint3), vec3(1.)) + displacement;\n\n        float total_map;\n\n        // total_map += box;\n        float map1 = Smooth_Intersection_SDF(sphere, box, 0.15);\n\n        float map2 = Smooth_Union_SDF(sphere2, box2, 0.15);\n\n        float map3 = Smooth_Difference_SDF(sphere3, box3, 0.15);\n\n        float map = Smooth_Union_SDF(map1, map3, 0.15);\n\n        // map = Smooth_Union_SDF(map, map3, 0.15);\n        \n        total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -5.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function AG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.5;\n\n        vec3 newPoint1 = point;\n        newPoint1.x += sin(u_time) * 2.;\n        // newPoint1.y += cos(u_time) * 2.;\n        float sphere = Sphere_SDF(vec3(newPoint1), 0.5) ;\n        float box = Box_SDF(vec3(newPoint1), vec3(0.5)) ;\n\n        vec3 newPoint2 = point;\n        float sphere2 = Sphere_SDF(vec3(newPoint2), 1.) ;\n        float box2 = Box_SDF(vec3(newPoint2), vec3(1.));\n\n        vec3 newPoint3 = point;\n        // newPoint3.x += 2.5;\n        float sphere3 = Sphere_SDF(vec3(newPoint3), 1.1) ;\n        float box3 = Box_SDF(vec3(newPoint3), vec3(1.)) ;\n\n        float total_map;\n\n        // total_map += box;\n        float map1 = Smooth_Intersection_SDF(sphere, box, 0.15) + displacement;\n\n        float map2 = Smooth_Union_SDF(sphere2, box2, 0.15);\n\n        float map3 = Smooth_Difference_SDF(sphere3, box3, 0.15);\n\n        float map = Smooth_Union_SDF(map1, map3, 0.1);\n\n        // map = Smooth_Union_SDF(map, map3, 0.15);\n        \n        total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -5.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function GG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.15;\n\n        float box = sdBoxFrame(point, vec3(1.0 + displacement), 0.05 );\n\n        float total_map;\n\n        total_map += box;\n        \n        // total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -6.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function NG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n   \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.15;\n\n        vec3 newPoint = point;\n        newPoint.y += 0.5;\n        vec3 newPoint2 = point;\n        newPoint.y -= 1.5;\n        // float box = sdBoxFrame(point, vec3(1.0 + displacement), 0.05 );\n        float plane = sdPlane(newPoint, vec3(0,1,0), 1.);\n        float pyramid = sdPyramid(newPoint2 , 1.);\n        float total_map;\n\n        // total_map += box;\n        total_map += plane;\n        total_map = Smooth_Union_SDF(total_map, pyramid, 0.05);\n        // total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 5., -3.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 0.5);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        ray_origin.y = clamp(ray_origin.y, 0.1, 2.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function BG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.15;\n\n        vec3 newPoint = point;\n        newPoint.y += 0.5;\n        vec3 newPoint2 = point;\n        newPoint.y -= 1.5;\n        // float box = sdBoxFrame(point, vec3(1.0 + displacement), 0.05 );\n        float plane = sdPlane(newPoint, vec3(0,1,0), 1.);\n        float pyramid = sdPyramid(newPoint2 , 1.);\n        float octahedron = sdOctahedron(point, 1.);\n        float total_map;\n\n        // total_map += box;\n        // total_map += plane;\n        total_map += octahedron;\n        // total_map = Smooth_Union_SDF( pyramid, total_map, 0.05);\n        // total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -3.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI + (u_time * 0.1));\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function qG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n\n    float sdKnot(vec3 p, float k) {\n        float r = length(p.xy);\n        float oa, a = atan(p.y, p.x); oa = k*a;\n        a = mod(a, 0.001*TWO_PI) - 0.001*TWO_PI/2.0;\n        p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n        p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n        p.x = abs(p.x) - 1.35; \n        return length(p) - 1.0;\n    }    \n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.15;\n\n        vec3 newPoint = point;\n        newPoint.y += 0.5;\n        vec3 newPoint2 = point;\n        newPoint.y -= 1.5;\n        // float box = sdBoxFrame(point, vec3(1.0 + displacement), 0.05 );\n        float plane = sdPlane(newPoint, vec3(0,1,0), 1.);\n        float pyramid = sdPyramid(newPoint2 , 1.);\n        float octahedron = sdOctahedron(point, 1.);\n        float knot = sdKnot(point, 2.5) + displacement;\n        float total_map;\n\n        // total_map += box;\n        // total_map += plane;\n        // total_map += octahedron;\n        total_map += knot;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -20.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI + (u_time * 0.25));\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function VG(){var n,e,t="./Models/EnvMaps/1/",o=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Vh+Wh+qh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n\n    float sdKnot(vec3 p, float k) {\n        float r = length(p.xy);\n        float oa, a = atan(p.y, p.x); oa = k*a;\n        a = mod(a, 0.001*TWO_PI) - 0.001*TWO_PI/2.0;\n        p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n        p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n        p.x = abs(p.x) - 1.35; \n        return length(p) - 1.0;\n    }    \n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.1;\n\n        vec3 newPoint = point;\n        newPoint.x += 4.5;\n\n        newPoint.xz *= Rotate(PI * 0.5);\n        newPoint.yz *= Rotate(PI * 0.5);\n\n        newPoint.yx *= Rotate((u_time));\n        newPoint.yx *= Rotate((u_time));\n        point.yx *= Rotate((u_time));\n        point.yx *= Rotate((u_time));\n        \n\n        float knot = sdKnot(point, 1.5) + displacement;\n        \n        float knot2 = sdKnot(newPoint, 1.5) + displacement;\n        float total_map;\n\n        // total_map += box;\n        // total_map += plane;\n        // total_map += octahedron;\n        total_map += knot;\n        total_map = Smooth_Union_SDF(total_map, knot2, 0.015);\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -30.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI + (u_time * 0.25));\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Lm.useRef)();return Bd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Hh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function WG(){var n=Bh((function(n){return n.currentShader})),e=[(0,Hh.jsx)(Yh,{}),(0,Hh.jsx)(Qh,{}),(0,Hh.jsx)(Kh,{}),(0,Hh.jsx)(nx,{}),(0,Hh.jsx)(tx,{}),(0,Hh.jsx)(rx,{}),(0,Hh.jsx)(ix,{}),(0,Hh.jsx)(cx,{}),(0,Hh.jsx)(sx,{}),(0,Hh.jsx)(fx,{}),(0,Hh.jsx)(mx,{}),(0,Hh.jsx)(hx,{}),(0,Hh.jsx)(yx,{}),(0,Hh.jsx)(bx,{}),(0,Hh.jsx)(Ux,{}),(0,Hh.jsx)(Sx,{}),(0,Hh.jsx)(zx,{}),(0,Hh.jsx)(Cx,{}),(0,Hh.jsx)(Rx,{}),(0,Hh.jsx)(Px,{}),(0,Hh.jsx)(jx,{}),(0,Hh.jsx)(Ex,{}),(0,Hh.jsx)(Lx,{}),(0,Hh.jsx)(Gx,{}),(0,Hh.jsx)(Bx,{}),(0,Hh.jsx)(Vx,{}),(0,Hh.jsx)(Hx,{}),(0,Hh.jsx)(Yx,{}),(0,Hh.jsx)(Qx,{}),(0,Hh.jsx)(Kx,{}),(0,Hh.jsx)(ny,{}),(0,Hh.jsx)(ty,{}),(0,Hh.jsx)(ry,{}),(0,Hh.jsx)(iy,{}),(0,Hh.jsx)(cy,{}),(0,Hh.jsx)(sy,{}),(0,Hh.jsx)(fy,{}),(0,Hh.jsx)(my,{}),(0,Hh.jsx)(hy,{}),(0,Hh.jsx)(yy,{}),(0,Hh.jsx)(by,{}),(0,Hh.jsx)(Uy,{}),(0,Hh.jsx)(Sy,{}),(0,Hh.jsx)(zy,{}),(0,Hh.jsx)(Cy,{}),(0,Hh.jsx)(Ry,{}),(0,Hh.jsx)(Py,{}),(0,Hh.jsx)(jy,{}),(0,Hh.jsx)(Ey,{}),(0,Hh.jsx)(Ly,{}),(0,Hh.jsx)(Gy,{}),(0,Hh.jsx)(By,{}),(0,Hh.jsx)(Vy,{}),(0,Hh.jsx)(Hy,{}),(0,Hh.jsx)(Yy,{}),(0,Hh.jsx)(Qy,{}),(0,Hh.jsx)(Ky,{}),(0,Hh.jsx)(ng,{}),(0,Hh.jsx)(tg,{}),(0,Hh.jsx)(rg,{}),(0,Hh.jsx)(ig,{}),(0,Hh.jsx)(cg,{}),(0,Hh.jsx)(sg,{}),(0,Hh.jsx)(fg,{}),(0,Hh.jsx)(mg,{}),(0,Hh.jsx)(hg,{}),(0,Hh.jsx)(yg,{}),(0,Hh.jsx)(bg,{}),(0,Hh.jsx)(Ug,{}),(0,Hh.jsx)(Sg,{}),(0,Hh.jsx)(zg,{}),(0,Hh.jsx)(Cg,{}),(0,Hh.jsx)(Rg,{}),(0,Hh.jsx)(Pg,{}),(0,Hh.jsx)(jg,{}),(0,Hh.jsx)(Eg,{}),(0,Hh.jsx)(Lg,{}),(0,Hh.jsx)(Gg,{}),(0,Hh.jsx)(Bg,{}),(0,Hh.jsx)(Vg,{}),(0,Hh.jsx)(Hg,{}),(0,Hh.jsx)(Yg,{}),(0,Hh.jsx)(Qg,{}),(0,Hh.jsx)(Kg,{}),(0,Hh.jsx)(nb,{}),(0,Hh.jsx)(tb,{}),(0,Hh.jsx)(rb,{}),(0,Hh.jsx)(ib,{}),(0,Hh.jsx)(cb,{}),(0,Hh.jsx)(sb,{}),(0,Hh.jsx)(fb,{}),(0,Hh.jsx)(mb,{}),(0,Hh.jsx)(hb,{}),(0,Hh.jsx)(yb,{}),(0,Hh.jsx)(bb,{}),(0,Hh.jsx)(Ub,{}),(0,Hh.jsx)(Sb,{}),(0,Hh.jsx)(zb,{}),(0,Hh.jsx)(Cb,{}),(0,Hh.jsx)(Rb,{}),(0,Hh.jsx)(Pb,{}),(0,Hh.jsx)(jb,{}),(0,Hh.jsx)(Eb,{}),(0,Hh.jsx)(Lb,{}),(0,Hh.jsx)(Gb,{}),(0,Hh.jsx)(Bb,{}),(0,Hh.jsx)(Vb,{}),(0,Hh.jsx)(Hb,{}),(0,Hh.jsx)(Yb,{}),(0,Hh.jsx)(Qb,{}),(0,Hh.jsx)(Kb,{}),(0,Hh.jsx)(n_,{}),(0,Hh.jsx)(t_,{}),(0,Hh.jsx)(r_,{}),(0,Hh.jsx)(i_,{}),(0,Hh.jsx)(c_,{}),(0,Hh.jsx)(s_,{}),(0,Hh.jsx)(f_,{}),(0,Hh.jsx)(m_,{}),(0,Hh.jsx)(h_,{}),(0,Hh.jsx)(y_,{}),(0,Hh.jsx)(b_,{}),(0,Hh.jsx)(U_,{}),(0,Hh.jsx)(S_,{}),(0,Hh.jsx)(z_,{}),(0,Hh.jsx)(C_,{}),(0,Hh.jsx)(R_,{}),(0,Hh.jsx)(P_,{}),(0,Hh.jsx)(j_,{}),(0,Hh.jsx)(E_,{}),(0,Hh.jsx)(L_,{}),(0,Hh.jsx)(G_,{}),(0,Hh.jsx)(B_,{}),(0,Hh.jsx)(V_,{}),(0,Hh.jsx)(H_,{}),(0,Hh.jsx)(Y_,{}),(0,Hh.jsx)(Q_,{}),(0,Hh.jsx)(K_,{}),(0,Hh.jsx)(nU,{}),(0,Hh.jsx)(tU,{}),(0,Hh.jsx)(rU,{}),(0,Hh.jsx)(iU,{}),(0,Hh.jsx)(cU,{}),(0,Hh.jsx)(sU,{}),(0,Hh.jsx)(fU,{}),(0,Hh.jsx)(mU,{}),(0,Hh.jsx)(hU,{}),(0,Hh.jsx)(yU,{}),(0,Hh.jsx)(bU,{}),(0,Hh.jsx)(UU,{}),(0,Hh.jsx)(SU,{}),(0,Hh.jsx)(zU,{}),(0,Hh.jsx)(CU,{}),(0,Hh.jsx)(RU,{}),(0,Hh.jsx)(PU,{}),(0,Hh.jsx)(jU,{}),(0,Hh.jsx)(EU,{}),(0,Hh.jsx)(LU,{}),(0,Hh.jsx)(GU,{}),(0,Hh.jsx)(BU,{}),(0,Hh.jsx)(VU,{}),(0,Hh.jsx)(HU,{}),(0,Hh.jsx)(YU,{}),(0,Hh.jsx)(QU,{}),(0,Hh.jsx)(KU,{}),(0,Hh.jsx)(nw,{}),(0,Hh.jsx)(tw,{}),(0,Hh.jsx)(rw,{}),(0,Hh.jsx)(iw,{}),(0,Hh.jsx)(cw,{}),(0,Hh.jsx)(sw,{}),(0,Hh.jsx)(fw,{}),(0,Hh.jsx)(mw,{}),(0,Hh.jsx)(hw,{}),(0,Hh.jsx)(yw,{}),(0,Hh.jsx)(bw,{}),(0,Hh.jsx)(Uw,{}),(0,Hh.jsx)(Sw,{}),(0,Hh.jsx)(zw,{}),(0,Hh.jsx)(Cw,{}),(0,Hh.jsx)(Rw,{}),(0,Hh.jsx)(Pw,{}),(0,Hh.jsx)(jw,{}),(0,Hh.jsx)(Ew,{}),(0,Hh.jsx)(Lw,{}),(0,Hh.jsx)(Gw,{}),(0,Hh.jsx)(Bw,{}),(0,Hh.jsx)(Vw,{}),(0,Hh.jsx)(Hw,{}),(0,Hh.jsx)(Yw,{}),(0,Hh.jsx)(Qw,{}),(0,Hh.jsx)(Kw,{}),(0,Hh.jsx)(nS,{}),(0,Hh.jsx)(tS,{}),(0,Hh.jsx)(rS,{}),(0,Hh.jsx)(iS,{}),(0,Hh.jsx)(cS,{}),(0,Hh.jsx)(sS,{}),(0,Hh.jsx)(fS,{}),(0,Hh.jsx)(mS,{}),(0,Hh.jsx)(hS,{}),(0,Hh.jsx)(yS,{}),(0,Hh.jsx)(bS,{}),(0,Hh.jsx)(US,{}),(0,Hh.jsx)(SS,{}),(0,Hh.jsx)(zS,{}),(0,Hh.jsx)(CS,{}),(0,Hh.jsx)(RS,{}),(0,Hh.jsx)(PS,{}),(0,Hh.jsx)(jS,{}),(0,Hh.jsx)(ES,{}),(0,Hh.jsx)(LS,{}),(0,Hh.jsx)(GS,{}),(0,Hh.jsx)(BS,{}),(0,Hh.jsx)(VS,{}),(0,Hh.jsx)(HS,{}),(0,Hh.jsx)(YS,{}),(0,Hh.jsx)(QS,{}),(0,Hh.jsx)(KS,{}),(0,Hh.jsx)(nM,{}),(0,Hh.jsx)(tM,{}),(0,Hh.jsx)(rM,{}),(0,Hh.jsx)(iM,{}),(0,Hh.jsx)(cM,{}),(0,Hh.jsx)(sM,{}),(0,Hh.jsx)(fM,{}),(0,Hh.jsx)(mM,{}),(0,Hh.jsx)(hM,{}),(0,Hh.jsx)(yM,{}),(0,Hh.jsx)(bM,{}),(0,Hh.jsx)(UM,{}),(0,Hh.jsx)(SM,{}),(0,Hh.jsx)(zM,{}),(0,Hh.jsx)(CM,{}),(0,Hh.jsx)(RM,{}),(0,Hh.jsx)(PM,{}),(0,Hh.jsx)(jM,{}),(0,Hh.jsx)(EM,{}),(0,Hh.jsx)(LM,{}),(0,Hh.jsx)(GM,{}),(0,Hh.jsx)(BM,{}),(0,Hh.jsx)(VM,{}),(0,Hh.jsx)(HM,{}),(0,Hh.jsx)(YM,{}),(0,Hh.jsx)(QM,{}),(0,Hh.jsx)(KM,{}),(0,Hh.jsx)(nz,{}),(0,Hh.jsx)(tz,{}),(0,Hh.jsx)(rz,{}),(0,Hh.jsx)(iz,{}),(0,Hh.jsx)(cz,{}),(0,Hh.jsx)(sz,{}),(0,Hh.jsx)(fz,{}),(0,Hh.jsx)(mz,{}),(0,Hh.jsx)(hz,{}),(0,Hh.jsx)(yz,{}),(0,Hh.jsx)(bz,{}),(0,Hh.jsx)(Uz,{}),(0,Hh.jsx)(Sz,{}),(0,Hh.jsx)(zz,{}),(0,Hh.jsx)(Cz,{}),(0,Hh.jsx)(Rz,{}),(0,Hh.jsx)(Pz,{}),(0,Hh.jsx)(jz,{}),(0,Hh.jsx)(Ez,{}),(0,Hh.jsx)(Lz,{}),(0,Hh.jsx)(Gz,{}),(0,Hh.jsx)(Bz,{}),(0,Hh.jsx)(Vz,{}),(0,Hh.jsx)(Hz,{}),(0,Hh.jsx)(Yz,{}),(0,Hh.jsx)(Qz,{}),(0,Hh.jsx)(Kz,{}),(0,Hh.jsx)(nk,{}),(0,Hh.jsx)(tk,{}),(0,Hh.jsx)(rk,{}),(0,Hh.jsx)(ik,{}),(0,Hh.jsx)(ck,{}),(0,Hh.jsx)(sk,{}),(0,Hh.jsx)(fk,{}),(0,Hh.jsx)(mk,{}),(0,Hh.jsx)(hk,{}),(0,Hh.jsx)(yk,{}),(0,Hh.jsx)(bk,{}),(0,Hh.jsx)(Uk,{}),(0,Hh.jsx)(Sk,{}),(0,Hh.jsx)(zk,{}),(0,Hh.jsx)(Ck,{}),(0,Hh.jsx)(Rk,{}),(0,Hh.jsx)(Pk,{}),(0,Hh.jsx)(jk,{}),(0,Hh.jsx)(Ek,{}),(0,Hh.jsx)(Lk,{}),(0,Hh.jsx)(Gk,{}),(0,Hh.jsx)(Bk,{}),(0,Hh.jsx)(Vk,{}),(0,Hh.jsx)(Hk,{}),(0,Hh.jsx)(Yk,{}),(0,Hh.jsx)(Qk,{}),(0,Hh.jsx)(Kk,{}),(0,Hh.jsx)(nC,{}),(0,Hh.jsx)(tC,{}),(0,Hh.jsx)(rC,{}),(0,Hh.jsx)(iC,{}),(0,Hh.jsx)(cC,{}),(0,Hh.jsx)(sC,{}),(0,Hh.jsx)(fC,{}),(0,Hh.jsx)(mC,{}),(0,Hh.jsx)(hC,{}),(0,Hh.jsx)(yC,{}),(0,Hh.jsx)(bC,{}),(0,Hh.jsx)(UC,{}),(0,Hh.jsx)(SC,{}),(0,Hh.jsx)(zC,{}),(0,Hh.jsx)(CC,{}),(0,Hh.jsx)(RC,{}),(0,Hh.jsx)(PC,{}),(0,Hh.jsx)(jC,{}),(0,Hh.jsx)(EC,{}),(0,Hh.jsx)(LC,{}),(0,Hh.jsx)(GC,{}),(0,Hh.jsx)(BC,{}),(0,Hh.jsx)(VC,{}),(0,Hh.jsx)(HC,{}),(0,Hh.jsx)(YC,{}),(0,Hh.jsx)(QC,{}),(0,Hh.jsx)(KC,{}),(0,Hh.jsx)(nT,{}),(0,Hh.jsx)(tT,{}),(0,Hh.jsx)(rT,{}),(0,Hh.jsx)(iT,{}),(0,Hh.jsx)(cT,{}),(0,Hh.jsx)(sT,{}),(0,Hh.jsx)(fT,{}),(0,Hh.jsx)(mT,{}),(0,Hh.jsx)(hT,{}),(0,Hh.jsx)(yT,{}),(0,Hh.jsx)(bT,{}),(0,Hh.jsx)(UT,{}),(0,Hh.jsx)(ST,{}),(0,Hh.jsx)(zT,{}),(0,Hh.jsx)(CT,{}),(0,Hh.jsx)(RT,{}),(0,Hh.jsx)(PT,{}),(0,Hh.jsx)(jT,{}),(0,Hh.jsx)(ET,{}),(0,Hh.jsx)(LT,{}),(0,Hh.jsx)(GT,{}),(0,Hh.jsx)(BT,{}),(0,Hh.jsx)(VT,{}),(0,Hh.jsx)(HT,{}),(0,Hh.jsx)(YT,{}),(0,Hh.jsx)(QT,{}),(0,Hh.jsx)(KT,{}),(0,Hh.jsx)(nR,{}),(0,Hh.jsx)(tR,{}),(0,Hh.jsx)(rR,{}),(0,Hh.jsx)(iR,{}),(0,Hh.jsx)(cR,{}),(0,Hh.jsx)(sR,{}),(0,Hh.jsx)(fR,{}),(0,Hh.jsx)(mR,{}),(0,Hh.jsx)(hR,{}),(0,Hh.jsx)(yR,{}),(0,Hh.jsx)(bR,{}),(0,Hh.jsx)(UR,{}),(0,Hh.jsx)(SR,{}),(0,Hh.jsx)(zR,{}),(0,Hh.jsx)(CR,{}),(0,Hh.jsx)(RR,{}),(0,Hh.jsx)(PR,{}),(0,Hh.jsx)(jR,{}),(0,Hh.jsx)(ER,{}),(0,Hh.jsx)(LR,{}),(0,Hh.jsx)(GR,{}),(0,Hh.jsx)(BR,{}),(0,Hh.jsx)(VR,{}),(0,Hh.jsx)(HR,{}),(0,Hh.jsx)(YR,{}),(0,Hh.jsx)(QR,{}),(0,Hh.jsx)(KR,{}),(0,Hh.jsx)(nD,{}),(0,Hh.jsx)(tD,{}),(0,Hh.jsx)(rD,{}),(0,Hh.jsx)(iD,{}),(0,Hh.jsx)(cD,{}),(0,Hh.jsx)(sD,{}),(0,Hh.jsx)(fD,{}),(0,Hh.jsx)(mD,{}),(0,Hh.jsx)(hD,{}),(0,Hh.jsx)(yD,{}),(0,Hh.jsx)(bD,{}),(0,Hh.jsx)(UD,{}),(0,Hh.jsx)(SD,{}),(0,Hh.jsx)(zD,{}),(0,Hh.jsx)(CD,{}),(0,Hh.jsx)(RD,{}),(0,Hh.jsx)(PD,{}),(0,Hh.jsx)(jD,{}),(0,Hh.jsx)(ED,{}),(0,Hh.jsx)(LD,{}),(0,Hh.jsx)(GD,{}),(0,Hh.jsx)(BD,{}),(0,Hh.jsx)(VD,{}),(0,Hh.jsx)(HD,{}),(0,Hh.jsx)(YD,{}),(0,Hh.jsx)(QD,{}),(0,Hh.jsx)(KD,{}),(0,Hh.jsx)(nP,{}),(0,Hh.jsx)(tP,{}),(0,Hh.jsx)(rP,{}),(0,Hh.jsx)(iP,{}),(0,Hh.jsx)(cP,{}),(0,Hh.jsx)(sP,{}),(0,Hh.jsx)(fP,{}),(0,Hh.jsx)(mP,{}),(0,Hh.jsx)(hP,{}),(0,Hh.jsx)(yP,{}),(0,Hh.jsx)(bP,{}),(0,Hh.jsx)(UP,{}),(0,Hh.jsx)(SP,{}),(0,Hh.jsx)(zP,{}),(0,Hh.jsx)(CP,{}),(0,Hh.jsx)(RP,{}),(0,Hh.jsx)(PP,{}),(0,Hh.jsx)(jP,{}),(0,Hh.jsx)(EP,{}),(0,Hh.jsx)(LP,{}),(0,Hh.jsx)(GP,{}),(0,Hh.jsx)(BP,{}),(0,Hh.jsx)(VP,{}),(0,Hh.jsx)(HP,{}),(0,Hh.jsx)(YP,{}),(0,Hh.jsx)(QP,{}),(0,Hh.jsx)(KP,{}),(0,Hh.jsx)(nF,{}),(0,Hh.jsx)(tF,{}),(0,Hh.jsx)(rF,{}),(0,Hh.jsx)(iF,{}),(0,Hh.jsx)(cF,{}),(0,Hh.jsx)(sF,{}),(0,Hh.jsx)(fF,{}),(0,Hh.jsx)(mF,{}),(0,Hh.jsx)(hF,{}),(0,Hh.jsx)(yF,{}),(0,Hh.jsx)(bF,{}),(0,Hh.jsx)(UF,{}),(0,Hh.jsx)(SF,{}),(0,Hh.jsx)(zF,{}),(0,Hh.jsx)(CF,{}),(0,Hh.jsx)(RF,{}),(0,Hh.jsx)(PF,{}),(0,Hh.jsx)(jF,{}),(0,Hh.jsx)(EF,{}),(0,Hh.jsx)(LF,{}),(0,Hh.jsx)(GF,{}),(0,Hh.jsx)(BF,{}),(0,Hh.jsx)(VF,{}),(0,Hh.jsx)(HF,{}),(0,Hh.jsx)(YF,{}),(0,Hh.jsx)(QF,{}),(0,Hh.jsx)(KF,{}),(0,Hh.jsx)(nj,{}),(0,Hh.jsx)(tj,{}),(0,Hh.jsx)(rj,{}),(0,Hh.jsx)(ij,{}),(0,Hh.jsx)(cj,{}),(0,Hh.jsx)(sj,{}),(0,Hh.jsx)(fj,{}),(0,Hh.jsx)(mj,{}),(0,Hh.jsx)(hj,{}),(0,Hh.jsx)(yj,{}),(0,Hh.jsx)(bj,{}),(0,Hh.jsx)(Uj,{}),(0,Hh.jsx)(Sj,{}),(0,Hh.jsx)(zj,{}),(0,Hh.jsx)(Cj,{}),(0,Hh.jsx)(Rj,{}),(0,Hh.jsx)(Pj,{}),(0,Hh.jsx)(jj,{}),(0,Hh.jsx)(Ej,{}),(0,Hh.jsx)(Lj,{}),(0,Hh.jsx)(Gj,{}),(0,Hh.jsx)(Bj,{}),(0,Hh.jsx)(Vj,{}),(0,Hh.jsx)(Hj,{}),(0,Hh.jsx)(Yj,{}),(0,Hh.jsx)(Qj,{}),(0,Hh.jsx)(Kj,{}),(0,Hh.jsx)(nI,{}),(0,Hh.jsx)(tI,{}),(0,Hh.jsx)(rI,{}),(0,Hh.jsx)(iI,{}),(0,Hh.jsx)(cI,{}),(0,Hh.jsx)(sI,{}),(0,Hh.jsx)(fI,{}),(0,Hh.jsx)(mI,{}),(0,Hh.jsx)(hI,{}),(0,Hh.jsx)(yI,{}),(0,Hh.jsx)(bI,{}),(0,Hh.jsx)(UI,{}),(0,Hh.jsx)(SI,{}),(0,Hh.jsx)(zI,{}),(0,Hh.jsx)(CI,{}),(0,Hh.jsx)(RI,{}),(0,Hh.jsx)(PI,{}),(0,Hh.jsx)(jI,{}),(0,Hh.jsx)(EI,{}),(0,Hh.jsx)(LI,{}),(0,Hh.jsx)(GI,{}),(0,Hh.jsx)(BI,{}),(0,Hh.jsx)(VI,{}),(0,Hh.jsx)(HI,{}),(0,Hh.jsx)(YI,{}),(0,Hh.jsx)(QI,{}),(0,Hh.jsx)(KI,{}),(0,Hh.jsx)(nE,{}),(0,Hh.jsx)(tE,{}),(0,Hh.jsx)(rE,{}),(0,Hh.jsx)(iE,{}),(0,Hh.jsx)(cE,{}),(0,Hh.jsx)(sE,{}),(0,Hh.jsx)(fE,{}),(0,Hh.jsx)(mE,{}),(0,Hh.jsx)(hE,{}),(0,Hh.jsx)(yE,{}),(0,Hh.jsx)(bE,{}),(0,Hh.jsx)(UE,{}),(0,Hh.jsx)(SE,{}),(0,Hh.jsx)(zE,{}),(0,Hh.jsx)(CE,{}),(0,Hh.jsx)(RE,{}),(0,Hh.jsx)(PE,{}),(0,Hh.jsx)(jE,{}),(0,Hh.jsx)(EE,{}),(0,Hh.jsx)(LE,{}),(0,Hh.jsx)(GE,{}),(0,Hh.jsx)(BE,{}),(0,Hh.jsx)(VE,{}),(0,Hh.jsx)(HE,{}),(0,Hh.jsx)(YE,{}),(0,Hh.jsx)(QE,{}),(0,Hh.jsx)(KE,{}),(0,Hh.jsx)(nO,{}),(0,Hh.jsx)(tO,{}),(0,Hh.jsx)(rO,{}),(0,Hh.jsx)(iO,{}),(0,Hh.jsx)(cO,{}),(0,Hh.jsx)(sO,{}),(0,Hh.jsx)(fO,{}),(0,Hh.jsx)(mO,{}),(0,Hh.jsx)(hO,{}),(0,Hh.jsx)(yO,{}),(0,Hh.jsx)(bO,{}),(0,Hh.jsx)(UO,{}),(0,Hh.jsx)(SO,{}),(0,Hh.jsx)(zO,{}),(0,Hh.jsx)(CO,{}),(0,Hh.jsx)(RO,{}),(0,Hh.jsx)(PO,{}),(0,Hh.jsx)(jO,{}),(0,Hh.jsx)(EO,{}),(0,Hh.jsx)(LO,{}),(0,Hh.jsx)(GO,{}),(0,Hh.jsx)(BO,{}),(0,Hh.jsx)(VO,{}),(0,Hh.jsx)(HO,{}),(0,Hh.jsx)(YO,{}),(0,Hh.jsx)(QO,{}),(0,Hh.jsx)(KO,{}),(0,Hh.jsx)(nL,{}),(0,Hh.jsx)(tL,{}),(0,Hh.jsx)(rL,{}),(0,Hh.jsx)(iL,{}),(0,Hh.jsx)(cL,{}),(0,Hh.jsx)(sL,{}),(0,Hh.jsx)(fL,{}),(0,Hh.jsx)(mL,{}),(0,Hh.jsx)(hL,{}),(0,Hh.jsx)(yL,{}),(0,Hh.jsx)(bL,{}),(0,Hh.jsx)(UL,{}),(0,Hh.jsx)(SL,{}),(0,Hh.jsx)(zL,{}),(0,Hh.jsx)(CL,{}),(0,Hh.jsx)(RL,{}),(0,Hh.jsx)(PL,{}),(0,Hh.jsx)(jL,{}),(0,Hh.jsx)(EL,{}),(0,Hh.jsx)(LL,{}),(0,Hh.jsx)(GL,{}),(0,Hh.jsx)(BL,{}),(0,Hh.jsx)(VL,{}),(0,Hh.jsx)(HL,{}),(0,Hh.jsx)(YL,{}),(0,Hh.jsx)(QL,{}),(0,Hh.jsx)(KL,{}),(0,Hh.jsx)(nA,{}),(0,Hh.jsx)(tA,{}),(0,Hh.jsx)(rA,{}),(0,Hh.jsx)(iA,{}),(0,Hh.jsx)(cA,{}),(0,Hh.jsx)(sA,{}),(0,Hh.jsx)(fA,{}),(0,Hh.jsx)(mA,{}),(0,Hh.jsx)(hA,{}),(0,Hh.jsx)(yA,{}),(0,Hh.jsx)(bA,{}),(0,Hh.jsx)(UA,{}),(0,Hh.jsx)(SA,{}),(0,Hh.jsx)(zA,{}),(0,Hh.jsx)(CA,{}),(0,Hh.jsx)(RA,{}),(0,Hh.jsx)(PA,{}),(0,Hh.jsx)(jA,{}),(0,Hh.jsx)(EA,{}),(0,Hh.jsx)(OA,{}),(0,Hh.jsx)(LA,{}),(0,Hh.jsx)(AA,{}),(0,Hh.jsx)(GA,{}),(0,Hh.jsx)(NA,{}),(0,Hh.jsx)(BA,{}),(0,Hh.jsx)(qA,{}),(0,Hh.jsx)(VA,{}),(0,Hh.jsx)(WA,{}),(0,Hh.jsx)(HA,{}),(0,Hh.jsx)(XA,{}),(0,Hh.jsx)(YA,{}),(0,Hh.jsx)(ZA,{}),(0,Hh.jsx)(QA,{}),(0,Hh.jsx)(JA,{}),(0,Hh.jsx)(KA,{}),(0,Hh.jsx)($A,{}),(0,Hh.jsx)(nG,{}),(0,Hh.jsx)(eG,{}),(0,Hh.jsx)(tG,{}),(0,Hh.jsx)(oG,{}),(0,Hh.jsx)(rG,{}),(0,Hh.jsx)(aG,{}),(0,Hh.jsx)(vG,{}),(0,Hh.jsx)(lG,{}),(0,Hh.jsx)(sG,{}),(0,Hh.jsx)(uG,{}),(0,Hh.jsx)(fG,{}),(0,Hh.jsx)(pG,{}),(0,Hh.jsx)(MG,{}),(0,Hh.jsx)(zG,{}),(0,Hh.jsx)(kG,{}),(0,Hh.jsx)(CG,{}),(0,Hh.jsx)(TG,{}),(0,Hh.jsx)(RG,{}),(0,Hh.jsx)(DG,{}),(0,Hh.jsx)(PG,{}),(0,Hh.jsx)(FG,{}),(0,Hh.jsx)(jG,{}),(0,Hh.jsx)(IG,{}),(0,Hh.jsx)(EG,{}),(0,Hh.jsx)(OG,{}),(0,Hh.jsx)(LG,{}),(0,Hh.jsx)(AG,{}),(0,Hh.jsx)(GG,{}),(0,Hh.jsx)(NG,{}),(0,Hh.jsx)(BG,{}),(0,Hh.jsx)(qG,{}),(0,Hh.jsx)(VG,{})];return(0,Hh.jsx)(Hh.Fragment,{children:e[n-1]})}var HG=Uint8Array,XG=Uint16Array,YG=Uint32Array,ZG=new HG([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),QG=new HG([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),JG=new HG([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),KG=function(n,e){for(var t=new XG(31),o=0;o<31;++o)t[o]=e+=1<<n[o-1];var r=new YG(t[30]);for(o=1;o<30;++o)for(var a=t[o];a<t[o+1];++a)r[a]=a-t[o]<<5|o;return[t,r]},$G=KG(ZG,2),nN=$G[0],eN=$G[1];nN[28]=258,eN[258]=28;for(var tN=KG(QG,0),oN=tN[0],rN=(tN[1],new XG(32768)),aN=0;aN<32768;++aN){var iN=(43690&aN)>>>1|(21845&aN)<<1;iN=(61680&(iN=(52428&iN)>>>2|(13107&iN)<<2))>>>4|(3855&iN)<<4,rN[aN]=((65280&iN)>>>8|(255&iN)<<8)>>>1}var vN=function(n,e,t){for(var o=n.length,r=0,a=new XG(e);r<o;++r)++a[n[r]-1];var i,v=new XG(e);for(r=0;r<e;++r)v[r]=v[r-1]+a[r-1]<<1;if(t){i=new XG(1<<e);var c=15-e;for(r=0;r<o;++r)if(n[r])for(var l=r<<4|n[r],s=e-n[r],u=v[n[r]-1]++<<s,f=u|(1<<s)-1;u<=f;++u)i[rN[u]>>>c]=l}else for(i=new XG(o),r=0;r<o;++r)n[r]&&(i[r]=rN[v[n[r]-1]++]>>>15-n[r]);return i},cN=new HG(288);for(aN=0;aN<144;++aN)cN[aN]=8;for(aN=144;aN<256;++aN)cN[aN]=9;for(aN=256;aN<280;++aN)cN[aN]=7;for(aN=280;aN<288;++aN)cN[aN]=8;var lN=new HG(32);for(aN=0;aN<32;++aN)lN[aN]=5;var sN=vN(cN,9,1),uN=vN(lN,5,1),fN=function(n){for(var e=n[0],t=1;t<n.length;++t)n[t]>e&&(e=n[t]);return e},pN=function(n,e,t){var o=e/8|0;return(n[o]|n[o+1]<<8)>>(7&e)&t},mN=function(n,e){var t=e/8|0;return(n[t]|n[t+1]<<8|n[t+2]<<16)>>(7&e)},dN=function(n){return(n/8|0)+(7&n&&1)},hN=function(n,e,t){(null==e||e<0)&&(e=0),(null==t||t>n.length)&&(t=n.length);var o=new(n instanceof XG?XG:n instanceof YG?YG:HG)(t-e);return o.set(n.subarray(e,t)),o},xN=function(n,e,t){var o=n.length;if(!o||t&&!t.l&&o<5)return e||new HG(0);var r=!e||t,a=!t||t.i;t||(t={}),e||(e=new HG(3*o));var i=function(n){var t=e.length;if(n>t){var o=new HG(Math.max(2*t,n));o.set(e),e=o}},v=t.f||0,c=t.p||0,l=t.b||0,s=t.l,u=t.d,f=t.m,p=t.n,m=8*o;do{if(!s){t.f=v=pN(n,c,1);var d=pN(n,c+1,3);if(c+=3,!d){var h=n[(k=dN(c)+4)-4]|n[k-3]<<8,x=k+h;if(x>o){if(a)throw"unexpected EOF";break}r&&i(l+h),e.set(n.subarray(k,x),l),t.b=l+=h,t.p=c=8*x;continue}if(1==d)s=sN,u=uN,f=9,p=5;else{if(2!=d)throw"invalid block type";var y=pN(n,c,31)+257,g=pN(n,c+10,15)+4,b=y+pN(n,c+5,31)+1;c+=14;for(var _=new HG(b),U=new HG(19),w=0;w<g;++w)U[JG[w]]=pN(n,c+3*w,7);c+=3*g;var S=fN(U),M=(1<<S)-1,z=vN(U,S,1);for(w=0;w<b;){var k,C=z[pN(n,c,M)];if(c+=15&C,(k=C>>>4)<16)_[w++]=k;else{var T=0,R=0;for(16==k?(R=3+pN(n,c,3),c+=2,T=_[w-1]):17==k?(R=3+pN(n,c,7),c+=3):18==k&&(R=11+pN(n,c,127),c+=7);R--;)_[w++]=T}}var D=_.subarray(0,y),P=_.subarray(y);f=fN(D),p=fN(P),s=vN(D,f,1),u=vN(P,p,1)}if(c>m){if(a)throw"unexpected EOF";break}}r&&i(l+131072);for(var F=(1<<f)-1,j=(1<<p)-1,I=c;;I=c){var E=(T=s[mN(n,c)&F])>>>4;if((c+=15&T)>m){if(a)throw"unexpected EOF";break}if(!T)throw"invalid length/literal";if(E<256)e[l++]=E;else{if(256==E){I=c,s=null;break}var O=E-254;if(E>264){var L=ZG[w=E-257];O=pN(n,c,(1<<L)-1)+nN[w],c+=L}var A=u[mN(n,c)&j],G=A>>>4;if(!A)throw"invalid distance";c+=15&A;P=oN[G];if(G>3){L=QG[G];P+=mN(n,c)&(1<<L)-1,c+=L}if(c>m){if(a)throw"unexpected EOF";break}r&&i(l+131072);for(var N=l+O;l<N;l+=4)e[l]=e[l-P],e[l+1]=e[l+1-P],e[l+2]=e[l+2-P],e[l+3]=e[l+3-P];l=N}}t.l=s,t.p=I,t.b=l,s&&(v=1,t.m=f,t.d=u,t.n=p)}while(!v);return l==e.length?e:hN(e,0,l)},yN=new HG(0),gN=function(n){if(8!=(15&n[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw"invalid zlib data";if(32&n[1])throw"invalid zlib data: preset dictionaries not supported"};function bN(n,e){return xN((gN(n),n.subarray(2,-4)),e)}var _N="undefined"!=typeof TextDecoder&&new TextDecoder;try{_N.decode(yN,{stream:!0}),1}catch(rB){}function UN(n,e,t){var o=t.length-n-1;if(e>=t[o])return o-1;if(e<=t[n])return n;for(var r=n,a=o,i=Math.floor((r+a)/2);e<t[i]||e>=t[i+1];)e<t[i]?a=i:r=i,i=Math.floor((r+a)/2);return i}function wN(n,e,t,o){var r=[],a=[],i=[];r[0]=1;for(var v=1;v<=t;++v){a[v]=e-o[n+1-v],i[v]=o[n+v]-e;for(var c=0,l=0;l<v;++l){var s=i[l+1],u=a[v-l],f=r[l]/(s+u);r[l]=c+s*f,c=u*f}r[v]=c}return r}function SN(n,e){for(var t=1,o=2;o<=n;++o)t*=o;for(var r=1,a=2;a<=e;++a)r*=a;for(var i=2;i<=n-e;++i)r*=i;return t/r}function MN(n,e,t,o,r){var a=function(n,e,t,o,r){for(var a=r<n?r:n,i=[],v=UN(n,o,e),c=function(n,e,t,o,r){for(var a=[],i=0;i<=t;++i)a[i]=0;for(var v=[],c=0;c<=o;++c)v[c]=a.slice(0);for(var l=[],s=0;s<=t;++s)l[s]=a.slice(0);l[0][0]=1;for(var u=a.slice(0),f=a.slice(0),p=1;p<=t;++p){u[p]=e-r[n+1-p],f[p]=r[n+p]-e;for(var m=0,d=0;d<p;++d){var h=f[d+1],x=u[p-d];l[p][d]=h+x;var y=l[d][p-1]/l[p][d];l[d][p]=m+h*y,m=x*y}l[p][p]=m}for(var g=0;g<=t;++g)v[0][g]=l[g][t];for(var b=0;b<=t;++b){for(var _=0,U=1,w=[],S=0;S<=t;++S)w[S]=a.slice(0);w[0][0]=1;for(var M=1;M<=o;++M){var z=0,k=b-M,C=t-M;b>=M&&(w[U][0]=w[_][0]/l[C+1][k],z=w[U][0]*l[k][C]);for(var T=b-1<=C?M-1:t-b,R=k>=-1?1:-k;R<=T;++R)w[U][R]=(w[_][R]-w[_][R-1])/l[C+1][k+R],z+=w[U][R]*l[k+R][C];b<=C&&(w[U][M]=-w[_][M-1]/l[C+1][b],z+=w[U][M]*l[b][C]),v[M][b]=z;var D=_;_=U,U=D}}for(var P=t,F=1;F<=o;++F){for(var j=0;j<=t;++j)v[F][j]*=P;P*=t-F}return v}(v,o,n,a,e),l=[],s=0;s<t.length;++s){var u=t[s].clone(),f=u.w;u.x*=f,u.y*=f,u.z*=f,l[s]=u}for(var p=0;p<=a;++p){for(var m=l[v-n].clone().multiplyScalar(c[p][0]),d=1;d<=n;++d)m.add(l[v-n+d].clone().multiplyScalar(c[p][d]));i[p]=m}for(var h=a+1;h<=r+1;++h)i[h]=new To(0,0,0);return i}(n,e,t,o,r);return function(n){for(var e=n.length,t=[],o=[],r=0;r<e;++r){var a=n[r];t[r]=new Oo(a.x,a.y,a.z),o[r]=a.w}for(var i=[],v=0;v<e;++v){for(var c=t[v].clone(),l=1;l<=v;++l)c.sub(i[v-l].clone().multiplyScalar(SN(v,l)*o[l]));i[v]=c.divideScalar(o[0])}return i}(a)}var zN,kN,CN,TN=function(n){_(t,n);var e=z(t);function t(n,o,r,a,i){var v;y(this,t),(v=e.call(this)).degree=n,v.knots=o,v.controlPoints=[],v.startKnot=a||0,v.endKnot=i||v.knots.length-1;for(var c=0;c<r.length;++c){var l=r[c];v.controlPoints[c]=new To(l.x,l.y,l.z,l.w)}return v}return b(t,[{key:"getPoint",value:function(n,e){var t=e||new Oo,o=this.knots[this.startKnot]+n*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=function(n,e,t,o){for(var r=UN(n,o,e),a=wN(r,o,n,e),i=new To(0,0,0,0),v=0;v<=n;++v){var c=t[r-n+v],l=a[v],s=c.w*l;i.x+=c.x*s,i.y+=c.y*s,i.z+=c.z*s,i.w+=c.w*l}return i}(this.degree,this.knots,this.controlPoints,o);return 1!=r.w&&r.divideScalar(r.w),t.set(r.x,r.y,r.z)}},{key:"getTangent",value:function(n,e){var t=e||new Oo,o=this.knots[0]+n*(this.knots[this.knots.length-1]-this.knots[0]),r=MN(this.degree,this.knots,this.controlPoints,o,1);return t.copy(r[1]).normalize(),t}}]),t}(Yl),RN=function(n){_(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=""===r.path?Rf.extractUrlBase(n):r.path,i=new tf(this.manager);i.setPath(r.path),i.setResponseType("arraybuffer"),i.setRequestHeader(r.requestHeader),i.setWithCredentials(r.withCredentials),i.load(n,(function(t){try{e(r.parse(t,a))}catch(rB){o?o(rB):console.error(rB),r.manager.itemError(n)}}),t,o)}},{key:"parse",value:function(n,e){if(function(n){var e="Kaydara FBX Binary  \0";return n.byteLength>=e.length&&e===XN(n,0,e.length)}(n))zN=(new IN).parse(n);else{var t=XN(n);if(!function(n){var e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"],t=0;function o(e){var o=n[e-1];return n=n.slice(t+e),t++,o}for(var r=0;r<e.length;++r){if(o(1)===e[r])return!1}return!0}(t))throw new Error("THREE.FBXLoader: Unknown format.");if(LN(t)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+LN(t));zN=(new jN).parse(t)}var o=new lf(this.manager).setPath(this.resourcePath||e).setCrossOrigin(this.crossOrigin);return new DN(o,this.manager).parse(zN)}}]),t}($u),DN=function(){function n(e,t){y(this,n),this.textureLoader=e,this.manager=t}return b(n,[{key:"parse",value:function(){kN=this.parseConnections();var n=this.parseImages(),e=this.parseTextures(n),t=this.parseMaterials(e),o=this.parseDeformers(),r=(new PN).parse(o);return this.parseScene(o,r,t),CN}},{key:"parseConnections",value:function(){var n=new Map;"Connections"in zN&&zN.Connections.connections.forEach((function(e){var t=e[0],o=e[1],r=e[2];n.has(t)||n.set(t,{parents:[],children:[]});var a={ID:o,relationship:r};n.get(t).parents.push(a),n.has(o)||n.set(o,{parents:[],children:[]});var i={ID:t,relationship:r};n.get(o).children.push(i)}));return n}},{key:"parseImages",value:function(){var n={},e={};if("Video"in zN.Objects){var t=zN.Objects.Video;for(var o in t){var r=t[o];if(n[parseInt(o)]=r.RelativeFilename||r.Filename,"Content"in r){var a=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,i="string"===typeof r.Content&&""!==r.Content;if(a||i){var v=this.parseImage(t[o]);e[r.RelativeFilename||r.Filename]=v}}}}for(var c in n){var l=n[c];void 0!==e[l]?n[c]=e[l]:n[c]=n[c].split("\\").pop()}return n}},{key:"parseImage",value:function(n){var e,t=n.Content,o=n.RelativeFilename||n.Filename,r=o.slice(o.lastIndexOf(".")+1).toLowerCase();switch(r){case"bmp":e="image/bmp";break;case"jpg":case"jpeg":e="image/jpeg";break;case"png":e="image/png";break;case"tif":e="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",o),e="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+r+'" is not supported.')}if("string"===typeof t)return"data:"+e+";base64,"+t;var a=new Uint8Array(t);return window.URL.createObjectURL(new Blob([a],{type:e}))}},{key:"parseTextures",value:function(n){var e=new Map;if("Texture"in zN.Objects){var t=zN.Objects.Texture;for(var o in t){var r=this.parseTexture(t[o],n);e.set(parseInt(o),r)}}return e}},{key:"parseTexture",value:function(n,e){var t=this.loadTexture(n,e);t.ID=n.id,t.name=n.attrName;var o=n.WrapModeU,r=n.WrapModeV,a=void 0!==o?o.value:0,i=void 0!==r?r.value:0;if(t.wrapS=0===a?An:Gn,t.wrapT=0===i?An:Gn,"Scaling"in n){var v=n.Scaling.value;t.repeat.x=v[0],t.repeat.y=v[1]}return t}},{key:"loadTexture",value:function(n,e){var t,o,r=this.textureLoader.path,a=kN.get(n.id).children;void 0!==a&&a.length>0&&void 0!==e[a[0].ID]&&(0!==(t=e[a[0].ID]).indexOf("blob:")&&0!==t.indexOf("data:")||this.textureLoader.setPath(void 0));var i=n.FileName.slice(-3).toLowerCase();if("tga"===i){var v=this.manager.getHandler(".tga");null===v?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",n.RelativeFilename),o=new Co):(v.setPath(this.textureLoader.path),o=v.load(t))}else"psd"===i?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",n.RelativeFilename),o=new Co):o=this.textureLoader.load(t);return this.textureLoader.setPath(r),o}},{key:"parseMaterials",value:function(n){var e=new Map;if("Material"in zN.Objects){var t=zN.Objects.Material;for(var o in t){var r=this.parseMaterial(t[o],n);null!==r&&e.set(parseInt(o),r)}}return e}},{key:"parseMaterial",value:function(n,e){var t=n.id,o=n.attrName,r=n.ShadingModel;if("object"===typeof r&&(r=r.value),!kN.has(t))return null;var a,i=this.parseParameters(n,e,t);switch(r.toLowerCase()){case"phong":a=new Uu;break;case"lambert":a=new Mu;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),a=new Uu}return a.setValues(i),a.name=o,a}},{key:"parseParameters",value:function(n,e,t){var o={};n.BumpFactor&&(o.bumpScale=n.BumpFactor.value),n.Diffuse?o.color=(new wo).fromArray(n.Diffuse.value):!n.DiffuseColor||"Color"!==n.DiffuseColor.type&&"ColorRGB"!==n.DiffuseColor.type||(o.color=(new wo).fromArray(n.DiffuseColor.value)),n.DisplacementFactor&&(o.displacementScale=n.DisplacementFactor.value),n.Emissive?o.emissive=(new wo).fromArray(n.Emissive.value):!n.EmissiveColor||"Color"!==n.EmissiveColor.type&&"ColorRGB"!==n.EmissiveColor.type||(o.emissive=(new wo).fromArray(n.EmissiveColor.value)),n.EmissiveFactor&&(o.emissiveIntensity=parseFloat(n.EmissiveFactor.value)),n.Opacity&&(o.opacity=parseFloat(n.Opacity.value)),o.opacity<1&&(o.transparent=!0),n.ReflectionFactor&&(o.reflectivity=n.ReflectionFactor.value),n.Shininess&&(o.shininess=n.Shininess.value),n.Specular?o.specular=(new wo).fromArray(n.Specular.value):n.SpecularColor&&"Color"===n.SpecularColor.type&&(o.specular=(new wo).fromArray(n.SpecularColor.value));var r=this;return kN.get(t).children.forEach((function(n){var t=n.relationship;switch(t){case"Bump":o.bumpMap=r.getTexture(e,n.ID);break;case"Maya|TEX_ao_map":o.aoMap=r.getTexture(e,n.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":o.map=r.getTexture(e,n.ID),void 0!==o.map&&("colorSpace"in o.map?o.map.colorSpace="srgb":o.map.encoding=3001);break;case"DisplacementColor":o.displacementMap=r.getTexture(e,n.ID);break;case"EmissiveColor":o.emissiveMap=r.getTexture(e,n.ID),void 0!==o.emissiveMap&&("colorSpace"in o.emissiveMap?o.emissiveMap.colorSpace="srgb":o.emissiveMap.encoding=3001);break;case"NormalMap":case"Maya|TEX_normal_map":o.normalMap=r.getTexture(e,n.ID);break;case"ReflectionColor":o.envMap=r.getTexture(e,n.ID),void 0!==o.envMap&&(o.envMap.mapping=En,"colorSpace"in o.envMap?o.envMap.colorSpace="srgb":o.envMap.encoding=3001);break;case"SpecularColor":o.specularMap=r.getTexture(e,n.ID),void 0!==o.specularMap&&("colorSpace"in o.specularMap?o.specularMap.colorSpace="srgb":o.specularMap.encoding=3001);break;case"TransparentColor":case"TransparencyFactor":o.alphaMap=r.getTexture(e,n.ID),o.transparent=!0;break;default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",t)}})),o}},{key:"getTexture",value:function(n,e){return"LayeredTexture"in zN.Objects&&e in zN.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),e=kN.get(e).children[0].ID),n.get(e)}},{key:"parseDeformers",value:function(){var n={},e={};if("Deformer"in zN.Objects){var t=zN.Objects.Deformer;for(var o in t){var r=t[o],a=kN.get(parseInt(o));if("Skin"===r.attrType){var i=this.parseSkeleton(a,t);i.ID=o,a.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),i.geometryID=a.parents[0].ID,n[o]=i}else if("BlendShape"===r.attrType){var v={id:o};v.rawTargets=this.parseMorphTargets(a,t),v.id=o,a.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),e[o]=v}}}return{skeletons:n,morphTargets:e}}},{key:"parseSkeleton",value:function(n,e){var t=[];return n.children.forEach((function(n){var o=e[n.ID];if("Cluster"===o.attrType){var r={ID:n.ID,indices:[],weights:[],transformLink:(new pr).fromArray(o.TransformLink.a)};"Indexes"in o&&(r.indices=o.Indexes.a,r.weights=o.Weights.a),t.push(r)}})),{rawBones:t,bones:[]}}},{key:"parseMorphTargets",value:function(n,e){for(var t=[],o=0;o<n.children.length;o++){var r=n.children[o],a=e[r.ID],i={name:a.attrName,initialWeight:a.DeformPercent,id:a.id,fullWeights:a.FullWeights.a};if("BlendShapeChannel"!==a.attrType)return;i.geoID=kN.get(parseInt(r.ID)).children.filter((function(n){return void 0===n.relationship}))[0].ID,t.push(i)}return t}},{key:"parseScene",value:function(n,e,t){CN=new zc;var o=this.parseModels(n.skeletons,e,t),r=zN.Objects.Model,a=this;o.forEach((function(n){var e=r[n.ID];a.setLookAtProperties(n,e),kN.get(n.ID).parents.forEach((function(e){var t=o.get(e.ID);void 0!==t&&t.add(n)})),null===n.parent&&CN.add(n)})),this.bindSkeleton(n.skeletons,e,o),this.createAmbientLight(),CN.traverse((function(n){if(n.userData.transformData){n.parent&&(n.userData.transformData.parentMatrix=n.parent.matrix,n.userData.transformData.parentMatrixWorld=n.parent.matrixWorld);var e=VN(n.userData.transformData);n.applyMatrix4(e),n.updateWorldMatrix()}}));var i=(new FN).parse();1===CN.children.length&&CN.children[0].isGroup&&(CN.children[0].animations=i,CN=CN.children[0]),CN.animations=i}},{key:"parseModels",value:function(n,e,t){var o=new Map,r=zN.Objects.Model;for(var a in r){var i=parseInt(a),v=r[a],c=kN.get(i),l=this.buildSkeleton(c,n,i,v.attrName);if(!l){switch(v.attrType){case"Camera":l=this.createCamera(c);break;case"Light":l=this.createLight(c);break;case"Mesh":l=this.createMesh(c,e,t);break;case"NurbsCurve":l=this.createCurve(c,e);break;case"LimbNode":case"Root":l=new pl;break;default:l=new zc}l.name=v.attrName?mp.sanitizeNodeName(v.attrName):"",l.ID=i}this.getTransformData(l,v),o.set(i,l)}return o}},{key:"buildSkeleton",value:function(n,e,t,o){var r=null;return n.parents.forEach((function(n){var a=function(a){var i=e[a];i.rawBones.forEach((function(e,a){if(e.ID===n.ID){var v=r;(r=new pl).matrixWorld.copy(e.transformLink),r.name=o?mp.sanitizeNodeName(o):"",r.ID=t,i.bones[a]=r,null!==v&&r.add(v)}}))};for(var i in e)a(i)})),r}},{key:"createCamera",value:function(n){var e,t;if(n.children.forEach((function(n){var e=zN.Objects.NodeAttribute[n.ID];void 0!==e&&(t=e)})),void 0===t)e=new Lr;else{var o=0;void 0!==t.CameraProjectionType&&1===t.CameraProjectionType.value&&(o=1);var r=1;void 0!==t.NearPlane&&(r=t.NearPlane.value/1e3);var a=1e3;void 0!==t.FarPlane&&(a=t.FarPlane.value/1e3);var i=window.innerWidth,v=window.innerHeight;void 0!==t.AspectWidth&&void 0!==t.AspectHeight&&(i=t.AspectWidth.value,v=t.AspectHeight.value);var c=i/v,l=45;void 0!==t.FieldOfView&&(l=t.FieldOfView.value);var s=t.FocalLength?t.FocalLength.value:null;switch(o){case 0:e=new Wa(l,c,r,a),null!==s&&e.setFocalLength(s);break;case 1:e=new di(-i/2,i/2,v/2,-v/2,r,a);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+o+"."),e=new Lr}}return e}},{key:"createLight",value:function(n){var e,t;if(n.children.forEach((function(n){var e=zN.Objects.NodeAttribute[n.ID];void 0!==e&&(t=e)})),void 0===t)e=new Lr;else{var o;o=void 0===t.LightType?0:t.LightType.value;var r=16777215;void 0!==t.Color&&(r=(new wo).fromArray(t.Color.value));var a=void 0===t.Intensity?1:t.Intensity.value/100;void 0!==t.CastLightOnObject&&0===t.CastLightOnObject.value&&(a=0);var i=0;void 0!==t.FarAttenuationEnd&&(i=void 0!==t.EnableFarAttenuation&&0===t.EnableFarAttenuation.value?0:t.FarAttenuationEnd.value);switch(o){case 0:e=new Uf(r,a,i,1);break;case 1:e=new Sf(r,a);break;case 2:var v=Math.PI/3;void 0!==t.InnerAngle&&(v=ro.degToRad(t.InnerAngle.value));var c=0;void 0!==t.OuterAngle&&(c=ro.degToRad(t.OuterAngle.value),c=Math.max(c,1)),e=new xf(r,a,i,v,c,1);break;default:console.warn("THREE.FBXLoader: Unknown light type "+t.LightType.value+", defaulting to a PointLight."),e=new Uf(r,a)}void 0!==t.CastShadows&&1===t.CastShadows.value&&(e.castShadow=!0)}return e}},{key:"createMesh",value:function(n,e,t){var o,r=null,a=null,i=[];return n.children.forEach((function(n){e.has(n.ID)&&(r=e.get(n.ID)),t.has(n.ID)&&i.push(t.get(n.ID))})),i.length>1?a=i:i.length>0?a=i[0]:(a=new Uu({color:13421772}),i.push(a)),"color"in r.attributes&&i.forEach((function(n){n.vertexColors=!0})),r.FBX_Deformer?(o=new fl(r,a)).normalizeSkinWeights():o=new Oa(r,a),o}},{key:"createCurve",value:function(n,e){var t=n.children.reduce((function(n,t){return e.has(t.ID)&&(n=e.get(t.ID)),n}),null),o=new Ml({color:3342591,linewidth:1});return new Dl(t,o)}},{key:"getTransformData",value:function(n,e){var t={};"InheritType"in e&&(t.inheritType=parseInt(e.InheritType.value)),t.eulerOrder="RotationOrder"in e?WN(e.RotationOrder.value):"ZYX","Lcl_Translation"in e&&(t.translation=e.Lcl_Translation.value),"PreRotation"in e&&(t.preRotation=e.PreRotation.value),"Lcl_Rotation"in e&&(t.rotation=e.Lcl_Rotation.value),"PostRotation"in e&&(t.postRotation=e.PostRotation.value),"Lcl_Scaling"in e&&(t.scale=e.Lcl_Scaling.value),"ScalingOffset"in e&&(t.scalingOffset=e.ScalingOffset.value),"ScalingPivot"in e&&(t.scalingPivot=e.ScalingPivot.value),"RotationOffset"in e&&(t.rotationOffset=e.RotationOffset.value),"RotationPivot"in e&&(t.rotationPivot=e.RotationPivot.value),n.userData.transformData=t}},{key:"setLookAtProperties",value:function(n,e){"LookAtProperty"in e&&kN.get(n.ID).children.forEach((function(e){if("LookAtProperty"===e.relationship){var t=zN.Objects.Model[e.ID];if("Lcl_Translation"in t){var o=t.Lcl_Translation.value;void 0!==n.target?(n.target.position.fromArray(o),CN.add(n.target)):n.lookAt((new Oo).fromArray(o))}}}))}},{key:"bindSkeleton",value:function(n,e,t){var o=this.parsePoseNodes(),r=function(r){var a=n[r];kN.get(parseInt(a.ID)).parents.forEach((function(n){if(e.has(n.ID)){var r=n.ID;kN.get(r).parents.forEach((function(n){t.has(n.ID)&&t.get(n.ID).bind(new xl(a.bones),o[n.ID])}))}}))};for(var a in n)r(a)}},{key:"parsePoseNodes",value:function(){var n={};if("Pose"in zN.Objects){var e=zN.Objects.Pose;for(var t in e)if("BindPose"===e[t].attrType&&e[t].NbPoseNodes>0){var o=e[t].PoseNode;Array.isArray(o)?o.forEach((function(e){n[e.Node]=(new pr).fromArray(e.Matrix.a)})):n[o.Node]=(new pr).fromArray(o.Matrix.a)}}return n}},{key:"createAmbientLight",value:function(){if("GlobalSettings"in zN&&"AmbientColor"in zN.GlobalSettings){var n=zN.GlobalSettings.AmbientColor.value,e=n[0],t=n[1],o=n[2];if(0!==e||0!==t||0!==o){var r=new wo(e,t,o);CN.add(new Mf(r,1))}}}}]),n}(),PN=function(){function n(){y(this,n)}return b(n,[{key:"parse",value:function(n){var e=new Map;if("Geometry"in zN.Objects){var t=zN.Objects.Geometry;for(var o in t){var r=kN.get(parseInt(o)),a=this.parseGeometry(r,t[o],n);e.set(parseInt(o),a)}}return e}},{key:"parseGeometry",value:function(n,e,t){switch(e.attrType){case"Mesh":return this.parseMeshGeometry(n,e,t);case"NurbsCurve":return this.parseNurbsGeometry(e)}}},{key:"parseMeshGeometry",value:function(n,e,t){var o=t.skeletons,r=[],a=n.parents.map((function(n){return zN.Objects.Model[n.ID]}));if(0!==a.length){var i=n.children.reduce((function(n,e){return void 0!==o[e.ID]&&(n=o[e.ID]),n}),null);n.children.forEach((function(n){void 0!==t.morphTargets[n.ID]&&r.push(t.morphTargets[n.ID])}));var v=a[0],c={};"RotationOrder"in v&&(c.eulerOrder=WN(v.RotationOrder.value)),"InheritType"in v&&(c.inheritType=parseInt(v.InheritType.value)),"GeometricTranslation"in v&&(c.translation=v.GeometricTranslation.value),"GeometricRotation"in v&&(c.rotation=v.GeometricRotation.value),"GeometricScaling"in v&&(c.scale=v.GeometricScaling.value);var l=VN(c);return this.genGeometry(e,i,r,l)}}},{key:"genGeometry",value:function(n,e,t,o){var r=new ga;n.attrName&&(r.name=n.attrName);var a=this.parseGeoNode(n,e),i=this.genBuffers(a),v=new sa(i.vertex,3);if(v.applyMatrix4(o),r.setAttribute("position",v),i.colors.length>0&&r.setAttribute("color",new sa(i.colors,3)),e&&(r.setAttribute("skinIndex",new ia(i.weightsIndices,4)),r.setAttribute("skinWeight",new sa(i.vertexWeights,4)),r.FBX_Deformer=e),i.normal.length>0){var c=(new io).getNormalMatrix(o),l=new sa(i.normal,3);l.applyNormalMatrix(c),r.setAttribute("normal",l)}if(i.uvs.forEach((function(n,e){var t="uv"+(e+1).toString();0===e&&(t="uv"),r.setAttribute(t,new sa(i.uvs[e],2))})),a.material&&"AllSame"!==a.material.mappingType){var s=i.materialIndex[0],u=0;if(i.materialIndex.forEach((function(n,e){n!==s&&(r.addGroup(u,e-u,s),s=n,u=e)})),r.groups.length>0){var f=r.groups[r.groups.length-1],p=f.start+f.count;p!==i.materialIndex.length&&r.addGroup(p,i.materialIndex.length-p,s)}0===r.groups.length&&r.addGroup(0,i.materialIndex.length,i.materialIndex[0])}return this.addMorphTargets(r,n,t,o),r}},{key:"parseGeoNode",value:function(n,e){var t={};if(t.vertexPositions=void 0!==n.Vertices?n.Vertices.a:[],t.vertexIndices=void 0!==n.PolygonVertexIndex?n.PolygonVertexIndex.a:[],n.LayerElementColor&&(t.color=this.parseVertexColors(n.LayerElementColor[0])),n.LayerElementMaterial&&(t.material=this.parseMaterialIndices(n.LayerElementMaterial[0])),n.LayerElementNormal&&(t.normal=this.parseNormals(n.LayerElementNormal[0])),n.LayerElementUV){t.uv=[];for(var o=0;n.LayerElementUV[o];)n.LayerElementUV[o].UV&&t.uv.push(this.parseUVs(n.LayerElementUV[o])),o++}return t.weightTable={},null!==e&&(t.skeleton=e,e.rawBones.forEach((function(n,e){n.indices.forEach((function(o,r){void 0===t.weightTable[o]&&(t.weightTable[o]=[]),t.weightTable[o].push({id:e,weight:n.weights[r]})}))}))),t}},{key:"genBuffers",value:function(n){var e={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]},t=0,o=0,r=!1,a=[],i=[],v=[],c=[],l=[],s=[],u=this;return n.vertexIndices.forEach((function(f,p){var m,d=!1;f<0&&(f^=-1,d=!0);var h=[],x=[];if(a.push(3*f,3*f+1,3*f+2),n.color){var y=NN(p,t,f,n.color);v.push(y[0],y[1],y[2])}if(n.skeleton){if(void 0!==n.weightTable[f]&&n.weightTable[f].forEach((function(n){x.push(n.weight),h.push(n.id)})),x.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);var g=[0,0,0,0],b=[0,0,0,0];x.forEach((function(n,e){var t=n,o=h[e];b.forEach((function(n,e,r){if(t>n){r[e]=t,t=n;var a=g[e];g[e]=o,o=a}}))})),h=g,x=b}for(;x.length<4;)x.push(0),h.push(0);for(var _=0;_<4;++_)l.push(x[_]),s.push(h[_])}if(n.normal){var U=NN(p,t,f,n.normal);i.push(U[0],U[1],U[2])}n.material&&"AllSame"!==n.material.mappingType&&(m=NN(p,t,f,n.material)[0]),n.uv&&n.uv.forEach((function(n,e){var o=NN(p,t,f,n);void 0===c[e]&&(c[e]=[]),c[e].push(o[0]),c[e].push(o[1])})),o++,d&&(u.genFace(e,n,a,m,i,v,c,l,s,o),t++,o=0,a=[],i=[],v=[],c=[],l=[],s=[])})),e}},{key:"genFace",value:function(n,e,t,o,r,a,i,v,c,l){for(var s=function(l){n.vertex.push(e.vertexPositions[t[0]]),n.vertex.push(e.vertexPositions[t[1]]),n.vertex.push(e.vertexPositions[t[2]]),n.vertex.push(e.vertexPositions[t[3*(l-1)]]),n.vertex.push(e.vertexPositions[t[3*(l-1)+1]]),n.vertex.push(e.vertexPositions[t[3*(l-1)+2]]),n.vertex.push(e.vertexPositions[t[3*l]]),n.vertex.push(e.vertexPositions[t[3*l+1]]),n.vertex.push(e.vertexPositions[t[3*l+2]]),e.skeleton&&(n.vertexWeights.push(v[0]),n.vertexWeights.push(v[1]),n.vertexWeights.push(v[2]),n.vertexWeights.push(v[3]),n.vertexWeights.push(v[4*(l-1)]),n.vertexWeights.push(v[4*(l-1)+1]),n.vertexWeights.push(v[4*(l-1)+2]),n.vertexWeights.push(v[4*(l-1)+3]),n.vertexWeights.push(v[4*l]),n.vertexWeights.push(v[4*l+1]),n.vertexWeights.push(v[4*l+2]),n.vertexWeights.push(v[4*l+3]),n.weightsIndices.push(c[0]),n.weightsIndices.push(c[1]),n.weightsIndices.push(c[2]),n.weightsIndices.push(c[3]),n.weightsIndices.push(c[4*(l-1)]),n.weightsIndices.push(c[4*(l-1)+1]),n.weightsIndices.push(c[4*(l-1)+2]),n.weightsIndices.push(c[4*(l-1)+3]),n.weightsIndices.push(c[4*l]),n.weightsIndices.push(c[4*l+1]),n.weightsIndices.push(c[4*l+2]),n.weightsIndices.push(c[4*l+3])),e.color&&(n.colors.push(a[0]),n.colors.push(a[1]),n.colors.push(a[2]),n.colors.push(a[3*(l-1)]),n.colors.push(a[3*(l-1)+1]),n.colors.push(a[3*(l-1)+2]),n.colors.push(a[3*l]),n.colors.push(a[3*l+1]),n.colors.push(a[3*l+2])),e.material&&"AllSame"!==e.material.mappingType&&(n.materialIndex.push(o),n.materialIndex.push(o),n.materialIndex.push(o)),e.normal&&(n.normal.push(r[0]),n.normal.push(r[1]),n.normal.push(r[2]),n.normal.push(r[3*(l-1)]),n.normal.push(r[3*(l-1)+1]),n.normal.push(r[3*(l-1)+2]),n.normal.push(r[3*l]),n.normal.push(r[3*l+1]),n.normal.push(r[3*l+2])),e.uv&&e.uv.forEach((function(e,t){void 0===n.uvs[t]&&(n.uvs[t]=[]),n.uvs[t].push(i[t][0]),n.uvs[t].push(i[t][1]),n.uvs[t].push(i[t][2*(l-1)]),n.uvs[t].push(i[t][2*(l-1)+1]),n.uvs[t].push(i[t][2*l]),n.uvs[t].push(i[t][2*l+1])}))},u=2;u<l;u++)s(u)}},{key:"addMorphTargets",value:function(n,e,t,o){if(0!==t.length){n.morphTargetsRelative=!0,n.morphAttributes.position=[];var r=this;t.forEach((function(t){t.rawTargets.forEach((function(t){var a=zN.Objects.Geometry[t.geoID];void 0!==a&&r.genMorphGeometry(n,e,a,o,t.name)}))}))}}},{key:"genMorphGeometry",value:function(n,e,t,o,r){for(var a=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],i=void 0!==t.Vertices?t.Vertices.a:[],v=void 0!==t.Indexes?t.Indexes.a:[],c=3*n.attributes.position.count,l=new Float32Array(c),s=0;s<v.length;s++){var u=3*v[s];l[u]=i[3*s],l[u+1]=i[3*s+1],l[u+2]=i[3*s+2]}var f={vertexIndices:a,vertexPositions:l},p=this.genBuffers(f),m=new sa(p.vertex,3);m.name=r||t.attrName,m.applyMatrix4(o),n.morphAttributes.position.push(m)}},{key:"parseNormals",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType,o=n.Normals.a,r=[];return"IndexToDirect"===t&&("NormalIndex"in n?r=n.NormalIndex.a:"NormalsIndex"in n&&(r=n.NormalsIndex.a)),{dataSize:3,buffer:o,indices:r,mappingType:e,referenceType:t}}},{key:"parseUVs",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType,o=n.UV.a,r=[];return"IndexToDirect"===t&&(r=n.UVIndex.a),{dataSize:2,buffer:o,indices:r,mappingType:e,referenceType:t}}},{key:"parseVertexColors",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType,o=n.Colors.a,r=[];return"IndexToDirect"===t&&(r=n.ColorIndex.a),{dataSize:4,buffer:o,indices:r,mappingType:e,referenceType:t}}},{key:"parseMaterialIndices",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType;if("NoMappingInformation"===e)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:t};for(var o=n.Materials.a,r=[],a=0;a<o.length;++a)r.push(a);return{dataSize:1,buffer:o,indices:r,mappingType:e,referenceType:t}}},{key:"parseNurbsGeometry",value:function(n){if(void 0===TN)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new ga;var e=parseInt(n.Order);if(isNaN(e))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",n.Order,n.id),new ga;for(var t,o,r=e-1,a=n.KnotVector.a,i=[],v=n.Points.a,c=0,l=v.length;c<l;c+=4)i.push((new To).fromArray(v,c));if("Closed"===n.Form)i.push(i[0]);else if("Periodic"===n.Form){t=r,o=a.length-1-t;for(var s=0;s<r;++s)i.push(i[s])}var u=new TN(r,a,i,t,o).getPoints(12*i.length);return(new ga).setFromPoints(u)}}]),n}(),FN=function(){function n(){y(this,n)}return b(n,[{key:"parse",value:function(){var n=[],e=this.parseClips();if(void 0!==e)for(var t in e){var o=e[t],r=this.addClip(o);n.push(r)}return n}},{key:"parseClips",value:function(){if(void 0!==zN.Objects.AnimationCurve){var n=this.parseAnimationCurveNodes();this.parseAnimationCurves(n);var e=this.parseAnimationLayers(n);return this.parseAnimStacks(e)}}},{key:"parseAnimationCurveNodes",value:function(){var n=zN.Objects.AnimationCurveNode,e=new Map;for(var t in n){var o=n[t];if(null!==o.attrName.match(/S|R|T|DeformPercent/)){var r={id:o.id,attr:o.attrName,curves:{}};e.set(r.id,r)}}return e}},{key:"parseAnimationCurves",value:function(n){var e=zN.Objects.AnimationCurve;for(var t in e){var o={id:e[t].id,times:e[t].KeyTime.a.map(AN),values:e[t].KeyValueFloat.a},r=kN.get(o.id);if(void 0!==r){var a=r.parents[0].ID,i=r.parents[0].relationship;i.match(/X/)?n.get(a).curves.x=o:i.match(/Y/)?n.get(a).curves.y=o:i.match(/Z/)?n.get(a).curves.z=o:i.match(/d|DeformPercent/)&&n.has(a)&&(n.get(a).curves.morph=o)}}}},{key:"parseAnimationLayers",value:function(n){var e=zN.Objects.AnimationLayer,t=new Map,o=function(e){var o=[],r=kN.get(parseInt(e));void 0!==r&&(r.children.forEach((function(e,t){if(n.has(e.ID)){var r=n.get(e.ID);if(void 0!==r.curves.x||void 0!==r.curves.y||void 0!==r.curves.z){if(void 0===o[t]){var a=kN.get(e.ID).parents.filter((function(n){return void 0!==n.relationship}))[0].ID;if(void 0!==a){var i=zN.Objects.Model[a.toString()];if(void 0===i)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",e);var v={modelName:i.attrName?mp.sanitizeNodeName(i.attrName):"",ID:i.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};CN.traverse((function(n){n.ID===i.id&&(v.transform=n.matrix,n.userData.transformData&&(v.eulerOrder=n.userData.transformData.eulerOrder))})),v.transform||(v.transform=new pr),"PreRotation"in i&&(v.preRotation=i.PreRotation.value),"PostRotation"in i&&(v.postRotation=i.PostRotation.value),o[t]=v}}o[t]&&(o[t][r.attr]=r)}else if(void 0!==r.curves.morph){if(void 0===o[t]){var c=kN.get(e.ID).parents.filter((function(n){return void 0!==n.relationship}))[0].ID,l=kN.get(c).parents[0].ID,s=kN.get(l).parents[0].ID,u=kN.get(s).parents[0].ID,f=zN.Objects.Model[u],p={modelName:f.attrName?mp.sanitizeNodeName(f.attrName):"",morphName:zN.Objects.Deformer[c].attrName};o[t]=p}o[t][r.attr]=r}}})),t.set(parseInt(e),o))};for(var r in e)o(r);return t}},{key:"parseAnimStacks",value:function(n){var e=zN.Objects.AnimationStack,t={};for(var o in e){var r=kN.get(parseInt(o)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");var a=n.get(r[0].ID);t[o]={name:e[o].attrName,layer:a}}return t}},{key:"addClip",value:function(n){var e=[],t=this;return n.layer.forEach((function(n){e=e.concat(t.generateTracks(n))})),new Xu(n.name,-1,e)}},{key:"generateTracks",value:function(n){var e=[],t=new Oo,o=new Eo,r=new Oo;if(n.transform&&n.transform.decompose(t,o,r),t=t.toArray(),o=(new wr).setFromQuaternion(o,n.eulerOrder).toArray(),r=r.toArray(),void 0!==n.T&&Object.keys(n.T.curves).length>0){var a=this.generateVectorTrack(n.modelName,n.T.curves,t,"position");void 0!==a&&e.push(a)}if(void 0!==n.R&&Object.keys(n.R.curves).length>0){var i=this.generateRotationTrack(n.modelName,n.R.curves,o,n.preRotation,n.postRotation,n.eulerOrder);void 0!==i&&e.push(i)}if(void 0!==n.S&&Object.keys(n.S.curves).length>0){var v=this.generateVectorTrack(n.modelName,n.S.curves,r,"scale");void 0!==v&&e.push(v)}if(void 0!==n.DeformPercent){var c=this.generateMorphTrack(n);void 0!==c&&e.push(c)}return e}},{key:"generateVectorTrack",value:function(n,e,t,o){var r=this.getTimesForAllAxes(e),a=this.getKeyframeTrackValues(r,e,t);return new Hu(n+"."+o,r,a)}},{key:"generateRotationTrack",value:function(n,e,t,o,r,a){void 0!==e.x&&(this.interpolateRotations(e.x),e.x.values=e.x.values.map(ro.degToRad)),void 0!==e.y&&(this.interpolateRotations(e.y),e.y.values=e.y.values.map(ro.degToRad)),void 0!==e.z&&(this.interpolateRotations(e.z),e.z.values=e.z.values.map(ro.degToRad));var i=this.getTimesForAllAxes(e),v=this.getKeyframeTrackValues(i,e,t);void 0!==o&&((o=o.map(ro.degToRad)).push(a),o=(new wr).fromArray(o),o=(new Eo).setFromEuler(o)),void 0!==r&&((r=r.map(ro.degToRad)).push(a),r=(new wr).fromArray(r),r=(new Eo).setFromEuler(r).invert());for(var c=new Eo,l=new wr,s=[],u=0;u<v.length;u+=3)l.set(v[u],v[u+1],v[u+2],a),c.setFromEuler(l),void 0!==o&&c.premultiply(o),void 0!==r&&c.multiply(r),c.toArray(s,u/3*4);return new Vu(n+".quaternion",i,s)}},{key:"generateMorphTrack",value:function(n){var e=n.DeformPercent.curves.morph,t=e.values.map((function(n){return n/100})),o=CN.getObjectByName(n.modelName).morphTargetDictionary[n.morphName];return new Bu(n.modelName+".morphTargetInfluences["+o+"]",e.times,t)}},{key:"getTimesForAllAxes",value:function(n){var e=[];if(void 0!==n.x&&(e=e.concat(n.x.times)),void 0!==n.y&&(e=e.concat(n.y.times)),void 0!==n.z&&(e=e.concat(n.z.times)),(e=e.sort((function(n,e){return n-e}))).length>1){for(var t=1,o=e[0],r=1;r<e.length;r++){var a=e[r];a!==o&&(e[t]=a,o=a,t++)}e=e.slice(0,t)}return e}},{key:"getKeyframeTrackValues",value:function(n,e,t){var o=t,r=[],a=-1,i=-1,v=-1;return n.forEach((function(n){if(e.x&&(a=e.x.times.indexOf(n)),e.y&&(i=e.y.times.indexOf(n)),e.z&&(v=e.z.times.indexOf(n)),-1!==a){var t=e.x.values[a];r.push(t),o[0]=t}else r.push(o[0]);if(-1!==i){var c=e.y.values[i];r.push(c),o[1]=c}else r.push(o[1]);if(-1!==v){var l=e.z.values[v];r.push(l),o[2]=l}else r.push(o[2])})),r}},{key:"interpolateRotations",value:function(n){for(var e=1;e<n.values.length;e++){var t=n.values[e-1],o=n.values[e]-t,r=Math.abs(o);if(r>=180){for(var a=r/180,i=o/a,v=t+i,c=n.times[e-1],l=(n.times[e]-c)/a,s=c+l,u=[],f=[];s<n.times[e];)u.push(s),s+=l,f.push(v),v+=i;n.times=YN(n.times,e,u),n.values=YN(n.values,e,f)}}}}]),n}(),jN=function(){function n(){y(this,n)}return b(n,[{key:"getPrevNode",value:function(){return this.nodeStack[this.currentIndent-2]}},{key:"getCurrentNode",value:function(){return this.nodeStack[this.currentIndent-1]}},{key:"getCurrentProp",value:function(){return this.currentProp}},{key:"pushStack",value:function(n){this.nodeStack.push(n),this.currentIndent+=1}},{key:"popStack",value:function(){this.nodeStack.pop(),this.currentIndent-=1}},{key:"setCurrentProp",value:function(n,e){this.currentProp=n,this.currentPropName=e}},{key:"parse",value:function(n){this.currentIndent=0,this.allNodes=new ON,this.nodeStack=[],this.currentProp=[],this.currentPropName="";var e=this,t=n.split(/[\r\n]+/);return t.forEach((function(n,o){var r=n.match(/^[\s\t]*;/),a=n.match(/^[\s\t]*$/);if(!r&&!a){var i=n.match("^\\t{"+e.currentIndent+"}(\\w+):(.*){",""),v=n.match("^\\t{"+e.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),c=n.match("^\\t{"+(e.currentIndent-1)+"}}");i?e.parseNodeBegin(n,i):v?e.parseNodeProperty(n,v,t[++o]):c?e.popStack():n.match(/^[^\s\t}]/)&&e.parseNodePropertyContinued(n)}})),this.allNodes}},{key:"parseNodeBegin",value:function(n,e){var t=e[1].trim().replace(/^"/,"").replace(/"$/,""),o=e[2].split(",").map((function(n){return n.trim().replace(/^"/,"").replace(/"$/,"")})),r={name:t},a=this.parseNodeAttr(o),i=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(t,r):t in i?("PoseNode"===t?i.PoseNode.push(r):void 0!==i[t].id&&(i[t]={},i[t][i[t].id]=i[t]),""!==a.id&&(i[t][a.id]=r)):"number"===typeof a.id?(i[t]={},i[t][a.id]=r):"Properties70"!==t&&(i[t]="PoseNode"===t?[r]:r),"number"===typeof a.id&&(r.id=a.id),""!==a.name&&(r.attrName=a.name),""!==a.type&&(r.attrType=a.type),this.pushStack(r)}},{key:"parseNodeAttr",value:function(n){var e=n[0];""!==n[0]&&(e=parseInt(n[0]),isNaN(e)&&(e=n[0]));var t="",o="";return n.length>1&&(t=n[1].replace(/^(\w+)::/,""),o=n[2]),{id:e,name:t,type:o}}},{key:"parseNodeProperty",value:function(n,e,t){var o=e[1].replace(/^"/,"").replace(/"$/,"").trim(),r=e[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===o&&","===r&&(r=t.replace(/"/g,"").replace(/,$/,"").trim());var a=this.getCurrentNode();if("Properties70"!==a.name){if("C"===o){var i=r.split(",").slice(1),v=parseInt(i[0]),c=parseInt(i[1]),l=r.split(",").slice(3);o="connections",function(n,e){for(var t=0,o=n.length,r=e.length;t<r;t++,o++)n[o]=e[t]}(r=[v,c],l=l.map((function(n){return n.trim().replace(/^"/,"")}))),void 0===a[o]&&(a[o]=[])}"Node"===o&&(a.id=r),o in a&&Array.isArray(a[o])?a[o].push(r):"a"!==o?a[o]=r:a.a=r,this.setCurrentProp(a,o),"a"===o&&","!==r.slice(-1)&&(a.a=HN(r))}else this.parseNodeSpecialProperty(n,o,r)}},{key:"parseNodePropertyContinued",value:function(n){var e=this.getCurrentNode();e.a+=n,","!==n.slice(-1)&&(e.a=HN(e.a))}},{key:"parseNodeSpecialProperty",value:function(n,e,t){var o=t.split('",').map((function(n){return n.trim().replace(/^\"/,"").replace(/\s/,"_")})),r=o[0],a=o[1],i=o[2],v=o[3],c=o[4];switch(a){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=HN(c)}this.getPrevNode()[r]={type:a,type2:i,flag:v,value:c},this.setCurrentProp(this.getPrevNode(),r)}}]),n}(),IN=function(){function n(){y(this,n)}return b(n,[{key:"parse",value:function(n){var e=new EN(n);e.skip(23);var t=e.getUint32();if(t<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+t);for(var o=new ON;!this.endOfContent(e);){var r=this.parseNode(e,t);null!==r&&o.add(r.name,r)}return o}},{key:"endOfContent",value:function(n){return n.size()%16===0?(n.getOffset()+160+16&-16)>=n.size():n.getOffset()+160+16>=n.size()}},{key:"parseNode",value:function(n,e){var t={},o=e>=7500?n.getUint64():n.getUint32(),r=e>=7500?n.getUint64():n.getUint32();e>=7500?n.getUint64():n.getUint32();var a=n.getUint8(),i=n.getString(a);if(0===o)return null;for(var v=[],c=0;c<r;c++)v.push(this.parseProperty(n));var l=v.length>0?v[0]:"",s=v.length>1?v[1]:"",u=v.length>2?v[2]:"";for(t.singleProperty=1===r&&n.getOffset()===o;o>n.getOffset();){var f=this.parseNode(n,e);null!==f&&this.parseSubNode(i,t,f)}return t.propertyList=v,"number"===typeof l&&(t.id=l),""!==s&&(t.attrName=s),""!==u&&(t.attrType=u),""!==i&&(t.name=i),t}},{key:"parseSubNode",value:function(n,e,t){if(!0===t.singleProperty){var o=t.propertyList[0];Array.isArray(o)?(e[t.name]=t,t.a=o):e[t.name]=o}else if("Connections"===n&&"C"===t.name){var r=[];t.propertyList.forEach((function(n,e){0!==e&&r.push(n)})),void 0===e.connections&&(e.connections=[]),e.connections.push(r)}else if("Properties70"===t.name){Object.keys(t).forEach((function(n){e[n]=t[n]}))}else if("Properties70"===n&&"P"===t.name){var a,i=t.propertyList[0],v=t.propertyList[1],c=t.propertyList[2],l=t.propertyList[3];0===i.indexOf("Lcl ")&&(i=i.replace("Lcl ","Lcl_")),0===v.indexOf("Lcl ")&&(v=v.replace("Lcl ","Lcl_")),a="Color"===v||"ColorRGB"===v||"Vector"===v||"Vector3D"===v||0===v.indexOf("Lcl_")?[t.propertyList[4],t.propertyList[5],t.propertyList[6]]:t.propertyList[4],e[i]={type:v,type2:c,flag:l,value:a}}else void 0===e[t.name]?"number"===typeof t.id?(e[t.name]={},e[t.name][t.id]=t):e[t.name]=t:"PoseNode"===t.name?(Array.isArray(e[t.name])||(e[t.name]=[e[t.name]]),e[t.name].push(t)):void 0===e[t.name][t.id]&&(e[t.name][t.id]=t)}},{key:"parseProperty",value:function(n){var e,t=n.getString(1);switch(t){case"C":return n.getBoolean();case"D":return n.getFloat64();case"F":return n.getFloat32();case"I":return n.getInt32();case"L":return n.getInt64();case"R":return e=n.getUint32(),n.getArrayBuffer(e);case"S":return e=n.getUint32(),n.getString(e);case"Y":return n.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":var o=n.getUint32(),r=n.getUint32(),a=n.getUint32();if(0===r)switch(t){case"b":case"c":return n.getBooleanArray(o);case"d":return n.getFloat64Array(o);case"f":return n.getFloat32Array(o);case"i":return n.getInt32Array(o);case"l":return n.getInt64Array(o)}var i=bN(new Uint8Array(n.getArrayBuffer(a))),v=new EN(i.buffer);switch(t){case"b":case"c":return v.getBooleanArray(o);case"d":return v.getFloat64Array(o);case"f":return v.getFloat32Array(o);case"i":return v.getInt32Array(o);case"l":return v.getInt64Array(o)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}]),n}(),EN=function(){function n(e,t){y(this,n),this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}return b(n,[{key:"getOffset",value:function(){return this.offset}},{key:"size",value:function(){return this.dv.buffer.byteLength}},{key:"skip",value:function(n){this.offset+=n}},{key:"getBoolean",value:function(){return 1===(1&this.getUint8())}},{key:"getBooleanArray",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getBoolean());return e}},{key:"getUint8",value:function(){var n=this.dv.getUint8(this.offset);return this.offset+=1,n}},{key:"getInt16",value:function(){var n=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,n}},{key:"getInt32",value:function(){var n=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,n}},{key:"getInt32Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getInt32());return e}},{key:"getUint32",value:function(){var n=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,n}},{key:"getInt64",value:function(){var n,e;return this.littleEndian?(n=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),n=this.getUint32()),2147483648&e?(e=4294967295&~e,4294967295===(n=4294967295&~n)&&(e=e+1&4294967295),-(4294967296*e+(n=n+1&4294967295))):4294967296*e+n}},{key:"getInt64Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getInt64());return e}},{key:"getUint64",value:function(){var n,e;return this.littleEndian?(n=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),n=this.getUint32()),4294967296*e+n}},{key:"getFloat32",value:function(){var n=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,n}},{key:"getFloat32Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getFloat32());return e}},{key:"getFloat64",value:function(){var n=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,n}},{key:"getFloat64Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getFloat64());return e}},{key:"getArrayBuffer",value:function(n){var e=this.dv.buffer.slice(this.offset,this.offset+n);return this.offset+=n,e}},{key:"getString",value:function(n){for(var e=[],t=0;t<n;t++)e[t]=this.getUint8();var o=e.indexOf(0);return o>=0&&(e=e.slice(0,o)),Rf.decodeText(new Uint8Array(e))}}]),n}(),ON=function(){function n(){y(this,n)}return b(n,[{key:"add",value:function(n,e){this[n]=e}}]),n}();function LN(n){var e=n.match(/FBXVersion: (\d+)/);if(e)return parseInt(e[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function AN(n){return n/46186158e3}var GN=[];function NN(n,e,t,o){var r;switch(o.mappingType){case"ByPolygonVertex":r=n;break;case"ByPolygon":r=e;break;case"ByVertice":r=t;break;case"AllSame":r=o.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+o.mappingType)}"IndexToDirect"===o.referenceType&&(r=o.indices[r]);var a=r*o.dataSize,i=a+o.dataSize;return function(n,e,t,o){for(var r=t,a=0;r<o;r++,a++)n[a]=e[r];return n}(GN,o.buffer,a,i)}var BN=new wr,qN=new Oo;function VN(n){var e=new pr,t=new pr,o=new pr,r=new pr,a=new pr,i=new pr,v=new pr,c=new pr,l=new pr,s=new pr,u=new pr,f=new pr,p=n.inheritType?n.inheritType:0;if(n.translation&&e.setPosition(qN.fromArray(n.translation)),n.preRotation){var m=n.preRotation.map(ro.degToRad);m.push(n.eulerOrder),t.makeRotationFromEuler(BN.fromArray(m))}if(n.rotation){var d=n.rotation.map(ro.degToRad);d.push(n.eulerOrder),o.makeRotationFromEuler(BN.fromArray(d))}if(n.postRotation){var h=n.postRotation.map(ro.degToRad);h.push(n.eulerOrder),r.makeRotationFromEuler(BN.fromArray(h)),r.invert()}n.scale&&a.scale(qN.fromArray(n.scale)),n.scalingOffset&&v.setPosition(qN.fromArray(n.scalingOffset)),n.scalingPivot&&i.setPosition(qN.fromArray(n.scalingPivot)),n.rotationOffset&&c.setPosition(qN.fromArray(n.rotationOffset)),n.rotationPivot&&l.setPosition(qN.fromArray(n.rotationPivot)),n.parentMatrixWorld&&(u.copy(n.parentMatrix),s.copy(n.parentMatrixWorld));var x=t.clone().multiply(o).multiply(r),y=new pr;y.extractRotation(s);var g=new pr;g.copyPosition(s);var b=g.clone().invert().multiply(s),_=y.clone().invert().multiply(b),U=a,w=new pr;if(0===p)w.copy(y).multiply(x).multiply(_).multiply(U);else if(1===p)w.copy(y).multiply(_).multiply(x).multiply(U);else{var S=(new pr).scale((new Oo).setFromMatrixScale(u)).clone().invert(),M=_.clone().multiply(S);w.copy(y).multiply(x).multiply(M).multiply(U)}var z=l.clone().invert(),k=i.clone().invert(),C=e.clone().multiply(c).multiply(l).multiply(t).multiply(o).multiply(r).multiply(z).multiply(v).multiply(i).multiply(a).multiply(k),T=(new pr).copyPosition(C),R=s.clone().multiply(T);return f.copyPosition(R),(C=f.clone().multiply(w)).premultiply(s.invert()),C}function WN(n){var e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(n=n||0)?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[n]}function HN(n){return n.split(",").map((function(n){return parseFloat(n)}))}function XN(n,e,t){return void 0===e&&(e=0),void 0===t&&(t=n.byteLength),Rf.decodeText(new Uint8Array(n,e,t))}function YN(n,e,t){return n.slice(0,e).concat(t).concat(n.slice(e))}function ZN(n){return Vd(RN,n)}ZN.preload=function(n){return Vd.preload(RN,n)},ZN.clear=function(n){return Vd.clear(RN,n)};var QN=function(n){return n===Object(n)&&!Array.isArray(n)&&"function"!==typeof n};function JN(n,e){var t=Nd((function(n){return n.gl})),o=Vd(lf,QN(n)?Object.values(n):n);if((0,Lm.useLayoutEffect)((function(){null==e||e(o)}),[e]),(0,Lm.useEffect)((function(){(Array.isArray(o)?o:[o]).forEach(t.initTexture)}),[t,o]),QN(n)){var r=Object.keys(n),a={};return r.forEach((function(n){return Object.assign(a,l({},n,o[r.indexOf(n)]))})),a}return o}function KN(n){var e=ZN("./Models/warehouse2/source/WareHouse.fbx"),t=JN("./Models/warehouse2/textures/Bake.jpg"),o=JN("./Models/warehouse2/textures/Tx.jpg");t.flipY=!0,o.flipY=!1;new Su;var r=new bu({map:t,aoMap:o});return(0,Hh.jsxs)("group",u(u({},n),{},{dispose:null,children:[(0,Hh.jsxs)("group",{position:[0,-27,80],children:[(0,Hh.jsx)("mesh",{geometry:e.children[0].children[1].geometry,material:r}),(0,Hh.jsx)("mesh",{geometry:e.children[0].children[0].children[1].geometry,material:r}),(0,Hh.jsx)("mesh",{geometry:e.children[0].children[0].children[0].children[0].geometry,material:r}),(0,Hh.jsx)("mesh",{geometry:e.children[1].geometry,material:r}),(0,Hh.jsx)("mesh",{geometry:e.children[2].geometry,material:r})]}),(0,Hh.jsx)("ambientLight",{intensity:.2}),(0,Hh.jsx)("rectAreaLight",{position:[0,0,-80],intensity:30})]}))}function $N(){var n=Bh((function(n){return n.songPlaying})),e=Bh((function(n){return n.getSongTime}));console.log(n);var t=(0,Lm.useRef)(),o=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var r=Ed((function(){var r,a=0,i=e();!0===n&&(a=0),a=Date.now()-i,a/=1e3,t.current&&a>0&&a<=137&&(t.current.textContent=(r=a,Math.floor(r%3600/60).toString().padStart(2,"0")+":"+Math.floor(r%60).toString().padStart(2,"0")),o.current.style.width=a/137*100+"%")}));return function(){r()}}),[]),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsxs)("div",{className:"interface",children:[(0,Hh.jsx)("div",{className:"song",children:"song: new adventure"}),(0,Hh.jsx)("div",{className:"artist",children:"artist: matrika "}),(0,Hh.jsx)("div",{id:"Progress_Status",children:(0,Hh.jsx)("div",{className:"progress",ref:o})}),(0,Hh.jsx)("div",{className:"time",ref:t,children:"00:00"})]})})}function nB(){var n=Bh((function(n){return n.songPlaying})),e=Bh((function(n){return n.getSongTime}));console.log(n);var t=(0,Lm.useRef)(),o=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var r=Ed((function(){var r,a=0,i=e();!0===n&&(a=0),a=Date.now()-i,a/=1e3,t.current&&a>0&&a<=204&&(t.current.textContent=(r=a,Math.floor(r%3600/60).toString().padStart(2,"0")+":"+Math.floor(r%60).toString().padStart(2,"0")),o.current.style.width=a/204*100+"%")}));return function(){r()}}),[]),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsxs)("div",{className:"interface",children:[(0,Hh.jsx)("div",{className:"song",children:"song: polaroid"}),(0,Hh.jsx)("div",{className:"artist",children:"artist: arston "}),(0,Hh.jsx)("div",{id:"Progress_Status",children:(0,Hh.jsx)("div",{className:"progress",ref:o})}),(0,Hh.jsx)("div",{className:"time",ref:t,children:"00:00"})]})})}function eB(){var n=Bh((function(n){return n.songPlaying})),e=Bh((function(n){return n.getSongTime}));console.log(n);var t=(0,Lm.useRef)(),o=(0,Lm.useRef)();return(0,Lm.useEffect)((function(){var r=Ed((function(){var r,a=0,i=e();!0===n&&(a=0),a=Date.now()-i,a/=1e3,t.current&&a>0&&a<=137&&(t.current.textContent=(r=a,Math.floor(r%3600/60).toString().padStart(2,"0")+":"+Math.floor(r%60).toString().padStart(2,"0")),o.current.style.width=a/137*100+"%")}));return function(){r()}}),[]),(0,Hh.jsx)(Hh.Fragment,{children:(0,Hh.jsxs)("div",{className:"interface",children:[(0,Hh.jsx)("div",{className:"song",children:"song: new adventure"}),(0,Hh.jsx)("div",{className:"artist",children:"artist: matrika "}),(0,Hh.jsx)("div",{id:"Progress_Status",children:(0,Hh.jsx)("div",{className:"progress",ref:o})}),(0,Hh.jsx)("div",{className:"time",ref:t,children:"00:00"})]})})}function tB(){var n=Bh((function(n){return n.currentShader})),e=Bh((function(n){return n.setCurrentShader})),t=Bh((function(n){return n.information})),o=Bh((function(n){return n.activateInformation})),r=Bh((function(n){return n.deactivateInformation}));document.addEventListener("wheel",(function(n){"number"===document.activeElement.type&&document.activeElement.blur()}));return(0,Hh.jsxs)(Hh.Fragment,{children:[(0,Hh.jsxs)("div",{className:"nav",children:[!t&&(0,Hh.jsx)("button",{className:"back",onClick:function(){n>1&&e(n-1)},children:"back"}),!t&&(0,Hh.jsx)("button",{className:"next",onClick:function(){n<665&&e(n+1)},children:"next"}),(0,Hh.jsx)("h1",{className:"current",children:n})]}),(0,Hh.jsxs)("form",{id:"myForm",className:"form",onSubmit:function(n){n.preventDefault();var t=n.target,o=new FormData(t),r=Object.fromEntries(o.entries()),a=parseInt(r.shader);!Number.isNaN(a)&&a>0&&a<=665&&e(a),document.getElementById("myForm").reset()},children:[!t&&(0,Hh.jsx)("input",{type:"number",name:"shader",placeholder:"Enter Shader Number",className:"input"}),!t&&(0,Hh.jsx)("input",{type:"submit",value:"Submit",className:"submit"})]}),(0,Hh.jsx)("div",{className:"icon",onClick:function(){!1===t&&(document.getElementsByClassName("webgl")[0].style.opacity="0.15",document.getElementsByClassName("nav")[0].style.opacity="0.025",document.getElementsByClassName("form")[0].style.opacity="0.025",document.getElementsByClassName("icon")[0].style.opacity="0.025",document.getElementsByClassName("random")[0].style.opacity="0.025",o())},children:(0,Hh.jsx)("i",{className:"fa-solid fa-info"})}),(0,Hh.jsx)("div",{className:"random",onClick:function(){e(Math.floor(665*Math.random())+1)},children:!t&&(0,Hh.jsx)("i",{className:"fa-solid fa-shuffle"})}),646===n&&(0,Hh.jsx)($N,{}),647===n&&(0,Hh.jsx)(nB,{}),648===n&&(0,Hh.jsx)(eB,{}),t&&(0,Hh.jsxs)("div",{className:"container",children:[(0,Hh.jsx)("div",{className:"close",onClick:function(){document.getElementsByClassName("webgl")[0].style.opacity="1.0",document.getElementsByClassName("nav")[0].style.opacity="1.0",document.getElementsByClassName("form")[0].style.opacity="1.0",document.getElementsByClassName("icon")[0].style.opacity="1.0",document.getElementsByClassName("random")[0].style.opacity="1.0",r()},children:(0,Hh.jsx)("i",{className:"fa-solid fa-x"})}),(0,Hh.jsx)("h1",{className:"header",children:"Welcome to Shader Daily!"}),(0,Hh.jsxs)("p",{className:"text",children:["This website is a result of my personal journey towards learning the magic of Shaders. A shader is a computer program that uses a variety of specialized functions and algorithms to calculate the color value of each pixel in a rendered result using the graphics processing unit (GPU). Shaders are used in a variety of industries ranging from cinema to video games. The programming language used in shaders depends on the target environment. This target environment uses GLSL (Graphics Library Shader Language). This shader program requires a vertex shader and a fragment shader. The vertex shader is not manipulated in this website and kept standard for all results. The fragment shader is modified for each result. The rendering result and experience is achieved using Three.js and React-Three-Fiber. ",(0,Hh.jsx)("br",{})," ",(0,Hh.jsx)("br",{})," Thank you for visiting!",(0,Hh.jsx)("br",{})," ",(0,Hh.jsx)("br",{}),"Nate Argaw  ",(0,Hh.jsx)("p",{className:"copyright",children:"\xa9 Shader Daily. All Rights Reserved"})]}),(0,Hh.jsxs)("div",{className:"contact",children:[(0,Hh.jsxs)("div",{className:"mail",onClick:function(){var n="nateargaw@gmail.com";navigator.clipboard.writeText(n),alert("Copied email: "+n)},children:[(0,Hh.jsx)("a",{href:"mailto: nateargaw@gmail.com"}),(0,Hh.jsx)("i",{className:"fa-solid fa-envelope"})]}),(0,Hh.jsx)("div",{className:"twitter",children:(0,Hh.jsx)("a",{href:"https://twitter.com/nate_dev_",children:(0,Hh.jsx)("i",{className:"fa-brands fa-x-twitter"})})}),(0,Hh.jsx)("div",{className:"linkedin",children:(0,Hh.jsx)("a",{href:"https://www.linkedin.com/in/nateargaw/",children:(0,Hh.jsx)("i",{className:"fa-brands fa-linkedin-in"})})}),(0,Hh.jsx)("div",{className:"instagram",children:(0,Hh.jsx)("a",{href:"https://www.instagram.com/shaderdaily/",children:(0,Hh.jsx)("i",{className:"fa-brands fa-instagram"})})})]})]})]})}function oB(){var n=(0,Lm.useRef)();return Nd((function(e){n.current=e.camera})),Bd((function(){})),(0,Hh.jsx)(Hh.Fragment,{})}JN.preload=function(n){return Vd.preload(lf,n)},JN.clear=function(n){return Vd.clear(lf,n)},(0,Ih.s)(document.querySelector("#root")).render((0,Hh.jsxs)(Lm.StrictMode,{children:[(0,Hh.jsxs)(jh,{className:"webgl",camera:{fov:50,aspect:window.innerWidth/window.innerHeight,near:.01,far:1e3,position:[0,0,5]},children:[(0,Hh.jsx)(WG,{}),(0,Hh.jsx)(KN,{}),(0,Hh.jsx)(oB,{})]}),(0,Hh.jsx)(tB,{})]}))}()}();
//# sourceMappingURL=main.b78df724.js.map